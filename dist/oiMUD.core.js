(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x2) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x2, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x2)(function(x2) {
    if (typeof require !== "undefined") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x2 + '" is not supported');
  });
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // src/lib/inflate_stream.min.js
  var require_inflate_stream_min = __commonJS({
    "src/lib/inflate_stream.min.js"(exports) {
      (function() {
        "use strict";
        var k = void 0, l2 = true, aa = this;
        function s(a, d2) {
          var b = a.split("."), c = aa;
          !(b[0] in c) && c.execScript && c.execScript("var " + b[0]);
          for (var e; b.length && (e = b.shift()); ) !b.length && d2 !== k ? c[e] = d2 : c = c[e] ? c[e] : c[e] = {};
        }
        ;
        var x2 = "undefined" !== typeof Uint8Array && "undefined" !== typeof Uint16Array && "undefined" !== typeof Uint32Array && "undefined" !== typeof DataView;
        function y2(a) {
          var d2 = a.length, b = 0, c = Number.POSITIVE_INFINITY, e, g, f, p, h, q, m, n, r, B;
          for (n = 0; n < d2; ++n) a[n] > b && (b = a[n]), a[n] < c && (c = a[n]);
          e = 1 << b;
          g = new (x2 ? Uint32Array : Array)(e);
          f = 1;
          p = 0;
          for (h = 2; f <= b; ) {
            for (n = 0; n < d2; ++n) if (a[n] === f) {
              q = 0;
              m = p;
              for (r = 0; r < f; ++r) q = q << 1 | m & 1, m >>= 1;
              B = f << 16 | n;
              for (r = q; r < e; r += h) g[r] = B;
              ++p;
            }
            ++f;
            p <<= 1;
            h <<= 1;
          }
          return [g, b, c];
        }
        ;
        function z2(a, d2, b) {
          this.u = [];
          this.i = b ? b : 32768;
          this.v = 0;
          this.a = d2 === k ? 0 : d2;
          this.d = this.e = 0;
          this.input = x2 ? new Uint8Array(a) : a;
          this.b = new (x2 ? Uint8Array : Array)(this.i);
          this.c = 0;
          this.t = this.l = false;
          this.f = 0;
          this.status = A;
        }
        var A = 0;
        z2.prototype.j = function(a, d2) {
          var b = false;
          a !== k && (this.input = a);
          d2 !== k && (this.a = d2);
          for (; !b; ) switch (this.status) {
            case A:
            case 1:
              var c;
              var e = k;
              this.status = 1;
              H(this);
              if (0 > (e = I(this, 3))) J(this), c = -1;
              else {
                e & 1 && (this.l = l2);
                e >>>= 1;
                switch (e) {
                  case 0:
                    this.h = 0;
                    break;
                  case 1:
                    this.h = 1;
                    break;
                  case 2:
                    this.h = 2;
                    break;
                  default:
                    throw Error("unknown BTYPE: " + e);
                }
                this.status = 2;
                c = k;
              }
              0 > c && (b = l2);
              break;
            case 2:
            case 3:
              switch (this.h) {
                case 0:
                  var g;
                  var f = k, p = k, h = this.input, q = this.a;
                  this.status = 3;
                  if (q + 4 >= h.length) g = -1;
                  else {
                    f = h[q++] | h[q++] << 8;
                    p = h[q++] | h[q++] << 8;
                    if (f === ~p) throw Error("invalid uncompressed block header: length verify");
                    this.d = this.e = 0;
                    this.a = q;
                    this.m = f;
                    this.status = 4;
                    g = k;
                  }
                  0 > g && (b = l2);
                  break;
                case 1:
                  this.status = 3;
                  this.k = ba;
                  this.n = ca;
                  this.status = 4;
                  break;
                case 2:
                  var m;
                  a: {
                    var n = k, r = k, B = k, V = new (x2 ? Uint8Array : Array)(K.length), W = k;
                    this.status = 3;
                    H(this);
                    n = I(this, 5) + 257;
                    r = I(this, 5) + 1;
                    B = I(this, 4) + 4;
                    if (0 > n || 0 > r || 0 > B) J(this), m = -1;
                    else {
                      try {
                        for (var w = k, D = k, E = 0, C = k, u = k, t = k, X = k, t = 0; t < B; ++t) {
                          if (0 > (w = I(this, 3))) throw Error("not enough input");
                          V[K[t]] = w;
                        }
                        W = y2(V);
                        u = new (x2 ? Uint8Array : Array)(n + r);
                        t = 0;
                        for (X = n + r; t < X; ) {
                          D = O(this, W);
                          if (0 > D) throw Error("not enough input");
                          switch (D) {
                            case 16:
                              if (0 > (w = I(this, 2))) throw Error("not enough input");
                              for (C = 3 + w; C--; ) u[t++] = E;
                              break;
                            case 17:
                              if (0 > (w = I(this, 3))) throw Error("not enough input");
                              for (C = 3 + w; C--; ) u[t++] = 0;
                              E = 0;
                              break;
                            case 18:
                              if (0 > (w = I(this, 7))) throw Error("not enough input");
                              for (C = 11 + w; C--; ) u[t++] = 0;
                              E = 0;
                              break;
                            default:
                              E = u[t++] = D;
                          }
                        }
                        new (x2 ? Uint8Array : Array)(n);
                        new (x2 ? Uint8Array : Array)(r);
                        this.k = x2 ? y2(u.subarray(
                          0,
                          n
                        )) : y2(u.slice(0, n));
                        this.n = x2 ? y2(u.subarray(n)) : y2(u.slice(n));
                      } catch (pa) {
                        J(this);
                        m = -1;
                        break a;
                      }
                      this.status = 4;
                      m = 0;
                    }
                  }
                  0 > m && (b = l2);
              }
              break;
            case 4:
            case 5:
              switch (this.h) {
                case 0:
                  var L;
                  a: {
                    var Y = this.input, F = this.a, M = this.b, G = this.c, N = this.m;
                    for (this.status = 5; N--; ) {
                      G === M.length && (M = P(this, { o: 2 }));
                      if (F >= Y.length) {
                        this.a = F;
                        this.c = G;
                        this.m = N + 1;
                        L = -1;
                        break a;
                      }
                      M[G++] = Y[F++];
                    }
                    0 > N && (this.status = 6);
                    this.a = F;
                    this.c = G;
                    L = 0;
                  }
                  0 > L && (b = l2);
                  break;
                case 1:
                case 2:
                  0 > da(this) && (b = l2);
              }
              break;
            case 6:
              this.l ? b = l2 : this.status = A;
          }
          var Z, v = this.c, $2;
          Z = this.t ? x2 ? new Uint8Array(this.b.subarray(this.f, v)) : this.b.slice(this.f, v) : x2 ? this.b.subarray(this.f, v) : this.b.slice(this.f, v);
          this.f = v;
          v > 32768 + this.i && (this.c = this.f = 32768, x2 ? ($2 = this.b, this.b = new Uint8Array(this.i + 32768), this.b.set($2.subarray(v - 32768, v))) : this.b = this.b.slice(v - 32768));
          return Z;
        };
        var ea = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], K = x2 ? new Uint16Array(ea) : ea, fa = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258], ga = x2 ? new Uint16Array(fa) : fa, ha = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0], ia = x2 ? new Uint8Array(ha) : ha, ja = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577], ka = x2 ? new Uint16Array(ja) : ja, la = [
          0,
          0,
          0,
          0,
          1,
          1,
          2,
          2,
          3,
          3,
          4,
          4,
          5,
          5,
          6,
          6,
          7,
          7,
          8,
          8,
          9,
          9,
          10,
          10,
          11,
          11,
          12,
          12,
          13,
          13
        ], ma = x2 ? new Uint8Array(la) : la, Q = new (x2 ? Uint8Array : Array)(288), R, na;
        R = 0;
        for (na = Q.length; R < na; ++R) Q[R] = 143 >= R ? 8 : 255 >= R ? 9 : 279 >= R ? 7 : 8;
        var ba = y2(Q), S = new (x2 ? Uint8Array : Array)(30), T, oa;
        T = 0;
        for (oa = S.length; T < oa; ++T) S[T] = 5;
        var ca = y2(S);
        function I(a, d2) {
          for (var b = a.e, c = a.d, e = a.input, g = a.a, f; c < d2; ) {
            if (e.length <= g) return -1;
            f = e[g++];
            b |= f << c;
            c += 8;
          }
          f = b & (1 << d2) - 1;
          a.e = b >>> d2;
          a.d = c - d2;
          a.a = g;
          return f;
        }
        function O(a, d2) {
          for (var b = a.e, c = a.d, e = a.input, g = a.a, f = d2[0], p = d2[1], h, q, m; c < p; ) {
            if (e.length <= g) return -1;
            h = e[g++];
            b |= h << c;
            c += 8;
          }
          q = f[b & (1 << p) - 1];
          m = q >>> 16;
          if (m > c) throw Error("invalid code length: " + m);
          a.e = b >> m;
          a.d = c - m;
          a.a = g;
          return q & 65535;
        }
        function H(a) {
          a.s = a.a;
          a.r = a.d;
          a.q = a.e;
        }
        function J(a) {
          a.a = a.s;
          a.d = a.r;
          a.e = a.q;
        }
        function da(a) {
          var d2 = a.b, b = a.c, c, e, g, f, p = a.k, h = a.n, q = d2.length, m;
          for (a.status = 5; ; ) {
            H(a);
            c = O(a, p);
            if (0 > c) return a.c = b, J(a), -1;
            if (256 === c) break;
            if (256 > c) b === q && (d2 = P(a), q = d2.length), d2[b++] = c;
            else {
              e = c - 257;
              f = ga[e];
              if (0 < ia[e]) {
                m = I(a, ia[e]);
                if (0 > m) return a.c = b, J(a), -1;
                f += m;
              }
              c = O(a, h);
              if (0 > c) return a.c = b, J(a), -1;
              g = ka[c];
              if (0 < ma[c]) {
                m = I(a, ma[c]);
                if (0 > m) return a.c = b, J(a), -1;
                g += m;
              }
              b + f >= q && (d2 = P(a), q = d2.length);
              for (; f--; ) d2[b] = d2[b++ - g];
              if (a.a === a.input.length) return a.c = b, -1;
            }
          }
          for (; 8 <= a.d; ) a.d -= 8, a.a--;
          a.c = b;
          a.status = 6;
        }
        function P(a, d2) {
          var b, c = a.input.length / a.a + 1 | 0, e, g, f, p = a.input, h = a.b;
          d2 && ("number" === typeof d2.o && (c = d2.o), "number" === typeof d2.p && (c += d2.p));
          2 > c ? (e = (p.length - a.a) / a.k[2], f = 258 * (e / 2) | 0, g = f < h.length ? h.length + f : h.length << 1) : g = h.length * c;
          x2 ? (b = new Uint8Array(g), b.set(h)) : b = h;
          a.b = b;
          return a.b;
        }
        ;
        function U(a) {
          this.input = a === k ? new (x2 ? Uint8Array : Array)() : a;
          this.a = 0;
          this.g = new z2(this.input, this.a);
          this.b = this.g.b;
        }
        U.prototype.j = function(a) {
          var d2;
          if (a !== k) if (x2) {
            var b = new Uint8Array(this.input.length + a.length);
            b.set(this.input, 0);
            b.set(a, this.input.length);
            this.input = b;
          } else this.input = this.input.concat(a);
          var c;
          if (c = this.method === k) {
            var e;
            var g = this.a, f = this.input, p = f[g++], h = f[g++];
            if (p === k || h === k) e = -1;
            else {
              switch (p & 15) {
                case 8:
                  this.method = 8;
                  break;
                default:
                  throw Error("unsupported compression method");
              }
              if (0 !== ((p << 8) + h) % 31) throw Error("invalid fcheck flag:" + ((p << 8) + h) % 31);
              if (h & 32) throw Error("fdict flag is not supported");
              this.a = g;
              e = k;
            }
            c = 0 > e;
          }
          if (c) return new (x2 ? Uint8Array : Array)();
          d2 = this.g.j(this.input, this.a);
          0 !== this.g.a && (this.input = x2 ? this.input.subarray(this.g.a) : this.input.slice(this.g.a), this.a = 0);
          return d2;
        };
        s("Zlib.InflateStream", U);
        s("Zlib.InflateStream.prototype.decompress", U.prototype.j);
      }).call(exports);
    }
  });

  // src/lib/buzz.js
  var require_buzz = __commonJS({
    "src/lib/buzz.js"(exports, module) {
      (function(context, factory) {
        "use strict";
        if (typeof module !== "undefined" && module.exports) {
          module.exports = factory();
        } else if (typeof define === "function" && define.amd) {
          define([], factory);
        } else {
          context.buzz = factory();
        }
      })(exports, function() {
        "use strict";
        var AudioContext = window.AudioContext || window.webkitAudioContext;
        var buzz2 = {
          defaults: {
            autoplay: false,
            duration: 5e3,
            formats: [],
            loop: false,
            placeholder: "--",
            preload: "metadata",
            volume: 80,
            webAudioApi: false,
            document: window.document
          },
          types: {
            mp3: "audio/mpeg",
            ogg: "audio/ogg",
            wav: "audio/wav",
            aac: "audio/aac",
            m4a: "audio/x-m4a"
          },
          sounds: [],
          el: document.createElement("audio"),
          getAudioContext: function() {
            if (this.audioCtx === void 0) {
              try {
                this.audioCtx = AudioContext ? new AudioContext() : null;
              } catch (e) {
                this.audioCtx = null;
              }
            }
            return this.audioCtx;
          },
          sound: function(src, options) {
            options = options || {};
            var doc = options.document || buzz2.defaults.document;
            var pid = 0, events = [], eventsOnce = {}, supported = buzz2.isSupported();
            this.load = function() {
              if (!supported) {
                return this;
              }
              this.sound.load();
              return this;
            };
            this.play = function() {
              if (!supported) {
                return this;
              }
              this.sound.play();
              return this;
            };
            this.togglePlay = function() {
              if (!supported) {
                return this;
              }
              if (this.sound.paused) {
                this.sound.play();
              } else {
                this.sound.pause();
              }
              return this;
            };
            this.pause = function() {
              if (!supported) {
                return this;
              }
              this.sound.pause();
              return this;
            };
            this.isPaused = function() {
              if (!supported) {
                return null;
              }
              return this.sound.paused;
            };
            this.stop = function() {
              if (!supported) {
                return this;
              }
              this.setTime(0);
              this.sound.pause();
              return this;
            };
            this.isEnded = function() {
              if (!supported) {
                return null;
              }
              return this.sound.ended;
            };
            this.loop = function() {
              if (!supported) {
                return this;
              }
              this.sound.loop = "loop";
              this.bind("ended.buzzloop", function() {
                this.currentTime = 0;
                this.play();
              });
              return this;
            };
            this.unloop = function() {
              if (!supported) {
                return this;
              }
              this.sound.removeAttribute("loop");
              this.unbind("ended.buzzloop");
              return this;
            };
            this.mute = function() {
              if (!supported) {
                return this;
              }
              this.sound.muted = true;
              return this;
            };
            this.unmute = function() {
              if (!supported) {
                return this;
              }
              this.sound.muted = false;
              return this;
            };
            this.toggleMute = function() {
              if (!supported) {
                return this;
              }
              this.sound.muted = !this.sound.muted;
              return this;
            };
            this.isMuted = function() {
              if (!supported) {
                return null;
              }
              return this.sound.muted;
            };
            this.setVolume = function(volume) {
              if (!supported) {
                return this;
              }
              if (volume < 0) {
                volume = 0;
              }
              if (volume > 100) {
                volume = 100;
              }
              this.volume = volume;
              this.sound.volume = volume / 100;
              return this;
            };
            this.getVolume = function() {
              if (!supported) {
                return this;
              }
              return this.volume;
            };
            this.increaseVolume = function(value) {
              return this.setVolume(this.volume + (value || 1));
            };
            this.decreaseVolume = function(value) {
              return this.setVolume(this.volume - (value || 1));
            };
            this.setTime = function(time) {
              if (!supported) {
                return this;
              }
              var set = true;
              this.whenReady(function() {
                if (set === true) {
                  set = false;
                  this.sound.currentTime = time;
                }
              });
              return this;
            };
            this.getTime = function() {
              if (!supported) {
                return null;
              }
              var time = Math.round(this.sound.currentTime * 100) / 100;
              return isNaN(time) ? buzz2.defaults.placeholder : time;
            };
            this.setPercent = function(percent) {
              if (!supported) {
                return this;
              }
              return this.setTime(buzz2.fromPercent(percent, this.sound.duration));
            };
            this.getPercent = function() {
              if (!supported) {
                return null;
              }
              var percent = Math.round(buzz2.toPercent(this.sound.currentTime, this.sound.duration));
              return isNaN(percent) ? buzz2.defaults.placeholder : percent;
            };
            this.setSpeed = function(duration) {
              if (!supported) {
                return this;
              }
              this.sound.playbackRate = duration;
              return this;
            };
            this.getSpeed = function() {
              if (!supported) {
                return null;
              }
              return this.sound.playbackRate;
            };
            this.getDuration = function() {
              if (!supported) {
                return null;
              }
              var duration = Math.round(this.sound.duration * 100) / 100;
              return isNaN(duration) ? buzz2.defaults.placeholder : duration;
            };
            this.getPlayed = function() {
              if (!supported) {
                return null;
              }
              return timerangeToArray(this.sound.played);
            };
            this.getBuffered = function() {
              if (!supported) {
                return null;
              }
              return timerangeToArray(this.sound.buffered);
            };
            this.getSeekable = function() {
              if (!supported) {
                return null;
              }
              return timerangeToArray(this.sound.seekable);
            };
            this.getErrorCode = function() {
              if (supported && this.sound.error) {
                return this.sound.error.code;
              }
              return 0;
            };
            this.getErrorMessage = function() {
              if (!supported) {
                return null;
              }
              switch (this.getErrorCode()) {
                case 1:
                  return "MEDIA_ERR_ABORTED";
                case 2:
                  return "MEDIA_ERR_NETWORK";
                case 3:
                  return "MEDIA_ERR_DECODE";
                case 4:
                  return "MEDIA_ERR_SRC_NOT_SUPPORTED";
                default:
                  return null;
              }
            };
            this.getStateCode = function() {
              if (!supported) {
                return null;
              }
              return this.sound.readyState;
            };
            this.getStateMessage = function() {
              if (!supported) {
                return null;
              }
              switch (this.getStateCode()) {
                case 0:
                  return "HAVE_NOTHING";
                case 1:
                  return "HAVE_METADATA";
                case 2:
                  return "HAVE_CURRENT_DATA";
                case 3:
                  return "HAVE_FUTURE_DATA";
                case 4:
                  return "HAVE_ENOUGH_DATA";
                default:
                  return null;
              }
            };
            this.getNetworkStateCode = function() {
              if (!supported) {
                return null;
              }
              return this.sound.networkState;
            };
            this.getNetworkStateMessage = function() {
              if (!supported) {
                return null;
              }
              switch (this.getNetworkStateCode()) {
                case 0:
                  return "NETWORK_EMPTY";
                case 1:
                  return "NETWORK_IDLE";
                case 2:
                  return "NETWORK_LOADING";
                case 3:
                  return "NETWORK_NO_SOURCE";
                default:
                  return null;
              }
            };
            this.set = function(key, value) {
              if (!supported) {
                return this;
              }
              this.sound[key] = value;
              return this;
            };
            this.get = function(key) {
              if (!supported) {
                return null;
              }
              return key ? this.sound[key] : this.sound;
            };
            this.bind = function(types, func) {
              if (!supported) {
                return this;
              }
              types = types.split(" ");
              var self = this, efunc = function(e) {
                func.call(self, e);
              };
              for (var t = 0; t < types.length; t++) {
                var type = types[t], idx = type;
                type = idx.split(".")[0];
                events.push({
                  idx,
                  func: efunc
                });
                this.sound.addEventListener(type, efunc, true);
              }
              return this;
            };
            this.unbind = function(types) {
              if (!supported) {
                return this;
              }
              types = types.split(" ");
              for (var t = 0; t < types.length; t++) {
                var idx = types[t], type = idx.split(".")[0];
                for (var i3 = 0; i3 < events.length; i3++) {
                  var namespace = events[i3].idx.split(".");
                  if (events[i3].idx === idx || namespace[1] && namespace[1] === idx.replace(".", "")) {
                    this.sound.removeEventListener(type, events[i3].func, true);
                    events.splice(i3, 1);
                  }
                }
              }
              return this;
            };
            this.bindOnce = function(type, func) {
              if (!supported) {
                return this;
              }
              var self = this;
              eventsOnce[pid++] = false;
              this.bind(type + "." + pid, function() {
                if (!eventsOnce[pid]) {
                  eventsOnce[pid] = true;
                  func.call(self);
                }
                self.unbind(type + "." + pid);
              });
              return this;
            };
            this.trigger = function(types, detail) {
              if (!supported) {
                return this;
              }
              types = types.split(" ");
              for (var t = 0; t < types.length; t++) {
                var idx = types[t];
                for (var i3 = 0; i3 < events.length; i3++) {
                  var eventType = events[i3].idx.split(".");
                  if (events[i3].idx === idx || eventType[0] && eventType[0] === idx.replace(".", "")) {
                    var evt = doc.createEvent("HTMLEvents");
                    evt.initEvent(eventType[0], false, true);
                    evt.originalEvent = detail;
                    this.sound.dispatchEvent(evt);
                  }
                }
              }
              return this;
            };
            this.fadeTo = function(to, duration, callback) {
              if (!supported) {
                return this;
              }
              if (duration instanceof Function) {
                callback = duration;
                duration = buzz2.defaults.duration;
              } else {
                duration = duration || buzz2.defaults.duration;
              }
              var from = this.volume, delay = duration / Math.abs(from - to), self = this;
              this.play();
              function doFade() {
                setTimeout(function() {
                  if (from < to && self.volume < to) {
                    self.setVolume(self.volume += 1);
                    doFade();
                  } else if (from > to && self.volume > to) {
                    self.setVolume(self.volume -= 1);
                    doFade();
                  } else if (callback instanceof Function) {
                    callback.apply(self);
                  }
                }, delay);
              }
              this.whenReady(function() {
                doFade();
              });
              return this;
            };
            this.fadeIn = function(duration, callback) {
              if (!supported) {
                return this;
              }
              return this.setVolume(0).fadeTo(100, duration, callback);
            };
            this.fadeOut = function(duration, callback) {
              if (!supported) {
                return this;
              }
              return this.fadeTo(0, duration, callback);
            };
            this.fadeWith = function(sound2, duration) {
              if (!supported) {
                return this;
              }
              this.fadeOut(duration, function() {
                this.stop();
              });
              sound2.play().fadeIn(duration);
              return this;
            };
            this.whenReady = function(func) {
              if (!supported) {
                return null;
              }
              var self = this;
              if (this.sound.readyState === 0) {
                this.bind("canplay.buzzwhenready", function() {
                  func.call(self);
                });
              } else {
                func.call(self);
              }
            };
            this.addSource = function(src2) {
              var self = this, source = doc.createElement("source");
              source.src = src2;
              if (buzz2.types[getExt(src2)]) {
                source.type = buzz2.types[getExt(src2)];
              }
              this.sound.appendChild(source);
              source.addEventListener("error", function(e) {
                self.trigger("sourceerror", e);
              });
              return source;
            };
            function timerangeToArray(timeRange) {
              var array = [], length = timeRange.length - 1;
              for (var i3 = 0; i3 <= length; i3++) {
                array.push({
                  start: timeRange.start(i3),
                  end: timeRange.end(i3)
                });
              }
              return array;
            }
            function getExt(filename) {
              return filename.split(".").pop();
            }
            if (supported && src) {
              for (var i2 in buzz2.defaults) {
                if (buzz2.defaults.hasOwnProperty(i2)) {
                  if (options[i2] === void 0) {
                    options[i2] = buzz2.defaults[i2];
                  }
                }
              }
              this.sound = doc.createElement("audio");
              if (options.webAudioApi) {
                var audioCtx = buzz2.getAudioContext();
                if (audioCtx) {
                  this.source = audioCtx.createMediaElementSource(this.sound);
                  this.source.connect(audioCtx.destination);
                }
              }
              if (src instanceof Array) {
                for (var j2 in src) {
                  if (src.hasOwnProperty(j2)) {
                    this.addSource(src[j2]);
                  }
                }
              } else if (options.formats.length) {
                for (var k in options.formats) {
                  if (options.formats.hasOwnProperty(k)) {
                    this.addSource(src + "." + options.formats[k]);
                  }
                }
              } else {
                this.addSource(src);
              }
              if (options.loop) {
                this.loop();
              }
              if (options.autoplay) {
                this.sound.autoplay = "autoplay";
              }
              if (options.preload === true) {
                this.sound.preload = "auto";
              } else if (options.preload === false) {
                this.sound.preload = "none";
              } else {
                this.sound.preload = options.preload;
              }
              this.setVolume(options.volume);
              buzz2.sounds.push(this);
            }
          },
          group: function(sounds) {
            sounds = argsToArray(sounds, arguments);
            this.getSounds = function() {
              return sounds;
            };
            this.add = function(soundArray) {
              soundArray = argsToArray(soundArray, arguments);
              for (var a = 0; a < soundArray.length; a++) {
                sounds.push(soundArray[a]);
              }
            };
            this.remove = function(soundArray) {
              soundArray = argsToArray(soundArray, arguments);
              for (var a = 0; a < soundArray.length; a++) {
                for (var i2 = 0; i2 < sounds.length; i2++) {
                  if (sounds[i2] === soundArray[a]) {
                    sounds.splice(i2, 1);
                    break;
                  }
                }
              }
            };
            this.load = function() {
              fn("load");
              return this;
            };
            this.play = function() {
              fn("play");
              return this;
            };
            this.togglePlay = function() {
              fn("togglePlay");
              return this;
            };
            this.pause = function(time) {
              fn("pause", time);
              return this;
            };
            this.stop = function() {
              fn("stop");
              return this;
            };
            this.mute = function() {
              fn("mute");
              return this;
            };
            this.unmute = function() {
              fn("unmute");
              return this;
            };
            this.toggleMute = function() {
              fn("toggleMute");
              return this;
            };
            this.setVolume = function(volume) {
              fn("setVolume", volume);
              return this;
            };
            this.increaseVolume = function(value) {
              fn("increaseVolume", value);
              return this;
            };
            this.decreaseVolume = function(value) {
              fn("decreaseVolume", value);
              return this;
            };
            this.loop = function() {
              fn("loop");
              return this;
            };
            this.unloop = function() {
              fn("unloop");
              return this;
            };
            this.setSpeed = function(speed) {
              fn("setSpeed", speed);
              return this;
            };
            this.setTime = function(time) {
              fn("setTime", time);
              return this;
            };
            this.set = function(key, value) {
              fn("set", key, value);
              return this;
            };
            this.bind = function(type, func) {
              fn("bind", type, func);
              return this;
            };
            this.unbind = function(type) {
              fn("unbind", type);
              return this;
            };
            this.bindOnce = function(type, func) {
              fn("bindOnce", type, func);
              return this;
            };
            this.trigger = function(type) {
              fn("trigger", type);
              return this;
            };
            this.fade = function(from, to, duration, callback) {
              fn("fade", from, to, duration, callback);
              return this;
            };
            this.fadeIn = function(duration, callback) {
              fn("fadeIn", duration, callback);
              return this;
            };
            this.fadeOut = function(duration, callback) {
              fn("fadeOut", duration, callback);
              return this;
            };
            function fn() {
              var args = argsToArray(null, arguments), func = args.shift();
              for (var i2 = 0; i2 < sounds.length; i2++) {
                sounds[i2][func].apply(sounds[i2], args);
              }
            }
            function argsToArray(array, args) {
              return array instanceof Array ? array : Array.prototype.slice.call(args);
            }
          },
          all: function() {
            return new buzz2.group(buzz2.sounds);
          },
          isSupported: function() {
            return !!buzz2.el.canPlayType;
          },
          isOGGSupported: function() {
            return !!buzz2.el.canPlayType && buzz2.el.canPlayType('audio/ogg; codecs="vorbis"');
          },
          isWAVSupported: function() {
            return !!buzz2.el.canPlayType && buzz2.el.canPlayType('audio/wav; codecs="1"');
          },
          isMP3Supported: function() {
            return !!buzz2.el.canPlayType && buzz2.el.canPlayType("audio/mpeg;");
          },
          isAACSupported: function() {
            return !!buzz2.el.canPlayType && (buzz2.el.canPlayType("audio/x-m4a;") || buzz2.el.canPlayType("audio/aac;"));
          },
          toTimer: function(time, withHours) {
            var h, m, s;
            h = Math.floor(time / 3600);
            h = isNaN(h) ? "--" : h >= 10 ? h : "0" + h;
            m = withHours ? Math.floor(time / 60 % 60) : Math.floor(time / 60);
            m = isNaN(m) ? "--" : m >= 10 ? m : "0" + m;
            s = Math.floor(time % 60);
            s = isNaN(s) ? "--" : s >= 10 ? s : "0" + s;
            return withHours ? h + ":" + m + ":" + s : m + ":" + s;
          },
          fromTimer: function(time) {
            var splits = time.toString().split(":");
            if (splits && splits.length === 3) {
              time = parseInt(splits[0], 10) * 3600 + parseInt(splits[1], 10) * 60 + parseInt(splits[2], 10);
            }
            if (splits && splits.length === 2) {
              time = parseInt(splits[0], 10) * 60 + parseInt(splits[1], 10);
            }
            return time;
          },
          toPercent: function(value, total, decimal) {
            var r = Math.pow(10, decimal || 0);
            return Math.round(value * 100 / total * r) / r;
          },
          fromPercent: function(percent, total, decimal) {
            var r = Math.pow(10, decimal || 0);
            return Math.round(total / 100 * percent * r) / r;
          }
        };
        return buzz2;
      });
    }
  });

  // src/lib/pathfinding3D.js
  var require_pathfinding3D = __commonJS({
    "src/lib/pathfinding3D.js"(exports, module) {
      (function(e) {
        if ("function" == typeof bootstrap) bootstrap("pf", e);
        else if ("object" == typeof exports) module.exports = e();
        else if ("function" == typeof define && define.amd) define(e);
        else if ("undefined" != typeof ses) {
          if (!ses.ok()) return;
          ses.makePF = e;
        } else "undefined" != typeof window ? window.PF = e() : global.PF = e();
      })(function() {
        var define2, ses2, bootstrap2, module2, exports2;
        return function(e, t, n) {
          function i2(n2, s2) {
            if (!t[n2]) {
              if (!e[n2]) {
                var o = typeof __require == "function" && __require;
                if (!s2 && o) return o(n2, true);
                if (r) return r(n2, true);
                throw new Error("Cannot find module '" + n2 + "'");
              }
              var u = t[n2] = { exports: {} };
              e[n2][0].call(u.exports, function(t2) {
                var r2 = e[n2][1][t2];
                return i2(r2 ? r2 : t2);
              }, u, u.exports);
            }
            return t[n2].exports;
          }
          var r = typeof __require == "function" && __require;
          for (var s = 0; s < n.length; s++) i2(n[s]);
          return i2;
        }({
          1: [function(require2, module3, exports3) {
            module3.exports = require2("./lib/heap");
          }, { "./lib/heap": 2 }],
          2: [function(require2, module3, exports3) {
            (function() {
              var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;
              floor = Math.floor, min = Math.min;
              defaultCmp = function(x2, y2) {
                if (x2 < y2) {
                  return -1;
                }
                if (x2 > y2) {
                  return 1;
                }
                return 0;
              };
              insort = function(a, x2, lo, hi, cmp) {
                var mid;
                if (lo == null) {
                  lo = 0;
                }
                if (cmp == null) {
                  cmp = defaultCmp;
                }
                if (lo < 0) {
                  throw new Error("lo must be non-negative");
                }
                if (hi == null) {
                  hi = a.length;
                }
                while (lo < hi) {
                  mid = floor((lo + hi) / 2);
                  if (cmp(x2, a[mid]) < 0) {
                    hi = mid;
                  } else {
                    lo = mid + 1;
                  }
                }
                return [].splice.apply(a, [lo, lo - lo].concat(x2)), x2;
              };
              heappush = function(array, item, cmp) {
                if (cmp == null) {
                  cmp = defaultCmp;
                }
                array.push(item);
                return _siftdown(array, 0, array.length - 1, cmp);
              };
              heappop = function(array, cmp) {
                var lastelt, returnitem;
                if (cmp == null) {
                  cmp = defaultCmp;
                }
                lastelt = array.pop();
                if (array.length) {
                  returnitem = array[0];
                  array[0] = lastelt;
                  _siftup(array, 0, cmp);
                } else {
                  returnitem = lastelt;
                }
                return returnitem;
              };
              heapreplace = function(array, item, cmp) {
                var returnitem;
                if (cmp == null) {
                  cmp = defaultCmp;
                }
                returnitem = array[0];
                array[0] = item;
                _siftup(array, 0, cmp);
                return returnitem;
              };
              heappushpop = function(array, item, cmp) {
                var _ref;
                if (cmp == null) {
                  cmp = defaultCmp;
                }
                if (array.length && cmp(array[0], item) < 0) {
                  _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];
                  _siftup(array, 0, cmp);
                }
                return item;
              };
              heapify = function(array, cmp) {
                var i2, _i, _j, _len, _ref, _ref1, _results, _results1;
                if (cmp == null) {
                  cmp = defaultCmp;
                }
                _ref1 = function() {
                  _results1 = [];
                  for (var _j2 = 0, _ref2 = floor(array.length / 2); 0 <= _ref2 ? _j2 < _ref2 : _j2 > _ref2; 0 <= _ref2 ? _j2++ : _j2--) {
                    _results1.push(_j2);
                  }
                  return _results1;
                }.apply(this).reverse();
                _results = [];
                for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                  i2 = _ref1[_i];
                  _results.push(_siftup(array, i2, cmp));
                }
                return _results;
              };
              updateItem = function(array, item, cmp) {
                var pos;
                if (cmp == null) {
                  cmp = defaultCmp;
                }
                pos = array.indexOf(item);
                if (pos === -1) {
                  return;
                }
                _siftdown(array, 0, pos, cmp);
                return _siftup(array, pos, cmp);
              };
              nlargest = function(array, n, cmp) {
                var elem, result, _i, _len, _ref;
                if (cmp == null) {
                  cmp = defaultCmp;
                }
                result = array.slice(0, n);
                if (!result.length) {
                  return result;
                }
                heapify(result, cmp);
                _ref = array.slice(n);
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                  elem = _ref[_i];
                  heappushpop(result, elem, cmp);
                }
                return result.sort(cmp).reverse();
              };
              nsmallest = function(array, n, cmp) {
                var elem, i2, los, result, _i, _j, _len, _ref, _ref1, _results;
                if (cmp == null) {
                  cmp = defaultCmp;
                }
                if (n * 10 <= array.length) {
                  result = array.slice(0, n).sort(cmp);
                  if (!result.length) {
                    return result;
                  }
                  los = result[result.length - 1];
                  _ref = array.slice(n);
                  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                    elem = _ref[_i];
                    if (cmp(elem, los) < 0) {
                      insort(result, elem, 0, null, cmp);
                      result.pop();
                      los = result[result.length - 1];
                    }
                  }
                  return result;
                }
                heapify(array, cmp);
                _results = [];
                for (i2 = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i2 = 0 <= _ref1 ? ++_j : --_j) {
                  _results.push(heappop(array, cmp));
                }
                return _results;
              };
              _siftdown = function(array, startpos, pos, cmp) {
                var newitem, parent, parentpos;
                if (cmp == null) {
                  cmp = defaultCmp;
                }
                newitem = array[pos];
                while (pos > startpos) {
                  parentpos = pos - 1 >> 1;
                  parent = array[parentpos];
                  if (cmp(newitem, parent) < 0) {
                    array[pos] = parent;
                    pos = parentpos;
                    continue;
                  }
                  break;
                }
                return array[pos] = newitem;
              };
              _siftup = function(array, pos, cmp) {
                var childpos, endpos, newitem, rightpos, startpos;
                if (cmp == null) {
                  cmp = defaultCmp;
                }
                endpos = array.length;
                startpos = pos;
                newitem = array[pos];
                childpos = 2 * pos + 1;
                while (childpos < endpos) {
                  rightpos = childpos + 1;
                  if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {
                    childpos = rightpos;
                  }
                  array[pos] = array[childpos];
                  pos = childpos;
                  childpos = 2 * pos + 1;
                }
                array[pos] = newitem;
                return _siftdown(array, startpos, pos, cmp);
              };
              Heap = function() {
                Heap2.push = heappush;
                Heap2.pop = heappop;
                Heap2.replace = heapreplace;
                Heap2.pushpop = heappushpop;
                Heap2.heapify = heapify;
                Heap2.nlargest = nlargest;
                Heap2.nsmallest = nsmallest;
                function Heap2(cmp) {
                  this.cmp = cmp != null ? cmp : defaultCmp;
                  this.nodes = [];
                }
                Heap2.prototype.push = function(x2) {
                  return heappush(this.nodes, x2, this.cmp);
                };
                Heap2.prototype.pop = function() {
                  return heappop(this.nodes, this.cmp);
                };
                Heap2.prototype.peek = function() {
                  return this.nodes[0];
                };
                Heap2.prototype.contains = function(x2) {
                  return this.nodes.indexOf(x2) !== -1;
                };
                Heap2.prototype.replace = function(x2) {
                  return heapreplace(this.nodes, x2, this.cmp);
                };
                Heap2.prototype.pushpop = function(x2) {
                  return heappushpop(this.nodes, x2, this.cmp);
                };
                Heap2.prototype.heapify = function() {
                  return heapify(this.nodes, this.cmp);
                };
                Heap2.prototype.updateItem = function(x2) {
                  return updateItem(this.nodes, x2, this.cmp);
                };
                Heap2.prototype.clear = function() {
                  return this.nodes = [];
                };
                Heap2.prototype.empty = function() {
                  return this.nodes.length === 0;
                };
                Heap2.prototype.size = function() {
                  return this.nodes.length;
                };
                Heap2.prototype.clone = function() {
                  var heap;
                  heap = new Heap2();
                  heap.nodes = this.nodes.slice(0);
                  return heap;
                };
                Heap2.prototype.toArray = function() {
                  return this.nodes.slice(0);
                };
                Heap2.prototype.insert = Heap2.prototype.push;
                Heap2.prototype.remove = Heap2.prototype.pop;
                Heap2.prototype.top = Heap2.prototype.peek;
                Heap2.prototype.front = Heap2.prototype.peek;
                Heap2.prototype.has = Heap2.prototype.contains;
                Heap2.prototype.copy = Heap2.prototype.clone;
                return Heap2;
              }();
              if (typeof module3 !== "undefined" && module3 !== null ? module3.exports : void 0) {
                module3.exports = Heap;
              } else {
                window.Heap = Heap;
              }
            }).call(this);
          }, {}],
          3: [function(require2, module3, exports3) {
            module3.exports = {
              "Heap": require2("heap"),
              "Node": require2("./core/Node"),
              "Grid": require2("./core/Grid"),
              "Util": require2("./core/Util"),
              "Heuristic": require2("./core/Heuristic"),
              "AStarFinder": require2("./finders/AStarFinder"),
              "BestFirstFinder": require2("./finders/BestFirstFinder"),
              "BreadthFirstFinder": require2("./finders/BreadthFirstFinder"),
              "DijkstraFinder": require2("./finders/DijkstraFinder"),
              "BiAStarFinder": require2("./finders/BiAStarFinder"),
              "BiBestFirstFinder": require2("./finders/BiBestFirstFinder"),
              "BiBreadthFirstFinder": require2("./finders/BiBreadthFirstFinder"),
              "BiDijkstraFinder": require2("./finders/BiDijkstraFinder"),
              "JumpPointFinder": require2("./finders/JumpPointFinder"),
              "IDAStarFinder": require2("./finders/IDAStarFinder")
            };
          }, { "./core/Grid": 4, "./core/Heuristic": 5, "./core/Node": 6, "./core/Util": 7, "./finders/AStarFinder": 8, "./finders/BestFirstFinder": 9, "./finders/BiAStarFinder": 10, "./finders/BiBestFirstFinder": 11, "./finders/BiBreadthFirstFinder": 12, "./finders/BiDijkstraFinder": 13, "./finders/BreadthFirstFinder": 14, "./finders/DijkstraFinder": 15, "./finders/IDAStarFinder": 16, "./finders/JumpPointFinder": 17, "heap": 1 }],
          4: [function(require2, module3, exports3) {
            var Node = require2("./Node");
            function Grid2(width, height, depth, matrix) {
              this.width = width;
              this.height = height;
              this.depth = depth;
              this.nodes = this._buildNodes(width, height, depth, matrix);
            }
            Grid2.prototype._buildNodes = function(width, height, depth, matrix) {
              var i2, j2, z2, nodes = new Array(height), row;
              for (i2 = 0; i2 < height; ++i2) {
                nodes[i2] = new Array(width);
                for (j2 = 0; j2 < width; ++j2) {
                  nodes[i2][j2] = new Array(depth);
                  for (z2 = 0; z2 < depth; ++z2) {
                    nodes[i2][j2][z2] = new Node(j2, i2, z2);
                  }
                }
              }
              if (matrix === void 0) {
                return nodes;
              }
              if (matrix.length !== height || matrix[0].length !== width) {
                throw new Error("Matrix size does not fit");
              }
              for (i2 = 0; i2 < height; ++i2) {
                for (j2 = 0; j2 < width; ++j2) {
                  for (z2 = 0; z2 < depth; ++z2) {
                    nodes[i2][j2][z2].walkable = matrix[i2][j2][z2];
                  }
                }
              }
              return nodes;
            };
            Grid2.prototype.getNodeAt = function(x2, y2, z2) {
              return this.nodes[y2][x2][z2];
            };
            Grid2.prototype.isWalkableAt = function(x2, y2, z2, d2) {
              return this.isInside(x2, y2, z2) && (this.nodes[y2][x2][z2].walkable & d2) == d2;
            };
            Grid2.prototype.isInside = function(x2, y2, z2) {
              return x2 >= 0 && x2 < this.width && (y2 >= 0 && y2 < this.height) && (z2 >= 0 && z2 < this.depth);
            };
            Grid2.prototype.setWalkableAt = function(x2, y2, z2, walkable) {
              this.nodes[y2][x2][z2].walkable = walkable;
            };
            Grid2.prototype.getNeighbors = function(node, allowDiagonal, dontCrossCorners) {
              var x2 = node.x, y2 = node.y, z2 = node.z, neighbors2 = [], s0 = false, d0 = false, s1 = false, d1 = false, s2 = false, d2 = false, s3 = false, d3 = false, s4 = false, s5 = false, nodes = this.nodes;
              if (this.isWalkableAt(x2, y2, z2, 128) && this.isInside(x2, y2 - 1, z2, 8)) {
                neighbors2.push(nodes[y2 - 1][x2][z2]);
                s0 = true;
              }
              if (this.isWalkableAt(x2, y2, z2, 32) && this.isInside(x2 + 1, y2, z2, 2)) {
                neighbors2.push(nodes[y2][x2 + 1][z2]);
                s1 = true;
              }
              if (this.isWalkableAt(x2, y2, z2, 8) && this.isInside(x2, y2 + 1, z2, 128)) {
                neighbors2.push(nodes[y2 + 1][x2][z2]);
                s2 = true;
              }
              if (this.isWalkableAt(x2, y2, z2, 2) && this.isInside(x2 - 1, y2, z2, 32)) {
                neighbors2.push(nodes[y2][x2 - 1][z2]);
                s3 = true;
              }
              if (this.isWalkableAt(x2, y2, z2, 512) && this.isInside(x2, y2, z2 + 1, 256)) {
                neighbors2.push(nodes[y2][x2][z2 + 1]);
                s4 = true;
              }
              if (this.isWalkableAt(x2, y2, z2, 256) && this.isInside(x2, y2, z2 - 1, 512)) {
                neighbors2.push(nodes[y2][x2][z2 - 1]);
                s5 = true;
              }
              if (!allowDiagonal) {
                return neighbors2;
              }
              if (dontCrossCorners) {
                d0 = s3 && s0;
                d1 = s0 && s1;
                d2 = s1 && s2;
                d3 = s2 && s3;
              } else {
                d0 = s3 || s0 || true;
                d1 = s0 || s1 || true;
                d2 = s1 || s2 || true;
                d3 = s2 || s3 || true;
              }
              if (d0 && this.isWalkableAt(x2, y2, z2, 1) && this.isInside(x2 - 1, y2 - 1, z2, 16)) {
                neighbors2.push(nodes[y2 - 1][x2 - 1][z2]);
              }
              if (d1 && this.isWalkableAt(x2, y2, z2, 64) && this.isInside(x2 + 1, y2 - 1, z2, 4)) {
                neighbors2.push(nodes[y2 - 1][x2 + 1][z2]);
              }
              if (d2 && this.isWalkableAt(x2, y2, z2, 16) && this.isInside(x2 + 1, y2 + 1, z2, 1)) {
                neighbors2.push(nodes[y2 + 1][x2 + 1][z2]);
              }
              if (d3 && this.isWalkableAt(x2, y2, z2, 4) && this.isInside(x2 - 1, y2 + 1, z2, 64)) {
                neighbors2.push(nodes[y2 + 1][x2 - 1][z2]);
              }
              return neighbors2;
            };
            Grid2.prototype.clone = function() {
              var i2, j2, width = this.width, height = this.height, depth = this.depth, thisNodes = this.nodes, newGrid = new Grid2(width, height, depth), newNodes = new Array(height), row;
              for (i2 = 0; i2 < height; ++i2) {
                newNodes[i2] = new Array(width);
                for (j2 = 0; j2 < width; ++j2) {
                  newNodes[i2][j2] = new Array(depth);
                  for (z = 0; z < depth; ++z) {
                    newNodes[i2][j2][z] = new Node(j2, i2, z, thisNodes[i2][j2][z].walkable);
                  }
                }
              }
              newGrid.nodes = newNodes;
              return newGrid;
            };
            module3.exports = Grid2;
          }, { "./Node": 6 }],
          5: [function(require2, module3, exports3) {
            module3.exports = {
              /**
               * Manhattan distance.
               * @param {number} dx - Difference in x.
               * @param {number} dy - Difference in y.
               * @return {number} dx + dy
               */
              manhattan: function(dx2, dy2, dz2) {
                return dx2 + dy2 + dz2;
              },
              /**
               * Euclidean distance.
               * @param {number} dx - Difference in x.
               * @param {number} dy - Difference in y.
               * @return {number} sqrt(dx * dx + dy * dy)
               */
              euclidean: function(dx2, dy2, dz2) {
                return Math.sqrt(dx2 * dx2 + dy2 * dy2 + dz2 * dz2);
              },
              /**
               * Chebyshev distance.
               * @param {number} dx - Difference in x.
               * @param {number} dy - Difference in y.
               * @return {number} max(dx, dy)
               */
              chebyshev: function(dx2, dy2, dz2) {
                return Math.max(dx2, dy2, dz2);
              }
            };
          }, {}],
          6: [function(require2, module3, exports3) {
            function Node(x2, y2, z2, walkable) {
              this.x = x2;
              this.y = y2;
              this.walkable = walkable === void 0 ? true : walkable;
              this.z = z2;
            }
            module3.exports = Node;
          }, {}],
          7: [function(require2, module3, exports3) {
            function backtrace(node) {
              var path = [[node.x, node.y, node.z]];
              while (node.parent) {
                node = node.parent;
                path.push([node.x, node.y, node.z]);
              }
              return path.reverse();
            }
            exports3.backtrace = backtrace;
            function biBacktrace(nodeA, nodeB) {
              var pathA = backtrace(nodeA), pathB = backtrace(nodeB);
              return pathA.concat(pathB.reverse());
            }
            exports3.biBacktrace = biBacktrace;
            function pathLength(path) {
              var i2, sum = 0, a, b, dx2, dy2, dz2;
              for (i2 = 1; i2 < path.length; ++i2) {
                a = path[i2 - 1];
                b = path[i2];
                dx2 = a[0] - b[0];
                dy2 = a[1] - b[1];
                dz2 = a[2] - b[2];
                sum += Math.sqrt(dx2 * dx2 + dy2 * dy2 + dz2 * dz2);
              }
              return sum;
            }
            exports3.pathLength = pathLength;
            function getLine(x1, y1, z1, x2, y2, z2) {
              let ListOfPoints = [];
              ListOfPoints.push([x1, y1, z1]);
              let dx2 = Math.abs(x2 - x1);
              let dy2 = Math.abs(y2 - y1);
              let dz2 = Math.abs(z2 - z1);
              let xs;
              let ys;
              let zs;
              if (x2 > x1) {
                xs = 1;
              } else {
                xs = -1;
              }
              if (y2 > y1) {
                ys = 1;
              } else {
                ys = -1;
              }
              if (z2 > z1) {
                zs = 1;
              } else {
                zs = -1;
              }
              if (dx2 >= dy2 && dx2 >= dz2) {
                let p1 = 2 * dy2 - dx2;
                let p2 = 2 * dz2 - dx2;
                while (x1 != x2) {
                  x1 += xs;
                  if (p1 >= 0) {
                    y1 += ys;
                    p1 -= 2 * dx2;
                  }
                  if (p2 >= 0) {
                    z1 += zs;
                    p2 -= 2 * dx2;
                  }
                  p1 += 2 * dy2;
                  p2 += 2 * dz2;
                  ListOfPoints.push([x1, y1, z1]);
                }
              } else if (dy2 >= dx2 && dy2 >= dz2) {
                let p1 = 2 * dx2 - dy2;
                let p2 = 2 * dz2 - dy2;
                while (y1 != y2) {
                  y1 += ys;
                  if (p1 >= 0) {
                    x1 += xs;
                    p1 -= 2 * dy2;
                  }
                  if (p2 >= 0) {
                    z1 += zs;
                    p2 -= 2 * dy2;
                  }
                  p1 += 2 * dx2;
                  p2 += 2 * dz2;
                  ListOfPoints.push([x1, y1, z1]);
                }
              } else {
                let p1 = 2 * dy2 - dz2;
                let p2 = 2 * dx2 - dz2;
                while (z1 != z2) {
                  z1 += zs;
                  if (p1 >= 0) {
                    y1 += ys;
                    p1 -= 2 * dz2;
                  }
                  if (p2 >= 0) {
                    x1 += xs;
                    p2 -= 2 * dz2;
                  }
                  p1 += 2 * dy2;
                  p2 += 2 * dx2;
                  ListOfPoints.push([x1, y1, z1]);
                }
              }
              return ListOfPoints;
            }
            exports3.getLine = getLine;
            function smoothenPath(grid, path) {
              var len = path.length, x0 = path[0][0], y0 = path[0][1], z0 = path[0][2], x1 = path[len - 1][0], y1 = path[len - 1][1], z1 = path[len - 1][2], sx, sy, sz;
              ex, ey, ez;
              lx, ly, lz;
              newPath, i, j, coord, line, testCoord, blocked;
              sx = x0;
              sy = y0;
              sz = z0;
              lx = path[1][0];
              ly = path[1][1];
              lz = path[1][2];
              newPath = [[sx, sy, sz]];
              for (i = 2; i < len; ++i) {
                coord = path[i];
                ex = coord[0];
                ey = coord[1];
                ez = coord[2];
                line = getLine(sx, sy, sz, ex, ey, ez);
                blocked = false;
                for (j = 1; j < line.length; ++j) {
                  testCoord = line[j];
                  if (!grid.isWalkableAt(testCoord[0], testCoord[1])) {
                    blocked = true;
                    newPath.push([lx, ly]);
                    sx = lx;
                    sy = ly;
                    break;
                  }
                }
                if (!blocked) {
                  lx = ex;
                  ly = ey;
                }
              }
              newPath.push([x1, y1]);
              return newPath;
            }
            exports3.smoothenPath = smoothenPath;
          }, {}],
          8: [function(require2, module3, exports3) {
            var Heap = require2("heap");
            var Util = require2("../core/Util");
            var Heuristic = require2("../core/Heuristic");
            function AStarFinder2(opt) {
              opt = opt || {};
              this.allowDiagonal = opt.allowDiagonal;
              this.dontCrossCorners = opt.dontCrossCorners;
              this.heuristic = opt.heuristic || Heuristic.manhattan;
              this.weight = opt.weight || 1;
            }
            AStarFinder2.prototype.findPath = function(startX, startY, startZ, endX, endY, endZ, grid) {
              if (!grid.isInside(startX, startY, startZ) || !grid.isInside(endX, endY, endZ))
                return [];
              var openList = new Heap(function(nodeA, nodeB) {
                return nodeA.f - nodeB.f;
              });
              var startNode = grid.getNodeAt(startX, startY, startZ), endNode = grid.getNodeAt(endX, endY, endZ), heuristic = this.heuristic, allowDiagonal = this.allowDiagonal, dontCrossCorners = this.dontCrossCorners, weight = this.weight, abs2 = Math.abs, SQRT2 = Math.SQRT2, node, neighbors2, neighbor2, i2, l2, x2, y2, ng2, z2;
              startNode.g = 0;
              startNode.f = 0;
              openList.push(startNode);
              startNode.opened = true;
              while (!openList.empty()) {
                node = openList.pop();
                node.closed = true;
                if (node === endNode) {
                  return Util.backtrace(endNode);
                }
                neighbors2 = grid.getNeighbors(node, allowDiagonal, dontCrossCorners);
                for (i2 = 0, l2 = neighbors2.length; i2 < l2; ++i2) {
                  neighbor2 = neighbors2[i2];
                  if (neighbor2.closed) {
                    continue;
                  }
                  x2 = neighbor2.x;
                  y2 = neighbor2.y;
                  z2 = neighbor2.z;
                  ng2 = node.g + (x2 - node.x === 0 || y2 - node.y === 0 || z2 - node.z === 0 ? 1 : SQRT2);
                  if (!neighbor2.opened || ng2 < neighbor2.g) {
                    neighbor2.g = ng2;
                    neighbor2.h = neighbor2.h || weight * heuristic(abs2(x2 - endX), abs2(y2 - endY), abs2(z2 - endZ));
                    neighbor2.f = neighbor2.g + neighbor2.h;
                    neighbor2.parent = node;
                    if (!neighbor2.opened) {
                      openList.push(neighbor2);
                      neighbor2.opened = true;
                    } else {
                      openList.updateItem(neighbor2);
                    }
                  }
                }
              }
              return [];
            };
            module3.exports = AStarFinder2;
          }, { "../core/Heuristic": 5, "../core/Util": 7, "heap": 1 }],
          9: [function(require2, module3, exports3) {
            var AStarFinder2 = require2("./AStarFinder");
            function BestFirstFinder(opt) {
              AStarFinder2.call(this, opt);
              var orig = this.heuristic;
              this.heuristic = function(dx2, dy2, dz2) {
                return orig(dx2, dy2, dz2) * 1e6;
              };
            }
            BestFirstFinder.prototype = new AStarFinder2();
            BestFirstFinder.prototype.constructor = BestFirstFinder;
            module3.exports = BestFirstFinder;
          }, { "./AStarFinder": 8 }],
          10: [function(require2, module3, exports3) {
            var Heap = require2("heap");
            var Util = require2("../core/Util");
            var Heuristic = require2("../core/Heuristic");
            function BiAStarFinder(opt) {
              opt = opt || {};
              this.allowDiagonal = opt.allowDiagonal;
              this.dontCrossCorners = opt.dontCrossCorners;
              this.heuristic = opt.heuristic || Heuristic.manhattan;
              this.weight = opt.weight || 1;
            }
            BiAStarFinder.prototype.findPath = function(startX, startY, startZ, endX, endY, endZ, grid) {
              var cmp = function(nodeA, nodeB) {
                return nodeA.f - nodeB.f;
              }, startOpenList = new Heap(cmp), endOpenList = new Heap(cmp), startNode = grid.getNodeAt(startX, startY), endNode = grid.getNodeAt(endX, endY), heuristic = this.heuristic, allowDiagonal = this.allowDiagonal, dontCrossCorners = this.dontCrossCorners, weight = this.weight, abs2 = Math.abs, SQRT2 = Math.SQRT2, node, neighbors2, neighbor2, i2, l2, x2, y2, ng2, z2, BY_START = 1, BY_END = 2;
              startNode.g = 0;
              startNode.f = 0;
              startOpenList.push(startNode);
              startNode.opened = BY_START;
              endNode.g = 0;
              endNode.f = 0;
              endOpenList.push(endNode);
              endNode.opened = BY_END;
              while (!startOpenList.empty() && !endOpenList.empty()) {
                node = startOpenList.pop();
                node.closed = true;
                neighbors2 = grid.getNeighbors(node, allowDiagonal, dontCrossCorners);
                for (i2 = 0, l2 = neighbors2.length; i2 < l2; ++i2) {
                  neighbor2 = neighbors2[i2];
                  if (neighbor2.closed) {
                    continue;
                  }
                  if (neighbor2.opened === BY_END) {
                    return Util.biBacktrace(node, neighbor2);
                  }
                  x2 = neighbor2.x;
                  y2 = neighbor2.y;
                  z2 = neighbor2.z;
                  ng2 = node.g + (x2 - node.x === 0 || y2 - node.y === 0 || z2 - node.z === 0 ? 1 : SQRT2);
                  if (!neighbor2.opened || ng2 < neighbor2.g) {
                    neighbor2.g = ng2;
                    neighbor2.h = neighbor2.h || weight * heuristic(abs2(x2 - endX), abs2(y2 - endY), abs2(z2 - endZ));
                    neighbor2.f = neighbor2.g + neighbor2.h;
                    neighbor2.parent = node;
                    if (!neighbor2.opened) {
                      startOpenList.push(neighbor2);
                      neighbor2.opened = BY_START;
                    } else {
                      startOpenList.updateItem(neighbor2);
                    }
                  }
                }
                node = endOpenList.pop();
                node.closed = true;
                neighbors2 = grid.getNeighbors(node, allowDiagonal, dontCrossCorners);
                for (i2 = 0, l2 = neighbors2.length; i2 < l2; ++i2) {
                  neighbor2 = neighbors2[i2];
                  if (neighbor2.closed) {
                    continue;
                  }
                  if (neighbor2.opened === BY_START) {
                    return Util.biBacktrace(neighbor2, node);
                  }
                  x2 = neighbor2.x;
                  y2 = neighbor2.y;
                  z2 = neighbor2.z;
                  ng2 = node.g + (x2 - node.x === 0 || y2 - node.y === 0 || z2 - node.z === 0 ? 1 : SQRT2);
                  if (!neighbor2.opened || ng2 < neighbor2.g) {
                    neighbor2.g = ng2;
                    neighbor2.h = neighbor2.h || weight * heuristic(abs2(x2 - startX), abs2(y2 - startY), abs2(z2 - startZ));
                    neighbor2.f = neighbor2.g + neighbor2.h;
                    neighbor2.parent = node;
                    if (!neighbor2.opened) {
                      endOpenList.push(neighbor2);
                      neighbor2.opened = BY_END;
                    } else {
                      endOpenList.updateItem(neighbor2);
                    }
                  }
                }
              }
              return [];
            };
            module3.exports = BiAStarFinder;
          }, { "../core/Heuristic": 5, "../core/Util": 7, "heap": 1 }],
          11: [function(require2, module3, exports3) {
            var BiAStarFinder = require2("./BiAStarFinder");
            function BiBestFirstFinder(opt) {
              BiAStarFinder.call(this, opt);
              var orig = this.heuristic;
              this.heuristic = function(dx2, dy2, dz2) {
                return orig(dx2, dy2, dz2) * 1e6;
              };
            }
            BiBestFirstFinder.prototype = new BiAStarFinder();
            BiBestFirstFinder.prototype.constructor = BiBestFirstFinder;
            module3.exports = BiBestFirstFinder;
          }, { "./BiAStarFinder": 10 }],
          12: [function(require2, module3, exports3) {
            var Util = require2("../core/Util");
            function BiBreadthFirstFinder(opt) {
              opt = opt || {};
              this.allowDiagonal = opt.allowDiagonal;
              this.dontCrossCorners = opt.dontCrossCorners;
            }
            BiBreadthFirstFinder.prototype.findPath = function(startX, startY, startZ, endX, endY, endZ, grid) {
              var startNode = grid.getNodeAt(startX, startY, startZ), endNode = grid.getNodeAt(endX, endY, endZ), startOpenList = [], endOpenList = [], neighbors2, neighbor2, node, allowDiagonal = this.allowDiagonal, dontCrossCorners = this.dontCrossCorners, BY_START = 0, BY_END = 1, i2, l2;
              startOpenList.push(startNode);
              startNode.opened = true;
              startNode.by = BY_START;
              endOpenList.push(endNode);
              endNode.opened = true;
              endNode.by = BY_END;
              while (startOpenList.length && endOpenList.length) {
                node = startOpenList.shift();
                node.closed = true;
                neighbors2 = grid.getNeighbors(node, allowDiagonal, dontCrossCorners);
                for (i2 = 0, l2 = neighbors2.length; i2 < l2; ++i2) {
                  neighbor2 = neighbors2[i2];
                  if (neighbor2.closed) {
                    continue;
                  }
                  if (neighbor2.opened) {
                    if (neighbor2.by === BY_END) {
                      return Util.biBacktrace(node, neighbor2);
                    }
                    continue;
                  }
                  startOpenList.push(neighbor2);
                  neighbor2.parent = node;
                  neighbor2.opened = true;
                  neighbor2.by = BY_START;
                }
                node = endOpenList.shift();
                node.closed = true;
                neighbors2 = grid.getNeighbors(node, allowDiagonal, dontCrossCorners);
                for (i2 = 0, l2 = neighbors2.length; i2 < l2; ++i2) {
                  neighbor2 = neighbors2[i2];
                  if (neighbor2.closed) {
                    continue;
                  }
                  if (neighbor2.opened) {
                    if (neighbor2.by === BY_START) {
                      return Util.biBacktrace(neighbor2, node);
                    }
                    continue;
                  }
                  endOpenList.push(neighbor2);
                  neighbor2.parent = node;
                  neighbor2.opened = true;
                  neighbor2.by = BY_END;
                }
              }
              return [];
            };
            module3.exports = BiBreadthFirstFinder;
          }, { "../core/Util": 7 }],
          13: [function(require2, module3, exports3) {
            var BiAStarFinder = require2("./BiAStarFinder");
            function BiDijkstraFinder(opt) {
              BiAStarFinder.call(this, opt);
              this.heuristic = function(dx2, dy2, dz2) {
                return 0;
              };
            }
            BiDijkstraFinder.prototype = new BiAStarFinder();
            BiDijkstraFinder.prototype.constructor = BiDijkstraFinder;
            module3.exports = BiDijkstraFinder;
          }, { "./BiAStarFinder": 10 }],
          14: [function(require2, module3, exports3) {
            var Util = require2("../core/Util");
            function BreadthFirstFinder(opt) {
              opt = opt || {};
              this.allowDiagonal = opt.allowDiagonal;
              this.dontCrossCorners = opt.dontCrossCorners;
            }
            BreadthFirstFinder.prototype.findPath = function(startX, startY, startZ, endX, endY, endZ, grid) {
              var openList = [], allowDiagonal = this.allowDiagonal, dontCrossCorners = this.dontCrossCorners, startNode = grid.getNodeAt(startX, startY, startZ), endNode = grid.getNodeAt(endX, endY, endZ), neighbors2, neighbor2, node, i2, l2;
              openList.push(startNode);
              startNode.opened = true;
              while (openList.length) {
                node = openList.shift();
                node.closed = true;
                if (node === endNode) {
                  return Util.backtrace(endNode);
                }
                neighbors2 = grid.getNeighbors(node, allowDiagonal, dontCrossCorners);
                for (i2 = 0, l2 = neighbors2.length; i2 < l2; ++i2) {
                  neighbor2 = neighbors2[i2];
                  if (neighbor2.closed || neighbor2.opened) {
                    continue;
                  }
                  openList.push(neighbor2);
                  neighbor2.opened = true;
                  neighbor2.parent = node;
                }
              }
              return [];
            };
            module3.exports = BreadthFirstFinder;
          }, { "../core/Util": 7 }],
          15: [function(require2, module3, exports3) {
            var AStarFinder2 = require2("./AStarFinder");
            function DijkstraFinder(opt) {
              AStarFinder2.call(this, opt);
              this.heuristic = function(dx2, dy2, dz2) {
                return 0;
              };
            }
            DijkstraFinder.prototype = new AStarFinder2();
            DijkstraFinder.prototype.constructor = DijkstraFinder;
            module3.exports = DijkstraFinder;
          }, { "./AStarFinder": 8 }],
          16: [function(require2, module3, exports3) {
            var Util = require2("../core/Util");
            var Heuristic = require2("../core/Heuristic");
            var Node = require2("../core/Node");
            function IDAStarFinder(opt) {
              opt = opt || {};
              this.allowDiagonal = opt.allowDiagonal;
              this.dontCrossCorners = opt.dontCrossCorners;
              this.heuristic = opt.heuristic || Heuristic.manhattan;
              this.weight = opt.weight || 1;
              this.trackRecursion = opt.trackRecursion || false;
              this.timeLimit = opt.timeLimit || Infinity;
            }
            IDAStarFinder.prototype.findPath = function(startX, startY, startZ, endX, endY, endZ, grid) {
              var nodesVisited = 0;
              var startTime = (/* @__PURE__ */ new Date()).getTime();
              var h = function(a, b) {
                return this.heuristic(Math.abs(b.x - a.x), Math.abs(b.y - a.y), Math.abs(b.z - a.z));
              }.bind(this);
              var cost = function(a, b) {
                return a.x === b.x || a.y === b.y || a.z === b.z ? 1 : Math.SQRT2;
              };
              var search = function(node, g, cutoff, route2, depth) {
                nodesVisited++;
                if (this.timeLimit > 0 && (/* @__PURE__ */ new Date()).getTime() - startTime > this.timeLimit * 1e3) {
                  return Infinity;
                }
                var f = g + h(node, end) * this.weight;
                if (f > cutoff) {
                  return f;
                }
                if (node == end) {
                  route2[depth] = [node.x, node.y, node.z];
                  return node;
                }
                var min, t2, k, neighbour;
                var neighbours = grid.getNeighbors(node, this.allowDiagonal, this.dontCrossCorners);
                for (k = 0, min = Infinity; neighbour = neighbours[k]; ++k) {
                  if (this.trackRecursion) {
                    neighbour.retainCount = neighbour.retainCount + 1 || 1;
                    if (neighbour.tested !== true) {
                      neighbour.tested = true;
                    }
                  }
                  t2 = search(neighbour, g + cost(node, neighbour), cutoff, route2, depth + 1);
                  if (t2 instanceof Node) {
                    route2[depth] = [node.x, node.y, node.z];
                    return t2;
                  }
                  if (this.trackRecursion && --neighbour.retainCount === 0) {
                    neighbour.tested = false;
                  }
                  if (t2 < min) {
                    min = t2;
                  }
                }
                return min;
              }.bind(this);
              var start = grid.getNodeAt(startX, startY, startZ);
              var end = grid.getNodeAt(endX, endY, endZ);
              var cutOff = h(start, end);
              var j2, route, t;
              for (j2 = 0; true; ++j2) {
                route = [];
                t = search(start, 0, cutOff, route, 0);
                if (t === Infinity) {
                  return [];
                }
                if (t instanceof Node) {
                  return route;
                }
                cutOff = t;
              }
              return [];
            };
            module3.exports = IDAStarFinder;
          }, { "../core/Heuristic": 5, "../core/Node": 6, "../core/Util": 7 }],
          17: [function(require2, module3, exports3) {
            var Heap = require2("heap");
            var Util = require2("../core/Util");
            var Heuristic = require2("../core/Heuristic");
            function JumpPointFinder(opt) {
              opt = opt || {};
              this.heuristic = opt.heuristic || Heuristic.manhattan;
              this.trackJumpRecursion = opt.trackJumpRecursion || false;
            }
            JumpPointFinder.prototype.findPath = function(startX, startY, startZ, endX, endY, endZ, grid) {
              var openList = this.openList = new Heap(function(nodeA, nodeB) {
                return nodeA.f - nodeB.f;
              }), startNode = this.startNode = grid.getNodeAt(startX, startY, startZ), endNode = this.endNode = grid.getNodeAt(endX, endY, endZ), node;
              this.grid = grid;
              startNode.g = 0;
              startNode.f = 0;
              openList.push(startNode);
              startNode.opened = true;
              while (!openList.empty()) {
                node = openList.pop();
                node.closed = true;
                if (node === endNode) {
                  return Util.backtrace(endNode);
                }
                this._identifySuccessors(node);
              }
              return [];
            };
            JumpPointFinder.prototype._identifySuccessors = function(node) {
              var grid = this.grid, heuristic = this.heuristic, openList = this.openList, endX = this.endNode.x, endY = this.endNode.y, endZ = this.endNode.z;
              neighbors, neighbor, jumpPoint, i, l, x = node.x, y = node.y, z = node.z;
              jx, jy, dx, dy, d, ng, jumpNode, dz, jz;
              abs = Math.abs, max = Math.max;
              neighbors = this._findNeighbors(node);
              for (i = 0, l = neighbors.length; i < l; ++i) {
                neighbor = neighbors[i];
                jumpPoint = this._jump(neighbor[0], neighbor[1], x, y, z);
                if (jumpPoint) {
                  jx = jumpPoint[0];
                  jy = jumpPoint[1];
                  jz = jumpPoint[2];
                  jumpNode = grid.getNodeAt(jx, jy, jz);
                  if (jumpNode.closed) {
                    continue;
                  }
                  d = Heuristic.euclidean(abs(jx - x), abs(jy - y), abs(jz - z));
                  ng = node.g + d;
                  if (!jumpNode.opened || ng < jumpNode.g) {
                    jumpNode.g = ng;
                    jumpNode.h = jumpNode.h || heuristic(abs(jx - endX), abs(jy - endY), abs(jz - endZ));
                    jumpNode.f = jumpNode.g + jumpNode.h;
                    jumpNode.parent = node;
                    if (!jumpNode.opened) {
                      openList.push(jumpNode);
                      jumpNode.opened = true;
                    } else {
                      openList.updateItem(jumpNode);
                    }
                  }
                }
              }
            };
            JumpPointFinder.prototype._jump = function(x2, y2, z2, px, py, pz) {
              var grid = this.grid, dx2 = x2 - px, dy2 = y2 - py, jx2, jy2;
              dz = z2 - pz, jz;
              if (!grid.isWalkableAt(x2, y2, z2)) {
                return null;
              }
              if (this.trackJumpRecursion === true) {
                grid.getNodeAt(x2, y2, z2).tested = true;
              }
              if (grid.getNodeAt(x2, y2, z2) === this.endNode) {
                return [x2, y2, z2];
              }
              if (dx2 !== 0 && dy2 !== 0) {
                if (grid.isWalkableAt(x2 - dx2, y2 + dy2, z2) && !grid.isWalkableAt(x2 - dx2, y2, z2) || grid.isWalkableAt(x2 + dx2, y2 - dy2, z2) && !grid.isWalkableAt(x2, y2 - dy2, z2)) {
                  return [x2, y2, z2];
                }
              } else {
                if (dx2 !== 0) {
                  if (grid.isWalkableAt(x2 + dx2, y2 + 1, z2) && !grid.isWalkableAt(x2, y2 + 1, z2) || grid.isWalkableAt(x2 + dx2, y2 - 1, z2) && !grid.isWalkableAt(x2, y2 - 1, z2)) {
                    return [x2, y2, z2];
                  }
                } else {
                  if (grid.isWalkableAt(x2 + 1, y2 + dy2, z2) && !grid.isWalkableAt(x2 + 1, y2, z2) || grid.isWalkableAt(x2 - 1, y2 + dy2, z2) && !grid.isWalkableAt(x2 - 1, y2, z2)) {
                    return [x2, y2, z2];
                  }
                }
              }
              if (dz !== 0) {
                jz = his._jump(x2, y2, z2 + dz, x2, y2, z2);
                if (jz) return [x2, y2, z2];
              }
              if (dx2 !== 0 && dy2 !== 0) {
                jx2 = this._jump(x2 + dx2, y2, z2, x2, y2, z2);
                jy2 = this._jump(x2, y2 + dy2, z2, x2, y2, z2);
                if (jx2 || jy2) {
                  return [x2, y2, z2];
                }
              }
              if (grid.isWalkableAt(x2 + dx2, y2, z2) || grid.isWalkableAt(x2, y2 + dy2, z2)) {
                return this._jump(x2 + dx2, y2 + dy2, z2, x2, y2, z2);
              } else {
                return null;
              }
            };
            JumpPointFinder.prototype._findNeighbors = function(node) {
              var parent = node.parent, x2 = node.x, y2 = node.y, z2 = node.z, grid = this.grid, px, py, nx, ny, dx2, dy2, pz, nz, dz2;
              neighbors = [], neighborNodes, neighborNode, i, l;
              if (parent) {
                px = parent.x;
                py = parent.y;
                pz = parent.z;
                dx2 = (x2 - px) / Math.max(Math.abs(x2 - px), 1);
                dy2 = (y2 - py) / Math.max(Math.abs(y2 - py), 1);
                dz2 = (z2 - pz) / Math.max(Math.abs(z2 - pz), 1);
                if (dz2 !== 0) {
                  if (grid.isWalkableAt(x2, y2, z2 + dz2)) {
                    if (grid.isWalkableAt(x2, y2, z2 + dz2)) {
                      neighbors.push([x2 + dx2, y2 + dy2, z2 + dz2]);
                    }
                    if (!grid.isWalkableAt(x2, y2, z2 + 1)) {
                      neighbors.push([x2 + dx2, y2 + dy2, z2 + 1]);
                    }
                    if (!grid.isWalkableAt(x2, y2, z2 - 1)) {
                      neighbors.push([x2 + dx2, y2 + dy2, z2 - 1]);
                    }
                  }
                } else if (dx2 !== 0 && dy2 !== 0) {
                  if (grid.isWalkableAt(x2, y2 + dy2, z2)) {
                    neighbors.push([x2, y2 + dy2, z2]);
                  }
                  if (grid.isWalkableAt(x2 + dx2, y2, z2)) {
                    neighbors.push([x2 + dx2, y2, z2]);
                  }
                  if (grid.isWalkableAt(x2, y2 + dy2, z2) || grid.isWalkableAt(x2 + dx2, y2, z2)) {
                    neighbors.push([x2 + dx2, y2 + dy2, z2]);
                  }
                  if (!grid.isWalkableAt(x2 - dx2, y2, z2) && grid.isWalkableAt(x2, y2 + dy2, z2)) {
                    neighbors.push([x2 - dx2, y2 + dy2, z2]);
                  }
                  if (!grid.isWalkableAt(x2, y2 - dy2, z2) && grid.isWalkableAt(x2 + dx2, y2, z2)) {
                    neighbors.push([x2 + dx2, y2 - dy2, z2]);
                  }
                } else {
                  if (dx2 === 0) {
                    if (grid.isWalkableAt(x2, y2 + dy2, z2)) {
                      if (grid.isWalkableAt(x2, y2 + dy2, z2)) {
                        neighbors.push([x2, y2 + dy2, z2]);
                      }
                      if (!grid.isWalkableAt(x2 + 1, y2, z2)) {
                        neighbors.push([x2 + 1, y2 + dy2, z2]);
                      }
                      if (!grid.isWalkableAt(x2 - 1, y2, z2)) {
                        neighbors.push([x2 - 1, y2 + dy2, z2]);
                      }
                    }
                  } else {
                    if (grid.isWalkableAt(x2 + dx2, y2, z2)) {
                      if (grid.isWalkableAt(x2 + dx2, y2, z2)) {
                        neighbors.push([x2 + dx2, y2, z2]);
                      }
                      if (!grid.isWalkableAt(x2, y2 + 1, z2)) {
                        neighbors.push([x2 + dx2, y2 + 1, z2]);
                      }
                      if (!grid.isWalkableAt(x2, y2 - 1, z2)) {
                        neighbors.push([x2 + dx2, y2 - 1, z2]);
                      }
                    }
                  }
                }
              } else {
                neighborNodes = grid.getNeighbors(node, true);
                for (i = 0, l = neighborNodes.length; i < l; ++i) {
                  neighborNode = neighborNodes[i];
                  neighbors.push([neighborNode.x, neighborNode.y, neighborNode.z]);
                }
              }
              return neighbors;
            };
            module3.exports = JumpPointFinder;
          }, { "../core/Heuristic": 5, "../core/Util": 7, "heap": 1 }]
        }, {}, [3])(3);
      });
    }
  });

  // src/events.ts
  var EventEmitter = class {
    #events = {};
    bind(type, listener, caller, once) {
      if (!Array.isArray(this.#events[type]) || typeof this.#events[type] === "undefined")
        this.#events[type] = [];
      this.#events[type].push({ listener, caller, once: once || false });
    }
    on(type, listener, caller) {
      this.bind(type, listener, caller);
    }
    once(type, listener, caller) {
      this.bind(type, listener, caller, true);
    }
    addEventListener(type, listener, caller) {
      this.bind(type, listener, caller);
    }
    fire(type, args, caller) {
      if (!type || typeof type !== "string")
        throw new Error("Event missing.");
      if (!Array.isArray(this.#events[type])) return;
      if (!args || args === null || typeof args === "undefined")
        args = [];
      else if (!Array.isArray(args))
        args = [args];
      caller = caller || this;
      let oEvents = this.#events[type];
      let events = oEvents.slice().reverse();
      const once = [];
      for (let i2 = events.length - 1; i2 >= 0; i2--) {
        if (oEvents.indexOf(events[i2]) === -1) continue;
        if (events[i2] && events[i2].once)
          once.push(events[i2]);
        events[i2].listener.apply(events[i2].caller || caller, args);
      }
      for (let i2 = once.length - 1; i2 >= 0; i2--) {
        let idx = this.#events[type].indexOf(once[i2]);
        if (idx !== -1)
          this.#events[type].splice(idx, 1);
      }
    }
    emit(type, ...args) {
      this.fire(type, args);
    }
    dispatchEvent(type, args, caller) {
      this.fire(type, args, caller);
    }
    unbind(type, listener) {
      if (!type || !listener) return;
      if (!Array.isArray(this.#events[type])) return;
      const events = this.#events[type];
      for (let i2 = events.length - 1; i2 >= 0; i2--) {
        if (events[i2].listener === listener) {
          events.splice(i2, 1);
          break;
        }
      }
    }
    remove(type, listener) {
      this.unbind(type, listener);
    }
    off(type, listener) {
      this.unbind(type, listener);
    }
    removeListener(type, listener) {
      this.unbind(type, listener);
    }
    removeAllListeners(type) {
      if (!type) {
        this.#events = [];
        return;
      }
      if (!Array.isArray(this.#events[type])) return;
      delete this.#events[type];
    }
    removeListenersFromCaller(caller, type) {
      if (!type) {
        Object.keys(this.#events).forEach((key) => {
          const events2 = this.#events[key];
          for (let i2 = events2.length - 1; i2 >= 0; i2--) {
            if (events2[i2].caller === caller) {
              events2.splice(i2, 1);
              break;
            }
          }
        });
        return;
      }
      if (!Array.isArray(this.#events[type])) return;
      const events = this.#events[type];
      for (let i2 = 0, len = events.length; i2 < len; i2++) {
        if (events[i2].caller === caller) {
          events.splice(i2, 1);
          break;
        }
      }
    }
    listeners(type) {
      if (!type) return this.#events;
      return this.#events[type] || [];
    }
  };

  // src/library.ts
  if (!Array.prototype.filter) {
    Array.prototype.filter = function(fun) {
      var len = this.length >>> 0;
      if (typeof fun != "function") {
        throw new TypeError();
      }
      ``;
      var res = [];
      var thisp = arguments[1];
      for (var i2 = 0; i2 < len; i2++) {
        if (i2 in this) {
          var val = this[i2];
          if (fun.call(thisp, val, i2, this)) {
            res.push(val);
          }
        }
      }
      return res;
    };
  }
  function SortArrayByPriority(a, b) {
    if (a.priority > b.priority)
      return -1;
    if (a.priority < b.priority)
      return 1;
    return 0;
  }
  function SortMapByPriority(a, b) {
    if (a.priority > b.priority)
      return -1;
    if (a.priority < b.priority)
      return 1;
    if (a.index < b.index)
      return -1;
    if (a.index > b.index)
      return 1;
    return 0;
  }
  function SortItemArrayByPriority(list) {
    const map = list.map((el, i2) => {
      return { index: i2, priority: el.priority };
    });
    map.sort(SortMapByPriority);
    return map.map((el) => {
      return list[el.index];
    });
  }
  function FilterArrayByKeyValue(array, k, v) {
    const res = [];
    if (!array || array.length === 0) return res;
    const al = array.length;
    for (let i2 = 0; i2 < al; i2++) {
      if (array[i2]["enabled"] && array[i2][k] === v)
        res.push(array[i2]);
    }
    if (res.length <= 1) return res;
    return res.sort(SortArrayByPriority);
  }
  var _edCache = document.createElement("div");
  function htmlEncode(value) {
    if (!value || !value.length) return "";
    _edCache.textContent = value;
    value = _edCache.innerHTML;
    _edCache.textContent = "";
    return value;
  }
  function htmlDecode(value) {
    if (!value || !value.length) return "";
    _edCache.innerHTML = value;
    value = _edCache.textContent;
    _edCache.innerHTML = "";
    return value;
  }
  function stripQuotes(str) {
    str = str.replace(/^"(.+(?="$))?"$/, "$1");
    str = str.replace(/^'(.+(?='$))?'$/, "$1");
    return str;
  }
  function offset(el) {
    const box = el.getBoundingClientRect();
    const docElem = document.documentElement;
    return {
      top: box.top + window.pageYOffset - docElem.clientTop,
      left: box.left + window.pageXOffset - docElem.clientLeft
    };
  }
  var StringBuffer = class {
    constructor(str) {
      //public rawbuffer: string[];
      this.length = 0;
      if (typeof str == "string" && str.length > 0)
        this.buffer = [str];
      else
        this.buffer = [];
      this.length = 0;
    }
    prepend(string) {
      this.buffer.unshift(string);
      this.length += string.length;
      return this;
    }
    append(string) {
      this.buffer.push(string);
      this.length += string.length;
      return this;
    }
    push(string) {
      if (typeof string === "number")
        this.appendCode(string);
      else
        this.append(string);
    }
    appendCode(b) {
      this.buffer.push(String.fromCharCode(b));
      this.length++;
      return this;
    }
    toString() {
      return this.buffer.join("");
    }
    clear(str) {
      this.buffer = [];
      this.length = 0;
      if (str && typeof str != "undefined" && str.length) {
        this.buffer.push(str);
        this.length = str.length;
      }
      return this;
    }
    concat(arr) {
      this.buffer = this.buffer.concat(arr);
    }
  };
  function CharAllowedInURL(chr, proto) {
    if (chr.length > 1)
      return false;
    if (chr === "-" || chr === "_" || chr === "." || chr === "~" || chr === "!" || chr === "*" || chr === "'" || chr === ";" || chr === ":" || chr === "@" || chr === "&" || chr === "=" || chr === "+" || chr === "$" || chr === "," || chr === "/" || chr === "\\" || chr === "?" || chr === "%" || chr === "#" || chr === "[" || chr === "]" || chr === "(" || chr === ")")
      return !proto;
    const i2 = chr.charCodeAt(0);
    if (i2 > 64 && i2 < 91)
      return true;
    if (i2 > 96 && i2 < 123)
      return true;
    if (i2 > 47 && i2 < 58)
      return true;
    if (i2 >= 160 && i2 <= 55295)
      return true;
    if (i2 >= 57344 && i2 <= 64975)
      return true;
    if (i2 >= 65008 && i2 <= 65533)
      return true;
    if (i2 >= 65536 && i2 <= 131069)
      return true;
    if (i2 >= 131072 && i2 <= 196605)
      return true;
    if (i2 >= 196608 && i2 <= 262141)
      return true;
    if (i2 >= 262144 && i2 <= 327677)
      return true;
    if (i2 >= 327680 && i2 <= 393213)
      return true;
    if (i2 >= 393216 && i2 <= 458749)
      return true;
    if (i2 >= 458752 && i2 <= 524285)
      return true;
    if (i2 >= 524288 && i2 <= 589821)
      return true;
    if (i2 >= 589824 && i2 <= 655357)
      return true;
    if (i2 >= 655360 && i2 <= 720893)
      return true;
    if (i2 >= 720896 && i2 <= 786429)
      return true;
    if (i2 >= 786432 && i2 <= 851965)
      return true;
    if (i2 >= 851968 && i2 <= 917501)
      return true;
    if (i2 >= 921600 && i2 <= 983037)
      return true;
    if (i2 >= 983040 && i2 <= 1048573)
      return true;
    if (i2 >= 1048576 && i2 <= 1114109)
      return true;
    return false;
  }
  var keyCodeToChar = {
    3: "Cancel",
    6: "Help",
    8: "Backspace",
    9: "Tab",
    19: "Pause/Break",
    20: "Caps Lock",
    21: "Kana",
    22: "Eisu",
    23: "Junja",
    24: "Final",
    25: "Hanja",
    27: "Esc",
    28: "Convert",
    29: "Nonconvert",
    30: "Accept",
    31: "Modechange",
    32: "Space",
    33: "Page Up",
    34: "Page Down",
    35: "End",
    36: "Home",
    37: "Left",
    38: "Up",
    39: "Right",
    40: "Down",
    41: "Select",
    42: "Print",
    43: "Execute",
    44: "Printscreen",
    45: "Insert",
    46: "Delete",
    48: "0",
    49: "1",
    50: "2",
    51: "3",
    52: "4",
    53: "5",
    54: "6",
    55: "7",
    56: "8",
    57: "9",
    58: "Colon",
    59: "Semicolon",
    60: "Less Than",
    61: "Equals2",
    62: "Greater Than",
    63: "Question Mark",
    65: "A",
    66: "B",
    67: "C",
    68: "D",
    69: "E",
    70: "F",
    71: "G",
    72: "H",
    73: "I",
    74: "J",
    75: "K",
    76: "L",
    77: "M",
    78: "N",
    79: "O",
    80: "P",
    81: "Q",
    82: "R",
    83: "S",
    84: "T",
    85: "U",
    86: "V",
    87: "W",
    88: "X",
    89: "Y",
    90: "Z",
    93: "Context Menu",
    95: "Sleep",
    96: "Numpad 0",
    97: "Numpad 1",
    98: "Numpad 2",
    99: "Numpad 3",
    100: "Numpad 4",
    101: "Numpad 5",
    102: "Numpad 6",
    103: "Numpad 7",
    104: "Numpad 8",
    105: "Numpad 9",
    106: "Numpad *",
    107: "Numpad +",
    109: "Numpad -",
    110: "Numpad .",
    111: "Numpad /",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    124: "F13",
    125: "F14",
    126: "F15",
    127: "F16",
    128: "F17",
    129: "F18",
    130: "F19",
    131: "F20",
    132: "F21",
    133: "F22",
    134: "F23",
    135: "F24",
    144: "Num Lock",
    145: "Scroll Lock",
    146: "Win Oem Fj Jisho",
    147: "Win Oem Fj Masshou",
    148: "Win Oem Fj Touroku",
    149: "Win Oem Fj Loya",
    150: "Win Oem Fj Roya",
    160: "Circumflex",
    161: "Exclamation",
    162: "Double Quote",
    163: "Hash",
    164: "Dollar",
    165: "Percent",
    166: "Ampersand",
    167: "Underscore",
    168: "Open Paren",
    169: "Close Paren",
    170: "Asterisk",
    171: "Plus",
    172: "Pipe",
    173: "Hyphen Minus",
    174: "Open Curly Bracket",
    175: "Close Curly Bracket",
    176: "Tilde",
    181: "Volume Mute",
    182: "Volume Down",
    183: "Volume Up",
    186: ";",
    187: "Equals",
    188: ",",
    189: "Minus",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'",
    227: "Win Ico Help",
    228: "Win Ico 00",
    230: "Win Ico Clear",
    233: "Win Oem Reset",
    234: "Win Oem Jump",
    235: "Win Oem Pa1",
    236: "Win Oem Pa2",
    237: "Win Oem Pa3",
    238: "Win Oem Wsctrl",
    239: "Win Oem Cusel",
    240: "Win Oem Attn",
    241: "Win Oem Finish",
    242: "Win Oem Copy",
    243: "Win Oem Auto",
    244: "Win Oem Enlw",
    245: "Win Oem Backtab",
    246: "Attn",
    247: "Crsel",
    248: "Exsel",
    249: "Ereof",
    250: "Play",
    251: "Zoom",
    253: "Pa1",
    254: "Win Oem Clear"
  };
  var keyCharToCode = {
    Cancel: 3,
    Help: 6,
    Backspace: 8,
    Tab: 9,
    "Pause/Break": 19,
    "Caps Lock": 20,
    Esc: 27,
    Space: 32,
    "Page Up": 33,
    "Page Down": 34,
    End: 35,
    Home: 36,
    Left: 37,
    Up: 38,
    Right: 39,
    Down: 40,
    Insert: 45,
    Delete: 46,
    0: 48,
    1: 49,
    2: 50,
    3: 51,
    4: 52,
    5: 53,
    6: 54,
    7: 55,
    8: 56,
    9: 57,
    A: 65,
    B: 66,
    C: 67,
    D: 68,
    E: 69,
    F: 70,
    G: 71,
    H: 72,
    I: 73,
    J: 74,
    K: 75,
    L: 76,
    M: 77,
    N: 78,
    O: 79,
    P: 80,
    Q: 81,
    R: 82,
    S: 83,
    T: 84,
    U: 85,
    V: 86,
    W: 87,
    X: 88,
    Y: 89,
    Z: 90,
    "Numpad 0": 96,
    "Numpad 1": 97,
    "Numpad 2": 98,
    "Numpad 3": 99,
    "Numpad 4": 100,
    "Numpad 5": 101,
    "Numpad 6": 102,
    "Numpad 7": 103,
    "Numpad 8": 104,
    "Numpad 9": 105,
    "Numpad *": 106,
    "Numpad +": 107,
    "Numpad -": 109,
    "Numpad .": 110,
    "Numpad /": 111,
    F1: 112,
    F2: 113,
    F3: 114,
    F4: 115,
    F5: 116,
    F6: 117,
    F7: 118,
    F8: 119,
    F9: 120,
    F10: 121,
    F11: 122,
    F12: 123,
    "Num Lock": 144,
    "Scroll Lock": 145,
    ";": 186,
    ",": 188,
    ".": 190,
    "/": 191,
    "`": 192,
    "[": 219,
    "\\": 220,
    "]": 221,
    "'": 222,
    Kana: 21,
    Eisu: 22,
    Junja: 23,
    Final: 24,
    Hanja: 25,
    Convert: 28,
    Nonconvert: 29,
    Accept: 30,
    Modechange: 31,
    Select: 41,
    Print: 42,
    Execute: 43,
    Printscreen: 44,
    Colon: 58,
    Semicolon: 59,
    "Less Than": 60,
    Equals2: 61,
    "Greater Than": 62,
    "Question Mark": 63,
    "Context Menu": 93,
    Sleep: 95,
    F13: 124,
    F14: 125,
    F15: 126,
    F16: 127,
    F17: 128,
    F18: 129,
    F19: 130,
    F20: 131,
    F21: 132,
    F22: 133,
    F23: 134,
    F24: 135,
    "Win Oem Fj Jisho": 146,
    "Win Oem Fj Masshou": 147,
    "Win Oem Fj Touroku": 148,
    "Win Oem Fj Loya": 149,
    "Win Oem Fj Roya": 150,
    Circumflex: 160,
    Exclamation: 161,
    "Double Quote": 162,
    Hash: 163,
    Dollar: 164,
    Percent: 165,
    Ampersand: 166,
    Underscore: 167,
    "Open Paren": 168,
    "Close Paren": 169,
    Asterisk: 170,
    Plus: 171,
    Pipe: 172,
    "Hyphen Minus": 173,
    "Open Curly Bracket": 174,
    "Close Curly Bracket": 175,
    Tilde: 176,
    "Volume Mute": 181,
    "Volume Down": 182,
    "Volume Up": 183,
    Equals: 187,
    Minus: 189,
    "Win Ico Help": 227,
    "Win Ico 00": 228,
    "Win Ico Clear": 230,
    "Win Oem Reset": 233,
    "Win Oem Jump": 234,
    "Win Oem Pa1": 235,
    "Win Oem Pa2": 236,
    "Win Oem Pa3": 237,
    "Win Oem Wsctrl": 238,
    "Win Oem Cusel": 239,
    "Win Oem Attn": 240,
    "Win Oem Finish": 241,
    "Win Oem Copy": 242,
    "Win Oem Auto": 243,
    "Win Oem Enlw": 244,
    "Win Oem Backtab": 245,
    Attn: 246,
    Crsel: 247,
    Exsel: 248,
    Ereof: 249,
    Play: 250,
    Zoom: 251,
    Pa1: 253,
    "Win Oem Clear": 254
  };
  (function($2) {
    $2.fn.hasHorizontalScrollBar = function() {
      return $2(this)[0].scrollWidth > $2(this).innerWidth();
    };
  })(jQuery);
  function clone(obj, replacer) {
    return JSON.parse(JSON.stringify(obj, replacer));
  }
  function copy(o) {
    let output;
    let v;
    let key;
    if (!o || typeof o !== "object" && !Array.isArray(o))
      return o;
    output = Array.isArray(o) ? [] : {};
    for (key in o) {
      if (!o.hasOwnProperty(key)) continue;
      v = o[key];
      output[key] = v && (typeof v === "object" || Array.isArray(v)) ? copy(v) : v;
    }
    return output;
  }
  function setSelectionRange(input, selectionStart, selectionEnd) {
    if (input.setSelectionRange) {
      input.focus();
      input.setSelectionRange(selectionStart, selectionEnd);
    } else if (input.createTextRange) {
      const range = input.createTextRange();
      range.collapse(true);
      range.moveEnd("character", selectionEnd);
      range.moveStart("character", selectionStart);
      range.select();
    }
  }
  function selectAll(input) {
    if (!input || input.value.length === 0) return;
    if (input.setSelectionRange) {
      input.focus();
      input.setSelectionRange(0, input.value.length);
    } else
      input.select();
  }
  CanvasRenderingContext2D.prototype.fillRoundedRect = function(x2, y2, w, h, r) {
    this.beginPath();
    this.moveTo(x2 + r, y2);
    this.lineTo(x2 + w - r, y2);
    this.quadraticCurveTo(x2 + w, y2, x2 + w, y2 + r);
    this.lineTo(x2 + w, y2 + h - r);
    this.quadraticCurveTo(x2 + w, y2 + h, x2 + w - r, y2 + h);
    this.lineTo(x2 + r, y2 + h);
    this.quadraticCurveTo(x2, y2 + h, x2, y2 + h - r);
    this.lineTo(x2, y2 + r);
    this.quadraticCurveTo(x2, y2, x2 + r, y2);
    this.closePath();
    this.fill();
  };
  CanvasRenderingContext2D.prototype.strokeRoundedRect = function(x2, y2, w, h, r) {
    this.beginPath();
    this.moveTo(x2 + r, y2);
    this.lineTo(x2 + w - r, y2);
    this.quadraticCurveTo(x2 + w, y2, x2 + w, y2 + r);
    this.lineTo(x2 + w, y2 + h - r);
    this.quadraticCurveTo(x2 + w, y2 + h, x2 + w - r, y2 + h);
    this.lineTo(x2 + r, y2 + h);
    this.quadraticCurveTo(x2, y2 + h, x2, y2 + h - r);
    this.lineTo(x2, y2 + r);
    this.quadraticCurveTo(x2, y2, x2 + r, y2);
    this.closePath();
    this.stroke();
  };
  if (!Object.keys) Object.keys = function(o) {
    if (o !== Object(o))
      throw new TypeError("Object.keys called on a non-object");
    var k = [], p;
    for (p in o) if (Object.prototype.hasOwnProperty.call(o, p)) k.push(p);
    return k;
  };
  if (!Object.toType) Object.toType = function(obj) {
    return {}.toString.call(obj).match(/\s([a-z|A-Z]+)/)[1].toLowerCase();
  };
  if (typeof String.prototype.startsWith != "function") {
    String.prototype.startsWith = function(str) {
      return this.slice(0, str.length) == str;
    };
  }
  if (typeof String.prototype.endsWith != "function") {
    String.prototype.endsWith = function(str) {
      return this.slice(-str.length) == str;
    };
  }
  if (typeof String.prototype.splice !== "function") {
    String.prototype.splice = function(idx, s, rem) {
      if (typeof rem === "undefined") rem = 0;
      return this.slice(0, idx) + s + this.slice(idx + Math.abs(rem));
    };
  }
  if (typeof String.prototype.padStart !== "function") {
    String.prototype.padStart = function(paddingValue) {
      if (typeof paddingValue === "number")
        paddingValue = " ".repeat(paddingValue);
      return String(paddingValue + this).slice(-paddingValue.length);
    };
  }
  if (typeof String.prototype.padEnd !== "function") {
    String.prototype.padEnd = function(paddingValue) {
      if (typeof paddingValue === "number") {
        if (paddingValue <= this.length) return this;
        paddingValue = " ".repeat(paddingValue - this.length);
        return this + paddingValue;
      }
      if (paddingValue.length <= this.length) return this;
      return this + paddingValue.slice(-this.length);
    };
  }
  if (!String.prototype.replaceAll) {
    String.prototype.replaceAll = function(str, newStr) {
      if (Object.prototype.toString.call(str).toLowerCase() === "[object regexp]") {
        return this.replace(str, newStr);
      }
      return this.replace(new RegExp(str, "g"), newStr);
    };
  }
  if (typeof Uint8Array.prototype.charAt != "function") {
    Uint8Array.prototype.charAt = function(idx) {
      return String.fromCharCode(this[idx]);
    };
  }
  if (typeof Uint8Array.prototype.charCodeAt != "function") {
    Uint8Array.prototype.charCodeAt = function(idx) {
      return this[idx];
    };
  }
  function addSlashes(string, all) {
    if (!string || !string.length) return string;
    if (all)
      return string.replace(/\\/g, "\\\\").replace(/\u0008/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/'/g, "\\'").replace(/"/g, '\\"').replace(/\u0000/g, "\\0");
    return string.replace(/\\/g, "\\\\").replace(/'/g, "\\'").replace(/"/g, '\\"');
  }
  String.prototype.addSlashes = function() {
    return addSlashes(this);
  };
  String.prototype.splitQuote = function(sep, type, escape2, escapeChar) {
    if (this.length === 0)
      return [];
    if (!sep || !sep.length)
      return [this];
    if (!type) type = 1 | 2;
    if (!escape2) escape2 = 1 | 2;
    if (!escapeChar) escapeChar = "\\";
    let quote = false;
    let sQuote = false;
    const str = [];
    let pS = 0;
    let s = 0;
    let c;
    let pC = "";
    let sp;
    const spl = sep.length;
    let spC;
    const tl = this.length;
    for (; s < tl; s++) {
      c = this.charAt(s);
      if (c === '"' && (type & 2) === 2) {
        if ((escape2 & 2) === 2) {
          if (s === 0 || pC !== escapeChar)
            quote = !quote;
        } else
          quote = !quote;
      } else if (c === "'" && (type & 1) === 1) {
        if ((escape2 & 1) === 1) {
          if (s === 0 || pC !== escapeChar)
            sQuote = !sQuote;
        } else
          sQuote = !sQuote;
      } else if (!quote && !sQuote) {
        for (sp = 0; sp < spl; sp++) {
          spC = sep.charAt(sp);
          if (c === spC) {
            if (s > pS || s === 0) {
              str.push(this.substr(pS, s - pS));
              pS = s + 1;
              break;
            } else if (s === pS) {
              str.push("");
              pS = s + 1;
              break;
            } else if (s === tl - 1)
              str.push("");
          }
        }
      }
      pC = c;
    }
    if (s === tl && s === pS && sep.indexOf(pC) !== -1) {
      str.push("");
      pS = s + 1;
    }
    if (s > pS)
      str.push(this.substr(pS, s - pS));
    return str;
  };
  function getTimeSpan(i2) {
    let al;
    const tmp = [];
    al = Math.floor(i2 / (1e3 * 60 * 60 * 24));
    i2 -= al * (1e3 * 60 * 60 * 24);
    if (al === 1) tmp.push(al + " day");
    else if (al > 0) tmp.push(al + " days");
    al = Math.floor(i2 / (1e3 * 60 * 60));
    i2 -= al * (1e3 * 60 * 60);
    if (al === 1) tmp.push(al + " hour");
    else if (al > 0) tmp.push(al + " hours");
    al = Math.floor(i2 / (1e3 * 60));
    i2 -= al * (1e3 * 60);
    if (al === 1) tmp.push(al + " minute");
    else if (al > 0) tmp.push(al + " minutes");
    al = Math.floor(i2 / 1e3);
    i2 -= al * 1e3;
    if (al === 1) tmp.push(al + " second");
    else if (al > 0) tmp.push(al + " seconds");
    if (tmp.length === 0)
      tmp.push("0 seconds");
    return tmp.join(", ");
  }
  function capitalize(s, first) {
    if (!s) return "";
    s = s.split(" ");
    let c;
    let i2;
    let p;
    const il = first ? 1 : s.length;
    for (i2 = 0; i2 < il; i2++) {
      const pl = s[i2].length;
      for (p = 0; p < pl; p++) {
        c = s[i2].charAt(p);
        if (c >= "a" && c <= "z" || c >= "A" && c <= "Z") {
          s[i2] = s[i2].substr(0, p) + c.toUpperCase() + s[i2].substr(p + 1).toLowerCase();
          break;
        }
      }
    }
    return s.join(" ");
  }
  function splitQuoted(str, sep, t, e, ec) {
    if (typeof t === "undefined") t = 1 | 2;
    if (typeof e === "undefined") e = 0;
    if (typeof ec === "undefined") ec = "\\";
    if (!str || str.length === 0)
      return [];
    if (!sep || sep.length === 0)
      return [str];
    sep = sep.split("");
    let q = false;
    let sq = false;
    const strings = [];
    let ps = 0;
    let s = 0;
    const sl = str.length;
    let c;
    for (; s < sl; s++) {
      c = str.charAt(s);
      if (c === '"' && (t & 2) === 2) {
        if ((e & 2) === 2 && s > 0) {
          if (s - 1 > 0 && str.charAt(s - 1) !== ec)
            q = !q;
        } else
          q = !q;
      } else if (c === "'" && (t & 1) === 1) {
        if ((e & 1) === 1 && s > 0) {
          if (s - 1 > 0 && str.charAt(s - 1) !== ec)
            sq = !sq;
        } else
          sq = !sq;
      } else if (!sq && !q) {
        const spl = sep.length;
        for (let sp = 0; sp < spl; sp++) {
          if (c === sep[sp]) {
            if (s > ps || s === 0) {
              strings.push(str.substring(ps, s));
              ps = s + 1;
              break;
            } else if (s === ps) {
              strings.push("");
              ps = s + 1;
              break;
            } else if (s === sl - 1)
              strings.push("");
          }
        }
      }
    }
    if (s === sl && s === ps && sep.indexOf(str.charAt(s - 1)) > -1) {
      strings.push("");
      ps = s + 1;
    }
    if (s > ps)
      strings.push(str.substring(ps, s));
    return strings;
  }
  function getCursor(el) {
    if (!el) return 0;
    if (typeof el.selectionStart === "number") {
      return el.selectionDirection == "backward" ? el.selectionStart : el.selectionEnd;
    } else if (document.selection) {
      el.focus();
      var oSel = document.selection.createRange();
      oSel.moveStart("character", -el.value.length);
      return oSel.text.length;
    }
    return 0;
  }
  var _colorCodes;
  function pinkfishToHTML(text) {
    text = text || "";
    text = text.split("%^");
    if (!_colorCodes)
      _loadColors();
    const stack = [];
    let codes = [];
    let t = 0;
    let tl = text.length;
    let bold = false;
    let boldNest = false;
    let classes = [];
    for (; t < tl; t++) {
      switch (text[t]) {
        case "ITALIC":
          stack.push("<em>");
          codes.push("</em>");
          break;
        case "UNDERLINE":
          classes.push("underline");
          break;
        case "STRIKEOUT":
          classes.push("strikeout");
          break;
        case "DBLUNDERLINE":
          classes.push("dblunderline");
          break;
        case "OVERLINE":
          classes.push("overline");
          break;
        case "FLASH":
          classes.push("noflash");
          break;
        case "REVERSE":
          classes.push("reverse");
          break;
        case "RESET":
        case "DEFAULT":
          const cl = codes.length;
          for (let c = 0; c < cl; c++)
            stack.push(codes[c]);
          codes = [];
          classes = [];
          break;
        case "BOLD":
          bold = true;
          break;
        case "":
          break;
        default:
          if (text[t].startsWith("B_")) {
            text[t] = text[t].substr(2);
            if (bold && !boldNest) {
              stack.push('<span style="border: inherit;text-decoration:inherit;color: #' + _colorCodes["BOLD%^%^WHITE"] + '">');
              codes.push("</span>");
            }
            stack.push('<span style="border: inherit;text-decoration:inherit;background-color: #' + _colorCodes[text[t]] + '">');
            codes.push("</span>");
            bold = false;
            continue;
          } else if (_colorCodes[text[t]]) {
            if (bold && !_colorCodes["BOLD%^%^" + text[t]]) {
              stack.push('<span style="border: inherit;text-decoration:inherit;color: #' + _colorCodes["BOLD%^%^WHITE"] + '">');
              codes.push("</span>");
              boldNest = true;
            } else if (bold) {
              stack.push('<span style="border: inherit;text-decoration:inherit;color: #' + _colorCodes["BOLD%^%^" + text[t]] + '">');
              codes.push("</span>");
              boldNest = true;
              continue;
            }
            stack.push('<span style="border: inherit;text-decoration:inherit;color: #' + _colorCodes[text[t]] + '">');
            codes.push("</span>");
            continue;
          } else if (bold && !boldNest) {
            stack.push('<span style="border: inherit;text-decoration:inherit;color: #' + _colorCodes["BOLD%^%^WHITE"] + '">');
            codes.push("</span>");
          }
          if (classes.length) {
            stack.push('<span class="' + classes.join(" ") + '">');
            codes.push("</span>");
            classes = [];
          }
          stack.push(text[t]);
          bold = false;
          boldNest = false;
          break;
      }
    }
    if (classes.length) {
      stack.push('<span class="' + classes.join(" ") + '">');
      codes.push("</span>");
    }
    for (t = 0, tl = codes.length; t < tl; t++)
      stack.push(codes[t]);
    return stack.join("");
  }
  function _loadColors() {
    let c;
    let color;
    let r;
    let g;
    let b;
    let idx;
    _colorCodes = {};
    _colorCodes["BLACK"] = "000000";
    _colorCodes["RED"] = "800000";
    _colorCodes["GREEN"] = "008000";
    _colorCodes["ORANGE"] = "808000";
    _colorCodes["BLUE"] = "0000EE";
    _colorCodes["MAGENTA"] = "800080";
    _colorCodes["CYAN"] = "008080";
    _colorCodes["WHITE"] = "BBBBBB";
    _colorCodes["mono11"] = "808080";
    _colorCodes["BOLD%^%^RED"] = "FF0000";
    _colorCodes["BOLD%^%^GREEN"] = "00FF00";
    _colorCodes["YELLOW"] = "FFFF00";
    _colorCodes["BOLD%^%^YELLOW"] = "FFFF00";
    _colorCodes["BOLD%^%^BLUE"] = "5C5CFF";
    _colorCodes["BOLD%^%^MAGENTA"] = "FF00FF";
    _colorCodes["BOLD%^%^CYAN"] = "00FFFF";
    _colorCodes["BOLD%^%^WHITE"] = "FFFFFF";
    _colorCodes["BOLD%^%^BLACK"] = "808080";
    for (r = 0; r < 6; r++) {
      for (g = 0; g < 6; g++) {
        for (b = 0; b < 6; b++) {
          idx = `RGB${r}${g}${b}`;
          color = "";
          c = 0;
          c = r * 40 + 55;
          if (c < 16)
            color += "0";
          color += c.toString(16);
          c = 0;
          c = g * 40 + 55;
          if (c < 16)
            color += "0";
          color += c.toString(16);
          c = 0;
          c = b * 40 + 55;
          if (c < 16)
            color += "0";
          color += c.toString(16);
          if (!_colorCodes[idx])
            _colorCodes[idx] = color.toUpperCase();
        }
      }
    }
    for (r = 232; r <= 255; r++) {
      g = (r - 232) * 10 + 8;
      if (g < 16)
        g = "0" + g.toString(16).toUpperCase();
      else
        g = g.toString(16).toUpperCase();
      g = g + g + g;
      if (r < 242)
        _colorCodes["mono0" + (r - 232)] = g;
      else
        _colorCodes["mono" + (r - 232)] = g;
    }
  }
  function getColors() {
    const _ColorTable = [];
    let r;
    let g;
    let b;
    let idx;
    for (r = 0; r < 6; r++) {
      for (g = 0; g < 6; g++) {
        for (b = 0; b < 6; b++) {
          idx = 16 + r * 36 + g * 6 + b;
          _ColorTable[idx] = "rgb(";
          if (r > 0)
            _ColorTable[idx] += r * 40 + 55;
          else
            _ColorTable[idx] += "0";
          _ColorTable[idx] += ",";
          if (g > 0)
            _ColorTable[idx] += g * 40 + 55;
          else
            _ColorTable[idx] += "0";
          _ColorTable[idx] += ",";
          if (b > 0)
            _ColorTable[idx] += b * 40 + 55;
          else
            _ColorTable[idx] += "0";
          _ColorTable[idx] += ")";
        }
      }
    }
    for (r = 232; r <= 255; r++) {
      g = (r - 232) * 10 + 8;
      _ColorTable[r] = ["rgb(", g, ",", g, ",", g, ")"].join("");
    }
    _ColorTable[0] = "rgb(0,0,0)";
    _ColorTable[1] = "rgb(128, 0, 0)";
    _ColorTable[2] = "rgb(0, 128, 0)";
    _ColorTable[3] = "rgb(128, 128, 0)";
    _ColorTable[4] = "rgb(0, 0, 238)";
    _ColorTable[5] = "rgb(128, 0, 128)";
    _ColorTable[6] = "rgb(0, 128, 128)";
    _ColorTable[7] = "rgb(187, 187, 187)";
    _ColorTable[8] = "rgb(128, 128, 128)";
    _ColorTable[9] = "rgb(255, 0, 0)";
    _ColorTable[10] = "rgb(0, 255, 0)";
    _ColorTable[11] = "rgb(255, 255, 0)";
    _ColorTable[12] = "rgb(92, 92, 255)";
    _ColorTable[13] = "rgb(255, 0, 255)";
    _ColorTable[14] = "rgb(0, 255, 255)";
    _ColorTable[15] = "rgb(255, 255, 255)";
    _ColorTable[256] = "rgb(0, 0, 0)";
    _ColorTable[257] = "rgb(118, 0, 0)";
    _ColorTable[258] = "rgb(0, 108, 0)";
    _ColorTable[259] = "rgb(145, 136, 0)";
    _ColorTable[260] = "rgb(0, 0, 167)";
    _ColorTable[261] = "rgb(108, 0, 108)";
    _ColorTable[262] = "rgb(0, 108, 108)";
    _ColorTable[263] = "rgb(161, 161, 161)";
    _ColorTable[264] = "rgb(0, 0, 0)";
    _ColorTable[265] = "rgb(128, 0, 0)";
    _ColorTable[266] = "rgb(0, 128, 0)";
    _ColorTable[267] = "rgb(128, 128, 0)";
    _ColorTable[268] = "rgb(0, 0, 238)";
    _ColorTable[269] = "rgb(128, 0, 128)";
    _ColorTable[270] = "rgb(0, 128, 128)";
    _ColorTable[271] = "rgb(187, 187, 187)";
    _ColorTable[272] = "rgb(0,0,0)";
    _ColorTable[273] = "rgb(0, 255, 255)";
    _ColorTable[274] = "rgb(0,0,0)";
    _ColorTable[275] = "rgb(255, 255, 0)";
    _ColorTable[276] = "rgb(0, 0, 0)";
    _ColorTable[277] = "rgb(229, 229, 229)";
    _ColorTable[278] = "rgb(205, 0, 0)";
    _ColorTable[279] = "rgb(229, 229, 229)";
    _ColorTable[280] = "rgb(255,255,255)";
    return _ColorTable;
  }
  function formatUnit(str, ch) {
    if (!str) return str;
    if (/^\d+c$/.test(str)) {
      if (ch)
        return parseInt(str, 10) * ch + "px";
      return str + "h";
    }
    if (/^\d+$/.test(str))
      return parseInt(str, 10) + "px";
    return str;
  }
  function isValidIdentifier(str) {
    if (!str || str.length === 0) return false;
    if (!str.match(/^[a-zA-Z_$][a-zA-Z_$0-9]*$/g))
      return false;
    return ["break", "case", "catch", "continue", "debugger", "default", "delete", "do", "else", "finally", "for", "function", "if", "in", "instanceof", "new", "return", "switch", "this", "throw", "try", "typeof", "var", "void", "while", "with", "class", "const", "enum", "export", "extends", "import", "super", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "null", "true", "false", "NaN", "Infinity", "undefined", "eval", "arguments"].indexOf(str) === -1;
  }
  function insertValue(input, value) {
    if (!input) return;
    const active = document.activeElement;
    if (!active || active != input)
      input.focus();
    document.execCommand("insertText", false, value);
    if (active && active != input)
      active.focus();
  }
  if (!Array.isArray) {
    Array.isArray = function(arg) {
      return Object.prototype.toString.call(arg) === "[object Array]";
    };
  }
  var _txtDecoder;
  function ArrayBufferToString(buffer) {
    if (window.TextDecoder !== void 0) {
      return (_txtDecoder || (_txtDecoder = new TextDecoder())).decode(new Uint8Array(buffer));
    }
    return BinaryToString(String.fromCharCode.apply(null, Array.prototype.slice.apply(new Uint8Array(buffer))));
  }
  function BinaryToString(binary) {
    var error;
    try {
      return decodeURIComponent(escape(binary));
    } catch (_error) {
      error = _error;
      if (error instanceof URIError) {
        return binary;
      } else {
        throw error;
      }
    }
  }
  function StringToBinary(string) {
    var chars, code, i2, isUCS2, len, _i;
    len = string.length;
    chars = [];
    isUCS2 = false;
    for (i2 = _i = 0; 0 <= len ? _i < len : _i > len; i2 = 0 <= len ? ++_i : --_i) {
      code = String.prototype.charCodeAt.call(string, i2);
      if (code > 255) {
        isUCS2 = true;
        chars = null;
        break;
      } else {
        chars.push(code);
      }
    }
    if (isUCS2 === true) {
      return unescape(encodeURIComponent(string));
    } else {
      return String.fromCharCode.apply(null, Array.prototype.slice.apply(chars));
    }
  }
  var _txtEncoder;
  function StringToUint8Array(string) {
    var binary, binLen, buffer, chars, i2, _i;
    if (window.TextEncoder !== void 0)
      return (_txtEncoder || (_txtEncoder = new TextEncoder())).encode(string);
    binary = StringToBinary(string);
    binLen = binary.length;
    buffer = new ArrayBuffer(binLen);
    chars = new Uint8Array(buffer);
    for (i2 = _i = 0; 0 <= binLen ? _i < binLen : _i > binLen; i2 = 0 <= binLen ? ++_i : --_i) {
      chars[i2] = String.prototype.charCodeAt.call(binary, i2);
    }
    return chars;
  }
  function copyText(text) {
    return new Promise(function(resolve, reject) {
      try {
        if (typeof navigator !== "undefined" && typeof navigator.clipboard !== "undefined" && typeof navigator.permissions !== "undefined") {
          var blob = new Blob([text], { type: "text/plain" });
          var data = [new ClipboardItem({ "text/plain": blob })];
          navigator.permissions.query({ name: "clipboardWrite" }).then(function(permission) {
            if (permission.state === "granted" || permission.state === "prompt") {
              navigator.clipboard.write(data).then(resolve, reject).catch(reject);
            } else {
              reject(new Error("Permission not granted!"));
            }
          });
        } else if (document.queryCommandSupported && document.queryCommandSupported("copy")) {
          var textarea = document.createElement("textarea");
          textarea.value = text;
          textarea.textContent = text;
          textarea.style.position = "fixed";
          textarea.style.width = "2em";
          textarea.style.height = "2em";
          textarea.style.padding = "0";
          textarea.style.border = "none";
          textarea.style.outline = "none";
          textarea.style.boxShadow = "none";
          textarea.style.background = "transparent";
          document.body.appendChild(textarea);
          textarea.focus();
          textarea.select();
          try {
            document.execCommand("copy");
            document.body.removeChild(textarea);
            resolve(null);
          } catch (e) {
            document.body.removeChild(textarea);
            reject(e);
          }
        } else {
          reject(new Error("None of copying methods are supported by this browser!"));
        }
      } catch (err) {
        reject(err);
      }
    });
  }
  function pasteText() {
    return new Promise(function(resolve, reject) {
      try {
        if (typeof navigator !== "undefined" && typeof navigator.clipboard !== "undefined" && typeof navigator.permissions !== "undefined") {
          navigator.permissions.query({ name: "clipboardRead" }).then(function(permission) {
            if (permission.state === "granted" || permission.state === "prompt") {
              navigator.clipboard.readText().then(resolve, reject).catch(reject);
            } else {
              reject(new Error("Permission not granted!"));
            }
          });
        } else if (document.queryCommandSupported && document.queryCommandSupported("paste")) {
          var textarea = document.createElement("textarea");
          textarea.style.position = "fixed";
          textarea.style.width = "2em";
          textarea.style.height = "2em";
          textarea.style.padding = "0";
          textarea.style.border = "none";
          textarea.style.outline = "none";
          textarea.style.boxShadow = "none";
          textarea.style.background = "transparent";
          document.body.appendChild(textarea);
          textarea.focus();
          textarea.select();
          try {
            document.execCommand("paste", false, null);
            resolve(textarea.value);
            document.body.removeChild(textarea);
          } catch (e) {
            document.body.removeChild(textarea);
            reject(e);
          }
        } else {
          reject(new Error("None of pasting methods are supported by this browser!"));
        }
      } catch (err) {
        reject(err);
      }
    });
  }
  function getParameterByName(name2, url) {
    if (!name2) return null;
    if (!url) url = window.location.href;
    name2 = name2.replace(/[[\]]/g, "\\$&");
    var regex = new RegExp("[?&]" + name2 + "(=([^&#]*)|&|#|$)"), results = regex.exec(url);
    if (!results) return null;
    if (!results[2]) return "";
    return decodeURIComponent(results[2].replace(/\+/g, " "));
  }
  function fSaveAs() {
    var DownloadAttributeSupport = "download" in document.createElement("a");
    var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
    var URL = window.URL || window.webkitURL || window.mozURL || window.msURL;
    navigator.saveBlob = navigator.saveBlob || navigator.msSaveBlob || navigator.mozSaveBlob || navigator.webkitSaveBlob;
    window.saveAs = window.saveAs || window.webkitSaveAs || window.mozSaveAs || window.msSaveAs;
    var BrowserSupportedMimeTypes = {
      "image/jpeg": true,
      "image/png": true,
      "image/gif": true,
      "image/svg+xml": true,
      "image/bmp": true,
      "image/x-windows-bmp": true,
      "image/webp": true,
      "audio/wav": true,
      "audio/mpeg": true,
      "audio/webm": true,
      "audio/ogg": true,
      "video/mpeg": true,
      "video/webm": true,
      "video/ogg": true,
      "text/plain": true,
      "text/html": true,
      "text/xml": true,
      "application/xhtml+xml": true,
      "application/json": true
    };
    if (BlobBuilder && (window.saveAs || navigator.saveBlob)) {
      this.show = function(data, name2, mimetype) {
        var builder = new BlobBuilder();
        builder.append(data);
        var blob = builder.getBlob(mimetype || "application/octet-stream");
        if (!name2) name2 = "Download.bin";
        if (window.saveAs) {
          window.saveAs(blob, name2);
        } else {
          navigator.saveBlob(blob, name2);
        }
      };
    } else if (BlobBuilder && URL) {
      this.show = function(data, name2, mimetype) {
        var blob, url, builder = new BlobBuilder();
        builder.append(data);
        if (!mimetype) mimetype = "application/octet-stream";
        if (DownloadAttributeSupport) {
          blob = builder.getBlob(mimetype);
          url = URL.createObjectURL(blob);
          var link = document.createElement("a");
          link.setAttribute("href", url);
          link.setAttribute("download", name2 || "Download.bin");
          var event2 = document.createEvent("MouseEvents");
          event2.initMouseEvent("click", true, true, window, 1, 0, 0, 0, 0, false, false, false, false, 0, null);
          link.dispatchEvent(event2);
        } else {
          if (BrowserSupportedMimeTypes[mimetype.split(";")[0]] === true) {
            mimetype = "application/octet-stream";
          }
          blob = builder.getBlob(mimetype);
          url = URL.createObjectURL(blob);
          window.open(url, "_blank", "");
        }
        setTimeout(function() {
          URL.revokeObjectURL(url);
        }, 250);
      };
    } else if (Blob && URL) {
      this.show = function(data, name2, mimetype) {
        var blob, url;
        if (!mimetype) mimetype = "application/octet-stream";
        blob = new Blob([data], { type: mimetype });
        if (DownloadAttributeSupport) {
          url = URL.createObjectURL(blob);
          var link = document.createElement("a");
          link.setAttribute("href", url);
          link.setAttribute("download", name2 || "Download.bin");
          var event2 = document.createEvent("MouseEvents");
          event2.initMouseEvent("click", true, true, window, 1, 0, 0, 0, 0, false, false, false, false, 0, null);
          link.dispatchEvent(event2);
        } else {
          if (BrowserSupportedMimeTypes[mimetype.split(";")[0]] === true) {
            mimetype = "application/octet-stream";
          }
          url = URL.createObjectURL(blob);
          window.open(url, "_blank", "");
        }
        setTimeout(function() {
          URL.revokeObjectURL(url);
        }, 250);
      };
    } else if (!/\bMSIE\b/.test(navigator.userAgent)) {
      this.show = function(data, name2, mimetype) {
        if (!mimetype) mimetype = "application/octet-stream";
        if (BrowserSupportedMimeTypes[mimetype.split(";")[0]] === true) {
          mimetype = "application/octet-stream";
        }
        window.open("data:" + mimetype + "," + encodeURIComponent(data), "_blank", "");
      };
    }
  }
  window.fileSaveAs = new fSaveAs();
  function _utf8() {
    var intc, i2;
    function _TryGetCharUTF8(b, count) {
      var c = b.charCodeAt(i2);
      if ((c & 128) === 0)
        intc = c;
      else {
        if ((c & 224) == 192) {
          intc = (c & 31) << 6 | b.charCodeAt(i2 + 1) & 63;
          i2 += 1;
        } else if ((c & 240) == 224) {
          intc = (c & 15) << 12 | (b.charCodeAt(i2 + 1) & 63) << 6 | b.charCodeAt(i2 + 2) & 63;
          i2 += 2;
        } else if ((c & 248) == 240) {
          intc = (c & 7) << 18 | (b.charCodeAt(i2 + 1) & 63) << 12 | (b.charCodeAt(i2 + 2) & 63) << 6 | b.charCodeAt(i2 + 3) & 63;
          i2 += 1;
        } else
          return false;
      }
      return true;
    }
    this.decode = function(s) {
      var ss = new StringBuffer();
      var sl = s.length;
      for (i2 = 0; i2 < sl; i2++) {
        if (_TryGetCharUTF8(s, sl))
          ss.appendCode(intc);
      }
      return ss.toString();
    };
    this.decode2 = function(s) {
      var ss = new StringBuffer();
      var sl = s.length;
      var i3, c;
      for (i3 = 0; i3 < sl; i3++) {
        c = s.charCodeAt(i3);
        if ((c & 128) !== 0) {
          if ((c & 224) == 192) {
            c = (c & 31) << 6 | s.charCodeAt(i3 + 1) & 63;
            i3 += 1;
          } else if ((c & 240) == 224) {
            c = (c & 15) << 12 | (s.charCodeAt(i3 + 1) & 63) << 6 | s.charCodeAt(i3 + 2) & 63;
            i3 += 2;
          } else if ((c & 248) == 240) {
            c = (c & 7) << 18 | (s.charCodeAt(i3 + 1) & 63) << 12 | (s.charCodeAt(i3 + 2) & 63) << 6 | s.charCodeAt(i3 + 3) & 63;
            i3 += 1;
          } else
            continue;
        }
        ss.appendCode(c);
      }
      return ss.toString();
    };
  }
  window.UTF8 = new _utf8();
  function printArray(data) {
    if (data === null || typeof data == "undefined") return data;
    var dl, ba;
    var idx = 0;
    dl = data.byteLength;
    ba = new StringBuffer();
    for (; idx < dl; idx++) {
      if (data[idx] < 32 || data[idx] >= 127)
        ba.append("<" + data[idx] + ">");
      else
        ba.append(String.fromCharCode(data[idx]));
    }
    return ba.toString();
  }
  function getScrollbarWidth() {
    const outer = document.createElement("div");
    outer.style.visibility = "hidden";
    outer.style.overflow = "scroll";
    outer.style.msOverflowStyle = "scrollbar";
    document.body.appendChild(outer);
    const inner = document.createElement("div");
    outer.appendChild(inner);
    const scrollbarWidth = outer.offsetWidth - inner.offsetWidth;
    outer.parentNode.removeChild(outer);
    return scrollbarWidth;
  }
  function openFileDialog(title, multiple, accept) {
    return new Promise((resolve, reject) => {
      let dialog = document.createElement("dialog");
      if (typeof dialog.showModal !== "function") {
        reject("Browser does not support dialogs.");
        return;
      }
      dialog.id = "openFileDialog";
      dialog.style.zIndex = "2000";
      dialog.style.height = "158px";
      dialog.style.width = "350px";
      dialog.innerHTML = `<div class="dialog-header" style="font-weight: bold"><button type="button" class="btn btn-close float-end btn-danger" data-dismiss="modal" onclick="document.getElementById('openFileDialog').close();"></button><div>${title || "Open file..."}</div></div><div class="dialog-body"><div class="m-3"><input class="form-control" type="file" id="openFileDialog-files"${multiple ? " multiple" : ""} required${accept && accept.length ? ' accept="' + accept + '"' : ""}></div></div><div class="dialog-footer"><button id="openFileDialog-cancel" style="float: right" type="button" class="btn btn-default" onclick="document.getElementById('openFileDialog').close();">Cancel</button><button id="openFileDialog-ok" style="float: right" type="button" class="btn btn-primary">Ok</button></div>`;
      document.body.appendChild(dialog);
      dialog.addEventListener("close", (e) => {
        if (e.target !== dialog) return;
        document.body.removeChild(dialog);
        if (dialog.returnValue !== "file-ok")
          reject("closed");
      });
      dialog.addEventListener("cancel", (e) => {
        if (e.target !== dialog) return;
        document.body.removeChild(dialog);
        if (dialog.returnValue !== "file-ok")
          reject("canceled");
      });
      document.getElementById("openFileDialog-ok").addEventListener("click", () => {
        const input = document.getElementById("openFileDialog-files");
        if (!input.files || input.files.length === 0) {
          input.classList.add("is-invalid");
          return;
        }
        input.classList.remove("is-invalid");
        dialog.close();
        dialog.returnValue = "files-ok";
        resolve(input.files);
      });
      dialog.showModal();
    });
  }
  function readFile(file, progress) {
    return new Promise((resolve, reject) => {
      if (!file) reject(new Error("Invalid file"));
      var reader = new FileReader();
      reader.onerror = reject;
      reader.onload = (evt) => {
        resolve(evt.target.result);
      };
      reader.readAsText(file);
      if (progress)
        reader.onprogress = progress;
    });
  }
  var _timers = {};
  function debounce(mainFunction, delay, key) {
    key = key || "default";
    clearTimeout(_timers[key]);
    _timers[key] = setTimeout(() => {
      mainFunction();
      delete _timers[key];
    }, delay);
  }
  function scrollChildIntoView(parent, child) {
    const childRect = child.getBoundingClientRect();
    const parentRect = parent.getBoundingClientRect();
    if (childRect.top < parentRect.top || childRect.bottom > parentRect.bottom || childRect.left < parentRect.left || childRect.right > parentRect.right) {
      child.scrollIntoView({
        behavior: "smooth",
        // Optional for smooth scrolling
        block: "nearest"
        // Scrolls to nearest edge of the parent
      });
    }
  }
  function isMobile(userAgent) {
    if (window.matchMedia("(orientation: landscape) and (max-width: 641px)").matches)
      return true;
    if (window.matchMedia("(orientation: landscape) and (max-height: 480px)").matches)
      return true;
    if (window.matchMedia("(orientation: portrait) and (max-width: 480px)").matches)
      return true;
    if (window.matchMedia(" (orientation: portrait) and (max-height: 641px)").matches)
      return true;
    if (userAgent && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini|Windows Phone/i.test(navigator.userAgent || navigator.vendor || window.opera))
      return true;
    return false;
  }

  // src/telnet.ts
  var import_inflate_stream_min = __toESM(require_inflate_stream_min());
  var Telnet = class extends EventEmitter {
    /**
     * Creates an instance of Telnet.
     *
     * @param {any} options a list of options to set
     *
     * @memberOf Telnet
     */
    constructor(options) {
      super();
      this._splitBuffer = [];
      this._connected = false;
      this._MTTS = 0;
      this._zStream = 0;
      this._latencyTime = null;
      this._doPing = false;
      this._closed = true;
      this._zlib = false;
      this.options = { MCCP: true, MXP: true, NAWS: true, MSDP: true, GMCP: true, MSSP: false, ECHO: true, TTYPE: true, EOR: true, NEWENVIRON: false, ZMP: false, ATCP: false, CHARSET: true };
      this.host = "";
      this.port = 23;
      this.prompt = false;
      this.echo = true;
      this.firstSent = true;
      this.firstReceived = true;
      this.server = { NAWS: false, MSDP: false, GMCP: false, MXP: false, MCCP1: false, MCCP2: false, MSSP: false, NEWENVIRON: false, ZMP: false, EOR: false, ATCP: false, CHARSET: false };
      this.version = "2.0";
      this.terminal = "ansi";
      this.UTF8 = true;
      this.MSSP = {};
      this.socket = null;
      this.latency = 0;
      this.latencyAvg = null;
      this.enableLatency = false;
      this.enablePing = false;
      this.GMCPSupports = ["Core 1"];
      this.enableDebug = false;
      this.scheme = "ws://";
      this.protocol = "binary";
      if (options) {
        if ("host" in options) {
          if (options.host && options.host.length)
            this.host = options.host;
          delete options.host;
        }
        if ("port" in options) {
          this.port = options.port;
          delete options.port;
        }
        if ("scheme" in options) {
          if (options.scheme && options.scheme.length)
            this.scheme = options.scheme;
          delete options.scheme;
        }
        if ("protocol" in options) {
          if (options.protocol && options.protocol.length)
            this.protocol = options.protocol;
          delete options.protocol;
        }
      }
      this.options = Object.assign(this.options, options || {});
    }
    /**
     * @name connected
     * @desc determine if connected to host
     * @returns {Boolean} weather connected to host or not
     *
     * @readonly
     *
     * @memberOf Telnet
     */
    get connected() {
      if (!this.socket || typeof this.socket === "undefined")
        return false;
      return this._connected;
    }
    /**
         * @name Telnet#reset
         * @desc reset state in preparation for a connect
         */
    reset() {
      this._MTTS = 0;
      this.firstSent = true;
      this.firstReceived = true;
      this.prompt = false;
      this.echo = true;
      this.server = { NAWS: false, MSDP: false, GMCP: false, MXP: false, MCCP1: false, MCCP2: false, MSSP: false, EOR: false, NEWENVIRON: false, ATCP: false, CHARSET: false, ZMP: false };
      this._splitBuffer = [];
      this._endMCCP();
      this._connected = false;
      this._closed = false;
      if (this.enableDebug)
        this.emit("debug", "Reset");
    }
    /**
     * @name connect
     * @desc connect to target host
     *
     * @fires Telnet#connecting
     */
    connect() {
      this._destroySocket();
      this.reset();
      this.emit("connecting");
      this.socket = this._createSocket(this.host, this.port);
      if (this.enableDebug)
        this.emit("debug", "Connecting to " + this.host + ":" + this.port);
    }
    /**
     * @name Telnet#close
     * @desc close the connection ot host and reset state in preparation for next connection
     *
     * @fires Telnet#close
     */
    close() {
      if (this._closed) return;
      this._destroySocket();
      this.reset();
      this.emit("close");
      this._closed = true;
      if (this.enableDebug)
        this.emit("debug", "Closed");
    }
    /**
     * @name Telnet#receivedData
     * @desc data that is received from the host to be processed
     *
     * @param {String} data string received from host
     * @fires Telnet#received-data
     */
    receivedData(data, skipDecompress, prependSplit) {
      if (this.enableLatency) {
        if (this._latencyTime !== null) {
          this.latency = (/* @__PURE__ */ new Date()).getTime() - this._latencyTime.getTime();
          if (this.latencyAvg == null)
            this.latencyAvg = this.latency;
          else
            this.latencyAvg = (this.latency + this.latencyAvg) / 2;
          this._latencyTime = null;
          this._doPing = false;
          this.emit("latency-changed", this.latency, this.latencyAvg);
        } else if (!this._doPing && this.enablePing)
          this._doPing = true;
        else {
          this._latencyTime = null;
          this._doPing = false;
        }
      }
      if (this.enableDebug)
        this.emit("debug", "PreProcess:" + data, 1);
      data = this.processData(data, skipDecompress, false, prependSplit);
      if (this.enableDebug)
        this.emit("debug", "PostProcess:" + data, 1);
      this.emit("received-data", data);
      if (this.enableLatency) {
        if (this._splitBuffer.length > 0) {
          if (this.enablePing) this._doPing = true;
          this._latencyTime = null;
        } else if (this._doPing && this.enablePing) {
          setTimeout(() => {
            this._latencyTime = /* @__PURE__ */ new Date();
            this.sendGMCP("Core.Ping " + this.latencyAvg);
          });
        } else
          this._doPing = false;
      }
    }
    /**
     * @name Telnet#sendTerminal
     * @desc Send terminal type telnet option to mud to identify the terminal
     */
    sendTerminal() {
      if (this.enableDebug) {
        if (this._MTTS === 0)
          this.emit("debug", "REPLY: <IAC><SB><TERMINALTYPE><IS>" + this.terminal + "<IAC><SE>");
        else if (this._MTTS === 1)
          this.emit("debug", "REPLY: <IAC><SB><TERMINALTYPE><IS>ANSI-256COLOR<IAC><SE>");
        else if (this._MTTS >= 2)
          this.emit("debug", "REPLY: <IAC><SB><TERMINALTYPE><IS>MTTS 9<IAC><SE>");
      }
      if (this._MTTS === 0) {
        var tmp = new Uint8Array(6 + this.terminal.length);
        tmp.set([255, 250, 24, 0], 0);
        tmp.set(StringToUint8Array(this.terminal), 4);
        tmp.set([255, 240], 4 + this.terminal.length);
        this.sendData(tmp, true);
      } else if (this._MTTS === 1)
        this.sendData([255, 250, 24, 0, 65, 78, 83, 73, 45, 50, 53, 54, 67, 79, 76, 79, 82, 255, 240], true);
      else if (this._MTTS >= 2)
        this.sendData([255, 250, 24, 0, 77, 84, 84, 83, 32, 57, 255, 240], true);
    }
    /**
     * @name Telnet#sendData
     * @desc Send data to the host
     *
     * @param {String} data string to send
     * @param {Boolean} raw send raw unescaped telnet data to host, other wise it will escape the IAC for proper telnet
     * @fires Telnet#data-sent
     */
    sendData(data, raw) {
      if (data == null || typeof data === "undefined" || data.length === 0)
        return;
      if (this.connected) {
        try {
          if (!raw) {
            this.prompt = false;
            data = this._escapeData(data);
            if (this.enableLatency) this._latencyTime = /* @__PURE__ */ new Date();
          }
          if (this.socket !== null) {
            if (data instanceof Uint8Array) {
              if (this.enableDebug)
                this.emit("debug", "sendDataU8:" + printArray(data));
              this.socket.send(data);
            } else if (Array.isArray(data)) {
              if (this.enableDebug)
                this.emit("debug", "sendDataBA" + printArray(new Uint8Array(data)));
              this.socket.send(new Uint8Array(data));
            } else {
              if (this.enableDebug)
                this.emit("debug", "sendDataR:" + printArray(StringToUint8Array(data)));
              this.socket.send(data);
            }
            if (!raw) this.firstSent = false;
          }
        } catch (e) {
          this.emit("error", e);
        }
      } else if (this.enableLatency)
        this._latencyTime = null;
      this.emit("data-sent", data, raw);
    }
    /**
     * @name Telnet#processData
     * @desc Process raw incoming data
     *
     * @param {string} data The data to process
     * @returns {string} The results of the processed data
     * @fires Telnet#receive-option
     * @fires Telnet#receive-MSDP
     * @fires Telnet#receive-GMCP
     * @fires Telnet#receive-MSSP
     * @fires Telnet#receive-NEWENVIRON
     * @fires Telnet#receive-CHARSET
     */
    //this.processData = function(data) { return data; };
    processData(data, skipDecompress, returnRaw, prependSplit) {
      let len;
      let tmp = "";
      let _sb;
      if (data == null)
        return data;
      if (!skipDecompress)
        data = this._decompressData(data);
      len = data.byteLength;
      if (len === 0)
        return data;
      _sb = this._splitBuffer;
      if (_sb.length > 0) {
        if (this.enableDebug) this.emit("debug", "Split buffer length: " + _sb.length, 1);
        tmp = new Uint8Array(len + _sb.length);
        if (prependSplit) {
          tmp.set(data, 0);
          tmp.set(_sb, data.byteLength);
        } else {
          tmp.set(_sb, 0);
          tmp.set(data, _sb.length);
        }
        data = tmp;
        _sb = [];
        len = data.byteLength;
      }
      let state = 0;
      let pState = 0;
      let processed = new StringBuffer();
      const ga = this.prompt;
      let verb = 0;
      let option = 0;
      let msdp_val = "";
      let msdp_var = "";
      let _MSSP;
      let i2 = 0;
      let ne;
      let idx = 0;
      tmp = "";
      this.prompt = false;
      let debugOp = "";
      try {
        for (; idx < len; idx++) {
          i2 = data[idx];
          switch (state) {
            case 0:
              if (i2 === 255) {
                if (this.enableDebug) debugOp = "TELOP: <IAC>";
                _sb.push(i2);
                state = 1;
              } else if (this.UTF8 || this.options.CHARSET && this.server.CHARSET) {
                if ((i2 & 128) === 128 && idx >= len - 4) {
                  let uLen = 0;
                  if ((i2 & 192) === 192)
                    uLen = 1;
                  else if ((i2 & 224) === 224)
                    uLen = 2;
                  else if ((i2 & 240) === 240)
                    uLen = 3;
                  if (idx + uLen >= len) {
                    _sb.push(...data.slice(idx));
                    if (this.enableDebug) {
                      this.emit("debug", "Unicode split length: " + uLen, 1);
                      this.emit("debug", "Split buffer length: " + _sb.length, 1);
                    }
                    break;
                  }
                }
                processed.appendCode(i2);
              } else
                processed.appendCode(i2);
              break;
            case 1:
              if (i2 === 255) {
                if (this.enableDebug) {
                  this.emit("debug", debugOp + "<IAC>");
                  debugOp = "";
                }
                processed.appendCode(i2);
                _sb = [];
                state = 0;
              } else if ((!this.options.EOR || !this.server.EOR) && i2 === 239) {
                if (this.enableDebug) {
                  this.emit("debug", debugOp + "<NOP>");
                  debugOp = "";
                }
                _sb = [];
                state = 0;
              } else if (i2 === 241 || i2 === 130) {
                if (this.enableDebug) {
                  this.emit("debug", debugOp + "<NOP>");
                  debugOp = "";
                }
                _sb = [];
                state = 0;
              } else if (i2 === 249 || i2 === 239) {
                if (this.enableDebug) {
                  if (i2 === 239)
                    this.emit("debug", debugOp + "<EOR>");
                  else
                    this.emit("debug", debugOp + "<GA>");
                  debugOp = "";
                }
                if (idx + 1 < len && len - idx > 2) {
                  processed.push("\n");
                  this.prompt = false;
                } else
                  this.prompt = true;
                _sb = [];
                state = 0;
              } else if (i2 === 253 || i2 === 254 || i2 === 251 || i2 === 252) {
                if (this.enableDebug) {
                  switch (i2) {
                    case 253:
                      debugOp += "<DO>";
                      break;
                    case 254:
                      debugOp += "<DONT>";
                      break;
                    case 251:
                      debugOp += "<WILL>";
                      break;
                    case 252:
                      debugOp += "<WONT>";
                      break;
                  }
                }
                _sb.push(i2);
                verb = i2;
                state = 2;
              } else if (i2 === 250) {
                if (this.enableDebug) debugOp += "<SB>";
                _sb.push(i2);
                state = 3;
              } else {
                if (this.enableDebug) debugOp += this._formatByte(i2);
                _sb = [];
                state = 0;
              }
              break;
            case 2:
              if (i2 === 1) {
                if (this.enableDebug) {
                  this.emit("debug", debugOp + "<ECHO>");
                  debugOp = "";
                }
                if (verb === 253) {
                  if (this.options.ECHO) {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><WILL><ECHO>");
                    this.replyToOption(i2, 251, verb);
                    this.echo = false;
                  } else {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DONT><ECHO>");
                    this.echo = true;
                    this.replyToOption(i2, 254, verb);
                  }
                } else if (verb === 254) {
                  if (this.enableDebug) this.emit("debug", "REPLY: <IAC><WONT><ECHO>");
                  this.replyToOption(i2, 252, verb);
                  this.echo = true;
                } else if (verb === 251) {
                  if (this.options.ECHO) {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DO><ECHO>");
                    this.replyToOption(i2, 253, verb);
                    this.echo = false;
                  } else {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DONT><ECHO>");
                    this.echo = true;
                    this.replyToOption(i2, 254, verb);
                  }
                } else if (verb === 252) {
                  if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DONT><ECHO>");
                  this.echo = true;
                  this.replyToOption(i2, 254, verb);
                }
                state = 0;
                _sb = [];
              } else if (i2 === 24) {
                if (this.enableDebug) {
                  this.emit("debug", debugOp + "<TERMINALTYPE>");
                  debugOp = "";
                }
                if (verb === 253) {
                  if (this.options.TTYPE) {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><WILL><TERMINALTYPE>");
                    this.replyToOption(i2, 251, verb);
                  } else {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DONT><TERMINALTYPE>");
                    this.replyToOption(i2, 254, verb);
                  }
                } else if (verb === 254) {
                  if (this.enableDebug) this.emit("debug", "REPLY: <IAC><WONT><TERMINALTYPE>");
                  this.replyToOption(i2, 252, verb);
                } else if (verb === 251) {
                  if (this.options.TTYPE) {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DO><TERMINALTYPE>");
                    this.replyToOption(i2, 253, verb);
                  } else {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DONT><TERMINALTYPE>");
                    this.replyToOption(i2, 254, verb);
                  }
                } else if (verb === 252) {
                  if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DONT><TERMINALTYPE>");
                  this.replyToOption(i2, 254, verb);
                }
                state = 0;
                _sb = [];
              } else if (i2 === 25) {
                if (this.enableDebug) {
                  this.emit("debug", debugOp + "<ENDOFRECORD>");
                  debugOp = "";
                }
                if (verb === 253) {
                  this.server.EOR = true;
                  if (this.options.EOR) {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><WILL><ENDOFRECORD>");
                    this.replyToOption(i2, 251, verb);
                  } else {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DONT><ENDOFRECORD>");
                    this.replyToOption(i2, 254, verb);
                  }
                } else if (verb === 254) {
                  if (this.enableDebug) this.emit("debug", "REPLY: <IAC><WONT><ENDOFRECORD>");
                  this.replyToOption(i2, 252, verb);
                } else if (verb === 251) {
                  this.server.EOR = true;
                  if (this.options.EOR) {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DO><ENDOFRECORD>");
                    this.replyToOption(i2, 253, verb);
                  } else {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DONT><ENDOFRECORD>");
                    this.replyToOption(i2, 254, verb);
                  }
                } else if (verb === 252) {
                  if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DONT><ENDOFRECORD>");
                  this.replyToOption(i2, 254, verb);
                }
                state = 0;
                _sb = [];
              } else if (i2 === 31) {
                if (this.enableDebug) {
                  this.emit("debug", debugOp + "<NAWS>");
                  debugOp = "";
                }
                if (verb === 253) {
                  this.server.NAWS = true;
                  if (this.options.NAWS) {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><WILL><NAWS>");
                    this.replyToOption(i2, 251, verb);
                  } else {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DONT><NAWS>");
                    this.replyToOption(i2, 254, verb);
                  }
                } else if (verb === 254) {
                  this.server.NAWS = false;
                  if (this.enableDebug) this.emit("debug", "REPLY: <IAC><WONT><NAWS>");
                  this.replyToOption(i2, 252, verb);
                } else if (verb === 251) {
                  this.server.NAWS = true;
                  if (this.options.NAWS) {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DO><NAWS>");
                    this.replyToOption(i2, 253, verb);
                  } else {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DONT><NAWS>");
                    this.replyToOption(i2, 254, verb);
                  }
                } else if (verb === 252) {
                  this.server.NAWS = false;
                  if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DONT><NAWS>");
                  this.replyToOption(i2, 254, verb);
                }
                this.emit("windowSize");
                state = 0;
                _sb = [];
              } else if (i2 === 36 || i2 === 39) {
                if (this.enableDebug) {
                  this.emit("debug", debugOp + "<NEWENVIRON>");
                  debugOp = "";
                }
                if (verb === 253) {
                  this.server.NEWENVIRON = true;
                  if (this.options.NEWENVIRON) {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><WILL><NEWENVIRON>");
                    this.replyToOption(i2, 251, verb);
                  } else {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DONT><NEWENVIRON>");
                    this.replyToOption(i2, 254, verb);
                  }
                } else if (verb === 254) {
                  if (this.enableDebug) this.emit("debug", "REPLY: <IAC><WONT><NEWENVIRON>");
                  this.replyToOption(i2, 252, verb);
                } else if (verb === 251) {
                  this.server.NEWENVIRON = true;
                  if (this.options.NEWENVIRON) {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DO><NEWENVIRON>");
                    this.replyToOption(i2, 253, verb);
                  } else {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DONT><NEWENVIRON>");
                    this.replyToOption(i2, 254, verb);
                  }
                } else if (verb === 252) {
                  if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DONT><NEWENVIRON>");
                  this.replyToOption(i2, 254, verb);
                }
                state = 0;
                _sb = [];
              } else if (i2 === 69) {
                if (this.enableDebug) {
                  this.emit("debug", debugOp + "<MSDP>");
                  debugOp = "";
                }
                if (verb === 253) {
                  this.server.MSDP = true;
                  if (this.options.MSDP) {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><WILL><MSDP>");
                    this.replyToOption(i2, 251, verb);
                  } else {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DONT><MSDP>");
                    this.replyToOption(i2, 254, verb);
                  }
                } else if (verb === 254) {
                  this.server.MSDP = false;
                  if (this.enableDebug) this.emit("debug", "REPLY: <IAC><WONT><MSDP>");
                  this.replyToOption(i2, 252, verb);
                } else if (verb === 251) {
                  this.server.MSDP = true;
                  if (this.options.MSDP) {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DO><MSDP>");
                    this.replyToOption(i2, 253, verb);
                  } else {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DONT><MSDP>");
                    this.replyToOption(i2, 254, verb);
                  }
                } else if (verb === 252) {
                  this.server.MSDP = false;
                  if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DONT><MSDP>");
                  this.replyToOption(i2, 254, verb);
                }
                state = 0;
                _sb = [];
              } else if (i2 === 70) {
                if (this.enableDebug) {
                  this.emit("debug", debugOp + "<MSSP>");
                  debugOp = "";
                }
                if (verb === 253) {
                  this.server.MSSP = true;
                  if (this.options.MSSP) {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><WILL><MSSP>");
                    this.replyToOption(i2, 251, verb);
                  } else {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DONT><MSSP>");
                    this.replyToOption(i2, 254, verb);
                  }
                } else if (verb === 254) {
                  this.server.MSSP = false;
                  if (this.enableDebug) this.emit("debug", "REPLY: <IAC><WONT><MSSP>");
                  this.replyToOption(i2, 252, verb);
                } else if (verb === 251) {
                  this.server.MSSP = true;
                  if (this.options.MSSP) {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DO><MSSP>");
                    this.replyToOption(i2, 253, verb);
                  } else {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DONT><MSSP>");
                    this.replyToOption(i2, 254, verb);
                  }
                } else if (verb === 252) {
                  this.server.MSSP = false;
                  if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DONT><MSSP>");
                  this.replyToOption(i2, 254, verb);
                }
                state = 0;
                _sb = [];
              } else if (i2 === 85) {
                if (this.enableDebug) {
                  this.emit("debug", debugOp + "<MCCP1>");
                  debugOp = "";
                }
                if (verb === 253) {
                  this.server.MCCP1 = true;
                  if (this.options.MCCP) {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><WILL><MCCP1>");
                    this.replyToOption(i2, 251, verb);
                  } else {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DONT><MCCP1>");
                    this.replyToOption(i2, 254, verb);
                  }
                } else if (verb === 254) {
                  this.server.MCCP1 = false;
                  if (this.enableDebug) this.emit("debug", "REPLY: <IAC><WONT><MCCP1>");
                  this.replyToOption(i2, 252, verb);
                } else if (verb === 251) {
                  this.server.MCCP1 = true;
                  if (this.options.MCCP) {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DO><MCCP1>");
                    this.replyToOption(i2, 253, verb);
                  } else {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DONT><MCCP1>");
                    this.replyToOption(i2, 254, verb);
                  }
                } else if (verb === 252) {
                  this.server.MCCP1 = false;
                  if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DONT><MCCP1>");
                  this.replyToOption(i2, 254, verb);
                }
                state = 0;
                _sb = [];
              } else if (i2 === 86) {
                if (this.enableDebug) {
                  this.emit("debug", debugOp + "<MCCP2>");
                  debugOp = "";
                }
                if (verb === 253) {
                  this.server.MCCP2 = true;
                  if (this.options.MCCP) {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><WILL><MCCP2>");
                    this.replyToOption(i2, 251, verb);
                  } else {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DONT><MCCP2>");
                    this.replyToOption(i2, 254, verb);
                  }
                } else if (verb === 254) {
                  this.server.MCCP2 = false;
                  if (this.enableDebug) this.emit("debug", "REPLY: <IAC><WONT><MCCP2>");
                  this.replyToOption(i2, 252, verb);
                } else if (verb === 251) {
                  this.server.MCCP2 = true;
                  if (this.options.MCCP) {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DO><MCCP2>");
                    this.replyToOption(i2, 253, verb);
                  } else {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DONT><MCCP2>");
                    this.replyToOption(i2, 254, verb);
                  }
                } else if (verb === 252) {
                  this.server.MCCP2 = false;
                  if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DONT><MCCP2>");
                  this.replyToOption(i2, 254, verb);
                }
                state = 0;
                _sb = [];
              } else if (i2 === 91) {
                if (this.enableDebug) {
                  this.emit("debug", debugOp + "<MXP>");
                  debugOp = "";
                }
                if (verb === 253) {
                  this.server.MXP = true;
                  if (this.options.MXP) {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><WILL><MXP>");
                    this.replyToOption(i2, 251, verb);
                  } else {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DONT><MXP>");
                    this.replyToOption(i2, 254, verb);
                  }
                } else if (verb === 254) {
                  this.server.MXP = false;
                  if (this.enableDebug) this.emit("debug", "REPLY: <IAC><WONT><MXP>");
                  this.replyToOption(i2, 252, verb);
                } else if (verb === 251) {
                  this.server.MXP = true;
                  if (this.options.MXP) {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DO><MXP>");
                    this.replyToOption(i2, 253, verb);
                  } else {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DONT><MXP>");
                    this.replyToOption(i2, 254, verb);
                  }
                } else if (verb === 252) {
                  this.server.MXP = false;
                  if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DONT><MXP>");
                  this.replyToOption(i2, 254, verb);
                }
                state = 0;
                _sb = [];
              } else if (i2 === 130 || i2 === 241) {
                if (this.enableDebug) {
                  this.emit("debug", debugOp + "<NOP>");
                  debugOp = "";
                }
                this._fireReceiveOption(i2, verb, "");
                _sb = [];
                state = 0;
              } else if (i2 === 201) {
                if (this.enableDebug) {
                  this.emit("debug", debugOp + "<GMCP>");
                  debugOp = "";
                }
                if (verb === 253) {
                  this.server.GMCP = true;
                  if (this.options.GMCP) {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><WILL><GMCP>");
                    this.replyToOption(i2, 251, verb);
                    this._startGMCP();
                  } else {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DONT><GMCP>");
                    this.replyToOption(i2, 254, verb);
                  }
                } else if (verb === 254) {
                  this.server.GMCP = false;
                  if (this.enableDebug) this.emit("debug", "REPLY: <IAC><WONT><GMCP>");
                  this.replyToOption(i2, 252, verb);
                } else if (verb === 251) {
                  this.server.GMCP = true;
                  if (this.options.GMCP) {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DO><GMCP>");
                    this.replyToOption(i2, 253, verb);
                    this._startGMCP();
                  } else {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DONT><GMCP>");
                    this.replyToOption(i2, 254, verb);
                  }
                } else if (verb === 252) {
                  this.server.GMCP = false;
                  if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DONT><GMCP>");
                  this.replyToOption(i2, 254, verb);
                }
                state = 0;
                _sb = [];
              } else if (i2 === 42) {
                if (this.enableDebug) {
                  this.emit("debug", debugOp + "<CHARSET>");
                  debugOp = "";
                }
                if (verb === 253) {
                  this.server.CHARSET = true;
                  if (this.options.CHARSET) {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><WILL><CHARSET>");
                    this.replyToOption(i2, 251, verb);
                  } else {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DONT><CHARSET>");
                    this.replyToOption(i2, 254, verb);
                  }
                } else if (verb === 254) {
                  this.server.CHARSET = false;
                  if (this.enableDebug) this.emit("debug", "REPLY: <IAC><WONT><CHARSET>");
                  this.replyToOption(i2, 252, verb);
                } else if (verb === 251) {
                  this.server.CHARSET = true;
                  if (this.options.CHARSET) {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DO><CHARSET>");
                    this.replyToOption(i2, 253, verb);
                  } else {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DONT><CHARSET>");
                    this.replyToOption(i2, 254, verb);
                  }
                } else if (verb === 252) {
                  this.server.CHARSET = false;
                  if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DONT><CHARSET>");
                  this.replyToOption(i2, 254, verb);
                }
                state = 0;
                _sb = [];
              } else {
                if (this.enableDebug) {
                  this.emit("debug", debugOp + this._formatByte(i2));
                  debugOp = "";
                }
                if (verb === 251 || verb === 252) {
                  if (this.enableDebug) this.emit("debug", "REPLY: <IAC><DONT><" + i2 + ">");
                  this.replyToOption(i2, 254, verb);
                } else if (verb === 254 || verb === 253) {
                  if (this.enableDebug) this.emit("debug", "REPLY: <IAC><WONT><" + i2 + ">");
                  this.replyToOption(i2, 252, verb);
                }
                state = 0;
                _sb = [];
              }
              break;
            case 3:
              option = i2;
              if (i2 === 24) {
                if (this.enableDebug) debugOp += "<TERMINALTYPE>";
                _sb.push(i2);
                option = i2;
                state = 4;
              } else if (i2 === 36 || i2 === 39) {
                if (this.enableDebug) debugOp += "<NEWENVIRON>";
                _sb.push(i2);
                option = i2;
                state = 12;
                ne = -1;
              } else if (i2 === 69) {
                if (this.enableDebug) debugOp += "<MSDP>";
                _sb.push(i2);
                option = i2;
                state = 4;
              } else if (i2 === 70) {
                if (this.enableDebug) debugOp += "<MSSP>";
                _sb.push(i2);
                option = i2;
                state = 8;
                _MSSP = {};
              } else if (i2 === 85 || i2 === 86) {
                if (this.enableDebug) debugOp += i2 === 85 ? "<MCCP1>" : "<MCCP2>";
                _sb.push(i2);
                option = i2;
                state = 11;
              } else if (i2 === 201) {
                if (this.enableDebug) debugOp += "<GMCP>";
                _sb.push(i2);
                option = i2;
                state = 7;
              } else if (i2 === 240) {
                if (this.enableDebug) {
                  this.emit("debug", debugOp + "<SE>");
                  debugOp = "";
                }
                tmp = ArrayBufferToString(_sb.slice(1, _sb.length - 4));
                this._fireReceiveOption(option, 250, tmp);
                tmp = null;
                state = 0;
                _sb = [];
              } else if (i2 === 42) {
                if (this.enableDebug) debugOp += "<CHARSET>";
                _sb.push(i2);
                option = i2;
                state = 17;
                msdp_val = "";
              } else {
                if (this.enableDebug) debugOp += this._formatByte(i2);
                _sb.push(i2);
              }
              break;
            case 4:
              if (option === 24 && i2 === 1) {
                if (this.enableDebug) debugOp += "<SEND>";
                _sb.push(i2);
                verb = 1;
              } else if (i2 === 240) {
                if (this.enableDebug) {
                  this.emit("debug", debugOp + "<SE>");
                  debugOp = "";
                }
                if (option === 24 && verb === 1) {
                  tmp = false;
                  this._fireReceiveOption(option, 250, "");
                  if (!tmp) {
                    this.sendTerminal();
                    this.sendTerminal();
                    this._MTTS++;
                  }
                }
                state = 0;
                _sb = [];
              } else if (option === 69 && i2 === 1) {
                if (this.enableDebug) debugOp += "<MSDP_VAR>";
                _sb.push(i2);
                msdp_var = "";
                state = 5;
              } else {
                if (this.enableDebug) debugOp += this._formatByte(i2);
                _sb.push(i2);
              }
              break;
            case 5:
              if (i2 === 2) {
                if (this.enableDebug) debugOp += "<MSDP_VAL>";
                _sb.push(i2);
                msdp_val = "";
                state = 6;
              } else {
                if (this.enableDebug) debugOp += this._formatByte(i2);
                msdp_var += String.fromCharCode(i2);
                _sb.push(i2);
              }
              break;
            case 6:
              if (i2 === 255) {
                if (this.enableDebug) debugOp += "<IAC>";
                _sb.push(i2);
              } else if (i2 === 1) {
                if (this.enableDebug) debugOp += "<MSDP_VAR>";
                this._fireReceiveMSDP(msdp_var, msdp_val);
                msdp_val = "";
                msdp_var = "";
                _sb.push(i2);
                state = 5;
              } else if (i2 === 240) {
                if (this.enableDebug) {
                  this.emit("debug", debugOp + "<SE>");
                  debugOp = "";
                }
                tmp = ArrayBufferToString(_sb.slice(1, _sb.length - 4));
                this._fireReceiveOption(option, 250, tmp);
                tmp = null;
                this._fireReceiveMSDP(msdp_var, msdp_val);
                msdp_val = "";
                msdp_var = "";
                state = 0;
                _sb = [];
              } else {
                if (this.enableDebug) debugOp += this._formatByte(i2);
                msdp_val += String.fromCharCode(i2);
                _sb.push(i2);
              }
              break;
            case 7:
              if (i2 === 255) {
                if (this.enableDebug) debugOp += "<IAC>";
                _sb.push(i2);
              } else if (i2 === 240) {
                if (this.enableDebug) {
                  this.emit("debug", debugOp + "<SE>");
                  debugOp = "";
                }
                tmp = ArrayBufferToString(_sb.slice(1, _sb.length - 4));
                this._fireReceiveOption(option, 250, tmp);
                tmp = null;
                this._fireReceiveGMCP(msdp_val);
                state = 0;
                msdp_val = "";
                _sb = [];
              } else {
                if (this.enableDebug) debugOp += this._formatByte(i2);
                msdp_val += String.fromCharCode(i2);
                _sb.push(i2);
              }
              break;
            case 8:
              if (i2 === 255) {
                if (this.enableDebug) debugOp += "<IAC>";
                _sb.push(i2);
              } else if (i2 === 240) {
                if (this.enableDebug) {
                  this.emit("debug", debugOp + "<SE>");
                  this.emit("debug", this.MSSP);
                  debugOp = "";
                }
                tmp = ArrayBufferToString(_sb.slice(1, _sb.length - 4));
                this._fireReceiveOption(option, 250, tmp);
                tmp = null;
                this.emit("receive-MSSP", _MSSP);
                msdp_val = "";
                msdp_var = "";
                _MSSP = 0;
                state = 0;
                _sb = [];
              } else if (i2 === 1) {
                if (this.enableDebug) debugOp += "<MSSP_VAR>";
                _sb.push(i2);
                msdp_var = "";
                state = 9;
              } else {
                if (this.enableDebug) debugOp += this._formatByte(i2);
                _sb.push(i2);
              }
              break;
            case 9:
              if (i2 === 255) {
                if (this.enableDebug) debugOp += "<IAC>";
                _sb.push(i2);
                state = 8;
              } else if (i2 === 1) {
                if (this.enableDebug) debugOp += "<MSSP_VAR>";
                _sb.push(i2);
                msdp_var = "";
              } else if (i2 === 2) {
                if (this.enableDebug) debugOp += "<MSSP_VAL>";
                _sb.push(i2);
                this.MSSP[msdp_var] = "";
                _MSSP[msdp_var] = "";
                state = 10;
              } else {
                if (this.enableDebug) debugOp += this._formatByte(i2);
                msdp_var += String.fromCharCode(i2);
                _sb.push(i2);
              }
              break;
            case 10:
              if (i2 === 255) {
                if (this.enableDebug) debugOp += "<IAC>";
                _sb.push(i2);
                state = 8;
              } else if (i2 === 1) {
                if (this.enableDebug) debugOp += "<MSSP_VAR>";
                _sb.push(i2);
                msdp_var = "";
                state = 9;
              } else if (i2 === 2) {
                if (this.enableDebug) debugOp += "<MSSP_VAL>";
                _sb.push(i2);
                this.MSSP[msdp_var] = "";
                _MSSP[msdp_var] = "";
              } else {
                if (this.enableDebug) debugOp += this._formatByte(i2);
                this.MSSP[msdp_var] += String.fromCharCode(i2);
                _MSSP[msdp_var] += String.fromCharCode(i2);
                _sb.push(i2);
              }
              break;
            case 11:
              if (i2 === 255) {
                if (this.enableDebug) debugOp += "<IAC>";
                _sb.push(i2);
              } else if (i2 === 240) {
                if (this.enableDebug) {
                  this.emit("debug", debugOp + "<SE>");
                  debugOp = "";
                }
                this._fireReceiveOption(option, 86, "");
                this._startMCCP();
                state = 0;
                _sb = [];
                if (idx < len - 1)
                  processed.append(this.processData(data.subarray(idx + 1), skipDecompress, true));
                idx = len;
              }
              break;
            case 12:
              if (i2 === 255) {
                if (this.enableDebug) debugOp += "<IAC>";
                _sb.push(i2);
              } else if (i2 === 240) {
                if (this.enableDebug) {
                  this.emit("debug", debugOp + "<SE>");
                  debugOp = "";
                }
                tmp = ArrayBufferToString(_sb.slice(1, _sb.length - 4));
                this._fireReceiveOption(option, 250, tmp);
                tmp = null;
                this._fireReceiveGMCP(msdp_val);
                state = 0;
                msdp_val = "";
                _sb = [];
              } else if (i2 === 0) {
                if (this.enableDebug) debugOp += "<IS>";
                _sb.push(i2);
                state = 13;
                verb = i2;
              } else if (i2 === 1) {
                if (this.enableDebug) debugOp += "<SEND>";
                _sb.push(i2);
                state = 13;
                verb = i2;
              } else if (i2 === 2) {
                if (this.enableDebug) debugOp += "<SEND>";
                _sb.push(i2);
                state = 13;
                verb = i2;
              } else {
                if (this.enableDebug) debugOp += this._formatByte(i2);
                msdp_val += String.fromCharCode(i2);
                _sb.push(i2);
              }
              break;
            case 13:
              if (i2 === 0) {
                if (this.enableDebug) debugOp += "<VAR>";
                _sb.push(i2);
                state = 14;
                verb = i2;
                msdp_var = "";
                if (ne === -1) ne = 0;
              } else if (i2 === 1) {
                if (this.enableDebug) debugOp += "<VALUE>";
                _sb.push(i2);
                state = 13;
                verb = i2;
                if (ne === -1) ne = 1;
              } else if (i2 === 3) {
                if (this.enableDebug) debugOp += "<USERVAR>";
                _sb.push(i2);
                state = 13;
                verb = i2;
              } else if (i2 === 255) {
                if (this.enableDebug) debugOp += "<IAC>";
                _sb.push(i2);
              } else if (i2 === 240) {
                if (this.enableDebug) {
                  this.emit("debug", debugOp + "<SE>");
                  debugOp = "";
                }
                tmp = ArrayBufferToString(_sb.slice(1, _sb.length - 4));
                tmp = this._fireReceiveOption(option, 250, tmp);
                this.emit("receive-NEWENVIRON", msdp_val);
                if (!tmp) {
                  if (this.enableDebug) this.emit("debug", "REPLY: <IAC><SB><NEWENVIRON><IS><IAC><SE>");
                  this.sendData(new Uint8Array([255, 250]), true);
                  this.sendData(option, true);
                  this.sendData(new Uint8Array([0, 255, 240]), true);
                }
                state = 0;
                msdp_val = "";
                _sb = [];
              } else {
                if (this.enableDebug) debugOp += this._formatByte(i2);
                msdp_val += String.fromCharCode(i2);
                _sb.push(i2);
              }
              break;
            case 14:
              if (i2 === 2) {
                if (this.enableDebug) debugOp += this._formatByte(i2);
                _sb.push(i2);
                state = 15;
                pState = 14;
              } else if (i2 === 255 || i2 <= 3) {
                idx--;
                state = 13;
              } else {
                if (this.enableDebug) debugOp += this._formatByte(i2);
                msdp_var += String.fromCharCode(i2);
                _sb.push(i2);
              }
              break;
            case 15:
              if (this.enableDebug) debugOp += this._formatByte(i2);
              if (pState === 16)
                msdp_val += String.fromCharCode(i2);
              else
                msdp_var += String.fromCharCode(i2);
              state = pState;
              _sb.push(i2);
              break;
            case 16:
              break;
            case 17:
              if (i2 === 1) {
                if (this.enableDebug) debugOp += "<REQUEST>";
                _sb.push(i2);
                state = 18;
                msdp_val = "";
              } else if (i2 === 255) {
                if (this.enableDebug) debugOp += "<IAC>";
                _sb.push(i2);
              } else if (i2 === 240) {
                if (this.enableDebug) {
                  this.emit("debug", debugOp + "<SE>");
                  debugOp = "";
                }
                tmp = this._fireReceiveOption(option, 250, msdp_val);
                this.emit("receive-CHARSET", msdp_val);
                if (!tmp) {
                  if (this.enableDebug) this.emit("debug", "REPLY: <IAC><SB><CHARSET><REJECTED><IAC><SE>");
                  this.sendData(new Uint8Array([255, 250, 42, 3, 255, 240]), true);
                }
                state = 0;
                msdp_val = "";
                _sb = [];
              } else {
                if (this.enableDebug) debugOp += this._formatByte(i2);
                msdp_val += String.fromCharCode(i2);
                _sb.push(i2);
              }
              break;
            case 18:
              if (i2 === 255) {
                if (this.enableDebug) debugOp += "<IAC>";
                _sb.push(i2);
              } else if (i2 === 240) {
                if (this.enableDebug) {
                  this.emit("debug", debugOp + "<SE>");
                  debugOp = "";
                }
                tmp = this._fireReceiveOption(option, 250, msdp_val);
                this.emit("receive-CHARSET", msdp_val.slice(1));
                if (!tmp) {
                  if (this.options.CHARSET && msdp_val.slice(1).toLowerCase() === "utf-8") {
                    this.server.CHARSET = true;
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><SB><ACCEPTED>UTF-8<IAC><SE>");
                    this.sendData(new Uint8Array([255, 250, 42, 2]), true);
                    this.sendData("UTF-8", true);
                    this.sendData(new Uint8Array([255, 240]), true);
                  } else {
                    if (this.enableDebug) this.emit("debug", "REPLY: <IAC><SB><CHARSET><REJECTED><IAC><SE>");
                    this.sendData(new Uint8Array([255, 250, 42, 3, 255, 240]), true);
                  }
                }
                state = 0;
                msdp_val = "";
                _sb = [];
              } else {
                if (this.enableDebug) debugOp += this._formatByte(i2);
                msdp_val += String.fromCharCode(i2);
                _sb.push(i2);
              }
              break;
          }
        }
      } catch (e) {
        this.emit("error", e);
      }
      if (this.enableDebug) {
        {
          if (debugOp.length > 0)
            this.emit("debug", debugOp);
        }
        this.emit("debug", "Post Split buffer length: " + _sb.length, 1);
        this.emit("debug", "PostSplit buffer  " + printArray(new Uint8Array(_sb)), 1);
      }
      if (ga && processed.length > 0)
        processed.prepend("\n");
      else if (ga)
        this.prompt = true;
      if (processed.length > 0)
        this.firstReceived = false;
      this._splitBuffer = _sb;
      if (returnRaw)
        return processed;
      if (this.UTF8 || this.options.CHARSET && this.server.CHARSET)
        return UTF8.decode2(processed.toString());
      return processed.toString();
    }
    /**
     * @name Telnet#replyToOption
     * @desc Replay to a telnet option
     *
     * @param {Number} op The telnet option code
     * @param {Number} verb The telnet verb to reply with
     * @param {Number} reply The telnet verb your reply from
     * @param {String|undefined} val The value if the option has one
     * @return boolean returns if the reply was handled or not
     * @fires Telnet#receive-option
     */
    replyToOption(op, verb, reply, val) {
      if (typeof val === "undefined") val = "";
      if (this._fireReceiveOption(op, reply, val))
        return false;
      this.sendData(new Uint8Array([255, verb, op]), true);
      return true;
    }
    /**
     * @name Telnet#updateWindow
     * @desc Send a NAWS Window update
     *
     * @param {Number} w The current width in lines of the window
     * @param {Number} h The current height in characters of the window
     */
    updateWindow(w, h) {
      if (h < 1 || w < 1 || !this.connected || !this.server.NAWS) return;
      try {
        let w1;
        let w2;
        let h1;
        let h2;
        const mf = Math.floor;
        w1 = mf(w / 256);
        if (w1 > 256)
          w1 = 255;
        w2 = w % 256;
        h1 = mf(h / 256);
        if (h1 > 256)
          h1 = 255;
        h2 = h % 256;
        if (this.enableDebug) this.emit("debug", "REPLY: <IAC><SB><NAWS><" + w1 + "><" + w2 + "><" + h1 + "><" + h2 + "><IAC><SE>");
        this.sendData(new Uint8Array([255, 250, 31, w1, w2, h1, h2, 255, 240]), true);
      } catch (e) {
        this.emit("error", { message: "UpdateWindow Error: " + e, err: e });
      }
    }
    /**
     * @name Telnet#sendGMCP
     * @desc Send a GMCP formatted string
     *
     * @param {String} str The GMCP formatted string to send to the host
     */
    sendGMCP(str) {
      if (this.connected && this.server.GMCP) {
        if (this.enableDebug) this.emit("debug", "REPLY: <IAC><SB><GMCP>" + this._escapeData(str).toString("binary") + "<IAC><SE>");
        this.sendData(new Uint8Array([255, 250, 201]), true);
        this.sendData(this._escapeData(str), true);
        this.sendData(new Uint8Array([255, 240]), true);
      }
    }
    /**
     * @name Telnet#startGMCP
     * @desc Start GMCP and send Core.Hello and Core.Support.Set
     */
    _startGMCP() {
      if (this.server.GMCP) {
        if (this.enableDebug)
          this.emit("debug", 'REPLY: <IAC><SB><GMCP>Core.Hello { "client": "' + this.terminal + '", "version": "' + this.version + '" }<IAC><SE>');
        this.sendData(new Uint8Array([255, 250, 201]), true);
        this.sendData('Core.Hello { "client": "' + this.terminal + '", "version": "' + this.version + '" }', true);
        this.sendData(new Uint8Array([255, 240]), true);
        this.sendData(new Uint8Array([255, 250, 201]), true);
        if (this.GMCPSupports.length > 0) {
          if (this.GMCPSupports.indexOf("Core 1") === -1)
            this.GMCPSupports.unshift("Core 1");
          if (this.enableDebug)
            this.emit("debug", "REPLY: <IAC><SB><GMCP>" + JSON.stringify(this.GMCPSupports) + "<IAC><SE>");
          this.sendData("Core.Supports.Set " + JSON.stringify(this.GMCPSupports));
        } else {
          if (this.enableDebug)
            this.emit("debug", 'REPLY: <IAC><SB><GMCP>Core.Supports.Set [ "Core 1" ]<IAC><SE>');
          this.sendData('Core.Supports.Set [ "Core 1" ]', true);
        }
        this.sendData(new Uint8Array([255, 240]), true);
      }
    }
    /**
     * @name Telnet#startMCCP
     * @desc Start MCCP compression protocol and set compress state on
     */
    _startMCCP() {
      this._zlib = true;
    }
    /**
     * @name Telnet#endMCCP
     * @desc End MCCP compression protocol and set compress state off
     */
    _endMCCP() {
      this._zlib = false;
      this._zStream = 0;
    }
    /**
     * @name Telnet#decompressData
     * @desc Decompresses a ZLIB stream if ZLIB is present and compress state is on
     *
     * @param {String} data The compressed data string
     * @returns {String} The decompressed data or the original data i ZLIB is not found or compress state is off
     */
    _decompressData(data) {
      if (!this._zlib) return data;
      if (!this._zStream)
        this._zStream = new import_inflate_stream_min.Zlib.InflateStream();
      if (this.enableDebug) this.emit("debug", "Pre decompress:" + printArray(data), 1);
      data = this._zStream.decompress(data);
      if (this.enableDebug) this.emit("debug", "Post decompress:" + printArray(data), 1);
      return new Uint8Array(data);
    }
    /**
     * @name Telnet#escapeData
     * @desc Escape data for sending over telnet, IAC should become IAC IAC and \r to \r\0 and \n to \r\n
     *
     * @param {String} data the data to be escaped
     * @returns {String} the data after being escaped
     *
     */
    _escapeData(data) {
      if (data == null || typeof data === "undefined") return data;
      let dl;
      let ba;
      let idx = 0;
      let i2;
      let c;
      if (data instanceof Uint8Array) {
        dl = data.byteLength;
        ba = new StringBuffer();
        for (; idx < dl; idx++) {
          ba.appendCode(data[idx]);
          if (data[idx] === 255)
            ba.appendCode(255);
          else if (data[idx] === 13 && dl === 1)
            ba.append("\r\n");
          else if (data[idx] === 10 && dl === 1)
            ba.append("\r\0");
        }
        return ba.toString();
      }
      dl = data.length;
      ba = new StringBuffer();
      for (; idx < dl; idx++) {
        c = data.charAt(idx);
        i2 = data.charCodeAt(idx);
        ba.append(c);
        if (i2 === 255)
          ba.append(c);
        else if (i2 === 13 && dl === 1)
          ba.append("\r\n");
        else if (i2 === 10 && dl === 1)
          ba.append("\r\0");
      }
      return ba.toString();
    }
    /**
     * @name Telnet#createSocket 
     * @desc Create a websocket object and assign events
     *
     * @returns {object} returns the socket object
     */
    _createSocket(host, port) {
      let _socket;
      try {
        const hasScheme = /^[a-z0-9]+:\/\//.test(host);
        if (hasScheme && port > 0)
          _socket = new WebSocket(host + ":" + port, this.protocol || "binary");
        else if (hasScheme)
          _socket = new WebSocket(host, this.protocol || "binary");
        else if (host && port > 0)
          _socket = new WebSocket((this.scheme || "ws://") + host + ":" + port, this.protocol || "binary");
        else if (host)
          _socket = new WebSocket((this.scheme || "ws://") + host, this.protocol || "binary");
        _socket.binaryType = "arraybuffer";
        _socket.onclose = (evt) => {
          if (evt.code === 1006 && evt.type === "close" && !this._closed)
            this.close();
          else if (evt.code !== 1e3 && !this._closed) {
            this.emit("error", { message: "Closed due to transmission error", err: evt });
            this.close();
          }
        };
        _socket.onopen = () => {
          this._connected = true;
          this.emit("connect");
        };
        _socket.onmessage = (evt) => {
          if (evt.data instanceof ArrayBuffer) {
            var data = new Uint8Array(evt.data);
            if (this.enableDebug) this.emit("debug", "Data ArrayBuffer received:" + printArray(data));
            this.receivedData(data);
          } else if (evt.data instanceof Blob) {
            var reader = new FileReader();
            reader.onloadend = () => {
              var data2 = new Uint8Array(reader.result);
              this.receivedData(data2);
              if (this.enableDebug) this.emit("debug", "Data Blob received:" + printArray(reader.result));
            };
            reader.readAsArrayBuffer(evt.data);
          } else {
            if (this.enableDebug) this.emit("debug", "Data received:" + evt.data);
            this.receivedData(evt.data);
          }
        };
        _socket.onerror = (evt) => {
          if (!this._closed)
            this.emit("error", evt);
        };
        return _socket;
      } catch (e) {
        this.emit("error", e);
      }
      return null;
    }
    /**
    * @name Telnet#destroySocket
    * @desc Destroy the current websocket object by assigning all functions to be empty
    *
    * @returns {object} returns null
    */
    _destroySocket() {
      if (!this.socket || this.socket == null) return;
      try {
        this.socket.onopen = function() {
        };
        this.socket.onclose = function() {
        };
        this.socket.onmessage = function() {
        };
        this.socket.onerror = function() {
        };
        if (this.connected)
          this.socket.close();
        delete this.socket;
      } catch (e) {
        this.emit("error", e);
      }
      this.socket = null;
    }
    /**
    * @name Telnet#fireTelnetOption 
    * @desc Fire the onTelnetOption e
    *
    * @returns {object} returns null
    */
    _fireReceiveOption(option, verb, val) {
      const data = { telnet: this, option, verb: 250, value: val, handled: false };
      this.emit("received-option", data);
      return data.handled;
    }
    _fireReceiveMSDP(msdp_var, msdp_val) {
      const data = { telnet: this, variable: msdp_var, value: msdp_val, handled: false };
      this.emit("received-MSDP", data);
      return data.handled;
    }
    _fireReceiveGMCP(val) {
      const data = { telnet: this, value: val, handled: false };
      this.emit("received-GMCP", data);
      return data.handled;
    }
    _formatByte(b) {
      if (b < 32 || b >= 127)
        return "<" + b + ">";
      return String.fromCharCode(b);
    }
    /**
     * @name Telnet#onError
     * @desc Fired when an error happens
     * @method 
     * @event Telnet#onError
     * @property {String|Object} err - the err object or message
     */
    /**
     * @name Telnet#onConnecting
     * @desc Fired when attempting to connect to host
     * @method  
     * @event Telnet#onConnecting
     */
    /**
     * @name Telnet#onConnect
     * @desc Fired when successfully connected to host
     * @method  
     * @event Telnet#onConnect
     */
    /**
    * @name Telnet#onClose
    * @desc Fired when connection is closed to host
    * @method  
    * @event Telnet#onClose
    */
    /**
     * @name Telnet#onReceivedData
     * @desc Fired when data is received from the host
     * @method  
     * @event Telnet#onReceivedData
     * @property {String} data - received from the host after being processed for telnet options
     */
    /**
     * @name Telnet#onDataSent
     * @desc Fired when data is sent to the host
     * @method  
     * @event Telnet#onDataSent
     * @property {String} data - data that was sent to the host
     */
    /**
     * @name Telnet#onReceiveMSDP
     * @desc Fired when a MSDP variable is received from host
     * @method  
     * @event Telnet#onReceiveMSDP
     * @property {String} msdp_var - MSDP variable name
     * @property {String} msdp_val - MSDP value of variable
     */
    /**
    * @name Telnet#onReceiveGMCP
    * @desc Fired when GMCP data is received from host
    * @method  
    * @event Telnet#onReceiveGMCP
    * @property {String} value - The raw GMCP string
    */
    /**
    * @name Telnet#onReceiveMSSP
    * @desc Fired when MSSP variables and values are found
    * @method  
    * @event Telnet#onReceiveMSSP
    * @type {object}
    * @property {object} - the MSSP object containing all variables and values found
    */
    /**
     * @name Telnet#onTelnetOption
     * @desc Fired when a telnet option is found and before any reply sent
     * @method  
     * @event Telnet#onTelnetOption
     * @type {object}
     * @property {Number} option - Telnet option code
     * @property {Number} verb - Telnet verb being replied to
     * @property {String} value - Telnet option value if it has one
     *
     * @returns {Boolean} true if the option was handled, false if not handled and to continue default action
     */
  };
  window.telnet = new Telnet();

  // src/ansi.ts
  var Ansi = /* @__PURE__ */ ((Ansi2) => {
    Ansi2[Ansi2["None"] = 0] = "None";
    Ansi2[Ansi2["Bold"] = 1] = "Bold";
    Ansi2[Ansi2["Faint"] = 2] = "Faint";
    Ansi2[Ansi2["Underline"] = 4] = "Underline";
    Ansi2[Ansi2["Italic"] = 3] = "Italic";
    Ansi2[Ansi2["Slow"] = 5] = "Slow";
    Ansi2[Ansi2["Rapid"] = 6] = "Rapid";
    Ansi2[Ansi2["Inverse"] = 7] = "Inverse";
    Ansi2[Ansi2["Hidden"] = 8] = "Hidden";
    Ansi2[Ansi2["Strikeout"] = 9] = "Strikeout";
    Ansi2[Ansi2["DoubleUnderline"] = 21] = "DoubleUnderline";
    Ansi2[Ansi2["Overline"] = 53] = "Overline";
    return Ansi2;
  })(Ansi || {});
  var AnsiColorCode = /* @__PURE__ */ ((AnsiColorCode2) => {
    AnsiColorCode2[AnsiColorCode2["ErrorBackground"] = -12] = "ErrorBackground";
    AnsiColorCode2[AnsiColorCode2["ErrorText"] = -11] = "ErrorText";
    AnsiColorCode2[AnsiColorCode2["InfoBackground"] = -8] = "InfoBackground";
    AnsiColorCode2[AnsiColorCode2["InfoText"] = -7] = "InfoText";
    AnsiColorCode2[AnsiColorCode2["LocalEcho"] = -3] = "LocalEcho";
    AnsiColorCode2[AnsiColorCode2["LocalEchoBack"] = -4] = "LocalEchoBack";
    AnsiColorCode2[AnsiColorCode2["Reset"] = 0] = "Reset";
    AnsiColorCode2[AnsiColorCode2["Bold"] = 1] = "Bold";
    AnsiColorCode2[AnsiColorCode2["Faint"] = 2] = "Faint";
    AnsiColorCode2[AnsiColorCode2["Italic"] = 3] = "Italic";
    AnsiColorCode2[AnsiColorCode2["Underline"] = 4] = "Underline";
    AnsiColorCode2[AnsiColorCode2["Blink"] = 5] = "Blink";
    AnsiColorCode2[AnsiColorCode2["BlinkRapid"] = 6] = "BlinkRapid";
    AnsiColorCode2[AnsiColorCode2["Reverse"] = 7] = "Reverse";
    AnsiColorCode2[AnsiColorCode2["Hidden"] = 8] = "Hidden";
    AnsiColorCode2[AnsiColorCode2["StrikeThrough"] = 9] = "StrikeThrough";
    AnsiColorCode2[AnsiColorCode2["DoubleUnderline"] = 21] = "DoubleUnderline";
    AnsiColorCode2[AnsiColorCode2["BoldOff"] = 22] = "BoldOff";
    AnsiColorCode2[AnsiColorCode2["ItalicOff"] = 23] = "ItalicOff";
    AnsiColorCode2[AnsiColorCode2["UnderlineOff"] = 24] = "UnderlineOff";
    AnsiColorCode2[AnsiColorCode2["BlinkOff"] = 25] = "BlinkOff";
    AnsiColorCode2[AnsiColorCode2["BlinkRapidOff"] = 26] = "BlinkRapidOff";
    AnsiColorCode2[AnsiColorCode2["ReverseOff"] = 27] = "ReverseOff";
    AnsiColorCode2[AnsiColorCode2["Visible"] = 28] = "Visible";
    AnsiColorCode2[AnsiColorCode2["StrikeThroughOff"] = 29] = "StrikeThroughOff";
    AnsiColorCode2[AnsiColorCode2["Black"] = 30] = "Black";
    AnsiColorCode2[AnsiColorCode2["Red"] = 31] = "Red";
    AnsiColorCode2[AnsiColorCode2["Green"] = 32] = "Green";
    AnsiColorCode2[AnsiColorCode2["Yellow"] = 33] = "Yellow";
    AnsiColorCode2[AnsiColorCode2["Blue"] = 34] = "Blue";
    AnsiColorCode2[AnsiColorCode2["Magenta"] = 35] = "Magenta";
    AnsiColorCode2[AnsiColorCode2["Cyan"] = 36] = "Cyan";
    AnsiColorCode2[AnsiColorCode2["White"] = 37] = "White";
    AnsiColorCode2[AnsiColorCode2["DefaultFore"] = 39] = "DefaultFore";
    AnsiColorCode2[AnsiColorCode2["BlackBackground"] = 40] = "BlackBackground";
    AnsiColorCode2[AnsiColorCode2["RedBackground"] = 41] = "RedBackground";
    AnsiColorCode2[AnsiColorCode2["GreenBackground"] = 42] = "GreenBackground";
    AnsiColorCode2[AnsiColorCode2["YellowBackground"] = 43] = "YellowBackground";
    AnsiColorCode2[AnsiColorCode2["BlueBackground"] = 44] = "BlueBackground";
    AnsiColorCode2[AnsiColorCode2["MagentaBackground"] = 45] = "MagentaBackground";
    AnsiColorCode2[AnsiColorCode2["CyanBackground"] = 46] = "CyanBackground";
    AnsiColorCode2[AnsiColorCode2["WhiteBackground"] = 47] = "WhiteBackground";
    AnsiColorCode2[AnsiColorCode2["DefaultBack"] = 49] = "DefaultBack";
    AnsiColorCode2[AnsiColorCode2["Subscript"] = 74] = "Subscript";
    AnsiColorCode2[AnsiColorCode2["Superscript"] = 73] = "Superscript";
    AnsiColorCode2[AnsiColorCode2["SubSuperOff"] = 75] = "SubSuperOff";
    AnsiColorCode2[AnsiColorCode2["XBlack"] = 90] = "XBlack";
    AnsiColorCode2[AnsiColorCode2["XRed"] = 91] = "XRed";
    AnsiColorCode2[AnsiColorCode2["XGreen"] = 92] = "XGreen";
    AnsiColorCode2[AnsiColorCode2["XYellow"] = 93] = "XYellow";
    AnsiColorCode2[AnsiColorCode2["XBlue"] = 94] = "XBlue";
    AnsiColorCode2[AnsiColorCode2["XMagenta"] = 95] = "XMagenta";
    AnsiColorCode2[AnsiColorCode2["XCyan"] = 96] = "XCyan";
    AnsiColorCode2[AnsiColorCode2["XWhite"] = 97] = "XWhite";
    AnsiColorCode2[AnsiColorCode2["XBlackBackground"] = 100] = "XBlackBackground";
    AnsiColorCode2[AnsiColorCode2["XRedBackground"] = 101] = "XRedBackground";
    AnsiColorCode2[AnsiColorCode2["XGreenBackground"] = 102] = "XGreenBackground";
    AnsiColorCode2[AnsiColorCode2["XYellowBackground"] = 103] = "XYellowBackground";
    AnsiColorCode2[AnsiColorCode2["XBlueBackground"] = 104] = "XBlueBackground";
    AnsiColorCode2[AnsiColorCode2["XMagentaBackground"] = 105] = "XMagentaBackground";
    AnsiColorCode2[AnsiColorCode2["XCyanBackground"] = 106] = "XCyanBackground";
    AnsiColorCode2[AnsiColorCode2["XWhiteBackground"] = 107] = "XWhiteBackground";
    return AnsiColorCode2;
  })(AnsiColorCode || {});
  function getAnsiColorCode(color, back) {
    switch (color.toLowerCase()) {
      case "black":
        return back ? 40 : 30;
      case "red":
        return back ? 41 : 31;
      case "green":
        return back ? 42 : 32;
      case "yellow":
        return back ? 43 : 33;
      case "blue":
        return back ? 44 : 34;
      case "magenta":
        return back ? 45 : 35;
      case "cyan":
        return back ? 46 : 36;
      case "white":
        return back ? 47 : 37;
      case "default":
        return back ? 49 : 39;
    }
    return -1;
  }
  function getColorCode(code) {
    let f = -1;
    let b = -1;
    let bold = false;
    if (code - 1024 >= 0) {
      code -= 1024;
    }
    if (code - 512 >= 0) {
      code -= 512;
    }
    if (code - 256 >= 0) {
      code -= 256;
    }
    if (code - 128 >= 0) {
      code -= 128;
      bold = true;
    }
    if (code - 112 >= 0) {
      code -= 112;
      b = 47;
    }
    if (code - 96 >= 0) {
      code -= 96;
      b = 43;
    }
    if (code - 80 >= 0) {
      code -= 80;
      b = 45;
    }
    if (code - 64 >= 0) {
      code -= 64;
      b = 41;
    }
    if (code - 48 >= 0) {
      code -= 48;
      b = 46;
    }
    if (code - 32 >= 0) {
      code -= 32;
      b = 42;
    }
    if (code - 16 >= 0) {
      code -= 16;
      b = 44;
    }
    if (code >= 8) {
      code -= 8;
      bold = true;
    }
    switch (code) {
      case 0:
        f = 30;
        break;
      case 1:
        f = 34;
        break;
      case 2:
        f = 32;
        break;
      case 3:
        f = 36;
        break;
      case 4:
        f = 31;
        break;
      case 5:
        f = 35;
        break;
      case 6:
        f = 33;
        break;
      case 7:
        f = 37;
        break;
    }
    if (bold && f === -1) f = 370;
    else if (bold) f *= 10;
    if (f === -1)
      return `,${b}`;
    if (b === -1)
      return f.toString();
    return `${f},${b}`;
  }
  function isMXPColor(color) {
    if (!color || color.length === 0) return false;
    return [
      "indianred",
      "lightcoral",
      "salmon",
      "darksalmon",
      "lightsalmon",
      "crimson",
      "red",
      "firebrick",
      "darkred",
      "pink",
      "lightpink",
      "hotpink",
      "deeppink",
      "mediumvioletred",
      "palevioletred",
      "lightsalmon",
      "coral",
      "tomato",
      "orangered",
      "darkorange",
      "orange",
      "gold",
      "yellow",
      "lightyellow",
      "lemonchiffon",
      "lightgoldenrodyellow",
      "papayawhip",
      "moccasin",
      "peachpuff",
      "palegoldenrod",
      "khaki",
      "darkkhaki",
      "lavender",
      "thistle",
      "plum",
      "violet",
      "orchid",
      "fuchsia",
      "magenta",
      "mediumorchid",
      "mediumpurple",
      "blueviolet",
      "darkviolet",
      "darkorchid",
      "darkmagenta",
      "purple",
      "indigo",
      "slateblue",
      "darkslateblue",
      "mediumslateblue",
      "greenyellow",
      "chartreuse",
      "lawngreen",
      "lime",
      "limegreen",
      "palegreen",
      "lightgreen",
      "mediumspringgreen",
      "springgreen",
      "mediumseagreen",
      "seagreen",
      "forestgreen",
      "green",
      "darkgreen",
      "yellowgreen",
      "olivedrab",
      "olive",
      "darkolivegreen",
      "mediumaquamarine",
      "darkseagreen",
      "lightseagreen",
      "darkcyan",
      "teal",
      "aqua",
      "cyan",
      "lightcyan",
      "paleturquoise",
      "aquamarine",
      "turquoise",
      "mediumturquoise",
      "darkturquoise",
      "cadetblue",
      "steelblue",
      "lightsteelblue",
      "powderblue",
      "lightblue",
      "skyblue",
      "lightskyblue",
      "deepskyblue",
      "dodgerblue",
      "cornflowerblue",
      "mediumslateblue",
      "royalblue",
      "blue",
      "mediumblue",
      "darkblue",
      "navy",
      "midnightblue",
      "cornsilk",
      "blanchedalmond",
      "bisque",
      "navajowhite",
      "wheat",
      "burlywood",
      "tan",
      "rosybrown",
      "sandybrown",
      "goldenrod",
      "darkgoldenrod",
      "peru",
      "chocolate",
      "saddlebrown",
      "sienna",
      "brown",
      "maroon",
      "white",
      "snow",
      "honeydew",
      "mintcream",
      "azure",
      "aliceblue",
      "ghostwhite",
      "whitesmoke",
      "seashell",
      "beige",
      "oldlace",
      "floralwhite",
      "ivory",
      "antiquewhite",
      "linen",
      "lavenderblush",
      "mistyrose",
      "gainsboro",
      "lightgrey",
      "silver",
      "darkgray",
      "gray",
      "dimgray",
      "lightslategray",
      "slategray",
      "darkslategray",
      "black"
    ].indexOf(color.toLowerCase()) != -1;
  }
  function getAnsiCode(str, back) {
    switch (str) {
      /** @desc  custom color for error information */
      case "errortextbackground":
      case "errorbackground":
        return -12;
      /** @desc  custom background color for error information */
      case "errortext":
        return back ? -12 : -11;
      /** @desc  custom background color for client information */
      case "infobackground":
        return -8;
      /** @desc  custom foreground color for client information */
      case "infotext":
        return back ? -8 : -7;
      /** @desc  custom tag for local echo */
      case "localecho":
        return back ? -4 : -3;
      /** @desc  custom tag for local echo */
      case "localechoback":
        return -4;
      /** @desc all attributes off */
      case "reset":
        return 0;
      /** @desc bold on */
      case "bold":
        return 1;
      /** @desc faint on */
      case "faint":
        return 2;
      /** @desc italic on */
      case "italic":
        return 3;
      /** @desc underscore */
      case "underline":
        return 4;
      /** @desc blink on (slow) */
      case "blink":
        return 5;
      /** @desc blink on (rapid) */
      case "blinkrapid":
        return 6;
      /** @desc reverse video on */
      case "reverse":
        return 7;
      /** @desc concealed on */
      case "hidden":
        return 8;
      /** @desc  strike through */
      case "strikethrough":
        return 9;
      /** @desc double underline on */
      case "doubleunderline":
        return 21;
      /** @desc bold off */
      case "boldoff":
        return 22;
      /** @desc italics off */
      case "italicoff":
        return 23;
      /** @desc underline off */
      case "underlineoff":
        return 24;
      /** @desc blink off (slow) */
      case "blinkoff":
        return 25;
      /** @desc blink off (rapid) */
      case "blinkrapidoff":
        return 26;
      /** @desc inverse off */
      case "reverseoff":
        return 27;
      /** @desc visible */
      case "visible":
        return 28;
      /** @desc strike through off */
      case "strikethroughoff":
        return 29;
      /** @desc black foreground */
      case "black":
        return back ? 40 : 30;
      /** @desc red foreground */
      case "red":
        return back ? 41 : 31;
      /** @desc green foreground */
      case "green":
        return back ? 42 : 32;
      /** @desc yellow foreground */
      case "yellow":
        return back ? 43 : 33;
      /** @desc blue foreground */
      case "blue":
        return back ? 44 : 34;
      /** @desc magenta foreground */
      case "magenta":
        return back ? 45 : 35;
      /** @desc cyan foreground */
      case "cyan":
        return back ? 46 : 36;
      /** @desc white foreground */
      case "white":
        return back ? 47 : 37;
      /** @desc default */
      case "default":
      case "defaultfore":
        return back ? 49 : 39;
      /** @desc black background */
      case "blackbackground":
        return 40;
      /** @desc red background */
      case "redbackground":
        return 41;
      /** @desc green background */
      case "greenbackground":
        return 42;
      /** @desc yellow background */
      case "yellowbackground":
        return 43;
      /** @desc blue background */
      case "bluebackground":
        return 44;
      /** @desc magenta background */
      case "magentabackground":
        return 45;
      /** @desc cyan background */
      case "cyanbackground":
        return 46;
      /** @desc white background */
      case "whitebackground":
        return 47;
      /** @desc default */
      case "defaultbackground":
      case "defaultback":
        return 49;
      case "overline":
        return 53;
      /** @desc subscript */
      case "subscript":
        return 74;
      /** @desc superscript */
      case "superscript":
        return 73;
      case "subsuperoff":
        return 75;
      // xterm 16 color support
      /** @desc set foreground color to black */
      case "xblack":
        return back ? 100 : 90;
      /** @desc set foreground color to red */
      case "xred":
        return back ? 101 : 91;
      /** @desc set foreground color to green */
      case "xgreen":
        return back ? 102 : 92;
      /** @desc set foreground color to yellow */
      case "xyellow":
        return back ? 103 : 93;
      /** @desc set foreground color to blue */
      case "xblue":
        return back ? 104 : 94;
      /** @desc set foreground color to magenta */
      case "xmagenta":
        return back ? 105 : 95;
      /** @desc set foreground color to cyan */
      case "xcyan":
        return back ? 106 : 96;
      /** @desc set foreground color to white */
      case "xwhite":
        return back ? 107 : 97;
      /** @desc set background color to black */
      case "xblackbackground":
        return 100;
      /** @desc set background color to red */
      case "xredbackground":
        return 101;
      /** @desc set background color to green */
      case "xgreenbackground":
        return 102;
      /** @desc set background color to yellow */
      case "xyellowbackground":
        return 103;
      /** @desc set background color to blue */
      case "xbluebackground":
        return 104;
      /** @desc set background color to magenta */
      case "xmagentabackground":
        return 105;
      /** @desc set background color to cyan */
      case "xcyanbackground":
        return 106;
      /** @desc set background color to white */
      case "xwhitebackground":
        return 107;
    }
    return -1;
  }

  // src/types.ts
  var Size = class {
    constructor(width, height) {
      this.width = 0;
      this.height = 0;
      this.width = width;
      this.height = height;
    }
  };

  // src/settings.ts
  var SettingList = [
    ["bufferSize", 0, 2, 500],
    ["commandDelay", 0, 2, 500],
    ["commandDelayCount", 0, 2, 5],
    ["commandHistorySize", 0, 2, 20],
    ["fontSize", 0, 0, "1em", 0],
    ["cmdfontSize", 0, 0, "1em", 0],
    ["commandEcho", 0, 1, true],
    ["flashing", 0, 1, false],
    ["autoConnect", 0, 1, true],
    ["enableAliases", -1, 1, true],
    ["enableTriggers", -1, 1, true],
    ["enableMacros", -1, 1, true],
    ["showScriptErrors", 0, 1, false],
    ["commandStacking", 0, 1, true],
    ["commandStackingChar", 0, 0, ";", 1],
    ["htmlLog", 0, 1, true],
    ["keepLastCommand", 0, 1, true],
    ["enableMCCP", 0, 1, true],
    ["enableUTF8", 0, 1, true],
    ["font", 0, 5, "'Courier New', Courier, monospace", 0],
    ["cmdfont", 0, 5, "'Courier New', Courier, monospace", 0],
    ["aliases", -1, 4],
    ["macros", -1, 4],
    ["triggers", -1, 4],
    ["mapFollow", "mapper.follow", 1, true],
    ["mapEnabled", "mapper.enabled", 1, true],
    ["MapperSplitArea", "mapper.split", 1, false],
    ["MapperFillWalls", "mapper.fill", 1, false],
    ["MapperOpen", "showMapper", 1, false],
    ["fullScreen", -1, 3, false],
    ["enableMXP", 0, 1, true],
    ["enableMSP", 0, 1, true],
    ["parseCommands", 0, 3, true],
    ["lagMeter", 0, 1, true],
    ["enablePing", 0, 1, false],
    ["enableEcho", 0, 1, true],
    ["enableSpeedpaths", 0, 1, true],
    ["speedpathsChar", 0, 0, "!", 1],
    ["parseSpeedpaths", 0, 1, true],
    ["profile", -1, 0, "Default", 1],
    ["parseSingleQuotes", 0, 1, false],
    ["parseDoubleQuotes", 0, 1, true],
    ["logEnabled", 0, 1, false],
    ["logPrepend", 0, 1, false],
    ["logOffline", 0, 1, false],
    ["logUniqueOnConnect", 0, 1, true],
    ["enableURLDetection", 0, 1, true],
    ["colors", 0, 4],
    ["notifyMSPPlay", 0, 1, false],
    ["CommandonClick", 0, 1, true],
    ["allowEval", 0, 1, true],
    ["allowEscape", 0, 1, true],
    ["AutoCopySelectedToClipboard", 0, 1, false],
    ["enableDebug", 0, 1, false],
    ["editorPersistent", 0, 1, false],
    ["askonclose", 0, 1, true],
    ["dev", 0, 1, false],
    //New settings
    ["chat.captureLines", 0, 1, false],
    ["chat.captureAllLines", 0, 1, false],
    ["chat.captureReviews", 0, 1, false],
    ["chat.captureTells", 0, 1, false],
    ["chat.captureTalk", 0, 1, false],
    ["chat.gag", 0, 1, false],
    ["chat.CaptureOnlyOpen", 0, 1, false],
    ["checkForUpdates", 0, 1, false],
    ["autoCreateCharacter", 0, 1, false],
    ["askonchildren", 0, 1, true],
    ["mapper.legend", 0, 1, false],
    ["mapper.room", 0, 1, false],
    ["mapper.importType", 0, 2, 1],
    ["mapper.vscroll", 0, 2, 0],
    ["mapper.hscroll", 0, 2, 0],
    ["mapper.scale", 0, 2, 100],
    ["mapper.alwaysOnTop", 0, 1, false],
    ["mapper.alwaysOnTopClient", 0, 1, true],
    ["mapper.memory", 0, 1, false],
    ["mapper.memorySavePeriod", 0, 2, 9e5],
    ["mapper.active.ID", 0, 0, null],
    ["mapper.active.x", 0, 2, 0],
    ["mapper.active.y", 0, 2, 0],
    ["mapper.active.z", 0, 2, 0],
    ["mapper.active.area", 0, 0, null],
    ["mapper.active.zone", 0, 2, 0],
    ["mapper.persistent", 0, 1, true],
    ["profiles.split", 0, 2, 204],
    ["profiles.askoncancel", 0, 1, true],
    ["profiles.triggersAdvanced", 0, 1, false],
    ["profiles.aliasesAdvanced", 0, 1, false],
    ["profiles.buttonsAdvanced", 0, 1, false],
    ["profiles.macrosAdvanced", 0, 1, false],
    ["profiles.contextsAdvanced", 0, 1, false],
    ["profiles.codeEditor", 0, 1, true],
    ["profiles.watchFiles", 0, 1, true],
    ["chat.alwaysOnTop", 0, 1, false],
    ["chat.alwaysOnTopClient", 0, 1, true],
    ["chat.log", 0, 1, false],
    ["chat.persistent", 0, 1, false],
    ["chat.zoom", 0, 2, 1],
    ["chat.font", 0, 5, "'Courier New', Courier, monospace"],
    ["chat.fontSize", 0, 0, "1em"],
    ["title", 0, 0, "$t"],
    ["logGagged", 0, 1, false],
    ["logTimeFormat", 0, 0, "YYYYMMDD-HHmmss"],
    ["autoConnectDelay", 0, 2, 600],
    ["autoLogin", 0, 1, true],
    ["onDisconnect", 0, 2, 2 /* ReconnectDialog */],
    ["enableKeepAlive", 0, 1, false],
    ["keepAliveDelay", 0, 2, 0],
    ["newlineShortcut", 0, 2, 1 /* Ctrl */],
    ["logWhat", 0, 2, 1],
    ["logErrors", 0, 1, true],
    ["showErrorsExtended", 0, 1, false],
    ["reportCrashes", 0, 1, false],
    ["enableCommands", 0, 1, true],
    ["commandChar", 0, 0, "#", 1],
    ["escapeChar", 0, 0, "\\", 1],
    ["enableVerbatim", 0, 1, true],
    ["verbatimChar", 0, 0, "`"],
    ["soundPath", 0, 0, ""],
    ["logPath", 0, 0, ""],
    ["theme", 0, 0, ""],
    ["gamepads", 0, 1, false],
    ["buttons.connect", 0, 1, true],
    ["buttons.characters", 0, 1, true],
    ["buttons.preferences", 0, 1, true],
    ["buttons.log", 0, 1, true],
    ["buttons.clear", 0, 1, true],
    ["buttons.lock", 0, 1, true],
    ["buttons.map", 0, 1, true],
    ["buttons.user", 0, 1, true],
    ["buttons.mail", 0, 1, false],
    ["buttons.compose", 0, 1, false],
    ["buttons.immortal", 0, 1, true],
    ["buttons.codeEditor", 0, 1, false],
    ["find.case", 0, 1, false],
    ["find.word", 0, 1, false],
    ["find.reverse", 0, 1, false],
    ["find.regex", 0, 1, false],
    ["find.selection", 0, 1, false],
    ["find.show", 0, 1, false],
    ["display.split", 0, 1, false],
    ["display.splitHeight", 0, 2, -1],
    ["display.splitLive", 0, 1, true],
    ["display.roundedOverlays", 0, 1, true],
    ["backupLoad", 0, 2, 30],
    ["backupSave", 0, 2, 30],
    ["backupAllProfiles", 0, 1, true],
    ["scrollLocked", 0, 1, false],
    ["showStatus", 0, 1, !isMobile()],
    ["showCharacterManager", 0, 1, false],
    ["showChat", 0, 1, false],
    ["showEditor", 0, 1, false],
    ["showArmor", 0, 1, false],
    ["showStatusWeather", 0, 1, true],
    ["showStatusLimbs", 0, 1, true],
    ["showStatusHealth", 0, 1, true],
    ["showStatusExperience", 0, 1, true],
    ["showStatusPartyHealth", 0, 1, true],
    ["showStatusCombatHealth", 0, 1, true],
    ["showButtonBar", 0, 1, true],
    ["allowNegativeNumberNeeded", 0, 1, false],
    ["spellchecking", 0, 1, true],
    ["hideOnMinimize", 0, 1, false],
    ["showTrayIcon", 0, 1, false],
    ["statusExperienceNeededProgressbar", 0, 1, false],
    ["trayClick", 0, 2, 0],
    ["trayDblClick", 0, 2, 0],
    ["pasteSpecialPrefix", 0, 0, ""],
    ["pasteSpecialPostfix", 0, 0, ""],
    ["pasteSpecialReplace", 0, 0, ""],
    ["pasteSpecialPrefixEnabled", 0, 1, true],
    ["pasteSpecialPostfixEnabled", 0, 1, true],
    ["pasteSpecialReplaceEnabled", 0, 1, true],
    ["display.showSplitButton", 0, 1, true],
    ["chat.split", 0, 1, false],
    ["chat.splitHeight", 0, 2, -1],
    ["chat.splitLive", 0, 1, true],
    ["chat.roundedOverlays", 0, 1, true],
    ["chat.showSplitButton", 0, 1, true],
    ["chat.bufferSize", 0, 2, 500],
    ["chat.flashing", 0, 1, false],
    ["display.hideTrailingEmptyLine", 0, 1, true],
    ["display.enableColors", 0, 1, true],
    ["display.enableBackgroundColors", 0, 1, true],
    ["enableSound", 0, 1, true],
    ["allowHalfOpen", 0, 1, true],
    ["editorClearOnSend", 0, 1, true],
    ["editorCloseOnSend", 0, 1, true],
    ["askOnCloseAll", 0, 1, true],
    ["askonloadCharacter", 0, 1, true],
    ["mapper.roomWidth", 0, 2, 200],
    ["mapper.roomGroups", 0, 2, 1 | 2 | 4],
    ["mapper.showInTaskBar", 0, 1, false],
    ["profiles.enabled", 0, 4, []],
    ["profiles.sortOrder", 0, 2, 4 /* Priority */ | 8 /* Index */],
    ["profiles.sortDirection", 0, 2, 1],
    ["profiles.showInTaskBar", 0, 1, false],
    ["profiles.profileSelected", 0, 0, "default"],
    ["profiles.profileExpandSelected", 0, 1, true],
    ["chat.lines", 0, 4, []],
    ["chat.showInTaskBar", 0, 1, false],
    ["chat.showTimestamp", 0, 2 /* Number */, 0],
    ["chat.timestampFormat", 0, 0, "[[]MM-DD HH:mm:ss.SSS[]] "],
    ["chat.tabWidth", 0, 2, 8],
    ["chat.displayControlCodes", 0, 1, false],
    ["chat.emulateTerminal", 0, 1, false],
    ["chat.emulateControlCodes", 0, 1, true],
    ["chat.wordWrap", 0, 1, false],
    ["chat.wrapAt", 0, 2, 0],
    ["chat.indent", 0, 2, 4],
    ["chat.scrollLocked", 0, 1, false],
    ["chat.find.case", 0, 1, false],
    ["chat.find.word", 0, 1, false],
    ["chat.find.reverse", 0, 1, false],
    ["chat.find.regex", 0, 1, false],
    ["chat.find.selection", 0, 1, false],
    ["chat.find.show", 0, 1, false],
    ["chat.find.highlight", 0, 1, false],
    ["chat.find.location", 0, 4, [5, 20]],
    ["codeEditor.showInTaskBar", 0, 1, false],
    ["codeEditor.persistent", 0, 1, false],
    ["codeEditor.alwaysOnTop", 0, 1, false],
    ["codeEditor.alwaysOnTopClient", 0, 1, true],
    ["autoTakeoverLogin", 0, 1, false],
    ["fixHiddenWindows", 0, 1, true],
    ["maxReconnectDelay", 0, 2, 3600],
    ["enableBackgroundThrottling", 0, 1, true],
    ["enableBackgroundThrottlingClients", 0, 1, false],
    ["showInTaskBar", 0, 1, true],
    ["showLagInTitle", 0, 1, false],
    ["mspMaxRetriesOnError", 0, 2, 0],
    ["logTimestamp", 0, 2 /* Number */, 0],
    ["logTimestampFormat", 0, 0, "[[]MM-DD HH:mm:ss.SSS[]] "],
    ["disableTriggerOnError", 0, 1, true],
    ["prependTriggeredLine", 0, 1, true],
    ["enableParameters", 0, 1, true],
    ["parametersChar", 0, 0, "%", 1],
    ["enableNParameters", 0, 1, true],
    ["nParametersChar", 0, 0, "$", 1],
    ["enableParsing", 0, 1, true],
    ["externalWho", 0, 1, true],
    ["externalHelp", 0, 1, true],
    ["watchForProfilesChanges", 0, 1, false],
    ["onProfileChange", 0, 2, 0 /* Nothing */],
    ["onProfileDeleted", 0, 2, 0 /* Nothing */],
    ["enableDoubleParameterEscaping", 0, 1, false],
    ["ignoreEvalUndefined", 0, 1, true],
    ["enableInlineComments", 0, 1, true],
    ["enableBlockComments", 0, 1, true],
    ["inlineCommentString", 0, 0, "//"],
    ["blockCommentString", 0, 0, "/*"],
    ["allowCommentsFromCommand", 0, 1, false],
    ["saveTriggerStateChanges", 0, 1, true],
    ["groupProfileSaves", 0, 1, false],
    ["groupProfileSaveDelay", 0, 2, 2e4],
    ["returnNewlineOnEmptyValue", 0, 1, false],
    ["pathDelay", 0, 2, 0],
    ["pathDelayCount", 0, 2, 1],
    ["echoSpeedpaths", 0, 1, false],
    ["alwaysShowTabs", 0, 1, false],
    ["scriptEngineType", 0, 2 /* Number */, 4 /* Simple */],
    ["initializeScriptEngineOnLoad", 0, 1 /* Boolean */, false],
    ["find.highlight", 0, 1 /* Boolean */, false],
    ["find.location", 0, 4 /* Custom */, [5, 20]],
    ["display.showInvalidMXPTags", 0, 1 /* Boolean */, false],
    ["display.showTimestamp", 0, 2 /* Number */, 0],
    ["display.timestampFormat", 0, 0 /* String */, "[[]MM-DD HH:mm:ss.SSS[]] "],
    ["display.displayControlCodes", 0, 1 /* Boolean */, false],
    ["display.emulateTerminal", 0, 1 /* Boolean */, false],
    ["display.emulateControlCodes", 0, 1 /* Boolean */, true],
    ["display.wordWrap", 0, 1 /* Boolean */, false],
    ["display.tabWidth", 0, 2 /* Number */, 8],
    ["display.wrapAt", 0, 2 /* Number */, 0],
    ["display.indent", 0, 2 /* Number */, 4],
    ["statusWidth", 0, 2 /* Number */, -1],
    ["showEditorInTaskBar", 0, 1 /* Boolean */, true],
    ["trayMenu", 0, 2 /* Number */, 0],
    ["lockLayout", 0, 1 /* Boolean */, false],
    ["loadLayout", 0, 0 /* String */, ""],
    ["useSingleInstance", 0, 1 /* Boolean */, true],
    ["onSecondInstance", 0, 2 /* Number */, 0],
    ["characterManagerDblClick", 0, 2 /* Number */, 0],
    ["enableTabCompletion", 1 /* Boolean */, true],
    ["ignoreCaseTabCompletion", 0, 1 /* Boolean */, false],
    ["tabCompletionBufferLimit", 0, 2 /* Number */, 100],
    ["enableNotifications", 0, 1 /* Boolean */, true],
    ["echo", 0, 2 /* Number */, 0 /* None */],
    ["commandAutoSize", 0, 1 /* Boolean */, false],
    ["commandWordWrap", 0, 1 /* Boolean */, false],
    ["commandScrollbars", 0, 1 /* Boolean */, false],
    ["tabCompletionList", 0, 0 /* String */, ""],
    ["tabCompletionLookupType", 0, 2 /* Number */, 1 /* PrependBuffer */],
    ["tabCompletionReplaceCasing", 0, 2 /* Number */, 0],
    ["characterManagerAddButtonAction", 0, 2 /* Number */, 0],
    ["enableCrashReporting", 0, 1 /* Boolean */, false],
    ["characterManagerPanelWidth", 0, 2 /* Number */, 0],
    ["ignoreInputLeadingWhitespace", 0, 1 /* Boolean */, false],
    ["profiles.find.case", 0, 1, false],
    ["profiles.find.word", 0, 1, false],
    ["profiles.find.reverse", 0, 1, false],
    ["profiles.find.regex", 0, 1, false],
    ["profiles.find.selection", 0, 1, false],
    ["profiles.find.show", 0, 1, false],
    ["profiles.find.value", 0, 1, false],
    ["skipMore", 0, 1, false],
    ["skipMoreDelay", 0, 2 /* Number */, 5e3],
    ["commandMinLines", 0, 2 /* Number */, 1],
    ["backupReplaceCharacters", 0, 1 /* Boolean */, true],
    ["simpleAlarms", 0, 1 /* Boolean */, false],
    ["simpleEditor", 0, 1 /* Boolean */, false],
    ["selectLastCommand", 0, 1 /* Boolean */, true],
    ["statusMode", 0, 2 /* Number */, isMobile() ? 1 : 0],
    ["logger.split", 0, 2 /* Number */, 204],
    ["showChatWindow", 0, 2 /* Number */, 0],
    ["chat.enableColors", 0, 2 /* Number */, true],
    ["chat.enableBackgroundColors", 0, 2 /* Number */, true]
  ];
  var SettingProperties = ["bufferSize", "commandDelay", "commandDelayCount", "commandHistorySize", "fontSize", "cmdfontSize", "commandEcho", "flashing", "autoConnect", "enableAliases", "enableTriggers", "enableMacros", "showScriptErrors", "commandStacking", "commandStackingChar", "htmlLog", "keepLastCommand", "enableMCCP", "enableUTF8", "font", "cmdfont", "mapper.follow", "mapper.enabled", "mapper.split", "mapper.fill", "showMapper", "fullScreen", "enableMXP", "enableMSP", "parseCommands", "lagMeter", "enablePing", "enableEcho", "enableSpeedpaths", "speedpathsChar", "parseSpeedpaths", "profile", "parseSingleQuotes", "parseDoubleQuotes", "logEnabled", "logPrepend", "logOffline", "logUniqueOnConnect", "enableURLDetection", "notifyMSPPlay", "CommandonClick", "allowEval", "allowEscape", "AutoCopySelectedToClipboard", "enableDebug", "editorPersistent", "askonclose", "dev", "chat.captureLines", "chat.captureAllLines", "chat.captureReviews", "chat.captureTells", "chat.captureTalk", "chat.gag", "chat.CaptureOnlyOpen", "checkForUpdates", "autoCreateCharacter", "askonchildren", "mapper.legend", "mapper.room", "mapper.importType", "mapper.vscroll", "mapper.hscroll", "mapper.scale", "mapper.alwaysOnTop", "mapper.alwaysOnTopClient", "mapper.memory", "mapper.memorySavePeriod", "mapper.active.ID", "mapper.active.x", "mapper.active.y", "mapper.active.z", "mapper.active.area", "mapper.active.zone", "mapper.persistent", "profiles.split", "profiles.askoncancel", "profiles.triggersAdvanced", "profiles.aliasesAdvanced", "profiles.buttonsAdvanced", "profiles.macrosAdvanced", "profiles.contextsAdvanced", "profiles.codeEditor", "profiles.watchFiles", "chat.alwaysOnTop", "chat.alwaysOnTopClient", "chat.log", "chat.persistent", "chat.zoom", "chat.font", "chat.fontSize", "title", "logGagged", "logTimeFormat", "autoConnectDelay", "autoLogin", "onDisconnect", "enableKeepAlive", "keepAliveDelay", "newlineShortcut", "logWhat", "logErrors", "showErrorsExtended", "reportCrashes", "enableCommands", "commandChar", "escapeChar", "enableVerbatim", "verbatimChar", "soundPath", "logPath", "theme", "gamepads", "buttons.connect", "buttons.characters", "buttons.preferences", "buttons.log", "buttons.clear", "buttons.lock", "buttons.map", "buttons.user", "buttons.mail", "buttons.compose", "buttons.immortal", "buttons.codeEditor", "find.case", "find.word", "find.reverse", "find.regex", "find.selection", "find.show", "display.split", "display.splitHeight", "display.splitLive", "display.roundedOverlays", "backupLoad", "backupSave", "backupAllProfiles", "backupReplaceCharacters", "scrollLocked", "showStatus", "showCharacterManager", "showChat", "showEditor", "showArmor", "showStatusWeather", "showStatusLimbs", "showStatusHealth", "showStatusExperience", "showStatusPartyHealth", "showStatusCombatHealth", "showButtonBar", "allowNegativeNumberNeeded", "spellchecking", "hideOnMinimize", "showTrayIcon", "statusExperienceNeededProgressbar", "trayClick", "trayDblClick", "pasteSpecialPrefix", "pasteSpecialPostfix", "pasteSpecialReplace", "pasteSpecialPrefixEnabled", "pasteSpecialPostfixEnabled", "pasteSpecialReplaceEnabled", "display.showSplitButton", "chat.split", "chat.splitHeight", "chat.splitLive", "chat.roundedOverlays", "chat.showSplitButton", "chat.bufferSize", "chat.flashing", "display.hideTrailingEmptyLine", "display.enableColors", "display.enableBackgroundColors", "enableSound", "allowHalfOpen", "editorClearOnSend", "editorCloseOnSend", "askOnCloseAll", "askonloadCharacter", "mapper.roomWidth", "mapper.roomGroups", "mapper.showInTaskBar", "profiles.enabled", "profiles.sortOrder", "profiles.sortDirection", "profiles.showInTaskBar", "profiles.profileSelected", "profiles.profileExpandSelected", "chat.lines", "chat.showInTaskBar", "chat.showTimestamp", "chat.timestampFormat", "chat.tabWidth", "chat.displayControlCodes", "chat.emulateTerminal", "chat.emulateControlCodes", "chat.wordWrap", "chat.wrapAt", "chat.indent", "chat.scrollLocked", "chat.find.case", "chat.find.word", "chat.find.reverse", "chat.find.regex", "chat.find.selection", "chat.find.show", "chat.find.highlight", "chat.find.location", "codeEditor.showInTaskBar", "codeEditor.persistent", "codeEditor.alwaysOnTop", "codeEditor.alwaysOnTopClient", "autoTakeoverLogin", "fixHiddenWindows", "maxReconnectDelay", "enableBackgroundThrottling", "enableBackgroundThrottlingClients", "showInTaskBar", "showLagInTitle", "mspMaxRetriesOnError", "logTimestamp", "logTimestampFormat", "disableTriggerOnError", "prependTriggeredLine", "enableParameters", "parametersChar", "enableNParameters", "nParametersChar", "enableParsing", "externalWho", "externalHelp", "watchForProfilesChanges", "onProfileChange", "onProfileDeleted", "enableDoubleParameterEscaping", "ignoreEvalUndefined", "enableInlineComments", "enableBlockComments", "inlineCommentString", "blockCommentString", "allowCommentsFromCommand", "saveTriggerStateChanges", "groupProfileSaves", "groupProfileSaveDelay", "returnNewlineOnEmptyValue", "pathDelay", "pathDelayCount", "echoSpeedpaths", "alwaysShowTabs", "scriptEngineType", "initializeScriptEngineOnLoad", "find.highlight", "find.location", "display.showInvalidMXPTags", "display.showTimestamp", "display.timestampFormat", "display.displayControlCodes", "display.emulateTerminal", "display.emulateControlCodes", "display.wordWrap", "display.tabWidth", "display.wrapAt", "display.indent", "statusWidth", "showEditorInTaskBar", "trayMenu", "lockLayout", "loadLayout", "useSingleInstance", "statusWidth", "characterManagerDblClick", "warnAdvancedSettings", "showAdvancedSettings", "enableTabCompletion", "tabCompletionBufferLimit", "ignoreCaseTabCompletion", "enableNotifications", "commandAutoSize", "commandWordWrap", "commandScrollbars", "tabCompletionList", "tabCompletionLookupType", "tabCompletionReplaceCasing", "characterManagerAddButtonAction", "enableCrashReporting", "characterManagerPanelWidth", "ignoreInputLeadingWhitespace", "profiles.find.case", "profiles.find.word", "profiles.find.reverse", "profiles.find.regex", "profiles.find.selection", "profiles.find.show", "profiles.find.value", "skipMore", "skipMoreDelay", "commandMinLines", "simpleAlarms", "simpleEditor", "selectLastCommand", "statusMode", "logger.split", "showChatWindow", "chat.enableColors", "chat.enableBackgroundColors"];
  var Settings = class _Settings {
    constructor() {
      for (var s = 0, sl = SettingList.length; s < sl; s++) {
        if (SettingList[s][2] === 4 /* Custom */) continue;
        this[SettingList[s][0]] = _Settings.getValue(SettingList[s][0]);
        if (SettingList[s][1] && SettingList[s][1].length)
          this[SettingList[s][1]] = _Settings.getValue(SettingList[s][1]);
      }
      this.colors = _Settings.getValue("colors");
    }
    static {
      this.settingError = false;
    }
    static getValue(setting, defaultValue) {
      var tmp;
      if (_Settings.settingError) {
        if (defaultValue === null || typeof defaultValue == "undefined")
          return _Settings.defaultValue(setting);
        return defaultValue;
      }
      try {
        tmp = $.jStorage.get(setting);
        if (typeof tmp == "undefined" || tmp === null) {
          if (defaultValue === null || typeof defaultValue == "undefined")
            return _Settings.defaultValue(setting);
          return defaultValue;
        }
        switch (setting) {
          case "showChat":
          case "showStatus":
          case "showButtons":
          case "enableCommands":
          case "enableVerbatim":
          case "allowEscape":
          case "autoConnect":
          case "mapFollow":
          case "mapEnabled":
          case "flashing":
          case "commandEcho":
          case "enableAliases":
          case "enableTriggers":
          case "enableButtons":
          case "enableMacros":
          case "commandStacking":
          case "htmlLog":
          case "keepLastCommand":
          case "fullScreen":
          case "enableMXP":
          case "enableURLDetection":
          case "enableMCCP":
          case "enableUTF8":
          case "parseCommands":
          case "lagMeter":
          case "showScriptErrors":
          case "enablePing":
          case "enableEcho":
          case "enableSpeedpaths":
          case "parseSpeedpaths":
          case "mapper.enabled":
          case "MapperSplitArea":
          case "mapper.split":
          case "MapperFillWalls":
          case "mapper.fill":
          case "mapper.follow":
          case "MapperOpen":
          case "showMapper":
          case "parseSingleQuotes":
          case "parseDoubleQuotes":
          case "logEnabled":
          case "logOffline":
          case "logPrepend":
          case "logUniqueOnConnect":
          case "toolsPinned":
          case "notifyMSPPlay":
          case "CommandonClick":
          case "allowEval":
          case "disableTriggerOnError":
          case "prependTriggeredLine":
          case "chat.captureLines":
          case "chat.captureAllLines":
          case "chat.captureReviews":
          case "chat.captureTells":
          case "chat.captureTalk":
          case "chat.gag":
          case "chat.CaptureOnlyOpen":
          case "simpleAlarms":
          case "simpleEditor":
          case "selectLastCommand":
          case "showLagInTitle":
            if (tmp == 1)
              return true;
            return false;
          case "colors":
          case "chat.lines":
            if (tmp === null || typeof tmp == "undefined" || tmp.length === 0)
              return [];
            return JSON.parse(tmp);
        }
        return tmp;
      } catch (err) {
        if (!_Settings.settingError) {
          alert("Unable to save to localStorage so reverting to default,\n\nError description: " + err.message);
          _Settings.settingError = true;
        }
        if (defaultValue === null || typeof defaultValue == "undefined")
          return _Settings.defaultValue(defaultValue);
        return defaultValue;
      }
    }
    static setValue(setting, value) {
      switch (setting) {
        case "colors":
        case "chat.lines":
          if (value === null || typeof value == "undefined" || value.length === 0)
            $.jStorage.deleteKey(setting);
          else
            $.jStorage.set(setting, JSON.stringify(value));
          break;
        default:
          if (typeof value == "boolean") {
            if (value)
              $.jStorage.set(setting, 1);
            else
              $.jStorage.set(setting, 0);
          } else
            $.jStorage.set(setting, value);
          break;
      }
    }
    static clearValue(setting) {
      $.jStorage.deleteKey(setting);
    }
    static defaultValue(setting) {
      switch (setting) {
        case "bufferSize":
          return 500;
        case "commandDelay":
          return 500;
        case "commandDelayCount":
          return 5;
        case "commandHistorySize":
          return 20;
        case "fontSize":
          return "1em";
        case "cmdfontSize":
          return "1em";
        case "commandEcho":
          return true;
        case "flashing":
          return false;
        case "autoConnect":
          return true;
        case "enableAliases":
          return true;
        case "enableTriggers":
          return true;
        case "enableMacros":
          return true;
        case "showScriptErrors":
          return false;
        case "commandStacking":
          return true;
        case "commandStackingChar":
          return ";";
        case "htmlLog":
          return true;
        case "keepLastCommand":
          return true;
        case "enableMCCP":
          return true;
        case "enableUTF8":
          return true;
        case "font":
          return "'Courier New', Courier, monospace";
        case "cmdfont":
          return "'Courier New', Courier, monospace";
        case "mapFollow":
        case "mapper.follow":
          return true;
        case "mapEnabled":
        case "mapper.enabled":
          return true;
        case "MapperSplitArea":
        case "mapper.split":
          return false;
        case "MapperFillWalls":
        case "mapper.fill":
          return false;
        case "MapperOpen":
        case "showMapper":
          return false;
        case "fullScreen":
          return false;
        case "enableMXP":
          return true;
        case "enableMSP":
          return true;
        case "parseCommands":
          return true;
        case "lagMeter":
          return true;
        case "enablePing":
          return false;
        case "enableEcho":
          return true;
        case "enableSpeedpaths":
          return true;
        case "speedpathsChar":
          return "!";
        case "parseSpeedpaths":
          return true;
        case "profile":
          return "Default";
        case "parseSingleQuotes":
          return false;
        case "parseDoubleQuotes":
          return true;
        case "logEnabled":
          return false;
        case "logPrepend":
          return false;
        case "logOffline":
          return false;
        case "logUniqueOnConnect":
          return true;
        case "enableURLDetection":
          return true;
        case "notifyMSPPlay":
          return false;
        case "CommandonClick":
          return true;
        case "allowEval":
          return true;
        case "allowEscape":
          return true;
        case "AutoCopySelectedToClipboard":
          return false;
        case "enableDebug":
          return false;
        case "editorPersistent":
          return false;
        case "askonclose":
          return true;
        case "dev":
          return false;
        //New settings
        case "chat.captureLines":
          return false;
        case "chat.captureAllLines":
          return false;
        case "chat.captureReviews":
          return false;
        case "chat.captureTells":
          return false;
        case "chat.captureTalk":
          return false;
        case "chat.gag":
          return false;
        case "chat.CaptureOnlyOpen":
          return false;
        case "checkForUpdates":
          return false;
        case "autoCreateCharacter":
          return false;
        case "askonchildren":
          return true;
        case "mapper.legend":
          return false;
        case "mapper.room":
          return false;
        case "mapper.importType":
          return 1;
        case "mapper.vscroll":
          return 0;
        case "mapper.hscroll":
          return 0;
        case "mapper.scale":
          return 100;
        case "mapper.active":
          return {
            ID: null,
            x: 0,
            y: 0,
            z: 0,
            area: null,
            zone: 0
          };
        case "mapper.active.ID":
          return null;
        case "mapper.active.x":
          return 0;
        case "mapper.active.y":
          return 0;
        case "mapper.active.z":
          return 0;
        case "mapper.active.area":
          return null;
        case "mapper.active.zone":
          return 0;
        case "profiles.split":
          return 204;
        case "logger.split":
          return 204;
        case "profiles.askoncancel":
          return true;
        case "profiles.triggersAdvanced":
          return false;
        case "profiles.aliasesAdvanced":
          return false;
        case "profiles.buttonsAdvanced":
          return false;
        case "profiles.macrosAdvanced":
          return false;
        case "profiles.contextsAdvanced":
          return false;
        case "profiles.codeEditor":
          return true;
        case "chat.log":
          return false;
        case "chat.zoom":
          return 1;
        case "chat.font":
          return "'Courier New', Courier, monospace";
        case "chat.fontSize":
          return "1em";
        case "title":
          return "$t";
        case "logGagged":
          return false;
        case "logTimeFormat":
          return "YYYYMMDD-HHmmss";
        case "autoConnectDelay":
          return 600;
        case "autoLogin":
          return true;
        case "onDisconnect":
          return 2 /* ReconnectDialog */;
        case "enableKeepAlive":
          return false;
        case "keepAliveDelay":
          return 0;
        case "newlineShortcut":
          return 1 /* Ctrl */;
        case "logWhat":
          return 1;
        case "logErrors":
          return true;
        case "showErrorsExtended":
          return false;
        case "reportCrashes":
          return false;
        case "enableCommands":
          return true;
        case "commandChar":
          return "#";
        case "escapeChar":
          return "\\";
        case "enableVerbatim":
          return true;
        case "verbatimChar":
          return "`";
        case "soundPath":
          return "";
        case "logPath":
          return "";
        case "theme":
          return "";
        case "gamepads":
          return false;
        case "backupLoad":
          return 30;
        case "backupSave":
          return 30;
        case "backupAllProfiles":
          return true;
        case "backupReplaceCharacters":
          return true;
        case "scrollLocked":
          return false;
        case "showStatus":
          return !isMobile();
        case "showChat":
          return false;
        case "showEditor":
          return false;
        case "showArmor":
          return false;
        case "showStatusWeather":
          return true;
        case "showStatusLimbs":
          return true;
        case "showStatusHealth":
          return true;
        case "showStatusExperience":
          return true;
        case "showStatusPartyHealth":
          return true;
        case "showStatusCombatHealth":
          return true;
        case "allowNegativeNumberNeeded":
          return false;
        case "spellchecking":
          return true;
        case "statusExperienceNeededProgressbar":
          return false;
        case "pasteSpecialPrefix":
          return "";
        case "pasteSpecialPostfix":
          return "";
        case "pasteSpecialReplace":
          return "";
        case "pasteSpecialPrefixEnabled":
          return true;
        case "pasteSpecialPostfixEnabled":
          return true;
        case "pasteSpecialReplaceEnabled":
          return true;
        case "display.showSplitButton":
          return true;
        case "chat.bufferSize":
          return 500;
        case "chat.flashing":
          return false;
        case "display.hideTrailingEmptyLine":
          return true;
        case "display.enableColors":
          return true;
        case "display.enableBackgroundColors":
          return true;
        case "enableSound":
          return true;
        case "editorClearOnSend":
          return true;
        case "editorCloseOnSend":
          return true;
        case "askOnCloseAll":
          return true;
        case "askonloadCharacter":
          return true;
        case "mapper.roomWidth":
          return 200;
        case "mapper.roomGroups":
          return 1 | 2 | 4;
        case "mapper.showInTaskBar":
          return false;
        case "profiles.enabled":
          return [];
        case "profiles.sortOrder":
          return 4 /* Priority */ | 8 /* Index */;
        case "profiles.sortDirection":
          return 1;
        case "profiles.profileSelected":
          return "default";
        case "profiles.profileExpandSelected":
          return true;
        case "chat.lines":
          return [];
        case "chat.showTimestamp":
          return 0;
        case "chat.timestampFormat":
          return "[[]MM-DD HH:mm:ss.SSS[]] ";
        case "chat.tabWidth":
          return 8;
        case "chat.displayControlCodes":
          return false;
        case "chat.emulateTerminal":
          return false;
        case "chat.emulateControlCodes":
          return true;
        case "chat.wordWrap":
          return false;
        case "chat.wrapAt":
          return 0;
        case "chat.indent":
          return 4;
        case "chat.enableColors":
          return true;
        case "chat.enableBackgroundColors":
          return true;
        case "autoTakeoverLogin":
          return false;
        case "maxReconnectDelay":
          return 3600;
        case "showLagInTitle":
          return false;
        case "mspMaxRetriesOnError":
          return 0;
        case "logTimestamp":
          return 0;
        case "logTimestampFormat":
          return "[[]MM-DD HH:mm:ss.SSS[]] ";
        case "disableTriggerOnError":
          return true;
        case "prependTriggeredLine":
          return true;
        case "enableParameters":
          return true;
        case "parametersChar":
          return "%";
        case "enableNParameters":
          return true;
        case "nParametersChar":
          return "$";
        case "enableParsing":
          return true;
        case "onProfileChange":
          return 0 /* Nothing */;
        case "onProfileDeleted":
          return 0 /* Nothing */;
        case "enableDoubleParameterEscaping":
          return false;
        case "ignoreEvalUndefined":
          return true;
        case "enableInlineComments":
          return true;
        case "enableBlockComments":
          return true;
        case "inlineCommentString":
          return "//";
        case "blockCommentString":
          return "/*";
        case "allowCommentsFromCommand":
          return false;
        case "saveTriggerStateChanges":
          return true;
        case "groupProfileSaves":
          return false;
        case "groupProfileSaveDelay":
          return 2e4;
        case "returnNewlineOnEmptyValue":
          return false;
        case "pathDelay":
          return 0;
        case "pathDelayCount":
          return 1;
        case "echoSpeedpaths":
          return false;
        case "scriptEngineType":
          return 4 /* Simple */;
        case "initializeScriptEngineOnLoad":
          return false;
        case "display.showInvalidMXPTags":
          return false;
        case "display.showTimestamp":
          return 0;
        case "display.timestampFormat":
          return "[[]MM-DD HH:mm:ss.SSS[]] ";
        case "display.displayControlCodes":
          return false;
        case "display.emulateTerminal":
          return false;
        case "display.emulateControlCodes":
          return true;
        case "display.wordWrap":
          return false;
        case "display.tabWidth":
          return 8;
        case "display.wrapAt":
          return 0;
        case "display.indent":
          return 4;
        case "statusWidth":
          return -1;
        case "extensions":
          return {};
        case "warnAdvancedSettings":
          return true;
        case "showAdvancedSettings":
          return false;
        case "enableTabCompletion":
          return true;
        case "ignoreCaseTabCompletion":
          return false;
        case "tabCompletionBufferLimit":
          return 100;
        case "enableNotifications":
          return true;
        case "echo":
          return 0 /* None */;
        case "commandAutoSize":
          return false;
        case "commandWordWrap":
          return false;
        case "commandMinLines":
          return 1;
        case "tabCompletionLookupType":
          return 1 /* PrependBuffer */;
        case "tabCompletionList":
          return "";
        case "tabCompletionReplaceCasing":
          return 0;
        case "ignoreInputLeadingWhitespace":
          return false;
        case "skipMore":
          return false;
        case "skipMoreDelay":
          return 5e3;
        case "simpleAlarms":
          return false;
        case "simpleEditor":
          return false;
        case "selectLastCommand":
          return true;
        case "statusMode":
          isMobile() ? 1 : 0;
        case "showChatWindow":
          return 0;
      }
      return null;
    }
    save() {
      for (var prop in this) {
        if (!this.hasOwnProperty(prop)) continue;
        _Settings.setValue(prop, this[prop]);
      }
    }
    reset() {
      for (var s = 0, sl = SettingList.length; s < sl; s++) {
        if (SettingList[s][2] === 4 /* Custom */) continue;
        this[SettingList[s][0]] = _Settings.defaultValue(SettingList[s][0]);
      }
      this.colors = [];
    }
  };

  // src/profile.ts
  var TriggerType = /* @__PURE__ */ ((TriggerType2) => {
    TriggerType2[TriggerType2["Regular"] = 0] = "Regular";
    TriggerType2[TriggerType2["CommandInputRegular"] = 1] = "CommandInputRegular";
    TriggerType2[TriggerType2["Event"] = 2] = "Event";
    TriggerType2[TriggerType2["Alarm"] = 3] = "Alarm";
    TriggerType2[TriggerType2["Pattern"] = 8] = "Pattern";
    TriggerType2[TriggerType2["CommandInputPattern"] = 16] = "CommandInputPattern";
    TriggerType2[TriggerType2["Expression"] = 64] = "Expression";
    TriggerType2[TriggerType2["LoopExpression"] = 128] = "LoopExpression";
    return TriggerType2;
  })(TriggerType || {});
  var SubTriggerTypes = /* @__PURE__ */ ((SubTriggerTypes2) => {
    SubTriggerTypes2[SubTriggerTypes2["Skip"] = 512] = "Skip";
    SubTriggerTypes2[SubTriggerTypes2["Wait"] = 1024] = "Wait";
    SubTriggerTypes2[SubTriggerTypes2["LoopPattern"] = 4096] = "LoopPattern";
    SubTriggerTypes2[SubTriggerTypes2["LoopLines"] = 8192] = "LoopLines";
    SubTriggerTypes2[SubTriggerTypes2["Duration"] = 16384] = "Duration";
    SubTriggerTypes2[SubTriggerTypes2["WithinLines"] = 32768] = "WithinLines";
    SubTriggerTypes2[SubTriggerTypes2["Manual"] = 65536] = "Manual";
    SubTriggerTypes2[SubTriggerTypes2["ReParse"] = 131072] = "ReParse";
    SubTriggerTypes2[SubTriggerTypes2["ReParsePattern"] = 262144] = "ReParsePattern";
    return SubTriggerTypes2;
  })(SubTriggerTypes || {});
  function MacroDisplay(item) {
    const d2 = [];
    if (item.gamepad > 0) {
      d2.push("Gamepad " + item.gamepad);
      if (item.key > 0)
        d2.push("Button " + item.key);
      else if (item.gamepadAxes < 0)
        d2.push("Axis " + -item.gamepadAxes);
      else if (item.gamepadAxes > 0)
        d2.push("Axis " + item.gamepadAxes);
      if (d2.length === 1)
        return "None";
      return d2.join("+");
    }
    if (item.key === 0) {
      if (item.name && item.name.length > 0)
        return "None - " + item.name;
      return "None";
    }
    if ((item.modifiers & 4 /* Ctrl */) === 4 /* Ctrl */)
      d2.push("Ctrl");
    if ((item.modifiers & 2 /* Alt */) === 2 /* Alt */)
      d2.push("Alt");
    if ((item.modifiers & 8 /* Shift */) === 8 /* Shift */)
      d2.push("Shift");
    if ((item.modifiers & 16 /* Meta */) === 16 /* Meta */)
      d2.push("Meta");
    if (keyCodeToChar[item.key])
      d2.push(keyCodeToChar[item.key]);
    else if (item.name && item.name.length > 0)
      return "None - " + item.name;
    else
      return "None";
    if (item.name && item.name.length > 0)
      return d2.join("+") + " - " + item.name;
    return d2.join("+");
  }
  var Alarm = class _Alarm {
    constructor(data, pattern) {
      this.temp = false;
      this.start = false;
      this.seconds = -1;
      this.secondsWildcard = true;
      this.hours = -1;
      this.hoursWildcard = true;
      this.minutes = -1;
      this.minutesWildcard = true;
      this.suspended = 0;
      this.restart = 0;
      if (typeof data === "string") {
        pattern = data;
        data = 0;
      }
      this.parent = data;
      this.pattern = pattern;
      this.startTime = Date.now();
      this.prevTime = this.startTime;
    }
    static parse(parent, pattern, readOnly) {
      if (typeof parent === "string") {
        pattern = parent;
        parent = 0;
      }
      if (!pattern || pattern.length === 0) {
        if (typeof parent === "object")
          pattern = parent.pattern;
        else
          throw new Error("Blank pattern");
      }
      const t = new _Alarm(parent, pattern);
      while (pattern[0] === "-" || pattern[0] === "+") {
        if (pattern[0] === "-")
          t.start = true;
        else if (pattern[0] === "+")
          t.temp = true;
        pattern = pattern.substr(1);
      }
      if (pattern !== "*") {
        const parts = pattern.split(":");
        let tmp;
        if (parts.length === 0)
          throw new Error("Invalid format: " + pattern);
        if (parts.length === 1) {
          if (parts[0] === "*") {
            t.secondsWildcard = true;
            t.seconds = -1;
          } else {
            if (parts[0][0] === "*") {
              t.secondsWildcard = true;
              parts[0] = parts[0].substr(1);
            } else
              t.secondsWildcard = false;
            tmp = parseInt(parts[0], 10);
            if (isNaN(tmp))
              throw new Error("Invalid Format: " + parts[0]);
            if (tmp < 0)
              throw new Error("Seconds must be greater than or equal to 0.");
            else if (tmp > 59)
              t.secondsWildcard = true;
            t.seconds = tmp;
          }
        } else if (parts.length === 2) {
          if (parts[0] === "*") {
            t.minutesWildcard = true;
            t.minutes = -1;
          } else {
            if (parts[0][0] === "*") {
              t.minutesWildcard = true;
              parts[0] = parts[0].substr(1);
            } else
              t.minutesWildcard = false;
            tmp = parseInt(parts[0], 10);
            if (isNaN(tmp))
              throw new Error("Invalid Format: " + parts[0]);
            if (tmp < 0 || tmp > 59)
              throw new Error("Minutes can only be 0 to 59");
            t.minutes = tmp;
          }
          if (parts[1] === "*") {
            t.secondsWildcard = true;
            t.seconds = -1;
          } else {
            if (parts[1][0] === "*") {
              t.secondsWildcard = true;
              parts[1] = parts[1].substr(1);
            } else
              t.secondsWildcard = false;
            tmp = parseInt(parts[1], 10);
            if (isNaN(tmp))
              throw new Error("Invalid Format: " + parts[1]);
            if (tmp < 0 || tmp > 59)
              throw new Error("Seconds can only be 0 to 59");
            t.seconds = tmp;
          }
        } else {
          if (parts[0] === "*") {
            t.hoursWildcard = true;
            t.hours = -1;
          } else {
            if (parts[0][0] === "*") {
              t.hoursWildcard = true;
              parts[0] = parts[0].substr(1);
            } else
              t.hoursWildcard = false;
            tmp = parseInt(parts[0], 10);
            if (isNaN(tmp))
              throw new Error("Invalid Format: " + parts[0]);
            if (tmp < 0 || tmp > 23)
              throw new Error("Hours can only be 0 to 23");
            t.hours = tmp;
          }
          if (parts[1] === "*") {
            t.minutesWildcard = true;
            t.seconds = -1;
          } else {
            if (parts[1][0] === "*") {
              t.minutesWildcard = true;
              parts[1] = parts[1].substr(1);
            } else
              t.minutesWildcard = false;
            tmp = parseInt(parts[1], 10);
            if (isNaN(tmp))
              throw new Error("Invalid Format: " + parts[1]);
            if (tmp < 0 || tmp > 59)
              throw new Error("Minutes can only be 0 to 59");
            t.minutes = tmp;
          }
          if (parts[2] === "*") {
            t.secondsWildcard = true;
            t.seconds = -1;
          } else {
            if (parts[2][0] === "*") {
              t.secondsWildcard = true;
              parts[2] = parts[2].substr(2);
            } else
              t.secondsWildcard = false;
            tmp = parseInt(parts[2], 10);
            if (isNaN(tmp))
              throw new Error("Invalid Format: " + parts[2]);
            if (tmp < 0 || tmp > 59)
              throw new Error("Seconds can only be 0 to 59");
            t.seconds = tmp;
          }
        }
      }
      if (readOnly)
        t.temp = false;
      return t;
    }
    setTempTime(value) {
      if (!value)
        this.tempTime = 0;
      else
        this.tempTime = Date.now() + value;
    }
  };
  var Item = class _Item {
    constructor(data, profile) {
      this.name = "";
      this.priority = 0;
      this.display = "name";
      this.displaytype = 0 /* Text */;
      this.value = "";
      this.style = 1 /* Parse */;
      this.group = "";
      this.enabled = true;
      this.notes = "";
      if (typeof data === "object") {
        let prop;
        for (prop in data) {
          if (!data.hasOwnProperty(prop)) {
            continue;
          }
          this[prop] = data[prop];
        }
      }
      this.profile = profile;
    }
    clone() {
      return new _Item(this);
    }
  };
  var Button = class _Button extends Item {
    constructor(data, profile) {
      super(data);
      this.caption = "";
      this.icon = "";
      this.append = false;
      this.send = true;
      this.chain = false;
      this.stretch = false;
      this.parse = false;
      this.top = -1;
      this.left = -1;
      this.right = -1;
      this.bottom = -1;
      this.width = 64;
      this.height = 64;
      this.iconOnly = false;
      this.caption = "NewButton";
      this.display = "caption";
      if (typeof data === "object") {
        let prop;
        for (prop in data) {
          if (!data.hasOwnProperty(prop)) {
            continue;
          }
          this[prop] = data[prop];
        }
      }
      this.profile = profile;
    }
    clone() {
      return new _Button(this);
    }
  };
  var Macro = class _Macro extends Item {
    constructor(data, profile) {
      super();
      this.key = 0;
      this.append = false;
      this.send = true;
      this.modifiers = 0 /* None */;
      this.chain = false;
      this.gamepad = 0;
      this.gamepadAxes = 0;
      this.display = "return MacroDisplay(item)";
      this.displaytype = 1 /* Function */;
      if (typeof data === "object") {
        let prop;
        for (prop in data) {
          if (!data.hasOwnProperty(prop)) {
            continue;
          }
          this[prop] = data[prop];
        }
      }
      this.profile = profile;
    }
    clone() {
      return new _Macro(this);
    }
  };
  var Alias = class _Alias extends Item {
    constructor(pattern, value, profile) {
      super();
      this.pattern = "NewAlias";
      this.regexp = false;
      this.multi = false;
      this.append = true;
      this.params = "";
      if (typeof pattern === "string")
        this.pattern = pattern;
      if (value != null)
        this.value = value;
      this.display = "pattern";
      if (typeof pattern === "object") {
        let prop;
        for (prop in pattern) {
          if (!pattern.hasOwnProperty(prop)) {
            continue;
          }
          this[prop] = pattern[prop];
        }
      }
      this.profile = profile;
    }
    clone() {
      return new _Alias(this);
    }
  };
  var Trigger = class _Trigger extends Item {
    constructor(data, profile) {
      super(data);
      this.pattern = "NewTrigger";
      this.verbatim = false;
      this.triggerNewline = true;
      this.triggerPrompt = false;
      this.type = 0 /* Regular */;
      this.temp = false;
      this.caseSensitive = false;
      this.raw = false;
      this.state = 0;
      this.params = "";
      this.triggers = [];
      this.fired = false;
      this.display = "pattern";
      if (typeof data === "object") {
        let prop;
        for (prop in data) {
          if (!data.hasOwnProperty(prop)) {
            continue;
          }
          if (prop === "triggers") {
            this.triggers = [];
            const il = data.triggers.length;
            for (let i2 = 0; i2 < il; i2++) {
              this.triggers.push(new _Trigger(data.triggers[i2]));
            }
          } else
            this[prop] = data[prop];
        }
      }
      this.profile = profile;
    }
    clone() {
      return new _Trigger(this);
    }
    getState(state) {
      if (state === 0)
        return this;
      state--;
      if (state >= this.triggers.length || state < 0) return null;
      return this.triggers[state];
    }
  };
  var Context = class _Context extends Item {
    constructor(data, profile) {
      super(data);
      this.caption = "";
      this.icon = "";
      this.append = false;
      this.send = true;
      this.chain = false;
      this.parent = "";
      this.items = [];
      this.parse = false;
      this.caption = "NewContext";
      this.display = "caption";
      if (typeof data === "object") {
        let prop;
        for (prop in data) {
          if (!data.hasOwnProperty(prop)) {
            continue;
          }
          if (prop === "items") {
            let i2 = 0;
            const il = data[prop].length;
            for (; i2 < il; i2++)
              this.items.push(new _Context(data[prop][i2]));
          } else
            this[prop] = data[prop];
        }
      }
      this.profile = profile;
    }
    clone() {
      return new _Context(this);
    }
  };
  var Variable = class _Variable extends Item {
    constructor(data, profile) {
      super(data);
      this._type = "string";
      this.type = 1 /* Auto */;
      this.defaultValue = "";
      this.useDefault = false;
      this.params = "";
      this.profile = profile;
      if (this.useDefault)
        this.setValue(this.defaultValue);
    }
    set setValue(value) {
      switch (this.type) {
        case 2 /* Integer */:
          if (typeof value === "string") {
            value = parseInt(value, 10);
            if (isNaN(value))
              value = 0;
          } else if (typeof value === "boolean")
            value = value ? 1 : 0;
          break;
        case 7 /* Float */:
          if (typeof value === "string") {
            value = parseFloat(value);
            if (isNaN(value))
              value = 0;
          } else if (typeof value === "boolean")
            value = value ? 1 : 0;
          break;
      }
      this.value = value;
      this._type = typeof value;
    }
    get getValue() {
      switch (this.type) {
        case 1 /* Auto */:
          if (typeof this.value !== this._type) {
            switch (this._type) {
              case "number":
                return Number(this.value);
              case "string":
                return this.value.toString();
              case "boolean":
                return Boolean(this.value);
            }
          }
          return this.value;
        case 7 /* Float */:
          return parseFloat(this.value);
        case 2 /* Integer */:
          return parseInt(this.value, 10);
        case 6 /* Record */:
          if (typeof this.value === "string")
            try {
              return JSON.parse(this.value);
            } catch {
              return this.value;
            }
          return this.value;
        case 5 /* StringList */:
          if (typeof this.value === "string")
            return splitQuoted(this.value, "|");
          return this.value;
      }
      return this.value;
    }
    clone() {
      return new _Variable(this);
    }
    toString() {
      switch (this.type) {
        case 6 /* Record */:
          if (typeof this.value === "string")
            return this.value;
          return JSON.stringify(this.value);
        case 5 /* StringList */:
          if (typeof this.value === "string")
            return this.value;
          return '"' + this.value.join('"|"') + '"';
      }
      return this.value?.toString();
    }
  };
  var Profile = class _Profile {
    constructor(name2, defaults) {
      this.name = "";
      this.file = "";
      this.priority = 0;
      this.enabled = true;
      this.aliases = [];
      this.triggers = [];
      this.macros = [];
      this.buttons = [];
      this.contexts = [];
      this.enableMacros = true;
      this.enableTriggers = true;
      this.enableAliases = true;
      this.enableButtons = true;
      this.enableContexts = true;
      this.enableDefaultContext = true;
      if (typeof name2 === "string") {
        this.name = name2;
        this.file = name2.toLowerCase();
        if (defaults == null || defaults)
          this.macros = _Profile.DefaultMacros;
      } else if (typeof name2 === "boolean") {
        if (name2)
          this.macros = _Profile.DefaultMacros;
      } else if (defaults == null || defaults)
        this.macros = _Profile.DefaultMacros;
    }
    static get Default() {
      return new _Profile("Default");
    }
    static get DefaultMacros() {
      const data = [
        {
          key: 97,
          display: "return MacroDisplay(item)",
          displaytype: 1 /* Function */,
          value: "sw",
          style: 1 /* Parse */,
          append: false,
          send: true,
          name: "SouthWest",
          group: "",
          enabled: true,
          modifiers: 0 /* None */,
          chain: true,
          priority: 0,
          notes: ""
        },
        {
          key: 98,
          display: "return MacroDisplay(item)",
          displaytype: 1 /* Function */,
          value: "s",
          style: 1 /* Parse */,
          append: false,
          send: true,
          name: "South",
          group: "",
          enabled: true,
          modifiers: 0 /* None */,
          chain: true,
          priority: 0,
          notes: ""
        },
        {
          key: 99,
          display: "return MacroDisplay(item)",
          displaytype: 1 /* Function */,
          value: "se",
          style: 1 /* Parse */,
          append: false,
          send: true,
          name: "SouthEast",
          group: "",
          enabled: true,
          modifiers: 0 /* None */,
          chain: true,
          priority: 0,
          notes: ""
        },
        {
          key: 100,
          display: "return MacroDisplay(item)",
          displaytype: 1 /* Function */,
          value: "w",
          style: 1 /* Parse */,
          append: false,
          send: true,
          name: "West",
          group: "",
          enabled: true,
          modifiers: 0 /* None */,
          chain: true,
          priority: 0,
          notes: ""
        },
        {
          key: 101,
          display: "return MacroDisplay(item)",
          displaytype: 1 /* Function */,
          value: "l",
          style: 1 /* Parse */,
          append: false,
          send: true,
          name: "Look",
          group: "",
          enabled: true,
          modifiers: 0 /* None */,
          chain: true,
          priority: 0,
          notes: ""
        },
        {
          key: 102,
          display: "return MacroDisplay(item)",
          displaytype: 1 /* Function */,
          value: "e",
          style: 1 /* Parse */,
          append: false,
          send: true,
          name: "East",
          group: "",
          enabled: true,
          modifiers: 0 /* None */,
          chain: true,
          priority: 0,
          notes: ""
        },
        {
          key: 103,
          display: "return MacroDisplay(item)",
          displaytype: 1 /* Function */,
          value: "nw",
          style: 1 /* Parse */,
          append: false,
          send: true,
          name: "NorthWest",
          group: "",
          enabled: true,
          modifiers: 0 /* None */,
          chain: true,
          priority: 0,
          notes: ""
        },
        {
          key: 104,
          display: "return MacroDisplay(item)",
          displaytype: 1 /* Function */,
          value: "n",
          style: 1 /* Parse */,
          append: false,
          send: true,
          name: "North",
          group: "",
          enabled: true,
          modifiers: 0 /* None */,
          chain: true,
          priority: 0,
          notes: ""
        },
        {
          key: 105,
          display: "return MacroDisplay(item)",
          displaytype: 1 /* Function */,
          value: "ne",
          style: 1 /* Parse */,
          append: false,
          send: true,
          name: "NorthEast",
          group: "",
          enabled: true,
          modifiers: 0 /* None */,
          chain: true,
          priority: 0,
          notes: ""
        }
      ];
      const m = [];
      const dl = data.length;
      for (let d2 = 0; d2 < dl; d2++)
        m.push(new Macro(data[d2]));
      return m;
    }
    static get DefaultButtons() {
      const buttons = [];
      let b;
      b = new Button();
      b.right = 176;
      b.top = 14;
      b.caption = "fa-solid fa-angle-double-up";
      b.value = "up";
      b.width = 48;
      b.height = 48;
      buttons.push(b);
      b = new Button();
      b.right = 124;
      b.top = 14;
      b.caption = "fa-solid fa-caret-up,rotate--45";
      b.value = "northwest";
      b.width = 48;
      b.height = 48;
      buttons.push(b);
      b = new Button();
      b.right = 72;
      b.top = 14;
      b.caption = "fa-solid fa-caret-up";
      b.value = "north";
      b.width = 48;
      b.height = 48;
      buttons.push(b);
      b = new Button();
      b.right = 20;
      b.top = 14;
      b.caption = "fa-solid fa-caret-up,rotate-45";
      b.value = "northeast";
      b.width = 48;
      b.height = 48;
      buttons.push(b);
      b = new Button();
      b.right = 176;
      b.top = 66;
      b.caption = "fa-solid fa-crosshairs";
      b.value = "kill ${selected}";
      b.width = 48;
      b.height = 48;
      buttons.push(b);
      b = new Button();
      b.right = 124;
      b.top = 66;
      b.caption = "fa-solid fa-caret-left";
      b.value = "west";
      b.width = 48;
      b.height = 48;
      buttons.push(b);
      b = new Button();
      b.right = 72;
      b.top = 66;
      b.caption = "fa-solid fa-magnifying-glass";
      b.value = "look ${selected}";
      b.width = 48;
      b.height = 48;
      buttons.push(b);
      b = new Button();
      b.right = 20;
      b.top = 66;
      b.caption = "fa-solid fa-caret-right";
      b.value = "east";
      b.width = 48;
      b.height = 48;
      buttons.push(b);
      b = new Button();
      b.right = 176;
      b.top = 118;
      b.caption = "fa-solid fa-angle-double-down";
      b.value = "down";
      b.width = 48;
      b.height = 48;
      buttons.push(b);
      b = new Button();
      b.right = 124;
      b.top = 118;
      b.caption = "fa-solid fa-caret-down,rotate-45";
      b.value = "southwest";
      b.width = 48;
      b.height = 48;
      buttons.push(b);
      b = new Button();
      b.right = 72;
      b.top = 118;
      b.caption = "fa-solid fa-caret-down";
      b.value = "south";
      b.width = 48;
      b.height = 48;
      buttons.push(b);
      b = new Button();
      b.right = 20;
      b.top = 118;
      b.caption = "fa-solid fa-caret-down,rotate--45";
      b.value = "southeast";
      b.width = 48;
      b.height = 48;
      buttons.push(b);
      return buttons;
    }
    static load(file) {
      let profile;
      let data;
      if (typeof file === "object")
        data = file;
      else
        return new _Profile();
      profile = new _Profile(false);
      let prop;
      for (prop in data) {
        if (!data.hasOwnProperty(prop)) {
          continue;
        }
        if (prop === "aliases" || prop === "triggers" || prop === "macros" || prop === "buttons" || prop === "contexts" || prop === "variables")
          continue;
        profile[prop] = data[prop];
      }
      let i2;
      let il;
      if (data.aliases && data.aliases.length > 0) {
        il = data.aliases.length;
        for (i2 = 0; i2 < il; i2++) {
          profile.aliases.push(new Alias(data.aliases[i2], null, profile));
        }
      }
      if (data.triggers && data.triggers.length > 0) {
        il = data.triggers.length;
        for (i2 = 0; i2 < il; i2++) {
          profile.triggers.push(new Trigger(data.triggers[i2], profile));
        }
      }
      if (data.macros && data.macros.length > 0) {
        il = data.macros.length;
        profile.macros = [];
        for (i2 = 0; i2 < il; i2++) {
          profile.macros.push(new Macro(data.macros[i2], profile));
        }
      }
      if (data.buttons && data.buttons.length > 0) {
        il = data.buttons.length;
        for (i2 = 0; i2 < il; i2++) {
          profile.buttons.push(new Button(data.buttons[i2], profile));
        }
      }
      if (data.contexts && data.contexts.length > 0) {
        il = data.contexts.length;
        for (i2 = 0; i2 < il; i2++) {
          profile.contexts.push(new Context(data.contexts[i2], profile));
        }
      }
      profile.file = profile.name;
      return profile;
    }
    clone(version2) {
      let data;
      let i2;
      let il;
      if (version2 === 2) {
        data = {
          name: this.name,
          priority: this.priority,
          enabled: this.enabled,
          aliases: [],
          triggers: [],
          macros: [],
          buttons: [],
          contexts: [],
          enableMacros: this.enableMacros,
          enableTriggers: this.enableTriggers,
          enableAliases: this.enableAliases,
          enableButtons: this.enableButtons,
          enableContexts: this.enableContexts,
          enableDefaultContext: this.enableDefaultContext
        };
        if (this.aliases.length > 0) {
          il = this.aliases.length;
          for (i2 = 0; i2 < il; i2++) {
            data.aliases.push({
              pattern: this.aliases[i2].pattern,
              value: this.aliases[i2].value,
              priority: this.aliases[i2].priority,
              regexp: this.aliases[i2].regexp,
              style: this.aliases[i2].style,
              multi: this.aliases[i2].multi,
              append: this.aliases[i2].append,
              name: this.aliases[i2].name,
              group: this.aliases[i2].group,
              enabled: this.aliases[i2].enabled,
              params: this.aliases[i2].params,
              display: this.aliases[i2].display,
              notes: this.aliases[i2].notes || ""
            });
          }
        }
        if (this.triggers.length > 0) {
          il = this.triggers.length;
          for (i2 = 0; i2 < il; i2++) {
            const t = {
              pattern: this.triggers[i2].pattern,
              value: this.triggers[i2].value,
              priority: this.triggers[i2].priority,
              verbatim: this.triggers[i2].verbatim,
              style: this.triggers[i2].style,
              name: this.triggers[i2].name,
              group: this.triggers[i2].group,
              enabled: this.triggers[i2].enabled,
              display: this.triggers[i2].display,
              triggernewline: this.triggers[i2].triggerNewline,
              caseSensitive: this.triggers[i2].caseSensitive,
              triggerprompt: this.triggers[i2].triggerPrompt,
              raw: this.triggers[i2].raw,
              type: this.triggers[i2].type,
              notes: this.triggers[i2].notes || "",
              state: this.triggers[i2].state || 0,
              params: this.triggers[i2].params || "",
              triggers: []
            };
            if (this.triggers[i2].triggers && this.triggers[i2].triggers.length) {
              const sl = this.triggers[i2].triggers.length;
              for (let s = 0; s < sl; s++) {
                t.triggers.push({
                  pattern: this.triggers[i2].triggers[s].pattern,
                  value: this.triggers[i2].triggers[s].value,
                  priority: this.triggers[i2].triggers[s].priority,
                  verbatim: this.triggers[i2].triggers[s].verbatim,
                  style: this.triggers[i2].triggers[s].style,
                  name: this.triggers[i2].triggers[s].name,
                  group: this.triggers[i2].triggers[s].group,
                  enabled: this.triggers[i2].triggers[s].enabled,
                  display: this.triggers[i2].triggers[s].display,
                  triggernewline: this.triggers[i2].triggers[s].triggerNewline,
                  caseSensitive: this.triggers[i2].triggers[s].caseSensitive,
                  triggerprompt: this.triggers[i2].triggers[s].triggerPrompt,
                  raw: this.triggers[i2].triggers[s].raw,
                  type: this.triggers[i2].triggers[s].type,
                  notes: this.triggers[i2].triggers[s].notes || "",
                  state: this.triggers[i2].triggers[s].state || 0,
                  params: this.triggers[i2].triggers[s].params || "",
                  triggers: []
                });
              }
            }
            data.triggers.push(t);
          }
        }
        if (this.macros.length > 0) {
          il = this.macros.length;
          for (i2 = 0; i2 < il; i2++) {
            data.macros.push({
              key: this.macros[i2].key,
              value: this.macros[i2].value,
              style: this.macros[i2].style,
              append: this.macros[i2].append,
              send: this.macros[i2].send,
              name: this.macros[i2].name,
              group: this.macros[i2].group,
              enabled: this.macros[i2].enabled,
              display: 'if(item.key === 0) return "None"; return keyCodeToChar[item.key]',
              displaytype: 1,
              modifiers: this.macros[i2].modifiers,
              chain: this.macros[i2].chain,
              notes: this.macros[i2].notes || ""
            });
          }
        }
        if (this.buttons.length > 0) {
          il = this.buttons.length;
          for (i2 = 0; i2 < il; i2++) {
            data.buttons.push(clone(this.buttons[i2], (key, value) => {
              if (key === "profile") return void 0;
              return value;
            }));
          }
        }
        if (this.contexts.length > 0) {
          il = this.contexts.length;
          for (i2 = 0; i2 < il; i2++) {
            data.contexts.push(clone(this.contexts[i2], (key, value) => {
              if (key === "profile") return void 0;
              return value;
            }));
          }
        }
        return data;
      }
      data = clone(this, (key, value) => {
        if (key === "profile") return void 0;
        return value;
      });
      const profile = new _Profile(false);
      let prop;
      for (prop in data) {
        if (!data.hasOwnProperty(prop)) {
          continue;
        }
        if (prop === "aliases" || prop === "triggers" || prop === "macros" || prop === "buttons" || prop === "contexts" || prop === "variables")
          continue;
        profile[prop] = data[prop];
      }
      if (data.aliases && data.aliases.length > 0) {
        il = data.aliases.length;
        for (i2 = 0; i2 < il; i2++) {
          profile.aliases.push(new Alias(data.aliases[i2], null, profile));
        }
      }
      if (data.triggers && data.triggers.length > 0) {
        il = data.triggers.length;
        for (i2 = 0; i2 < il; i2++) {
          profile.triggers.push(new Trigger(data.triggers[i2], profile));
        }
      }
      if (data.macros && data.macros.length > 0) {
        il = data.macros.length;
        profile.macros = [];
        for (i2 = 0; i2 < il; i2++) {
          profile.macros.push(new Macro(data.macros[i2], profile));
        }
      }
      if (data.buttons && data.buttons.length > 0) {
        il = data.buttons.length;
        for (i2 = 0; i2 < il; i2++) {
          profile.buttons.push(new Button(data.buttons[i2], profile));
        }
      }
      if (data.contexts && data.contexts.length > 0) {
        il = data.contexts.length;
        for (i2 = 0; i2 < il; i2++) {
          profile.contexts.push(new Context(data.contexts[i2], profile));
        }
      }
      return profile;
    }
    find(type, field, value) {
      let tmp;
      if (!type || type.length === 0 || !this[type] || this[type].length === 0)
        return null;
      tmp = SortItemArrayByPriority(this[type]);
      const l2 = tmp.length;
      for (let t = 0; t < l2; t++) {
        if (tmp[t][field] === value)
          return tmp[t];
      }
      return null;
    }
    findAny(type, field, value) {
      let tmp;
      if (!type || type.length === 0 || !this[type] || this[type].length === 0)
        return null;
      tmp = SortItemArrayByPriority(this[type]);
      const l2 = tmp.length;
      if (typeof field === "object") {
        for (let t = 0; t < l2; t++) {
          for (const v in field) {
            if (!field.hasOwnProperty(v)) continue;
            if (tmp[t][v] === field[v])
              return tmp[t];
          }
        }
        return -1;
      }
      for (let t = 0; t < l2; t++) {
        if (tmp[t][field] === value)
          return tmp[t];
      }
      return null;
    }
    indexOfAny(type, field, value) {
      let tmp;
      if (!type || type.length === 0 || !this[type] || this[type].length === 0)
        return null;
      tmp = SortItemArrayByPriority(this[type]);
      const l2 = tmp.length;
      if (typeof field === "object") {
        for (let t = 0; t < l2; t++) {
          for (const v in field) {
            if (!field.hasOwnProperty(v)) continue;
            if (tmp[t][v] === field[v])
              return this[type].indexOf(tmp[t]);
          }
        }
        return -1;
      }
      for (let t = 0; t < l2; t++) {
        if (tmp[t][field] === value)
          return this[type].indexOf(tmp[t]);
      }
      return -1;
    }
    indexOf(type, field, value) {
      let tmp;
      if (!type || type.length === 0 || !this[type] || this[type].length === 0)
        return null;
      tmp = SortItemArrayByPriority(this[type]);
      const l2 = tmp.length;
      if (typeof field === "object") {
        for (let t = 0; t < l2; t++) {
          for (const v in field) {
            if (!field.hasOwnProperty(v)) continue;
            if (tmp[t][v] !== field[v]) continue;
          }
          return this[type].indexOf(tmp[t]);
        }
        return -1;
      }
      for (let t = 0; t < l2; t++) {
        if (tmp[t][field] === value)
          return this[type].indexOf(tmp[t]);
      }
      return -1;
    }
  };
  var ProfileCollection = class _ProfileCollection {
    constructor(defaultProfile) {
      this.items = {};
      this.keys = [];
      this.add(defaultProfile == null ? Profile.Default : defaultProfile);
    }
    SortByPriority() {
      this.keys.sort((a, b) => {
        let ap = this.items[a].priority;
        let bp = this.items[b].priority;
        if (ap > bp)
          return -1;
        if (ap < bp)
          return 1;
        if (a === "default")
          return -1;
        if (b === "default")
          return 1;
        ap = this.items[a].name;
        bp = this.items[b].name;
        if (ap > bp)
          return 1;
        if (ap < bp)
          return -1;
        return 0;
      });
    }
    enabled(profile) {
      if (!profile || this.keys.length === 0) return false;
      if (typeof profile === "string") {
        if (!this.items[profile.toLowerCase()])
          return false;
        return this.items[profile.toLowerCase()].enabled;
      }
      return this.items[profile.name.toLowerCase()] ? this.items[profile.name.toLowerCase()].enabled : false;
    }
    contains(profile) {
      if (!profile || this.keys.length === 0) return false;
      if (typeof profile === "string")
        return this.items[profile.toLowerCase()] ? true : false;
      return this.items[profile.name.toLowerCase()] ? true : false;
    }
    canDisable(profile) {
      if (!profile || this.keys.length === 0) return false;
      let idx;
      if (typeof profile === "number") {
        if (profile < 0)
          return false;
        if (profile >= this.keys.length)
          return false;
        idx = this.keys[profile];
      } else if (typeof profile === "object")
        idx = profile.name.toLowerCase();
      else if (typeof profile === "string")
        idx = profile.toLowerCase();
      else
        return false;
      if (!this.items[idx]) return false;
      const e = !this.items[idx].enabled;
      if (!e) {
        let c = false;
        for (const key in this.items) {
          if (key === idx) continue;
          if (this.items[key].enabled) c = true;
          break;
        }
        if (!c)
          return false;
      }
      return true;
    }
    toggle(profile) {
      if (!profile || this.keys.length === 0) return false;
      let idx;
      if (typeof profile === "number") {
        if (profile < 0)
          return false;
        if (profile >= this.keys.length)
          return false;
        idx = this.keys[profile];
      } else if (typeof profile === "object")
        idx = profile.name.toLowerCase();
      else if (typeof profile === "string")
        idx = profile.toLowerCase();
      else
        return false;
      if (!this.items[idx]) return false;
      const e = !this.items[idx].enabled;
      if (!e) {
        let c = false;
        for (const key in this.items) {
          if (key === idx) continue;
          if (this.items[key].enabled) c = true;
          break;
        }
        if (!c)
          return false;
      }
      this.items[idx].enabled = e;
      return true;
    }
    update() {
      this.keys = Object.keys(this.items);
      this.SortByPriority();
    }
    add(profile, noUpdate) {
      if (!profile)
        return;
      this.items[profile.name.toLowerCase()] = profile;
      if (!noUpdate)
        this.update();
    }
    remove(profile) {
      if (!profile || this.keys.length === 0) return;
      if (typeof profile === "string")
        delete this.items[profile.toLowerCase()];
      else if (typeof profile === "number") {
        if (profile < 0 || profile >= this.keys.length) return;
        delete this.items[this.keys[profile]];
      } else
        delete this.items[profile.name.toLowerCase()];
      this.update();
    }
    copy(profile) {
      if (!profile) return clone(this.items);
      if (this.keys.length === 0)
        return null;
      if (typeof profile === "string") {
        if (!this.items[profile.toLowerCase()])
          return null;
        return this.items[profile.toLowerCase()].clone();
      }
      if (typeof profile === "number") {
        if (profile < 0 || profile >= this.keys.length) return null;
        return this.items[this.keys[profile]].clone();
      }
      return profile.clone();
    }
    clone(version2) {
      if (version2 === 2) {
        const profiles = {};
        for (const p in this.items)
          profiles[this.items[p].name.toLowerCase()] = this.items[p].clone(2);
        return profiles;
      }
      const pc = new _ProfileCollection();
      for (const p in this.items)
        pc.items[this.items[p].name.toLowerCase()] = this.items[p].clone();
      pc.update();
      return pc;
    }
    static load(key) {
      return new Promise((resolve, reject) => {
        let collection = new _ProfileCollection();
        localforage.getItem(key || "OoMUDProfiles").then((value) => {
          if (typeof value === "string")
            value = JSON.parse(value);
          if (!value)
            collection.add(Profile.Default);
          else {
            const keys = Object.keys(value);
            let k = 0;
            let kl = keys.length;
            for (; k < kl; k++) {
              collection.add(Profile.load(value[keys[k]]));
            }
          }
          resolve(collection);
        }).catch(reject);
      });
    }
    save(key) {
      return localforage.setItem(key || "OoMUDProfiles", JSON.parse(JSON.stringify(this.items, (key2, value) => {
        if (key2 === "profile") return void 0;
        return value;
      })));
    }
    get length() {
      return this.keys.length;
    }
    count() {
      return this.keys.length;
    }
    get active() {
      const keys = this.keys;
      if (keys.length === 0) {
        this.add(Profile.Default);
        return this.items["default"];
      }
      if (keys.length === 1) {
        if (this.items[keys[0]].enabled)
          return this.items[keys[0]];
        if (this.items[keys[0]].name === "Default") {
          this.items[keys[0]].enable = true;
          return this.items["default"];
        }
        this.add(Profile.Default);
        return this.items["default"];
      }
      for (const key in keys) {
        if (this.items[key].enabled)
          return this.items[key];
      }
      if (this.items["default"]) {
        this.items["default"].enabled = true;
        return this.items["default"];
      }
      this.add(Profile.Default);
      return this.items["default"];
    }
    get aliases() {
      const keys = this.keys;
      let tmp = [];
      let k = 0;
      const kl = keys.length;
      if (kl === 0) return [];
      if (kl === 1) {
        if (!this.items[keys[0]].enabled || !this.items[keys[0]].enableAliases)
          return [];
        return this.items[keys[0]].aliases;
      }
      for (; k < kl; k++) {
        if (!this.items[keys[k]].enabled || !this.items[keys[k]].enableAliases || this.items[keys[k]].aliases.length === 0)
          continue;
        tmp = tmp.concat(this.items[keys[k]].aliases);
      }
      return tmp;
    }
    get triggers() {
      const keys = this.keys;
      let tmp = [];
      let k = 0;
      const kl = keys.length;
      if (kl === 0) return [];
      if (kl === 1) {
        if (!this.items[keys[0]].enabled || !this.items[keys[0]].enableTriggers)
          return [];
        return this.items[keys[0]].triggers;
      }
      for (; k < kl; k++) {
        if (!this.items[keys[k]].enabled || !this.items[keys[k]].enableTriggers || this.items[keys[k]].triggers.length === 0)
          continue;
        tmp = tmp.concat(this.items[keys[k]].triggers);
      }
      return tmp;
    }
    get macros() {
      const keys = this.keys;
      let tmp = [];
      let k = 0;
      const kl = keys.length;
      if (kl === 0) return [];
      if (kl === 1) {
        if (!this.items[keys[0]].enabled || !this.items[keys[0]].enableMacros)
          return [];
        return this.items[keys[0]].macros;
      }
      for (; k < kl; k++) {
        if (!this.items[keys[k]].enabled || !this.items[keys[k]].enableMacros || this.items[keys[k]].macros.length === 0)
          continue;
        tmp = tmp.concat(this.items[keys[k]].macros);
      }
      return tmp;
    }
    get buttons() {
      const keys = this.keys;
      let tmp = [];
      let k = 0;
      const kl = keys.length;
      if (kl === 0) return [];
      if (kl === 1) {
        if (!this.items[keys[0]].enabled || !this.items[keys[0]].enableButtons)
          return [];
        return this.items[keys[0]].buttons;
      }
      for (; k < kl; k++) {
        if (!this.items[keys[k]].enabled || !this.items[keys[k]].enableButtons || this.items[keys[k]].buttons.length === 0)
          continue;
        tmp = tmp.concat(this.items[keys[k]].buttons);
      }
      return tmp;
    }
    get contexts() {
      const keys = this.keys;
      let tmp = [];
      let k = 0;
      const kl = keys.length;
      if (kl === 0) return [];
      if (kl === 1) {
        if (!this.items[keys[0]].enabled || !this.items[keys[0]].enableContexts)
          return [];
        return this.items[keys[0]].contexts;
      }
      for (; k < kl; k++) {
        if (!this.items[keys[k]].enabled || !this.items[keys[k]].enableContexts || this.items[keys[k]].contexts.length === 0)
          continue;
        tmp = tmp.concat(this.items[keys[k]].contexts);
      }
      return tmp;
    }
    get defaultContext() {
      const keys = this.keys;
      let k = 0;
      const kl = keys.length;
      if (kl === 0) return true;
      if (kl === 1) {
        if (!this.items[keys[0]].enabled)
          return true;
        return this.items[keys[0]].enableDefaultContext;
      }
      for (; k < kl; k++) {
        if (!this.items[keys[k]].enabled)
          continue;
        if (!this.items[keys[k]].enableDefaultContext)
          return false;
      }
      return true;
    }
  };
  function convertPattern(pattern, client2) {
    if (!pattern || !pattern.length) return "";
    let convertPatternState;
    ((convertPatternState2) => {
      convertPatternState2[convertPatternState2["None"] = 0] = "None";
      convertPatternState2[convertPatternState2["Ampersand"] = 1] = "Ampersand";
      convertPatternState2[convertPatternState2["Percent"] = 2] = "Percent";
      convertPatternState2[convertPatternState2["StringMatch"] = 3] = "StringMatch";
      convertPatternState2[convertPatternState2["SubPattern"] = 4] = "SubPattern";
      convertPatternState2[convertPatternState2["AmpersandPercent"] = 5] = "AmpersandPercent";
      convertPatternState2[convertPatternState2["AmpersandPattern"] = 6] = "AmpersandPattern";
      convertPatternState2[convertPatternState2["AmpersandRange"] = 7] = "AmpersandRange";
      convertPatternState2[convertPatternState2["PercentRegex"] = 8] = "PercentRegex";
      convertPatternState2[convertPatternState2["Escape"] = 9] = "Escape";
      convertPatternState2[convertPatternState2["Variable"] = 10] = "Variable";
    })(convertPatternState || (convertPatternState = {}));
    let state = 0 /* None */;
    let stringBuilder = [];
    let idx = 0;
    let tl = pattern.length;
    let c;
    let i2;
    let arg;
    let pat;
    let nest = 0;
    for (idx = 0; idx < tl; idx++) {
      c = pattern.charAt(idx);
      i2 = pattern.charCodeAt(idx);
      switch (state) {
        case 1 /* Ampersand */:
          if (arg.length === 0 && (c === "*" || c === "?" || c === "^" || c === "$"))
            pat = c;
          else if (arg.length === 0 && c === "%")
            state = 5 /* AmpersandPercent */;
          else if (pat.length === 0 && c === "(") {
            pat = c;
            state = 6 /* AmpersandPattern */;
          } else if (pat.length === 0 && c === "[") {
            pat = c;
            state = 7 /* AmpersandRange */;
          } else if (c === "{")
            continue;
          else if (c === "}" || !(i2 >= 48 && i2 <= 57 || i2 >= 65 && i2 <= 90 || i2 >= 97 && i2 <= 122 || i2 === 95 || i2 === 36)) {
            if (!isValidIdentifier(arg))
              throw new Error("Invalid variable name");
            if (!pat.length && /^\d+$/.exec(arg))
              stringBuilder.push("{", arg, "}");
            else if (!pat.length)
              stringBuilder.push("(?<", arg, ">.*)");
            else
              stringBuilder.push("(?<", arg, ">", convertPattern(pat), ")");
            if (c !== "}")
              idx--;
            state = 0 /* None */;
          } else
            arg += c;
          break;
        case 5 /* AmpersandPercent */:
          pat += "%" + c;
          state = 1 /* Ampersand */;
          break;
        case 6 /* AmpersandPattern */:
          pat += c;
          if (c === ")")
            state = 1 /* Ampersand */;
          break;
        case 7 /* AmpersandRange */:
          pat += c;
          if (c === "]")
            state = 1 /* Ampersand */;
          break;
        case 2 /* Percent */:
          switch (c) {
            case "d":
              stringBuilder.push("\\d+");
              state = 0 /* None */;
              break;
            case "n":
              stringBuilder.push("[+-]?\\d+");
              state = 0 /* None */;
              break;
            case "w":
              stringBuilder.push("\\w");
              state = 0 /* None */;
              break;
            case "a":
              stringBuilder.push("[a-zA-Z0-9]*");
              state = 0 /* None */;
              break;
            case "s":
              stringBuilder.push("\\s*");
              state = 0 /* None */;
              break;
            case "x":
              stringBuilder.push("\\S*");
              state = 0 /* None */;
              break;
            case "y":
              stringBuilder.push("\\S*");
              state = 0 /* None */;
              break;
            case "p":
              stringBuilder.push(`[\\.\\?\\!\\:\\;\\-\\\u2014\\(\\)\\[\\]\\'\\"\\\\/\\,]{1}`);
              state = 0 /* None */;
              break;
            case "q":
              stringBuilder.push(`[\\.\\?\\!\\:\\;\\-\\\u2014\\(\\)\\[\\]\\'\\"\\\\/\\,]{1}`);
              state = 0 /* None */;
              break;
            case "t":
              state = 0 /* None */;
              break;
            case "e":
              stringBuilder.push("\x1B");
              state = 0 /* None */;
              break;
            case "/":
              state = 8 /* PercentRegex */;
              arg = "";
              break;
          }
          break;
        case 8 /* PercentRegex */:
          if (c === "%") {
            if (!arg.endsWith("/"))
              throw new Error("Invalid %/regex/% pattern");
            stringBuilder.push(arg.substr(0, arg.length - 1));
          } else
            arg += c;
          break;
        case 3 /* StringMatch */:
          if (c === "^" && arg.length === 0)
            pat = true;
          else if (c === "}") {
            if (pat)
              stringBuilder.push("[^", arg, "]");
            else
              stringBuilder.push(arg);
            state = 0 /* None */;
          } else
            arg += c;
          break;
        case 4 /* SubPattern */:
          if (c === ":") {
            stringBuilder.push("(?<", arg, ">");
            state = 0 /* None */;
          } else if (c === ")") {
            stringBuilder.push("(", convertPattern(arg), ")");
            state = 0 /* None */;
            nest--;
          } else
            arg += c;
          break;
        case 9 /* Escape */:
          stringBuilder.push("\\", c);
          state = 0 /* None */;
          break;
        case 10 /* Variable */:
          if (c === "{" && arg.length === 0)
            continue;
          else if (c === "}" || !(i2 >= 48 && i2 <= 57 || i2 >= 65 && i2 <= 90 || i2 >= 97 && i2 <= 122 || i2 === 95 || i2 === 36)) {
            if (!isValidIdentifier(arg))
              throw new Error("Invalid variable name");
            if (client2) {
              if (client2.variables[arg] instanceof Variable)
                stringBuilder.push(client2.variables[arg].value || "");
              else
                stringBuilder.push(client2.variables[arg] || "");
            }
            if (c !== "}")
              idx--;
            state = 0 /* None */;
          } else
            arg += c;
          break;
        default:
          if (c === "*")
            stringBuilder.push(".*");
          else if (c === "?")
            stringBuilder.push(".");
          else if (c === "~")
            state = 9 /* Escape */;
          else if (c === "@") {
            state = 10 /* Variable */;
            arg = "";
          } else if (c === "&") {
            arg = "";
            pat = "";
            state = 1 /* Ampersand */;
          } else if (c === "%")
            state = 2 /* Percent */;
          else if (c === "{") {
            state = 3 /* StringMatch */;
            arg = "";
          } else if (c === "(") {
            state = 4 /* SubPattern */;
            arg = "";
            nest++;
          } else {
            if (c === ")")
              nest--;
            stringBuilder.push(c);
          }
          break;
      }
    }
    switch (state) {
      case 1 /* Ampersand */:
        if (!isValidIdentifier(arg))
          throw new Error("Invalid variable name");
        if (!pat.length && /^\d+$/.exec(arg))
          stringBuilder.push("{", arg, "}");
        else if (!pat.length)
          stringBuilder.push("(?<", arg, ">.*)");
        else
          stringBuilder.push("(?<", arg, ">", convertPattern(pat), ")");
        break;
      case 5 /* AmpersandPercent */:
      case 6 /* AmpersandPattern */:
      case 7 /* AmpersandRange */:
        throw new Error("Invalid &VarName pattern");
      case 2 /* Percent */:
        throw new Error("Invalid % pattern");
      case 8 /* PercentRegex */:
        throw new Error("Invalid %/regex/% pattern");
      case 3 /* StringMatch */:
        throw new Error("Invalid string match pattern");
      case 4 /* SubPattern */:
        throw new Error("Invalid (sub:pattern) pattern");
      case 9 /* Escape */:
        throw new Error("Invalid escape pattern");
      case 10 /* Variable */:
        if (!isValidIdentifier(arg))
          throw new Error("Invalid variable name");
        if (client2) {
          if (client2.variables[arg] instanceof Variable)
            stringBuilder.push(client2.variables[arg].getValue() || "");
          else
            stringBuilder.push(client2.variables[arg] || "");
        }
        break;
    }
    if (nest)
      throw new Error("Invalid save matched pattern");
    return stringBuilder.join("");
  }

  // src/input.ts
  var mathjs;
  var _mathjs;
  var WindowVariables = ["$selectedword", "$selword", "$selectedurl", "$selurl", "$selectedline", "$selline", "$selected", "$character", "$copied", "$action", "$trigger", "$caption", "$characterid"];
  function ProperCase(str) {
    return str.replace(/\w*\S*/g, (txt) => {
      return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
    });
  }
  function fudgeDice() {
    switch (~~(Math.random() * 6) + 1) {
      case 1:
      case 4:
        return -1;
      case 3:
      case 2:
        return 1;
    }
    return 0;
  }
  var Input = class extends EventEmitter {
    constructor(client2) {
      super();
      this._historyIdx = -1;
      this._tabIdx = -1;
      this._tabWords = null;
      this._locked = 0;
      this._TriggerCache = null;
      this._TriggerStates = {};
      this._TriggerFunctionCache = {};
      this._TriggerRegExCache = {};
      this._LastTriggered = "";
      this._LastTrigger = null;
      this._scrollLock = false;
      this._gag = 0;
      this._gagID = [];
      this._gags = [];
      this._stack = [];
      this._vStack = [];
      this._controllers = {};
      this._controllersCount = 0;
      this._gamepadCaches = null;
      this._lastSuspend = -1;
      this._MacroCache = {};
      this._loops = [];
      this._pathQueue = [];
      this._pathTimeout = null;
      this._pathPaused = false;
      this.client = null;
      this.enableParsing = true;
      this.enableTriggers = true;
      if (!client2)
        throw new Error("Invalid client!");
      this.client = client2;
      mathjs = () => {
        if (_mathjs) return _mathjs;
        this._initMathJS();
        return _mathjs;
      };
      this._commandHistory = [];
      document.addEventListener("keydown", (event2) => {
        if (!this.isLocked && this.ProcessMacros(event2.which, event2.altKey, event2.ctrlKey, event2.shiftKey, event2.metaKey)) {
          event2.preventDefault();
          event2.stopPropagation();
        } else if (event2.key === "ScrollLock")
          this.toggleScrollLock();
      });
      this.client.on("parse-command", (data) => {
        if (this.client.getOption("parseCommands"))
          data.value = this.parseOutgoing(data.value, null, null, null, null, !data.comments);
      });
      this.client.on("add-line", (data) => {
        this.ExecuteTriggers(4 /* Regular */ | 8 /* Pattern */ | 128 /* LoopExpression */, data.line, data.raw, data.fragment, false, true);
        if (this._gag > 0 && !data.fragment) {
          data.gagged = true;
          this._gag--;
        }
        if (!data.fragment)
          for (let state in this._TriggerStates) {
            if (this._TriggerStates[state].lineCount)
              this._TriggerStates[state].lineCount--;
          }
      });
      this.client.on("options-loaded", () => {
        if (!_mathjs && this.client.getOption("initializeScriptEngineOnLoad"))
          this._initMathJS();
        this._initPads();
      });
      this.client.commandInput.addEventListener("keyup", (event2) => {
        if (event2.key !== "Escape" && event2.key !== "ArrowUp" && event2.key !== "ArrowDown")
          this._historyIdx = this._commandHistory.length;
      });
      this.client.commandInput.addEventListener("keydown", (event2) => {
        switch (event2.key) {
          case "Escape":
            if (event2.ctrlKey || event2.shiftKey || event2.metaKey || event2.altKey) return;
            this.client.commandInput.blur();
            this.client.commandInput.value = "";
            this.client.commandInput.select();
            this._historyIdx = this._commandHistory.length;
            this._tabIdx = -1;
            this._tabWords = null;
            this._tabSearch = null;
            this.emit("history-navigate", event2);
            break;
          case "ArrowUp":
            if (event2.ctrlKey || event2.shiftKey || event2.metaKey || event2.altKey) return;
            if (this._historyIdx === this._commandHistory.length && this.client.commandInput.value.length > 0) {
              this.AddCommandToHistory(this.client.commandInput.value);
              if (this.client.commandInput.value === this._commandHistory[this._historyIdx - 1])
                this._historyIdx--;
            }
            this._historyIdx--;
            if (this._historyIdx < 0)
              this._historyIdx = 0;
            if (this._commandHistory.length < 0) {
              this._historyIdx = -1;
              this.client.commandInput.value = "";
            } else if (this._commandHistory.length > 0 && this._historyIdx < this._commandHistory.length && this._historyIdx >= 0) {
              this.client.commandInput.value = this._commandHistory[this._historyIdx];
            }
            setTimeout(() => this.client.commandInput.select(), 0);
            this.emit("history-navigate", event2);
            break;
          case "ArrowDown":
            if (event2.ctrlKey || event2.shiftKey || event2.metaKey || event2.altKey) return;
            if (this._historyIdx === this._commandHistory.length && this.client.commandInput.value.length > 0)
              this.AddCommandToHistory(this.client.commandInput.value);
            this._historyIdx++;
            if (this._historyIdx >= this._commandHistory.length || this._commandHistory.length < 1) {
              this._historyIdx = this._commandHistory.length;
              this.client.commandInput.value = "";
            } else if (this._commandHistory.length > 0 && this._historyIdx < this._commandHistory.length && this._historyIdx >= 0) {
              this.client.commandInput.value = this._commandHistory[this._historyIdx];
            }
            setTimeout(() => this.client.commandInput.select(), 0);
            this.emit("history-navigate", event2);
            break;
          case "Enter":
            switch (this.client.getOption("newlineShortcut")) {
              case 1 /* Ctrl */:
                if (event2.ctrlKey && !event2.shiftKey && !event2.metaKey && !event2.altKey) {
                  insertValue(this.client.commandInput, "\n");
                  this.emit("history-navigate", event2);
                  this.client.commandInput.blur();
                  this.client.commandInput.focus();
                  return true;
                }
                break;
              case 8 /* CtrlAndShift */:
                if (event2.ctrlKey && event2.shiftKey && !event2.metaKey && !event2.altKey) {
                  insertValue(this.client.commandInput, "\n");
                  this.emit("history-navigate", event2);
                  this.client.commandInput.blur();
                  this.client.commandInput.focus();
                  return true;
                }
                break;
              case 4 /* CtrlOrShift */:
                if ((event2.ctrlKey || event2.shiftKey) && !event2.metaKey && !event2.altKey) {
                  insertValue(this.client.commandInput, "\n");
                  this.emit("history-navigate", event2);
                  this.client.commandInput.blur();
                  this.client.commandInput.focus();
                  return true;
                }
                break;
              case 2 /* Shift */:
                if (event2.ctrlKey && event2.shiftKey && !event2.metaKey && !event2.altKey) {
                  insertValue(this.client.commandInput, "\n");
                  this.emit("history-navigate", event2);
                  this.client.commandInput.blur();
                  this.client.commandInput.focus();
                  return true;
                }
                break;
            }
            if (!event2.ctrlKey && !event2.shiftKey && !event2.metaKey && !event2.altKey) {
              this._tabIdx = -1;
              this._tabWords = null;
              this._tabSearch = null;
              event2.preventDefault();
              this.client.sendCommand(null, null, this.client.getOption("allowCommentsFromCommand"));
              this.emit("history-navigate", event2);
            }
            event2.preventDefault();
            break;
          case "Tab":
            if (!this.client.getOption("enableTabCompletion") || this.client.commandInput.value.length === 0) return;
            if (event2.altKey || event2.ctrlKey || event2.metaKey) return;
            if (event2.shiftKey)
              this._tabIdx--;
            else
              this._tabIdx++;
            let start = this.client.commandInput.selectionStart;
            let end = this.client.commandInput.selectionEnd;
            if (this._tabWords === null) {
              const cursorPos = getCursor(this.client.commandInput);
              let endPos = this.client.commandInput.value.indexOf(" ", cursorPos);
              if (endPos === -1)
                endPos = this.client.commandInput.value.indexOf("\n", cursorPos);
              let startPos = this.client.commandInput.value.lastIndexOf(" ", cursorPos - 1);
              if (startPos === -1)
                startPos = this.client.commandInput.value.indexOf("\n", cursorPos - 1);
              if (endPos === -1)
                endPos = this.client.commandInput.value.length;
              if (startPos === -1)
                startPos = 0;
              else
                startPos++;
              start = startPos;
              end = endPos;
              if (start === end)
                end++;
              const findStr = this.client.commandInput.value.substring(startPos, endPos);
              if (findStr.length === 0) return;
              this._tabSearch = { start: startPos, end: endPos, find: findStr.length };
              const regSearch = new RegExp(`^${findStr.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}`, this.client.getOption("ignoreCaseTabCompletion") ? "i" : "");
              if (this.client.getOption("tabCompletionLookupType") === 8 /* List */)
                this._tabWords = [...new Set(this.client.getOption("tabCompletionList").split(/\s+/).filter((word) => word.match(regSearch)))];
              else {
                this._tabWords = [].concat(...this.client.display.lines.slice(this.client.display.lines.length - this.client.getOption("tabCompletionBufferLimit")).map((line2) => line2.text.split(/\s+/))).filter((word) => word.match(regSearch)).reverse();
                if (this.client.getOption("tabCompletionLookupType") === 1 /* PrependBuffer */)
                  this._tabWords = [...new Set(this.client.getOption("tabCompletionList").split(/\s+/).filter((word) => word.match(regSearch)).reverse())].concat(this._tabWords);
                else if (this.client.getOption("tabCompletionLookupType") === 2 /* AppendBuffer */)
                  this._tabWords = this._tabWords.concat([...new Set(this.client.getOption("tabCompletionList").split(/\s+/).filter((word) => word.match(regSearch)).reverse())]);
                this._tabWords = [...new Set(this._tabWords)];
              }
            } else
              start -= this._tabSearch.find;
            if (this._tabWords.length === 0) return;
            if (this._tabIdx < 0) this._tabIdx = this._tabWords.length - 1;
            if (this._tabIdx >= this._tabWords.length) this._tabIdx = 0;
            const tabCasing = this.client.getOption("tabCompletionReplaceCasing");
            this.client.commandInput.value = this.client.commandInput.value.substring(0, start) + (tabCasing === 1 ? this._tabWords[this._tabIdx].toLowerCase() : tabCasing === 2 ? this._tabWords[this._tabIdx].toUpperCase() : this._tabWords[this._tabIdx]) + this.client.commandInput.value.substring(end, this.client.commandInput.value.length);
            this.client.commandInput.selectionStart = this._tabSearch.start + this._tabSearch.find;
            this.client.commandInput.selectionEnd = this._tabSearch.start + this._tabWords[this._tabIdx].length;
            event2.preventDefault();
            this.emit("history-navigate", event2);
            break;
          case "Shift":
          case "Control":
          case "Meta":
          case "Alt":
          case "CapsLock":
          case "Fn":
          case "NumLock":
          case "ScrollLock":
          case "Super":
          case "PageDown":
          case "PageUp":
          case "End":
          case "Home":
          case "ArrowLeft":
          case "ArrowRight":
          case "ContextMenu":
            break;
          default:
            this._tabIdx = -1;
            this._tabWords = null;
            this._tabSearch = null;
            break;
        }
      });
      this.client.commandInput.addEventListener("mouseup", (event2) => {
        this._tabIdx = -1;
        this._tabWords = null;
        this._tabSearch = null;
      });
      window.addEventListener("gamepadconnected", (e) => {
        if (!this.client.getOption("gamepads")) return;
        if (!this._gamepadCaches)
          this._gamepadCaches = [];
        this._controllers[e.gamepad.index] = { pad: e.gamepad, axes: clone(e.gamepad.axes), state: { axes: [], buttons: [] }, pState: { axes: [], buttons: [] } };
        this._controllersCount++;
        this._updatePads();
      });
      window.addEventListener("gamepaddisconnected", (e) => {
        if (!this.client.getOption("gamepads")) return;
        delete this._controllers[e.gamepad.index];
        this._controllersCount--;
      });
      this._initPads();
    }
    getScope() {
      let scope = {};
      Object.assign(scope, this.client.variables);
      WindowVariables.forEach((a) => {
        scope[a] = window[a];
        scope[a.substr(1)] = window[a];
      });
      if (this._stack.length === 0)
        return scope;
      if (!this.stack.named && !this.loops.length)
        return scope;
      if (this.stack.named)
        Object.assign(scope, this.stack.named);
      if (this.loops.length) {
        scope.repeatnum = this.repeatnum;
        const ll = this.loops.length;
        for (let l2 = 0; l2 < ll && l2 < 18; l2++)
          scope[String.fromCharCode(105 + l2)] = this.loops[l2];
      }
      return scope;
    }
    setScope(scope) {
      if (scope === this.client.variables) return;
      const ll = this.loops.length;
      for (const name2 in scope) {
        if (!Object.prototype.hasOwnProperty.call(scope, name2) || name2 === "i" || name2 === "repeatnum")
          continue;
        if (WindowVariables.indexOf(name2) !== -1 || WindowVariables.indexOf("$" + name2) !== -1)
          continue;
        switch (name2) {
          case "clientid":
            continue;
        }
        if (name2.length === 1 && ll && name2.charCodeAt(0) >= 105 && name2.charCodeAt(0) < 105 + ll)
          continue;
        if (this.stack.named && Object.prototype.hasOwnProperty.call(this.stack.named, name2))
          continue;
        this.client.variables[name2] = scope[name2];
      }
    }
    evaluate(expression) {
      let scope = this.getScope();
      let results = mathjs().evaluate(expression, scope);
      this.setScope(scope);
      return results;
    }
    get stack() {
      if (this._stack.length === 0)
        this._stack.push({ args: 0, named: 0, used: 0, append: false });
      return this._stack[this._stack.length - 1];
    }
    get repeatnum() {
      if (this.loops.length === 0)
        return 0;
      return this.loops[this.loops.length - 1];
    }
    get loops() {
      if (this._stack.length === 0 || !this.stack.hasOwnProperty("loops"))
        return this._loops;
      return this.stack.loops;
    }
    get regex() {
      let sl = this._stack.length;
      if (sl === 0)
        return null;
      while (sl >= 0) {
        sl--;
        if (this._stack[sl].hasOwnProperty("regex"))
          return this._stack[sl].regex;
      }
      return null;
    }
    get indices() {
      let sl = this._stack.length;
      if (sl === 0)
        return [];
      while (sl >= 0) {
        sl--;
        if (this._stack[sl].hasOwnProperty("indices"))
          return this._stack[sl].indices;
      }
      return [];
    }
    get vStack() {
      if (this._vStack.length === 0)
        return {};
      return this._vStack[this._vStack.length - 1];
    }
    vStackPush(obj) {
      this._vStack.push(obj);
    }
    vStackPop() {
      this._vStack.pop();
    }
    get scrollLock() {
      return this._scrollLock;
    }
    set scrollLock(locked) {
      if (locked !== this._scrollLock) {
        this._scrollLock = locked;
        this.emit("scroll-lock", this.scrollLock);
      }
    }
    get lastTriggerExecuted() {
      return this._LastTrigger;
    }
    get lastTriggered() {
      return this._LastTriggered;
    }
    set lastTriggered(value) {
      this._LastTriggered = value;
    }
    _getDiceArguments(arg, scope, fun) {
      let res = /(\d+)\s*?d(F|f|%|\d+)(\s*?[-|+|*|\/]?\s*?\d+)?/g.exec(arg.toString());
      if (!res || res.length < 3) {
        res = /(\d+)\s*?d\s*?\/\s*?(100)(\s*?[-|+|*|\/]?\s*?\d+)?/g.exec(arg.toString());
        if (!res || res.length < 3) {
          arg = arg.compile().evaluate(scope);
          res = /(\d+)\s*?d(F|f|%|\d+)(\s*?[-|+|*|\/]?\s*?\d+)?/g.exec(arg.toString());
          if (!res || res.length < 3) {
            res = /(\d+)\s*?d\s*?\/\s*?(100)(\s*?[-|+|*|\/]?\s*?\d+)?/g.exec(arg.toString());
            if (!res || res.length < 3)
              throw new Error("Invalid dice for " + (fun || "dice"));
            res[2] = "%";
          }
        } else
          res[2] = "%";
      }
      return res;
    }
    _initMathJS() {
      _mathjs = math;
      const functions = {
        esc: "\x1B",
        cr: "\n",
        lf: "\r",
        crlf: "\r\n",
        diceavg: (args, math2, scope) => {
          let res;
          let c;
          let sides;
          let mod;
          let min;
          let max2;
          if (args.length === 0) throw new Error("Invalid arguments for diceavg");
          if (args.length === 1) {
            res = this._getDiceArguments(args[0], scope, "diceavg");
            c = parseInt(res[1]);
            sides = res[2];
            if (res.length > 3)
              mod = res[3];
          } else if (args.length < 4) {
            c = args[0].compile().evaluate(scope);
            sides = args[1].toString().trim();
            if (sides !== "F" && sides !== "%")
              sides = args[1].compile().evaluate(scope);
            if (args.length > 2)
              mod = args[2].compile().evaluate(scope);
          } else
            throw new Error("Too many arguments for diceavg");
          min = 1;
          if (sides === "F" || sides === "f") {
            min = -1;
            max2 = 1;
          } else if (sides === "%") {
            max2 = 1;
            min = 0;
          } else
            max2 = parseInt(sides);
          if (mod)
            return math2.evaluate((min + max2) / 2 * c + mod, scope);
          return (min + max2) / 2 * c;
        },
        dicemin: (args, math2, scope) => {
          let res;
          let c;
          let sides;
          let mod;
          let min;
          if (args.length === 0) throw new Error("Invalid arguments for dicemin");
          if (args.length === 1) {
            res = res = this._getDiceArguments(args[0], scope, "dicemin");
            c = parseInt(res[1]);
            sides = res[2];
            if (res.length > 3)
              mod = res[3];
          } else if (args.length < 4) {
            c = args[0].compile().evaluate(scope);
            sides = args[1].toString().trim();
            if (sides !== "F" && sides !== "%")
              sides = args[1].compile().evaluate(scope);
            if (args.length > 2)
              mod = args[2].compile().evaluate(scope);
          } else
            throw new Error("Too many arguments for dicemin");
          min = 1;
          if (sides === "F" || sides === "f")
            min = -1;
          else if (sides === "%")
            min = 0;
          if (mod)
            return math2.evaluate(min * c + mod, scope);
          return min * c;
        },
        dicemax: (args, math2, scope) => {
          let res;
          let c;
          let sides;
          let mod;
          let max2;
          if (args.length === 0) throw new Error("Invalid arguments for dicemax");
          if (args.length === 1) {
            res = this._getDiceArguments(args[0], scope, "dicemax");
            c = parseInt(res[1]);
            sides = res[2];
            if (res.length > 3)
              mod = res[3];
          } else if (args.length < 4) {
            c = args[0].compile().evaluate(scope);
            sides = args[1].toString().trim();
            if (sides !== "F" && sides !== "%")
              sides = args[1].compile().evaluate(scope);
            if (args.length > 2)
              mod = args[2].compile().evaluate(scope);
          } else
            throw new Error("Too many arguments for dicemax");
          if (sides === "F" || sides === "f")
            max2 = 1;
          else if (sides === "%")
            max2 = 1;
          else
            max2 = parseInt(sides);
          if (mod)
            return math2.evaluate(max2 * c + mod, scope);
          return max2 * c;
        },
        dicedev: (args, math2, scope) => {
          let res;
          let c;
          let sides;
          let mod;
          let max2;
          if (args.length === 0) throw new Error("Invalid arguments for dicedev");
          if (args.length === 1) {
            res = this._getDiceArguments(args[0], scope, "dicedev");
            c = parseInt(res[1]);
            sides = res[2];
            if (res.length > 3)
              mod = res[3];
          } else if (args.length < 4) {
            c = args[0].compile().evaluate(scope);
            sides = args[1].toString().trim();
            if (sides !== "F" && sides !== "%")
              sides = args[1].compile().evaluate(scope);
            if (args.length > 2)
              mod = args[2].compile().evaluate(scope);
          } else
            throw new Error("Too many arguments for dicedev");
          if (sides === "F" || sides === "f")
            max2 = 6;
          else if (sides === "%")
            max2 = 1;
          else
            max2 = parseInt(sides);
          if (mod)
            return math2.evaluate(Math.sqrt((max2 * max2 - 1) / 12 * c) + mod, scope);
          return Math.sqrt((max2 * max2 - 1) / 12 * c);
        },
        zdicedev: (args, math2, scope) => {
          let res;
          let c;
          let sides;
          let mod;
          let max2;
          if (args.length === 0) throw new Error("Invalid arguments for zdicedev");
          if (args.length === 1) {
            res = this._getDiceArguments(args[0], scope, "zdicedev");
            c = parseInt(res[1]);
            sides = res[2];
            if (res.length > 3)
              mod = res[3];
          } else if (args.length < 4) {
            c = args[0].compile().evaluate(scope);
            sides = args[1].toString().trim();
            if (sides !== "F" && sides !== "%")
              sides = args[1].compile().evaluate(scope);
            if (args.length > 2)
              mod = args[2].compile().evaluate(scope);
          } else
            throw new Error("Too many arguments for zdicedev");
          if (sides === "F" || sides === "f")
            max2 = 6;
          else if (sides === "%")
            max2 = 1;
          else
            max2 = parseInt(sides);
          max2--;
          if (mod)
            return math2.evaluate(Math.sqrt((max2 * max2 - 1) / 12 * c) + mod, scope);
          return Math.sqrt((max2 * max2 - 1) / 12 * c);
        },
        dice: (args, math2, scope) => {
          let res;
          let c;
          let sides;
          let mod;
          if (args.length === 1) {
            res = this._getDiceArguments(args[0], scope, "dice");
            c = parseInt(res[1]);
            sides = res[2];
            if (res.length > 3)
              mod = res[3];
          } else if (args.length > 1) {
            c = args[0].compile().evaluate(scope);
            sides = args[1].toString().trim();
            if (sides !== "F" && sides !== "%")
              sides = args[1].compile().evaluate(scope);
            if (args.length > 2)
              mod = args[2].compile().evaluate(scope);
          } else
            throw new Error("Invalid arguments for dice");
          let sum = 0;
          for (let i2 = 0; i2 < c; i2++) {
            if (sides === "F" || sides === "f")
              sum += fudgeDice();
            else if (sides === "%")
              sum += ~~(Math.random() * 100) + 1;
            else
              sum += ~~(Math.random() * sides) + 1;
          }
          if (sides === "%")
            sum /= 100;
          if (mod)
            return math2.evaluate(sum + mod, scope);
          return sum;
        },
        isdefined: (args, math2, scope) => {
          if (args.length === 1) {
            args[0] = this.stripQuotes(args[0].toString());
            if (this.client.variables.hasOwnProperty(args[0]))
              return 1;
            if (scope.has(args[0]))
              return 1;
            return 0;
          }
          throw new Error("Invalid arguments for isdefined");
        },
        defined: (args, math2, scope) => {
          let sides;
          if (args.length === 0)
            throw new Error("Missing arguments for defined");
          else if (args.length === 1) {
            args[0] = this.stripQuotes(args[0], true);
            const keys = this.client.profiles.keys;
            let k = 0;
            const kl = keys.length;
            if (kl === 0) return 0;
            for (; k < kl; k++) {
              sides = SortItemArrayByPriority(this.client.profiles.items[keys[k]].aliases);
              sides = sides.find((i2) => {
                return i2.pattern === args[0];
              });
              if (sides) return 1;
              sides = SortItemArrayByPriority(this.client.profiles.items[keys[k]].triggers);
              sides = sides.find((i2) => {
                return i2.pattern === args[0] || i2.name === args[0];
              });
              if (sides) return 1;
              sides = SortItemArrayByPriority(this.client.profiles.items[keys[k]].macros);
              sides = sides.find((i2) => {
                return MacroDisplay(i2).toLowerCase() === args[0].toLowerCase() || i2.name === args[0];
              });
              if (sides) return 1;
              sides = SortItemArrayByPriority(this.client.profiles.items[keys[k]].aliases);
              sides = sides.find((i2) => {
                return i2.caption === args[0] || i2.name === args[0];
              });
              if (sides) return 1;
            }
            return this.client.variables.hasOwnProperty(args[0]);
          } else if (args.length === 2) {
            args[0] = this.stripQuotes(args[0].toString());
            args[0] = this.stripQuotes(args[1].toString());
            const keys = this.client.profiles.keys;
            let k = 0;
            const kl = keys.length;
            if (kl === 0) return 0;
            for (; k < kl; k++) {
              switch (args[1]) {
                case "alias":
                  sides = SortItemArrayByPriority(this.client.profiles.items[keys[k]].aliases);
                  sides = sides.find((i2) => {
                    return i2.pattern === args[0];
                  });
                  if (sides) return 1;
                  return 0;
                case "event":
                  sides = SortItemArrayByPriority(this.client.profiles.items[keys[k]].triggers);
                  sides = sides.find((i2) => {
                    return i2.type === 2 /* Event */ && (i2.pattern === args[0] || i2.name === args[0]);
                  });
                  if (sides) return 1;
                  return 0;
                case "trigger":
                  sides = SortItemArrayByPriority(this.client.profiles.items[keys[k]].triggers);
                  sides = sides.find((i2) => {
                    return i2.pattern === args[0] || i2.name === args[0];
                  });
                  if (sides) return 1;
                  return 0;
                case "macro":
                  sides = SortItemArrayByPriority(this.client.profiles.items[keys[k]].macros);
                  sides = sides.find((i2) => {
                    return MacroDisplay(i2).toLowerCase() === args[0].toLowerCase() || i2.name === args[0];
                  });
                  if (sides) return 1;
                  return 0;
                case "button":
                  sides = SortItemArrayByPriority(this.client.profiles.items[keys[k]].aliases);
                  sides = sides.find((i2) => {
                    return i2.caption === args[0] || i2.name === args[0];
                  });
                  if (sides) return 1;
                  return 0;
              }
            }
            if (args[1] === "variable")
              return this.client.variables.hasOwnProperty(args[0]) || scope.has(args[0]);
          } else
            throw new Error("Too many arguments for defined");
          return 0;
        },
        time: (args, math2, scope) => {
          if (args.length > 1)
            throw new Error("Too many arguments for time");
          if (!moment) return (/* @__PURE__ */ new Date()).toISOString();
          if (args.length)
            return moment().format(args[0].compile().evaluate(scope));
          return moment().format();
        },
        clip: (args, math2, scope) => {
          if (args.length > 1)
            throw new Error("Too many arguments for clip");
          if (args.length) {
            this.client.writeClipboard(args[0].compile().evaluate(scope));
            return;
          }
          return this.client.readClipboard();
        },
        if: (args, math2, scope) => {
          if (args.length < 3)
            throw new Error("Missing arguments for if");
          if (args.length !== 3)
            throw new Error("Too many arguments for if");
          if (args[0].compile().evaluate(scope))
            return args[1].compile().evaluate(scope);
          return args[2].compile().evaluate(scope);
        },
        len: (args, math2, scope) => {
          if (args.length === 0)
            throw new Error("Missing arguments for len");
          if (args.length !== 1)
            throw new Error("Too many arguments for len");
          return args[0].compile().evaluate(scope).toString().length;
        },
        stripansi: (args, math2, scope) => {
          if (args.length === 0)
            throw new Error("Missing arguments for len");
          if (args.length !== 1)
            throw new Error("Too many arguments for len");
          const ansiRegex = new RegExp("[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))", "g");
          return args[0].compile().evaluate(scope).toString().replace(ansiRegex, "");
        },
        ansi: (args, math2, scope) => {
          if (args.length === 0)
            throw new Error("Missing arguments for ansi");
          args = args.map(
            (a) => getAnsiCode(a.toString()) === -1 && a.toString() !== "current" ? a.compile().evaluate(scope).toString() : a.toString()
          );
          const c = args.length;
          let mod = [];
          let min = {};
          let sides;
          let max2;
          for (sides = 0; sides < c; sides++) {
            if (args[sides].trim() === "current")
              mod.push(args[sides].trim());
            else {
              max2 = getAnsiCode(args[sides].trim());
              if (max2 === -1)
                throw new Error("Invalid color or style for ansi");
              if (max2 >= 0 && max2 < 30)
                min[max2] = 1;
              else
                mod.push(args[sides]);
            }
          }
          if (mod.length > 2)
            throw new Error("Too many colors for ansi");
          if (mod.length > 1) {
            if (mod[1] === "current")
              mod[1] = "";
            else
              mod[1] = getAnsiCode(mod[1], true);
          }
          if (mod.length > 0) {
            if (min[1] && mod[0] === "white")
              mod[0] = "";
            else if (mod[0] === "current")
              mod[0] = "";
            else
              mod[0] = getAnsiCode(mod[0]);
          }
          min = [...Object.keys(min), ...mod];
          if (!min.length)
            throw new Error("Invalid colors or styles for ansi");
          min = min.filter((f) => f !== "");
          return `\x1B[${min.join(";")}m`;
        },
        color: (args, math2, scope) => {
          if (args.length === 0)
            throw new Error("Missing arguments for color");
          args = args.map(
            (a) => getAnsiCode(a.toString()) === -1 && a.toString() !== "current" ? a.compile().evaluate(scope).toString() : a.toString()
          );
          let c;
          let sides;
          if (args.length === 1) {
            if (args[0] === "bold")
              return "370";
            c = getAnsiColorCode(args[0]);
            if (c === -1)
              throw new Error("Invalid fore color");
            return c.toString();
          } else if (args.length === 2) {
            if (args[0] === "bold")
              c = 370;
            else {
              c = getAnsiColorCode(args[0]);
              if (c === -1)
                throw new Error("Invalid fore color");
              if (args[1] === "bold")
                return (c * 10).toString();
            }
            sides = c.toString();
            c = getAnsiColorCode(args[1], true);
            if (c === -1)
              throw new Error("Invalid back color");
            return sides + "," + c.toString();
          } else if (args.length === 3) {
            if (args[0] === "bold") {
              args.shift();
              args.push("bold");
            }
            if (args[2] !== "bold")
              throw new Error("Only bold is supported as third argument for color");
            c = getAnsiColorCode(args[0]);
            if (c === -1)
              throw new Error("Invalid fore color");
            sides = (c * 10).toString();
            c = getAnsiColorCode(args[1], true);
            if (c === -1)
              throw new Error("Invalid back color");
            return sides + "," + c.toString();
          }
          throw new Error("Too many arguments");
        },
        zcolor: (args, math2, scope) => {
          if (args.length === 0)
            throw new Error("Missing arguments for zcolor");
          else if (args.length > 1)
            throw new Error("Too many arguments for zcolor");
          return getColorCode(parseInt(args[0].compile().evaluate(scope), 10));
        },
        case: (args, math2, scope) => {
          if (args.length === 0)
            throw new Error("Missing arguments for case");
          let i2 = args[0].compile().evaluate(scope);
          if (i2 > 0 && i2 < args.length)
            return args[i2].compile().evaluate(scope);
          return null;
        },
        switch: (args, math2, scope) => {
          if (args.length === 0)
            throw new Error("Missing arguments for switch");
          if (args.length % 2 === 1)
            throw new Error("All expressions must have a value for switch");
          let i2 = args.length;
          for (let c = 0; c < i2; c += 2) {
            if (args[c].compile().evaluate(scope))
              return args[c + 1].compile().evaluate(scope);
          }
          return null;
        },
        ascii: (args, math2, scope) => {
          if (args.length === 0)
            throw new Error("Missing arguments for ascii");
          else if (args.length > 1)
            throw new Error("Too many arguments for ascii");
          if (args[0].toString().trim().length === 0)
            throw new Error("Invalid argument, empty string for ascii");
          return args[0].toString().trim().charCodeAt(0);
        },
        char: (args, math2, scope) => {
          if (args.length === 0)
            throw new Error("Missing arguments for char");
          else if (args.length > 1)
            throw new Error("Too many arguments for char");
          let c = args[0].compile().evaluate(scope);
          if (isNaN(c))
            throw new Error("Invalid argument '" + args[0].toString() + "' must be a number for char");
          return String.fromCharCode(c);
        },
        bitand: (args, math2, scope) => {
          if (args.length === 0)
            throw new Error("Missing arguments for bitand");
          else if (args.length !== 2)
            throw new Error("Too many arguments for bitand");
          let c = args[0].compile().evaluate(scope);
          if (isNaN(c))
            throw new Error("Invalid argument '" + args[0].toString() + "' must be a number for bitand");
          let sides = args[1].compile().evaluate(scope);
          if (isNaN(sides))
            throw new Error("Invalid argument '" + args[1].toString() + "' must be a number for bitand");
          return c & sides;
        },
        bitnot: (args, math2, scope) => {
          if (args.length === 0)
            throw new Error("Missing arguments for bitnot");
          else if (args.length !== 1)
            throw new Error("Too many arguments for bitnot");
          let c = args[0].compile().evaluate(scope);
          if (isNaN(c))
            throw new Error("Invalid argument '" + args[0].toString() + "' must be a number for bitnot");
          return ~c;
        },
        bitor: (args, math2, scope) => {
          if (args.length === 0)
            throw new Error("Missing arguments for bitor");
          else if (args.length !== 2)
            throw new Error("Too many arguments for bitor");
          let c = args[0].compile().evaluate(scope);
          if (isNaN(c))
            throw new Error("Invalid argument '" + args[0].toString() + "' must be a number for bitor");
          let sides = args[1].compile().evaluate(scope);
          if (isNaN(sides))
            throw new Error("Invalid argument '" + args[1].toString() + "' must be a number for bitor");
          return c | sides;
        },
        bitset: (args, math2, scope) => {
          if (args.length === 0)
            throw new Error("Missing arguments for bitset");
          else if (args.length > 3)
            throw new Error("Too many arguments for bitset");
          let c = args[0].compile().evaluate(scope);
          if (isNaN(c))
            throw new Error("Invalid argument '" + args[0].toString() + "' must be a number for bitset");
          let sides = args[1].compile().evaluate(scope);
          if (isNaN(sides))
            throw new Error("Invalid argument '" + args[1].toString() + "' must be a number for bitset");
          sides--;
          let mod = 1;
          if (args.length === 3) {
            mod = args[2].compile().evaluate(scope);
            if (isNaN(mod))
              throw new Error("Invalid argument '" + args[2].toString() + "' must be a number for bitset");
          }
          return c & ~(1 << sides) | (mod ? 1 : 0) << sides;
        },
        bitshift: (args, math2, scope) => {
          if (args.length === 0)
            throw new Error("Missing arguments for bitshift");
          else if (args.length !== 2)
            throw new Error("Too many arguments for bitshift");
          let c = args[0].compile().evaluate(scope);
          if (isNaN(c))
            throw new Error("Invalid argument '" + args[0].toString() + "' must be a number for bitshift");
          let sides = args[1].compile().evaluate(scope);
          if (isNaN(sides))
            throw new Error("Invalid argument '" + args[1].toString() + "' must be a number for bitshift");
          if (sides < 0)
            return c >> -sides;
          return c << sides;
        },
        bittest: (args, math2, scope) => {
          if (args.length === 0)
            throw new Error("Missing arguments for bittest");
          else if (args.length !== 2)
            throw new Error("Too many arguments for bittest");
          let c = args[0].compile().evaluate(scope);
          if (isNaN(c))
            throw new Error("Invalid argument '" + args[0].toString() + "' must be a number for bittest");
          let sides = args[1].compile().evaluate(scope);
          if (isNaN(sides))
            throw new Error("Invalid argument '" + args[1].toString() + "' must be a number for bittest");
          sides--;
          return (c >> sides) % 2 != 0 ? 1 : 0;
        },
        bitxor: (args, math2, scope) => {
          if (args.length === 0)
            throw new Error("Missing arguments for bitxor");
          else if (args.length !== 2)
            throw new Error("Too many arguments for bitxor");
          let c = args[0].compile().evaluate(scope);
          if (isNaN(c))
            throw new Error("Invalid argument '" + args[0].toString() + "' must be a number for bitxor");
          let sides = args[1].compile().evaluate(scope);
          if (isNaN(sides))
            throw new Error("Invalid argument '" + args[1].toString() + "' must be a number for bitxor");
          return c ^ sides;
        },
        tonumber: (args, math2, scope) => {
          if (args.length === 0)
            throw new Error("Missing arguments for number");
          else if (args.length > 1)
            throw new Error("Too many arguments for number");
          args[0] = args[0].compile().evaluate(scope).toString();
          if (args[0].match(/^\s*?[-|+]?\d+\s*?$/))
            return parseInt(args[0], 10);
          else if (args[0].match(/^\s*?[-|+]?\d+\.\d+\s*?$/))
            return parseFloat(args[0]);
          else if (args[0] === "true")
            return 1;
          else if (args[0] === "false")
            return 0;
          return 0;
        },
        isfloat: (args, math2, scope) => {
          if (args.length === 0)
            throw new Error("Missing arguments for isfloat");
          else if (args.length > 1)
            throw new Error("Too many arguments for isfloat");
          args[0] = args[0].compile().evaluate(scope).toString();
          if (args[0].match(/^\s*?[-|+]?\d+\.\d+\s*?$/))
            return 1;
          return 0;
        },
        isnumber: (args, math2, scope) => {
          if (args.length === 0)
            throw new Error("Missing arguments for isnumber");
          else if (args.length > 1)
            throw new Error("Too many arguments for isnumber");
          args[0] = args[0].compile().evaluate(scope).toString();
          if (args[0].match(/^\s*?[-|+]?\d+\s*?$/) || args[0].match(/^\s*?[-|+]?\d+\.\d+\s*?$/))
            return 1;
          return 0;
        },
        tostring: (args, math2, scope) => {
          if (args.length === 0)
            throw new Error("Missing arguments for string");
          else if (args.length > 1)
            throw new Error("Too many arguments for string");
          return args[0].compile().evaluate(scope).toString();
        },
        float: (args, math2, scope) => {
          if (args.length === 0)
            throw new Error("Missing arguments for float");
          else if (args.length > 1)
            throw new Error("Too many arguments for float");
          args[0] = args[0].compile().evaluate(scope).toString();
          if (args[0].match(/^\s*?[-|+]?\d+\s*?$/) || args[0].match(/^\s*?[-|+]?\d+\.\d+\s*?$/))
            return parseFloat(args[0]);
          else if (args[0] === "true")
            return 1;
          else if (args[0] === "false")
            return 0;
          return 0;
        },
        trim: (args, math2, scope) => {
          if (args.length !== 1)
            throw new Error("Missing arguments for trim");
          return args[0].compile().evaluate(scope).toString().trim();
        },
        trimleft: (args, math2, scope) => {
          if (args.length !== 1)
            throw new Error("Missing arguments for trimleft");
          return args[0].compile().evaluate(scope).toString().trimLeft();
        },
        trimright: (args, math2, scope) => {
          if (args.length !== 1)
            throw new Error("Missing arguments for trimright");
          return args[0].compile().evaluate(scope).toString().trimRight();
        },
        pos: (args, math2, scope) => {
          if (args.length < 2)
            throw new Error("Missing arguments for pos");
          else if (args.length > 2)
            throw new Error("Too many arguments for pos");
          args[0] = args[0].compile().evaluate(scope).toString();
          args[1] = args[1].compile().evaluate(scope).toString();
          return args[1].indexOf(args[0]) + 1;
        },
        ipos: (args, math2, scope) => {
          if (args.length < 2)
            throw new Error("Missing arguments for pos");
          else if (args.length > 2)
            throw new Error("Too many arguments for pos");
          args[0] = args[0].compile().evaluate(scope).toString().toLowerCase();
          args[1] = args[1].compile().evaluate(scope).toString().toLowerCase();
          return args[1].indexOf(args[0]) + 1;
        },
        ends: (args, math2, scope) => {
          if (args.length < 2)
            throw new Error("Missing arguments for ends");
          else if (args.length > 2)
            throw new Error("Too many arguments for ends");
          args[0] = args[0].compile().evaluate(scope).toString().toLowerCase();
          args[1] = args[1].compile().evaluate(scope).toString().toLowerCase();
          return args[0].endsWith(args[1]);
        },
        begins: (args, math2, scope) => {
          if (args.length < 2)
            throw new Error("Missing arguments for begins");
          else if (args.length > 2)
            throw new Error("Too many arguments for begins");
          args[0] = args[0].compile().evaluate(scope).toString().toLowerCase();
          args[1] = args[1].compile().evaluate(scope).toString().toLowerCase();
          return args[0].startsWith(args[1]);
        },
        alarm: (args, math2, scope) => {
          let alarms;
          let a;
          let al;
          let t;
          let p;
          switch (args.length) {
            case 0:
              throw new Error("Missing arguments for alarm");
            case 1:
              args[0] = args[0].compile().evaluate(scope).toString();
              alarms = this.client.alarms;
              al = alarms.length;
              if (al === 0)
                throw new Error("No alarms set.");
              a = 0;
              for (; a < al; a++) {
                if (alarms[a].type !== 3 /* Alarm */) continue;
                if (alarms[a].name === args[0] || alarms[a].pattern === args[0]) {
                  if (alarms[a].suspended)
                    return 0;
                  return this.client.getRemainingAlarmTime(a);
                }
              }
              return;
            case 2:
              t = args[1].compile().evaluate(scope);
              args[0] = args[0].compile().evaluate(scope).toString();
              alarms = this.client.alarms;
              al = alarms.length;
              if (al === 0)
                throw new Error("No alarms set.");
              a = 0;
              if (typeof t === "string") {
                for (; a < al; a++) {
                  if (alarms[a].type !== 3 /* Alarm */) continue;
                  if (alarms[a].name === args[0] || alarms[a].pattern === args[0]) {
                    if (alarms[a].profile.name.toUpperCase() !== t.toUpperCase())
                      continue;
                    if (alarms[a].suspended)
                      return 0;
                    return this.client.getRemainingAlarmTime(a);
                  }
                }
                throw new Error("Alarm not found in profile: " + t + ".");
              } else {
                for (; a < al; a++) {
                  if (alarms[a].type !== 3 /* Alarm */) continue;
                  if (alarms[a].name === args[0] || alarms[a].pattern === args[0]) {
                    if (!alarms[a].suspended)
                      this.client.setAlarmTempTime(a, t);
                    return t;
                  }
                }
                throw new Error("Alarm not found.");
              }
            case 3:
              t = args[1].compile().evaluate(scope);
              args[0] = args[0].compile().evaluate(scope).toString();
              p = args[2].compile().evaluate(scope).toString();
              alarms = this.client.alarms;
              al = alarms.length;
              if (al === 0)
                throw new Error("No alarms set.");
              a = 0;
              for (; a < al; a++) {
                if (alarms[a].type !== 3 /* Alarm */) continue;
                if (alarms[a].name === args[0] || alarms[a].pattern === args[0]) {
                  if (alarms[a].profile.name.toUpperCase() !== p.toUpperCase())
                    continue;
                  if (!alarms[a].suspended)
                    this.client.setAlarmTempTime(a, t);
                  return t;
                }
              }
              throw Error("Could not set time, alarm not found in profile: " + args[2] + ".");
          }
          throw new Error("Too many arguments for alarm");
        },
        state: (args, math2, scope) => {
          let trigger;
          if (args.length === 0)
            throw new Error("Missing arguments for state");
          if (args.length > 2)
            throw new Error("Too many arguments for state");
          args[0] = args[0].compile().evaluate(scope).toString();
          if (args.length === 1) {
            const keys = this.client.profiles.keys;
            let k = 0;
            const kl = keys.length;
            if (kl === 0)
              return null;
            if (kl === 1) {
              if (!this.client.profiles.items[keys[0]].enabled || !this.client.profiles.items[keys[0]].enableTriggers)
                throw Error("No enabled profiles found!");
              trigger = SortItemArrayByPriority(this.client.profiles.items[keys[k]].triggers);
              trigger = trigger.find((t) => {
                return t.name === args[0] || t.pattern === args[0];
              });
            } else {
              for (; k < kl; k++) {
                if (!this.client.profiles.items[keys[k]].enabled || !this.client.profiles.items[keys[k]].enableTriggers || this.client.profiles.items[keys[k]].triggers.length === 0)
                  continue;
                trigger = SortItemArrayByPriority(this.client.profiles.items[keys[k]].triggers);
                trigger = trigger.find((t) => {
                  return t.name === args[0] || t.pattern === args[0];
                });
                if (trigger)
                  break;
              }
            }
          } else if (args.length === 2) {
            args[1] = args[1].compile().evaluate(scope);
            let profile;
            if (this.client.profiles.contains(args[1]))
              profile = this.client.profiles.items[args[1].toLowerCase()];
            else
              throw new Error("Profile not found: " + args[1]);
            trigger = SortItemArrayByPriority(profile.triggers);
            trigger = trigger.find((t) => {
              return t.name === args[0] || t.pattern === args[0];
            });
          }
          if (trigger)
            return trigger.triggers && trigger.triggers.length ? trigger.state : 0;
          throw new Error("Trigger not found");
        },
        isnull: (args, math2, scope) => {
          if (args.length === 0)
            return null;
          if (args.length !== 1)
            throw new Error("Too many arguments for null");
          return args[0].compile().evaluate(scope) ? 1 : 0;
        },
        escape: (args, math2, scope) => {
          if (args.length === 0)
            throw new Error("Missing arguments for unescape");
          if (args.length !== 1)
            throw new Error("Too many arguments for unescape");
          let c;
          args[0] = args[0].compile().evaluate(scope).toString();
          if (this.client.getOption("allowEscape")) {
            const escape2 = this.client.getOption("allowEscape") ? this.client.getOption("escapeChar") : "";
            c = escape2;
            if (escape2 === "\\")
              c += escape2;
            if (this.client.getOption("parseDoubleQuotes"))
              c += '"';
            if (this.client.getOption("parseSingleQuotes"))
              c += "'";
            if (this.client.getOption("commandStacking"))
              c += this.client.getOption("commandStackingChar");
            if (this.client.getOption("enableSpeedpaths"))
              c += this.client.getOption("speedpathsChar");
            if (this.client.getOption("enableCommands"))
              c += this.client.getOption("commandChar");
            if (this.client.getOption("enableVerbatim"))
              c += this.client.getOption("verbatimChar");
            if (this.client.getOption("enableDoubleParameterEscaping"))
              c += this.client.getOption("parametersChar");
            if (this.client.getOption("enableNParameters"))
              c += this.client.getOption("nParametersChar");
            return args.replace(new RegExp(`[${c}]`, "g"), escape2 + "$&");
          }
          return args.replace(/[\\"']/g, "$&");
        },
        unescape: (args, math2, scope) => {
          if (args.length === 0)
            throw new Error("Missing arguments for unescape");
          if (args.length !== 1)
            throw new Error("Too many arguments for unescape");
          let c;
          args[0] = args[0].compile().evaluate(scope).toString();
          if (this.client.getOption("allowEscape")) {
            const escape2 = this.client.getOption("allowEscape") ? this.client.getOption("escapeChar") : "";
            c = escape2;
            if (escape2 === "\\")
              c += escape2;
            if (this.client.getOption("parseDoubleQuotes"))
              c += '"';
            if (this.client.getOption("parseSingleQuotes"))
              c += "'";
            if (this.client.getOption("commandStacking"))
              c += this.client.getOption("commandStackingChar");
            if (this.client.getOption("enableSpeedpaths"))
              c += this.client.getOption("speedpathsChar");
            if (this.client.getOption("enableCommands"))
              c += this.client.getOption("commandChar");
            if (this.client.getOption("enableVerbatim"))
              c += this.client.getOption("verbatimChar");
            if (this.client.getOption("enableDoubleParameterEscaping"))
              c += this.client.getOption("parametersChar");
            if (this.client.getOption("enableNParameters"))
              c += this.client.getOption("nParametersChar");
            if (escape2 === "\\")
              return args[0].replace(new RegExp(`\\\\[${c}]`, "g"), (m) => m.substr(1));
            return args[0].replace(new RegExp(`${escape2}[${c}]`, "g"), (m) => m.substr(1));
          }
          return args[0].replace(/\\[\\"']/g, (m) => m.substr(1));
        },
        prompt: (args, math2, scope) => {
          if (args.length > 3)
            throw new Error("Too many arguments");
          if (args.length === 0)
            return window.prompt();
          args = args.map((a) => a.compile().evaluate(scope).toString());
          return window.prompt(...args);
        }
        /*
        fileprompt: (args, math, scope) => {
            if (args.length > 2)
                throw new Error('Too many arguments');
            args = args.map(a => a.compile().evaluate(scope).toString());
            let f = [
                { name: 'All files (*.*)', extensions: ['*'] },
            ];
            if (args.length > 0 && args[0].trim().length > 0) {
                f.unshift({
                    name: args[0],
                    extensions: args[0].split(',').map(a => a.trim())
                })
            }
            var files = dialog.showOpenDialogSync({
                filters: f,
                properties: ['openFile', 'promptToCreate'],
                defaultPath: args.length >= 2 ? parseTemplate(args[1]) : ''
            });
            if (files && files.length) return files[0];
        }
        */
      };
      for (let fun in functions) {
        if (!functions.hasOwnProperty(fun) || typeof functions[fun] !== "function") {
          continue;
        }
        functions[fun].rawArgs = true;
      }
      _mathjs.import(functions, {});
    }
    resetExpressionEngine() {
      if (!_mathjs) return;
      _mathjs = void 0;
    }
    async _initPads() {
      if (!this.client || !this.client.options) {
        setTimeout(this._initPads, 5);
        return;
      }
      this._controllers = [];
      this._controllersCount = 0;
      this._gamepadCaches = null;
      if (!this.client.getOption("gamepads")) return;
      const controllers = navigator.getGamepads();
      let ct = 0;
      const cl = controllers.length;
      for (; ct < cl; ct++) {
        if (!controllers[ct]) continue;
        this._controllers[controllers[ct].index] = { pad: controllers[ct], axes: clone(controllers[ct].axes), state: { axes: [], buttons: [] }, pState: { axes: [], buttons: [] } };
        this._controllersCount++;
      }
      this._updatePads();
    }
    _updatePads() {
      if (this._controllersCount === 0 || !this.client.getOption("gamepads"))
        return;
      const controllers = navigator.getGamepads();
      let c = 0;
      const cl = controllers.length;
      if (!this._gamepadCaches && cl > 0)
        this._gamepadCaches = [];
      for (; c < cl; c++) {
        const controller = controllers[c];
        if (!controller || !this._controllers[controller.index]) continue;
        const state = this._controllers[controller.index].state;
        const axes = this._controllers[controller.index].axes;
        const bl = controller.buttons.length;
        let i2;
        let macros;
        if (!this._gamepadCaches[c])
          this._gamepadCaches[c] = FilterArrayByKeyValue(this.client.macros, "gamepad", c + 1);
        macros = this._gamepadCaches[c];
        let m = 0;
        const ml = macros.length;
        if (ml === 0) continue;
        for (i2 = 0; i2 < bl; i2++) {
          let val = controller.buttons[i2];
          let pressed;
          if (typeof val === "object") {
            pressed = val.pressed;
            val = val.value;
          } else
            pressed = val >= 0.5;
          if (state.buttons[i2]) {
            if (state.buttons[i2].pressed !== pressed) {
              state.buttons[i2].pressed = pressed;
              if (!pressed) {
                for (; m < ml; m++) {
                  if (!macros[m].enabled) continue;
                  if (macros[m].key !== i2 + 1) continue;
                  if (this.ExecuteMacro(macros[m])) {
                    if (this._controllersCount > 0 || controllers.length > 0)
                      requestAnimationFrame(() => {
                        this._updatePads();
                      });
                    return;
                  }
                }
              }
            }
          } else {
            state.buttons[i2] = { pct: Math.round(val * 100), pressed };
          }
        }
        const al = controller.axes.length;
        let a = 0;
        for (i2 = 0; i2 < al; i2++) {
          if (state.axes[i2] !== controller.axes[i2] && controller.axes[i2] !== axes[i2]) {
            state.axes[i2] = controller.axes[i2];
            if (state.axes[i2] < -0.75) {
              a = -(i2 + 1);
            } else if (state.axes[i2] > 0.75) {
              a = i2 + 1;
            }
          } else if (state.axes[i2] < -0.75) {
            a = -(i2 + 1);
          } else if (state.axes[i2] > 0.75) {
            a = i2 + 1;
          }
          if (a !== 0)
            for (; m < ml; m++) {
              if (!macros[m].enabled) continue;
              if (macros[m].gamepadAxes !== i2 + 1) continue;
              if (this.ExecuteMacro(macros[m])) {
                if (this._controllersCount > 0 || controllers.length > 0)
                  requestAnimationFrame(() => {
                    this._updatePads();
                  });
                return;
              }
            }
        }
      }
      if (this._controllersCount > 0 || controllers.length > 0)
        requestAnimationFrame(() => {
          this._updatePads();
        });
    }
    adjustLastLine(n, raw) {
      if (!this.client.display.lines || this.client.display.lines.length === 0)
        return 0;
      if (raw) {
        if (n === this.client.display.lines.length) {
          n--;
          if (this.client.display.lines[n].text.length === 0 && this.client.display.lines[n].raw.length)
            n--;
        } else if (n === this.client.display.lines.length - 1 && this.client.display.lines[n].text.length === 0 && this.client.display.lines[n].raw.length)
          n--;
      } else if (n === this.client.display.lines.length) {
        n--;
        if (this.client.display.lines[n].text.length === 0)
          n--;
      } else if (n === this.client.display.lines.length - 1 && this.client.display.lines[n].text.length === 0)
        n--;
      return n;
    }
    get isLocked() {
      return this._locked === 0 ? false : true;
    }
    addLock() {
      this._locked++;
    }
    removeLock() {
      this._locked--;
    }
    AddCommandToHistory(cmd) {
      if ((this._commandHistory.length < 1 || this._commandHistory[this._commandHistory.length - 1] !== cmd) && cmd.length > 0) {
        if (this._commandHistory.length >= this.client.getOption("commandHistorySize"))
          this._commandHistory.shift();
        this._commandHistory.push(cmd);
        this.emit("command-history-changed", this._commandHistory);
      }
    }
    clearCommandHistory() {
      this._commandHistory = [];
      this._historyIdx = -1;
      this.emit("command-history-changed", this._commandHistory);
    }
    setHistoryIndex(index) {
      if (index < 0 || this._commandHistory.length === 0)
        this._historyIdx = -1;
      else if (index >= this._commandHistory.length)
        this._historyIdx = this._commandHistory.length - 1;
      else
        this._historyIdx = index;
    }
    get commandHistory() {
      return this._commandHistory;
    }
    executeScript(txt) {
      if (txt == null)
        return txt;
      let state = 0;
      let idx = 0;
      let c;
      const tl = txt.length;
      let fun = "";
      let args = [];
      let arg = "";
      let raw;
      let s = 0;
      const pd = this.client.getOption("parseDoubleQuotes");
      const ps = this.client.getOption("parseSingleQuotes");
      const cmdChar = this.client.getOption("commandChar");
      for (; idx < tl; idx++) {
        c = txt.charAt(idx);
        switch (state) {
          //find name
          case 1:
            if (c === " ") {
              state = 2;
              raw += c;
            } else {
              fun += c;
              raw += c;
            }
            break;
          //find arguments
          case 2:
            if (c === "{") {
              state = 7;
              arg += c;
            } else if (c === "(") {
              state = 8;
              arg += c;
            } else if (c === " ") {
              args.push(arg);
              arg = "";
            } else {
              if (c === '"' && pd)
                state = 3;
              else if (c === "'" && ps)
                state = 4;
              arg += c;
            }
            raw += c;
            break;
          case 3:
            if (c === '"')
              state = 2;
            arg += c;
            raw += c;
            break;
          case 4:
            if (c === "'")
              state = 2;
            arg += c;
            raw += c;
            break;
          case 7:
            arg += c;
            if (c === "}") {
              if (s === 0) {
                state = 2;
              } else
                s--;
            } else if (c === "{")
              s++;
            raw += c;
            break;
          case 8:
            arg += c;
            if (c === ")") {
              if (s === 0) {
                state = 2;
              } else
                s--;
            } else if (c === "(")
              s++;
            raw += c;
            break;
          /*
          case 5:
              if (c === '"') {
                  arg += c;
                  raw += c;
              }
              else {
                  arg += '\\';
                  raw += '\\';
                  idx--;
              }
              state = 3;
              break;
          case 6:
              if (c === '\'') {
                  arg += c;
                  raw += c;
              }
              else {
                  arg += '\\';
                  raw += '\\';
                  idx--;
              }
              state = 4;
              break;
              */
          default:
            if (idx === 0 && c === cmdChar) {
              state = 1;
              fun = "";
              args = [];
              arg = "";
              raw = c;
            } else
              return txt;
            break;
        }
      }
      if (fun.length > 0) {
        if (arg.endsWith("\n"))
          arg = arg.substring(0, arg.length - 1);
        if (arg.length > 0) args.push(arg);
        return this.executeFunction(fun, args, raw, cmdChar);
      }
      return txt;
    }
    executeFunction(fun, args, raw, cmdChar) {
      let n;
      let f = false;
      let items;
      let al;
      let i2;
      let tmp;
      let profile = null;
      let name2 = null;
      let item;
      let p;
      let reload;
      let trigger;
      switch (fun.toLowerCase()) {
        //spell-checker:ignore untrigger unaction
        case "unaction":
        case "untrigger":
        case "unt":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          profile = null;
          name2 = null;
          reload = true;
          if (args.length < 1 || args.length > 2)
            throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "unt\x1B[0;-11;-12mrigger {pattern|name} \x1B[3mprofile\x1B[0;-11;-12m");
          if (args[0].length === 0)
            throw new Error("Invalid name or pattern");
          if (args[0].match(/^\{.*\}$/g))
            args[0] = this.parseInline(args[0].substr(1, args[0].length - 2));
          else
            args[0] = this.parseInline(this.stripQuotes(args[0]));
          if (args.length === 2) {
            profile = this.stripQuotes(args[2]);
            profile = this.parseInline(profile);
          }
          if (!profile || profile.length === 0) {
            const keys = this.client.profiles.keys;
            let k = 0;
            const kl = keys.length;
            if (kl === 0)
              return null;
            if (kl === 1) {
              if (!this.client.profiles.items[keys[0]].enabled || !this.client.profiles.items[keys[0]].enableTriggers)
                throw Error("No enabled profiles found!");
              item = this.client.profiles.items[keys[k]].findAny("triggers", { name: args[0], pattern: args[0] });
            } else {
              for (; k < kl; k++) {
                if (!this.client.profiles.items[keys[k]].enabled || !this.client.profiles.items[keys[k]].enableTriggers || this.client.profiles.items[keys[k]].triggers.length === 0)
                  continue;
                item = this.client.profiles.items[keys[k]].findAny("triggers", { name: args[0], pattern: args[0] });
                if (item) {
                  profile = this.client.profiles.items[keys[k]];
                  break;
                }
              }
            }
            if (!item)
              throw new Error("Trigger '" + args[0] + "' not found in '" + profile.name + "'!");
            this.client.removeTrigger(item);
            this.client.echo("Trigger '" + args[0] + "' removed from '" + profile.name + "'.", -7, -8, true, true);
          } else {
            profile = this.parseInline(profile);
            if (this.client.profiles.contains(profile)) {
              profile = this.client.profiles.items[profile.toLowerCase()];
              item = profile.findAny("triggers", { name: args[0], pattern: args[0] });
              if (!item)
                throw new Error("Trigger '" + args[0] + "' not found in '" + profile.name + "'!");
              this.client.removeTrigger(item);
              this.client.echo("Trigger '" + args[0] + "' removed from '" + profile.name + "'.", -7, -8, true, true);
            } else
              throw new Error("Profile not found: " + profile);
          }
          return null;
        case "suspend":
        case "sus":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          switch (args.length) {
            case 0:
              tmp = this.client.alarms;
              if (tmp.length === 0)
                this.client.echo("No alarms defined.", -7, -8, true, true);
              else {
                this.client.setAlarmState(0, false);
                this._lastSuspend = 0;
                this.client.echo("Last alarm suspended.", -7, -8, true, true);
              }
              return null;
            case 1:
              items = this.parseInline(this.stripQuotes(args[0]));
              tmp = this.client.alarms;
              al = tmp.length;
              for (let a = tmp.length - 1; a >= 0; a--) {
                if (tmp[a].name === items || tmp[a].pattern === items) {
                  this.client.setAlarmState(a, false);
                  this.client.echo("Alarm '" + items + "' suspended.", -7, -8, true, true);
                  this._lastSuspend = a;
                  break;
                }
              }
              return null;
            default:
              throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "sus\x1B[0;-11;-12mpend id \x1B[3mprofile\x1B[0;-11;-12m or \x1B[4m" + cmdChar + "sus\x1B[0;-11;-12mpend");
          }
        case "resume":
        case "resu":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          switch (args.length) {
            case 0:
              if (this._lastSuspend === -1)
                return null;
              this.client.setAlarmState(this._lastSuspend, true);
              this.client.echo("Last alarm suspended resumed.", -7, -8, true, true);
              this._lastSuspend = -1;
              return null;
            case 1:
              items = this.parseInline(this.stripQuotes(args[0]));
              tmp = this.client.alarms;
              al = tmp.length;
              for (let a = al - 1; a >= 0; a--) {
                if (tmp[a].name === items || tmp[a].pattern === items) {
                  this.client.setAlarmState(a, true);
                  this.client.echo("Alarm '" + items + "' resumed.", -7, -8, true, true);
                  break;
                }
              }
              return null;
            default:
              throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "resu\x1B[0;-11;-12mme id \x1B[3mprofile\x1B[0;-11;-12m or \x1B[4m" + cmdChar + "resu\x1B[0;-11;-12mme");
          }
        case "action":
        case "ac":
        case "trigger":
        case "tr":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          item = {
            profile: null,
            name: null,
            pattern: null,
            commands: null,
            options: { priority: 0 }
          };
          if (args.length < 2 || args.length > 5)
            throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "tr\x1B[0;-11;-12migger name {pattern} {commands} \x1B[3moptions profile\x1B[0;-11;-12m or \x1B[4m" + cmdChar + "tr\x1B[0;-11;-12migger {pattern} {commands} \x1B[3m{options} profile\x1B[0;-11;-12m");
          if (args[0].length === 0)
            throw new Error("Invalid trigger name or pattern");
          if (args[0].match(/^\{.*\}$/g)) {
            item.pattern = args.shift();
            item.pattern = this.parseInline(item.pattern.substr(1, item.pattern.length - 2));
          } else {
            item.name = this.parseInline(this.stripQuotes(args.shift()));
            if (!item.name || item.name.length === 0)
              throw new Error("Invalid trigger name");
            if (args[0].match(/^\{.*\}$/g)) {
              item.pattern = args.shift();
              item.pattern = this.parseInline(item.pattern.substr(1, item.pattern.length - 2));
            }
          }
          if (args.length !== 0) {
            if (args[0].match(/^\{[\s\S]*\}$/g)) {
              item.commands = args.shift();
              item.commands = item.commands.substr(1, item.commands.length - 2);
            }
            if (args.length === 1) {
              if (args[0].match(/^\{[\s\S]*\}$/g))
                args[0] = args[0].substr(1, args[0].length - 2);
              else
                args[0] = this.stripQuotes(args[0]);
              if (args[0].length !== 0) {
                this.parseInline(args[0]).split(",").forEach((o) => {
                  switch (o.trim()) {
                    case "nocr":
                    case "prompt":
                    case "case":
                    case "verbatim":
                    case "disable":
                    case "enable":
                    case "cmd":
                    case "temporary":
                    case "temp":
                    case "raw":
                    case "pattern":
                    case "regular":
                    case "alarm":
                    case "event":
                    case "cmdpattern":
                    case "loopexpression":
                      item.options[o.trim()] = true;
                      break;
                    default:
                      if (o.trim().startsWith("param=")) {
                        tmp = o.trim().split("=");
                        if (tmp.length !== 2)
                          throw new Error(`Invalid trigger param option '${o.trim()}'`);
                        item.options["params"] = tmp[1];
                      } else if (o.trim().startsWith("type=")) {
                        tmp = o.trim().split("=");
                        if (tmp.length !== 2)
                          throw new Error(`Invalid trigger type option '${o.trim()}'`);
                        if (!this._isTriggerType(tmp[1], 1 /* Main */))
                          throw new Error("Invalid trigger type");
                        item.options["type"] = tmp[1];
                      } else if (o.trim().startsWith("pri=") || o.trim().startsWith("priority=")) {
                        tmp = o.trim().split("=");
                        if (tmp.length !== 2)
                          throw new Error(`Invalid trigger priority option '${o.trim()}'`);
                        i2 = parseInt(tmp[1], 10);
                        if (isNaN(i2))
                          throw new Error("Invalid trigger priority value '" + tmp[1] + "' must be a number");
                        item.options["priority"] = i2;
                      } else
                        throw new Error(`Invalid trigger option '${o.trim()}'`);
                  }
                });
              } else
                throw new Error("Invalid trigger options");
            } else if (args.length === 2) {
              if (args[0].match(/^\{[\s\S]*\}$/g))
                args[0] = args[0].substr(1, args[0].length - 2);
              if (args[0].length !== 0) {
                this.parseInline(args[0]).split(",").forEach((o) => {
                  switch (o.trim()) {
                    case "nocr":
                    case "prompt":
                    case "case":
                    case "verbatim":
                    case "disable":
                    case "enable":
                    case "cmd":
                    case "temporary":
                    case "temp":
                    case "raw":
                    case "pattern":
                    case "regular":
                    case "alarm":
                    case "event":
                    case "cmdpattern":
                    case "loopexpression":
                      item.options[o.trim()] = true;
                      break;
                    default:
                      if (o.trim().startsWith("param=")) {
                        tmp = o.trim().split("=");
                        if (tmp.length !== 2)
                          throw new Error(`Invalid trigger param option '${o.trim()}'`);
                        item.options["params"] = tmp[1];
                      } else if (o.trim().startsWith("type=")) {
                        tmp = o.trim().split("=");
                        if (tmp.length !== 2)
                          throw new Error(`Invalid trigger type option '${o.trim()}'`);
                        if (!this._isTriggerType(tmp[1], 1 /* Main */))
                          throw new Error("Invalid trigger type");
                        item.options["type"] = tmp[1];
                      } else if (o.trim().startsWith("pri=") || o.trim().startsWith("priority=")) {
                        tmp = o.trim().split("=");
                        if (tmp.length !== 2)
                          throw new Error(`Invalid trigger priority option '${o.trim()}'`);
                        i2 = parseInt(tmp[1], 10);
                        if (isNaN(i2))
                          throw new Error("Invalid trigger priority value '" + tmp[1] + "' must be a number");
                        item.options["priority"] = i2;
                      } else
                        throw new Error(`Invalid trigger option '${o.trim()}'`);
                  }
                });
              } else
                throw new Error("Invalid trigger options");
              item.profile = this.stripQuotes(args[1]);
              if (item.profile.length !== 0)
                item.profile = this.parseInline(item.profile);
            }
          }
          this.createTrigger(item.pattern, item.commands, item.profile, item.options, item.name);
          return null;
        case "event":
        case "ev":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          profile = null;
          reload = true;
          item = {
            profile: null,
            name: null,
            pattern: null,
            commands: null,
            options: { priority: 0 }
          };
          if (args.length < 2 || args.length > 4)
            throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "ev\x1B[0;-11;-12ment name {commands} \x1B[3moptions profile\x1B[0;-11;-12m");
          if (args[0].length === 0)
            throw new Error("Invalid event name");
          item.name = this.parseInline(this.stripQuotes(args.shift()));
          if (!item.name || item.name.length === 0)
            throw new Error("Invalid event name");
          if (args.length === 0)
            throw new Error("Missing commands or options");
          if (args[0].match(/^\{[\s\S]*\}$/g)) {
            item.commands = args.shift();
            item.commands = item.commands.substr(1, item.commands.length - 2);
          } else
            throw new Error("Missing commands");
          if (args.length === 1) {
            args[0] = args[0].substr(1, args[0].length - 2);
            if (args[0].length !== 0) {
              this.parseInline(args[0]).split(",").forEach((o) => {
                switch (o.trim()) {
                  case "nocr":
                  case "prompt":
                  case "case":
                  case "verbatim":
                  case "disable":
                  case "temporary":
                  case "temp":
                    item.options[o.trim()] = true;
                    break;
                  default:
                    if (o.trim().startsWith("pri=") || o.trim().startsWith("priority=")) {
                      tmp = o.trim().split("=");
                      if (tmp.length !== 2)
                        throw new Error(`Invalid event priority option '${o.trim()}'`);
                      i2 = parseInt(tmp[1], 10);
                      if (isNaN(i2))
                        throw new Error("Invalid event priority value '" + tmp[1] + "' must be a number");
                      item.options["priority"] = i2;
                    } else
                      throw new Error(`Invalid event option '${o.trim()}'`);
                }
              });
            } else
              throw new Error("Invalid event options");
          } else if (args.length === 2) {
            if (args[0].match(/^\{[\s\S]*\}$/g))
              args[0] = args[0].substr(1, args[0].length - 2);
            if (args[0].length !== 0) {
              this.parseInline(args[0]).split(",").forEach((o) => {
                switch (o.trim()) {
                  case "nocr":
                  case "prompt":
                  case "case":
                  case "verbatim":
                  case "disable":
                  case "temporary":
                  case "temp":
                    item.options[o.trim()] = true;
                    break;
                  default:
                    if (o.trim().startsWith("pri=") || o.trim().startsWith("priority=")) {
                      tmp = o.trim().split("=");
                      if (tmp.length !== 2)
                        throw new Error(`Invalid event priority option '${o.trim()}'`);
                      i2 = parseInt(tmp[1], 10);
                      if (isNaN(i2))
                        throw new Error("Invalid event priority value '" + tmp[1] + "' must be a number");
                      item.options["priority"] = i2;
                    } else
                      throw new Error(`Invalid event option '${o.trim()}'`);
                }
              });
            } else
              throw new Error("Invalid event options");
            item.profile = this.stripQuotes(args[1]);
            if (item.profile.length !== 0)
              item.profile = this.parseInline(item.profile);
          }
          if (!item.profile || item.profile.length === 0) {
            const keys = this.client.profiles.keys;
            let k = 0;
            const kl = keys.length;
            if (kl === 0)
              return null;
            if (kl === 1) {
              if (!this.client.profiles.items[keys[0]].enabled || !this.client.profiles.items[keys[0]].enableTriggers)
                throw Error("No enabled profiles found!");
              profile = this.client.profiles.items[keys[0]];
              tmp = SortItemArrayByPriority(this.client.profiles.items[keys[k]].triggers.filter((t) => t.type === 2 /* Event */));
              trigger = tmp.find((t) => {
                return t.name === item.name || t.pattern === item.name;
              });
            } else {
              for (; k < kl; k++) {
                if (!this.client.profiles.items[keys[k]].enabled || !this.client.profiles.items[keys[k]].enableTriggers || this.client.profiles.items[keys[k]].triggers.length === 0)
                  continue;
                tmp = SortItemArrayByPriority(this.client.profiles.items[keys[k]].triggers.filter((t) => t.type === 2 /* Event */));
                trigger = tmp.find((t) => {
                  return t.name === item.name || t.pattern === item.name;
                });
                if (trigger) {
                  profile = this.client.profiles.items[keys[k]];
                  break;
                }
              }
              if (!profile)
                profile = this.client.activeProfile;
            }
          } else {
            if (this.client.profiles.contains(item.profile))
              profile = this.client.profiles.items[item.profile.toLowerCase()];
            else
              throw new Error("Profile not found: " + item.profile);
            trigger = tmp.find((t) => {
              return t.name === item.name || t.pattern === item.name;
            });
          }
          if (!trigger) {
            trigger = new Trigger();
            trigger.name = item.name;
            profile.triggers.push(trigger);
            this.client.echo("Event '" + trigger.name + "' added.", -7, -8, true, true);
            item.new = true;
          } else
            this.client.echo("Event '" + trigger.name + "' updated.", -7, -8, true, true);
          trigger.pattern = item.name;
          if (item.commands !== null)
            trigger.value = item.commands;
          trigger.type = 2 /* Event */;
          if (item.options.prompt)
            trigger.triggerPrompt = true;
          if (item.options.nocr)
            trigger.triggerNewline = false;
          if (item.options.case)
            trigger.caseSensitive = true;
          if (item.options.raw)
            trigger.raw = true;
          if (item.options.verbatim)
            trigger.verbatim = true;
          if (item.options.disable)
            trigger.enabled = false;
          else if (item.options.enable)
            trigger.enabled = true;
          if (item.options.temporary || item.options.temp)
            trigger.temp = true;
          trigger.priority = item.options.priority;
          this.client.saveProfiles();
          if (reload)
            this.client.clearCache();
          if (item.new)
            this.emit("item-added", "trigger", profile.name, trigger);
          else
            this.emit("item-updated", "trigger", profile.name, profile.triggers.indexOf(trigger), trigger);
          profile = null;
          return null;
        case "unevent":
        case "une":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          if (args.length === 0)
            throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "une\x1B[0;-11;-12mvent name or \x1B[4m" + cmdChar + "une\x1B[0;-11;-12mvent {name} \x1B[3mprofile\x1B[0;-11;-12m");
          else {
            reload = true;
            profile = null;
            if (args[0].match(/^\{.*\}$/g) || args[0].match(/^".*"$/g) || args[0].match(/^'.*'$/g)) {
              if (args.length > 2)
                throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "une\x1B[0;-11;-12mvent name or \x1B[4m" + cmdChar + "une\x1B[0;-11;-12mvent {name} \x1B[3mprofile\x1B[0;-11;-12m");
              if (args.length === 2) {
                profile = this.parseInline(this.stripQuotes(args[1])).toLowerCase();
                if (this.client.profiles.contains(profile))
                  profile = this.client.profiles.items[profile];
                else
                  throw new Error("Profile not found: " + profile);
              } else
                profile = this.client.activeProfile;
              if (args[0].match(/^".*"$/g) || args[0].match(/^'.*'$/g))
                n = this.parseInline(this.stripQuotes(args[0]));
              else
                n = this.parseInline(args[0].substr(1, args[0].length - 2));
            } else {
              n = this.parseInline(args.join(" "));
              profile = this.client.activeProfile;
            }
            items = SortItemArrayByPriority(profile.triggers.filter((t) => t.type === 2 /* Event */));
            n = this.stripQuotes(n);
            tmp = n;
            n = items.findIndex((i3) => i3.pattern === n || i3.name === n);
            f = n !== -1;
            if (!f)
              this.client.echo("Event '" + tmp + "' not found.", -7, -8, true, true);
            else {
              this.client.echo("Event '" + (items[n].name || items[n].pattern) + "' removed.", -7, -8, true, true);
              if (reload)
                this.client.removeTrigger(items[n]);
              else {
                n = profile.triggers.indexOf(items[n]);
                profile.triggers.splice(n, 1);
                this.client.saveProfiles();
                this.emit("item-removed", "trigger", profile.name, n);
              }
              profile = null;
            }
          }
          return null;
        //#endregion
        case "button":
        case "bu":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          if (args.length === 1) {
            n = this.parseInline(this.stripQuotes(args[0]));
            items = document.getElementById("user-buttons").children;
            if (/^\s*?\d+\s*?$/.exec(n)) {
              n = parseInt(n, 10);
              if (n < 0 || n >= items.length)
                throw new Error("Button index must be >= 0 and < " + items.length);
              else
                items[n].click();
            } else if (items[n])
              items[n].click();
            else
              throw new Error(`Button '${n}' not found`);
            return null;
          }
          profile = null;
          reload = true;
          item = {
            profile: null,
            name: null,
            caption: null,
            commands: null,
            icon: null,
            options: { priority: 0 }
          };
          if (args.length < 2 || args.length > 5)
            throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "bu\x1B[0;-11;-12mtton name|index or \x1B[4m" + cmdChar + "bu\x1B[0;-11;-12mtton name \x1B[3mcaption\x1B[0;-11;-12m {commands} \x1B[3m{icon} options profile\x1B[0;-11;-12m or \x1B[4m" + cmdChar + "by\x1B[0;-11;-12mutton \x1B[3mcaption\x1B[0;-11;-12m {commands} \x1B[3m{icon} {options} profile\x1B[0;-11;-12m");
          if (args[0].length === 0)
            throw new Error("Invalid button name, caption or commands");
          if (args[0].match(/^\{[\s\S]*\}$/g)) {
            item.commands = args.shift();
            item.commands = item.commands.substr(1, item.commands.length - 2);
          } else {
            item.name = this.parseInline(this.stripQuotes(args.shift()));
            if (!item.name || item.name.length === 0)
              throw new Error("Invalid button name or caption");
            if (args[0].match(/^\{[\s\S]*\}$/g)) {
              item.commands = args.shift();
              item.commands = item.commands.substr(1, item.commands.length - 2);
            } else {
              item.caption = this.stripQuotes(args.shift());
              if (!args[0].match(/^\{[\s\S]*\}$/g))
                throw new Error("Missing commands");
            }
          }
          if (args.length !== 0) {
            if (args[0].match(/^\{.*\}$/g)) {
              item.icon = args.shift();
              item.icon = item.icon.substr(1, item.icon.length - 2);
            }
            if (args.length === 1) {
              if (args[0].match(/^\{[\s\S]*\}$/g))
                args[0] = args[0].substr(1, args[0].length - 2);
              else
                args[0] = this.stripQuotes(args[0]);
              if (args[0].length !== 0) {
                this.parseInline(args[0]).split(",").forEach((o) => {
                  switch (o.trim()) {
                    case "nosend":
                    case "chain":
                    case "append":
                    case "stretch":
                    case "disable":
                    case "enable":
                      item.options[o.trim()] = true;
                      break;
                    default:
                      if (o.trim().startsWith("pri=") || o.trim().startsWith("priority=")) {
                        tmp = o.trim().split("=");
                        if (tmp.length !== 2)
                          throw new Error(`Invalid button priority option '${o.trim()}'`);
                        i2 = parseInt(tmp[1], 10);
                        if (isNaN(i2))
                          throw new Error("Invalid button priority value '" + tmp[1] + "' must be a number");
                        item.options["priority"] = i2;
                      } else
                        throw new Error(`Invalid button option '${o.trim()}'`);
                  }
                });
              } else
                throw new Error("Invalid button options");
            } else if (args.length === 2) {
              if (args[0].match(/^\{[\s\S]*\}$/g))
                args[0] = args[0].substr(1, args[0].length - 2);
              if (args[0].length !== 0) {
                this.parseInline(args[0]).split(",").forEach((o) => {
                  switch (o.trim()) {
                    case "nosend":
                    case "chain":
                    case "append":
                    case "stretch":
                    case "disable":
                    case "enable":
                      item.options[o.trim()] = true;
                      break;
                    default:
                      if (o.trim().startsWith("pri=") || o.trim().startsWith("priority=")) {
                        tmp = o.trim().split("=");
                        if (tmp.length !== 2)
                          throw new Error(`Invalid button priority option '${o.trim()}'`);
                        i2 = parseInt(tmp[1], 10);
                        if (isNaN(i2))
                          throw new Error("Invalid button priority value '" + tmp[1] + "' must be a number");
                        item.options["priority"] = i2;
                      } else
                        throw new Error(`Invalid button option '${o.trim()}'`);
                  }
                });
              } else
                throw new Error("Invalid button options");
              item.profile = this.stripQuotes(args[1]);
              if (item.profile.length !== 0)
                item.profile = this.parseInline(item.profile);
            }
          }
          if (!item.profile || item.profile.length === 0) {
            const keys = this.client.profiles.keys;
            let k = 0;
            const kl = keys.length;
            if (kl === 0)
              return null;
            if (kl === 1) {
              if (!this.client.profiles.items[keys[0]].enabled || !this.client.profiles.items[keys[0]].enableTriggers)
                throw Error("No enabled profiles found!");
              profile = this.client.profiles.items[keys[0]];
              if (item.name !== null)
                trigger = this.client.profiles.items[keys[k]].find("buttons", "name", item.name);
              else
                trigger = this.client.profiles.items[keys[k]].find("buttons", "caption", item.caption);
            } else {
              for (; k < kl; k++) {
                if (!this.client.profiles.items[keys[k]].enabled || !this.client.profiles.items[keys[k]].enableTriggers || this.client.profiles.items[keys[k]].triggers.length === 0)
                  continue;
                if (item.name !== null)
                  trigger = this.client.profiles.items[keys[k]].find("buttons", "name", item.name);
                else
                  trigger = this.client.profiles.items[keys[k]].find("buttons", "caption", item.caption);
                if (trigger) {
                  profile = this.client.profiles.items[keys[k]];
                  break;
                }
              }
              if (!profile)
                profile = this.client.activeProfile;
            }
          } else {
            if (this.client.profiles.contains(item.profile))
              profile = this.client.profiles.items[item.profile.toLowerCase()];
            else
              throw new Error("Profile not found: " + item.profile);
            if (item.name !== null)
              trigger = profile.find("buttons", "name", item.name);
            else
              trigger = profile.find("buttons", "caption", item.caption);
          }
          if (!trigger) {
            trigger = new Button();
            trigger.name = item.name || "";
            trigger.caption = item.caption || "";
            profile.buttons.push(trigger);
            if (!item.name && !item.caption)
              this.client.echo("Button added.", -7, -8, true, true);
            else
              this.client.echo("Button '" + (trigger.name || trigger.caption || "") + "' added.", -7, -8, true, true);
            item.new = true;
          } else
            this.client.echo("Button '" + (trigger.name || trigger.caption || "") + "' updated.", -7, -8, true, true);
          if (item.caption !== null)
            trigger.caption = item.caption;
          if (item.commands !== null)
            trigger.value = item.commands;
          if (item.options.icon)
            trigger.icon = item.options.icon;
          if (item.options.nosend)
            trigger.send = false;
          if (item.options.chain)
            trigger.chain = true;
          if (item.options.append)
            trigger.append = true;
          if (item.options.stretch)
            trigger.stretch = true;
          if (item.options.disable)
            trigger.enabled = false;
          else if (item.options.enable)
            trigger.enabled = true;
          trigger.priority = item.options.priority;
          this.client.saveProfiles();
          if (reload)
            this.client.clearCache();
          if (item.new)
            this.emit("item-added", "button", profile.name, trigger);
          else
            this.emit("item-updated", "button", profile.name, profile.buttons.indexOf(trigger), trigger);
          profile = null;
          return null;
        case "unbutton":
        case "unb":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          if (args.length === 0)
            throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "unb\x1B[0;-11;-12mtton name or \x1B[4m" + cmdChar + "unb\x1B[0;-11;-12mtton {name} \x1B[3mprofile\x1B[0;-11;-12m");
          else {
            reload = true;
            profile = null;
            if (args[0].match(/^\{.*\}$/g) || args[0].match(/^".*"$/g) || args[0].match(/^'.*'$/g)) {
              if (args.length > 2)
                throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "unb\x1B[0;-11;-12mtton name or \x1B[4m" + cmdChar + "unb\x1B[0;-11;-12mtton {name} \x1B[3mprofile\x1B[0;-11;-12m");
              if (args.length === 2) {
                profile = this.parseInline(this.stripQuotes(args[1]));
                if (this.client.profiles.contains(profile))
                  profile = this.client.profiles.items[profile.toLowerCase()];
                else
                  throw new Error("Profile not found: " + profile);
              } else
                profile = this.client.activeProfile;
              if (args[0].match(/^".*"$/g) || args[0].match(/^'.*'$/g))
                n = this.parseInline(this.stripQuotes(args[0]));
              else
                n = this.parseInline(args[0].substr(1, args[0].length - 2));
            } else {
              n = this.parseInline(args.join(" "));
              profile = this.client.activeProfile;
            }
            items = SortItemArrayByPriority(profile.buttons);
            tmp = n;
            if (/^\s*?\d+\s*?$/.exec(n)) {
              n = parseInt(n, 10);
              if (n < 0 || n >= items.length)
                throw new Error("Button index must be >= 0 and < " + items.length);
              f = true;
            } else {
              n = this.stripQuotes(n);
              n = items.findIndex((i3) => i3.name === n || i3.caption === n);
              f = n !== -1;
            }
            if (!f)
              this.client.echo("Button '" + tmp + "' not found.", -7, -8, true, true);
            else {
              if (items[n].name.length === 0 && items[n].caption.length === 0)
                this.client.echo("Button '" + tmp + "' removed.", -7, -8, true, true);
              else
                this.client.echo("Button '" + (items[n].name || items[n].caption) + "' removed.", -7, -8, true, true);
              n = profile.buttons.indexOf(items[n]);
              profile.buttons.splice(n, 1);
              this.client.saveProfiles();
              if (reload)
                this.client.clearCache();
              this.emit("item-removed", "button", profile.name, n);
              profile = null;
            }
          }
          return null;
        //#endregion button
        case "alarm":
        case "ala":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          profile = null;
          name2 = null;
          reload = true;
          n = false;
          if (args.length < 2 || args.length > 4)
            throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "ala\x1B[0;-11;-12mrm name {timepattern} {commands} \x1B[3mprofile\x1B[0;-11;-12m, \x1B[4m" + cmdChar + "ala\x1B[0;-11;-12mrm name {timepattern} \x1B[3mprofile\x1B[0;-11;-12m, or \x1B[4m" + cmdChar + "ala\x1B[0;-11;-12mrm {timepattern} {commands} \x1B[3mprofile\x1B[0;-11;-12m");
          if (args[0].length === 0)
            throw new Error("Invalid name or timepattern");
          if (args[0].match(/^\{.*\}$/g)) {
            if (args.length > 3)
              throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "ala\x1B[0;-11;-12mrm {timepattern} {commands} profile");
            args[0] = args[0].substr(1, args[0].length - 2);
            args[0] = this.parseInline(args[0]);
            if (args[1].match(/^\{[\s\S]*\}$/g))
              args[1] = args[1].substr(1, args[1].length - 2);
            if (args.length === 3) {
              profile = this.stripQuotes(args[2]);
              profile = this.parseInline(profile);
            }
            if (!profile || profile.length === 0)
              profile = this.client.activeProfile;
            else {
              if (this.client.profiles.contains(profile))
                profile = this.client.profiles.items[profile.toLowerCase()];
              else
                throw new Error("Profile not found: " + profile);
            }
            trigger = new Trigger();
            trigger.pattern = args[0];
            trigger.value = args[1];
            trigger.type = 3 /* Alarm */;
            profile.triggers.push(trigger);
            this.client.saveProfiles();
            if (reload) {
              this._lastSuspend = -1;
              this.client.updateAlarms();
            }
            this.client.echo("Alarm '" + trigger.pattern + "' added.", -7, -8, true, true);
            this.emit("item-added", "trigger", profile.name, trigger);
            profile = null;
            return null;
          }
          name2 = this.stripQuotes(args[0]);
          if (!name2 || name2.length === 0)
            throw new Error("Invalid alarm name");
          name2 = this.parseInline(name2);
          let pattern = args[1];
          let commands = null;
          if (pattern.match(/^\{.*\}$/g))
            pattern = pattern.substr(1, pattern.length - 2);
          pattern = this.parseInline(pattern);
          if (args.length === 3) {
            if (args[2].match(/^\{[\s\S]*\}$/g))
              commands = args[2].substr(1, args[2].length - 2);
            else
              profile = this.stripQuotes(args[2]);
          } else if (args.length === 4) {
            commands = args[2];
            profile = this.stripQuotes(args[3]);
            if (commands.match(/^\{[\s\S]*\}$/g))
              commands = commands.substr(1, commands.length - 2);
          }
          if (!profile || profile.length === 0) {
            const keys = this.client.profiles.keys;
            let k = 0;
            const kl = keys.length;
            if (kl === 0)
              return null;
            if (kl === 1) {
              if (!this.client.profiles.items[keys[0]].enabled || !this.client.profiles.items[keys[0]].enableTriggers)
                throw Error("No enabled profiles found!");
              profile = this.client.profiles.items[keys[0]];
              trigger = profile.find("triggers", "name", name2);
              if (!trigger && !commands)
                throw new Error("Alarm not found!");
              else if (!trigger) {
                trigger = new Trigger();
                trigger.name = name2;
                profile.triggers.push(trigger);
                this.client.echo("Alarm '" + trigger.name + "' added.", -7, -8, true, true);
                n = true;
              } else
                this.client.echo("Alarm '" + trigger.name + "' updated.", -7, -8, true, true);
            } else {
              for (; k < kl; k++) {
                if (!this.client.profiles.items[keys[k]].enabled || !this.client.profiles.items[keys[k]].enableTriggers || this.client.profiles.items[keys[k]].triggers.length === 0)
                  continue;
                trigger = this.client.profiles.items[keys[k]].find("triggers", "name", name2);
                if (trigger) {
                  profile = this.client.profiles.items[keys[k]];
                  break;
                }
              }
              if (!profile && !commands)
                throw new Error("Alarm not found!");
              if (!profile)
                profile = this.client.activeProfile;
              if (!trigger) {
                trigger = new Trigger();
                n = true;
                trigger.name = name2;
                profile.triggers.push(trigger);
                this.client.echo("Alarm '" + trigger.name + "' added.", -7, -8, true, true);
              } else
                this.client.echo("Alarm '" + trigger.name + "' updated.", -7, -8, true, true);
            }
          } else {
            profile = this.parseInline(profile);
            if (this.client.profiles.contains(profile))
              profile = this.client.profiles.items[profile.toLowerCase()];
            else
              throw new Error("Profile not found: " + profile);
            trigger = profile.find("triggers", "name", name2);
            if (!trigger && !commands)
              throw new Error("Alarm not found!");
            else if (!trigger) {
              trigger = new Trigger();
              trigger.name = name2;
              profile.triggers.push(trigger);
              n = true;
              this.client.echo("Alarm '" + trigger.name + "' added.", -7, -8, true, true);
            } else
              this.client.echo("Alarm '" + trigger.name + "' updated.", -7, -8, true, true);
          }
          trigger.pattern = pattern;
          trigger.type = 3 /* Alarm */;
          if (commands)
            trigger.value = commands;
          this.client.saveProfiles();
          if (n)
            this.emit("item-added", "trigger", profile.name, trigger);
          else
            this.emit("item-updated", "trigger", profile.name, profile.triggers.indexOf(trigger), trigger);
          profile = null;
          if (reload) {
            this._lastSuspend = -1;
            this.client.updateAlarms();
          }
          return null;
        //#endregion alarm
        case "ungag":
        case "ung":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          if (args.length > 0)
            throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "ung\x1B[0;-11;-12mag number or \x1B[4m" + cmdChar + "ung\x1B[0;-11;-12mag");
          if (this._gagID.length) {
            clearTimeout(this._gagID.pop());
            this._gags.pop();
          }
          this._gag = 0;
          return null;
        case "gag":
        case "ga":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          if (args.length === 0) {
            if (this._gags.length && this._gags[this._gags.length - 1] == this.client.display.lines.length) {
              this._gag = 0;
              this._gags.pop();
            }
            this._gags.push(this.client.display.lines.length);
            this._gagID.push(setTimeout(() => {
              n = this.adjustLastLine(this._gags.pop());
              if (this._gags.length) {
                let gl = this._gags.length;
                while (gl >= 0) {
                  gl--;
                  if (this._gags[gl] > n)
                    this._gags[gl]--;
                }
              }
              this.client.display.removeLine(n);
            }, 0));
            this._gag = 0;
            return null;
          } else if (args.length > 1)
            throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "ga\x1B[0;-11;-12mg number or \x1B[4m" + cmdChar + "ga\x1B[0;-11;-12mg");
          i2 = parseInt(args[0], 10);
          if (isNaN(i2))
            throw new Error("Invalid number '" + args[0] + "'");
          if (this._gags.length && this._gags[this._gags.length - 1] == this.client.display.lines.length) {
            this._gag = 0;
            this._gags.pop();
          }
          this._gags.push(this.client.display.lines.length);
          if (i2 >= 0) {
            this._gagID.push(setTimeout(() => {
              n = this.adjustLastLine(this._gags.pop());
              if (this._gags.length) {
                let gl = this._gags.length;
                while (gl >= 0) {
                  gl--;
                  if (this._gags[gl] > n)
                    this._gags[gl]--;
                }
              }
              this.client.display.removeLine(n);
              this._gag = i2;
            }, 0));
            this._gag = 0;
          } else {
            this._gagID.push(setTimeout(() => {
              n = this.adjustLastLine(this._gags.pop());
              i2 *= -1;
              if (i2 > this.client.display.lines.length)
                i2 = this.client.display.lines.length;
              this.client.display.removeLines(n - i2, i2);
              this._gag = 0;
            }, 0));
            this._gag = 0;
          }
          return null;
        //#endregion gag
        case "wait":
        case "wa":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          args = args.filter((a) => a);
          if (args.length === 0 || args.length > 1)
            throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "wa\x1B[0;-11;-12mit number");
          i2 = parseInt(this.parseInline(args[0]), 10);
          if (isNaN(i2))
            throw new Error("Invalid number '" + i2 + "' for wait");
          if (i2 < 1)
            throw new Error("Must be greater then zero for wait");
          return i2;
        case "showclient":
        case "showcl":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          this.client.show();
          return null;
        case "hideclient":
        case "hidecl":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          this.client.hide();
          return null;
        case "toggleclient":
        case "togglecl":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          this.client.toggle();
          return null;
        case "raiseevent":
        case "raise":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          if (this.client.getOption("parseDoubleQuotes"))
            args.forEach((a) => {
              return a.replace(/^\"(.*)\"$/g, (v, e, w) => {
                return e.replace(/\\\"/g, '"');
              });
            });
          if (this.client.getOption("parseSingleQuotes"))
            args.forEach((a) => {
              return a.replace(/^\'(.*)\'$/g, (v, e, w) => {
                return e.replace(/\\\'/g, "'");
              });
            });
          if (args.length === 0)
            throw new Error("Invalid syntax use " + cmdChar + "\x1B[4mraise\x1B[0;-11;-12mevent name or " + cmdChar + "\x1B[4mraise\x1B[0;-11;-12mevent name arguments");
          else if (args.length === 1)
            this.client.raise(args[0]);
          else
            this.client.raise(args[0], args.slice(1));
          return null;
        case "window":
        case "win":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          if (this.client.getOption("parseDoubleQuotes"))
            args.forEach((a) => {
              return a.replace(/^\"(.*)\"$/g, (v, e, w) => {
                return e.replace(/\\\"/g, '"');
              });
            });
          if (this.client.getOption("parseSingleQuotes"))
            args.forEach((a) => {
              return a.replace(/^\'(.*)\'$/g, (v, e, w) => {
                return e.replace(/\\\'/g, "'");
              });
            });
          if (args.length === 0 || args.length > 3)
            throw new Error("Invalid syntax use " + cmdChar + "\x1B[4mwin\x1B[0;-11;-12mdow name \x1B[3mclose\x1B[0;-11;-12m or " + cmdChar + "\x1B[4mwin\x1B[0;-11;-12mdow new \x1B[3mcharacter\x1B[0;-11;-12m");
          else if (args.length === 3)
            this.client.emit("window", this.stripQuotes(this.parseInline(args[0])), this.stripQuotes(this.parseInline(args[1])), this.stripQuotes(this.parseInline(args.slice(2).join(" "))));
          else if (args.length === 1)
            this.client.emit("window", this.stripQuotes(this.parseInline(args[0])));
          else
            this.client.emit("window", this.stripQuotes(this.parseInline(args[0])), this.stripQuotes(this.parseInline(args.slice(1).join(" "))));
          return null;
        case "raisedelayed":
        case "raisede":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          if (args.length < 2)
            throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "raisede\x1B[0;-11;-12mlayed milliseconds name or \x1B[4m" + cmdChar + "raisede\x1B[0;-11;-12mlayed milliseconds name arguments");
          i2 = parseInt(this.stripQuotes(this.parseInline(args[0])), 10);
          if (isNaN(i2))
            throw new Error("Invalid number '" + args[0] + "' for raisedelayed");
          if (i2 < 1)
            throw new Error("Must be greater then zero for raisedelayed");
          args.shift();
          if (this.client.getOption("parseDoubleQuotes"))
            args.forEach((a) => {
              return a.replace(/^\"(.*)\"$/g, (v, e, w) => {
                return e.replace(/\\\"/g, '"');
              });
            });
          if (this.client.getOption("parseSingleQuotes"))
            args.forEach((a) => {
              return a.replace(/^\'(.*)\'$/g, (v, e, w) => {
                return e.replace(/\\\'/g, "'");
              });
            });
          if (args.length === 1)
            this.client.raise(args[0], 0, i2);
          else
            this.client.raise(args[0], args.slice(1), i2);
          return null;
        case "notify":
        case "not":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          if (args.length === 0)
            throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "not\x1B[0;-11;-12mify title \x1B[3mmessage icon\x1B[0;-11;-12m");
          else {
            args[0] = this.stripQuotes(args[0]);
            if (args[args.length - 1].match(/^\{.*\}$/g)) {
              item = args.pop();
              n = { icon: this.parseInline(item.substr(1, item.length - 2)) };
            }
            if (args.length === 0)
              throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "not\x1B[0;-11;-12mify title \x1B[3mmessage icon\x1B[0;-11;-12m");
            if (args.length === 1)
              this.client.notify(this.parseInline(this.stripQuotes(args[0])), null, n);
            else
              this.client.notify(this.parseInline(this.stripQuotes(args[0])), this.parseInline(args.slice(1).join(" ")), n);
          }
          return null;
        case "idle":
        case "idletime":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          if (!this.client.lastSendTime)
            this.client.echo("Not connected", -7, -8, true, true);
          else
            this.client.echo("You have been idle: " + getTimeSpan(Date.now() - this.client.lastSendTime), -7, -8, true, true);
          return null;
        case "connect":
        case "connecttime":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          if (!this.client.connectTime) {
            if (!moment && this.client.disconnectTime)
              this.client.echo("Disconnected since: " + new Date(this.client.disconnectTime).toLocaleString(), -7, -8, true, true);
            else if (this.client.disconnectTime)
              this.client.echo("Disconnected since: " + new moment(this.client.disconnectTime).format("MM/DD/YYYY hh:mm:ss A"), -7, -8, true, true);
            else
              this.client.echo("Not connected", -7, -8, true, true);
          } else
            this.client.echo("You have been connected: " + getTimeSpan(Date.now() - this.client.connectTime), -7, -8, true, true);
          return null;
        case "beep":
        case "be":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          this.client.beep();
          return null;
        case "version":
        case "ve":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          this.client.echo(this.client.telnet.terminal + " v" + this.client.version, -7, -8, true, true);
          return null;
        case "showprompt":
        case "showp":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          args = this.parseInline(args.join(" "));
          this.client.telnet.receivedData(StringToUint8Array(args), true, true);
          this.client.telnet.prompt = true;
          return null;
        case "show":
        case "sh":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          args = this.parseInline(args.join(" ") + "\n");
          this.client.telnet.receivedData(StringToUint8Array(args), true, true);
          return null;
        case "sayprompt":
        case "sayp":
        case "echoprompt":
        case "echop":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          args = this.parseInline(args.join(" "));
          this.client.print("\x1B[-7;-8m" + args + "\x1B[0m", false);
          return null;
        case "say":
        case "sa":
        case "echo":
        case "ec":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          args = this.parseInline(args.join(" "));
          if (this.client.telnet.prompt)
            this.client.print("\n\x1B[-7;-8m" + args + "\x1B[0m\n", false);
          else
            this.client.print("\x1B[-7;-8m" + args + "\x1B[0m\n", false);
          this.client.telnet.prompt = false;
          return null;
        case "print":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          i2 = this.client.enableTriggers;
          this.client.enableTriggers = false;
          args = this.parseInline(args.join(" "));
          if (this.client.telnet.prompt)
            this.client.print("\n\x1B[-7;-8m" + args + "\x1B[0m\n", false);
          else
            this.client.print("\x1B[-7;-8m" + args + "\x1B[0m\n", false);
          this.client.telnet.prompt = false;
          this.client.enableTriggers = i2;
          return null;
        case "printprompt":
        case "printp":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          i2 = this.client.enableTriggers;
          this.client.enableTriggers = false;
          args = this.parseInline(args.join(" "));
          this.client.print("\x1B[-7;-8m" + args + "\x1B[0m", false);
          this.client.enableTriggers = i2;
          return null;
        case "alias":
        case "al":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          if (args.length === 0)
            throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "al\x1B[0;-11;-12mias name value or \x1B[4m" + cmdChar + "al\x1B[0;-11;-12mias name {value} \x1B[3mprofile\x1B[0;-11;-12m");
          else if (args.length === 1)
            throw new Error("Must supply an alias value");
          else {
            n = this.parseInline(this.stripQuotes(args.shift()));
            reload = true;
            profile = null;
            if (args[0].match(/^\{.*\}$/g) || args[0].match(/^".*"$/g) || args[0].match(/^'.*'$/g)) {
              if (args.length > 2)
                throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "al\x1B[0;-11;-12mias name value or \x1B[4m" + cmdChar + "al\x1B[0;-11;-12mias name {value} \x1B[3mprofile\x1B[0;-11;-12m");
              if (args.length === 2) {
                profile = this.parseInline(this.stripQuotes(args[1]));
                if (this.client.profiles.contains(profile))
                  profile = this.client.profiles.items[profile.toLowerCase()];
                else
                  throw new Error("Profile not found: " + profile);
              } else
                profile = this.client.activeProfile;
              if (args[0].match(/^".*"$/g) || args[0].match(/^'.*'$/g))
                args = this.parseInline(this.stripQuotes(args[0]));
              else
                args = this.parseInline(args[0].substr(1, args[0].length - 2));
            } else {
              args = args.join(" ");
              profile = this.client.activeProfile;
            }
            items = profile.aliases;
            args = this.stripQuotes(args);
            if (/^\s*?\d+\s*?$/.exec(n)) {
              n = parseInt(n, 10);
              if (n < 0 || n >= items.length)
                throw new Error("Alias index must be >= 0 and < " + items.length);
              else {
                items[n].value = args;
                this.client.echo("Alias '" + items[n].pattern + "' updated.", -7, -8, true, true);
              }
            } else {
              for (i2 = 0, al = items.length; i2 < al; i2++) {
                if (items[i2]["pattern"] === n) {
                  items[i2].value = args;
                  this.client.echo("Alias '" + n + "' updated.", -7, -8, true, true);
                  this.emit("item-updated", "alias", profile.name, i2, tmp);
                  f = true;
                  break;
                }
              }
              if (!f) {
                tmp = new Alias(n, args);
                items.push(tmp);
                this.emit("item-added", "alias", profile.name, tmp);
                this.client.echo("Alias '" + n + "' added.", -7, -8, true, true);
              }
            }
            profile.aliases = items;
            this.client.saveProfiles();
            profile = null;
            if (reload)
              this.client.clearCache();
          }
          return null;
        case "unalias":
        case "una":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          if (args.length === 0)
            throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "una\x1B[0;-11;-12mlias name or \x1B[4m" + cmdChar + "una\x1B[0;-11;-12mlias {name} \x1B[3mprofile\x1B[0;-11;-12m");
          else {
            reload = true;
            profile = null;
            if (args[0].match(/^\{.*\}$/g) || args[0].match(/^".*"$/g) || args[0].match(/^'.*'$/g)) {
              if (args.length > 2)
                throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "una\x1B[0;-11;-12mlias name or \x1B[4m" + cmdChar + "una\x1B[0;-11;-12mlias {name} \x1B[3mprofile\x1B[0;-11;-12m");
              if (args.length === 2) {
                profile = this.stripQuotes(args[1]);
                profile = this.parseInline(profile);
                if (this.client.profiles.contains(profile))
                  profile = this.client.profiles.items[profile.toLowerCase()];
                else
                  throw new Error("Profile not found: " + profile);
              } else
                profile = this.client.activeProfile;
              if (args[0].match(/^".*"$/g) || args[0].match(/^'.*'$/g))
                n = this.parseInline(this.stripQuotes(args[0]));
              else
                n = this.parseInline(args[0].substr(1, args[0].length - 2));
            } else {
              n = this.parseInline(args.join(" "));
              profile = this.client.activeProfile;
            }
            items = profile.aliases;
            n = this.stripQuotes(n);
            if (/^\s*?\d+\s*?$/.exec(n)) {
              tmp = n;
              n = parseInt(n, 10);
              if (n < 0 || n >= items.length)
                throw new Error("Alias index must be >= 0 and < " + items.length);
              else
                f = true;
            } else {
              tmp = n;
              n = items.findIndex((i3) => i3.pattern === n);
              f = n !== -1;
            }
            if (!f)
              this.client.echo("Alias '" + tmp + "' not found.", -7, -8, true, true);
            else {
              this.client.echo("Alias '" + items[n].pattern + "' removed.", -7, -8, true, true);
              items.splice(n, 1);
              profile.aliases = items;
              this.client.saveProfiles();
              if (reload)
                this.client.clearCache();
              profile = null;
              this.emit("item-removed", "alias", profile.name, n);
            }
          }
          return null;
        case "setsetting":
        case "sets":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          if (args.length === 0)
            throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "sets\x1B[0;-11;-12metting name value");
          else if (args.length === 1)
            throw new Error("Must supply a setsetting value");
          else {
            n = this.stripQuotes(this.parseInline(args[0]));
            args = this.stripQuotes(this.parseInline(args.slice(1).join(" ")));
            if (/^\s*?\d+\s*?$/.exec(n)) {
              tmp = n;
              n = parseInt(n, 10);
              if (n < 0 || n >= SettingList.length)
                throw new Error("Setting index must be >= 0 and < " + SettingList.length);
              f = true;
            } else {
              n = n.toLowerCase();
              for (i2 = 0, al = SettingList.length; i2 < al; i2++) {
                if (SettingList[i2][0].toLowerCase() === n) {
                  n = i2;
                  f = true;
                  break;
                }
              }
            }
            if (!f)
              throw new Error("Unknown setting '" + tmp + "'");
            else {
              switch (SettingList[n][2]) {
                case 0:
                  if (SettingList[n][4] > 0 && args.length > SettingList[n][4])
                    throw new Error("String can not be longer then " + SettingList[n][4] + " characters");
                  else {
                    this.client.setOption(SettingList[n][1] || SettingList[n][0], args);
                    this.client.echo("Setting '" + SettingList[n][0] + "' set to '" + args + "'.", -7, -8, true, true);
                    this.client.loadOptions();
                  }
                  break;
                case 1:
                case 3:
                  switch (args.toLowerCase()) {
                    case "true":
                    case "1":
                    case "yes":
                      this.client.setOption(SettingList[n][1] || SettingList[n][0], true);
                      this.client.echo("Setting '" + SettingList[n][0] + "' set to true.", -7, -8, true, true);
                      this.client.loadOptions();
                      break;
                    case "no":
                    case "false":
                    case "0":
                      this.client.setOption(SettingList[n][1] || SettingList[n][0], false);
                      this.client.echo("Setting '" + SettingList[n][0] + "' set to false.", -7, -8, true, true);
                      this.client.loadOptions();
                      break;
                    case "toggle":
                      args = this.client.getOption(SettingList[n][1] || SettingList[n][0]) ? false : true;
                      this.client.setOption(SettingList[n][1] || SettingList[n][0], args);
                      this.client.echo("Setting '" + SettingList[n][0] + "' set to " + args + ".", -7, -8, true, true);
                      this.client.loadOptions();
                      break;
                    default:
                      throw new Error("Invalid value, must be true or false");
                  }
                  break;
                case 2:
                  i2 = parseInt(args, 10);
                  if (isNaN(i2))
                    throw new Error("Invalid number '" + args + "'");
                  else {
                    this.client.setOption(SettingList[n][1] || SettingList[n][0], i2);
                    this.client.echo("Setting '" + SettingList[n][0] + "' set to '" + i2 + "'.", -7, -8, true, true);
                    this.client.loadOptions();
                  }
                  break;
                case 4:
                case 5:
                  throw new Error("Unsupported setting '" + n + "'");
              }
            }
          }
          return null;
        case "getsetting":
        case "gets":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          if (args.length === 0)
            throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "gets\x1B[0;-11;-12metting name");
          else {
            n = this.stripQuotes(this.parseInline(args.join(" ")));
            if (/^\s*?\d+\s*?$/.exec(n)) {
              n = parseInt(n, 10);
              if (n < 0 || n >= SettingList.length)
                throw new Error("Setting index must be >= 0 and < " + SettingList.length);
              else
                f = true;
            } else {
              tmp = n;
              n = n.toLowerCase();
              if (n !== "all") {
                for (i2 = 0, al = SettingList.length; i2 < al; i2++) {
                  if (SettingList[i2][0].toLowerCase() === n) {
                    n = i2;
                    f = true;
                    break;
                  }
                }
              }
              if (n === "all") {
                tmp = "Current settings:\n";
                for (i2 = 0, al = SettingList.length; i2 < al; i2++) {
                  switch (SettingList[i2][2]) {
                    case 0:
                    case 2:
                      tmp += "    " + SettingList[i2][0] + ": " + this.client.getOption(SettingList[n][1] || SettingList[n][0]) + "\n";
                      break;
                    case 1:
                    case 3:
                      if (this.client.getOption(SettingList[n][1] || SettingList[n][0]))
                        tmp += "    " + SettingList[i2][0] + ": true\n";
                      else
                        tmp += "    " + SettingList[i2][0] + ": false\n";
                      break;
                  }
                }
                this.client.echo(tmp, -7, -8, true, true);
              } else if (!f)
                throw new Error("Unknown setting '" + n + "'");
              else {
                switch (SettingList[n][2]) {
                  case 0:
                  case 2:
                    this.client.echo("Setting '" + SettingList[n][0] + "' is '" + this.client.getOption(SettingList[n][1] || SettingList[n][0]) + "'", -7, -8, true, true);
                    break;
                  case 1:
                  case 3:
                    if (this.client.getOption(SettingList[n][1] || SettingList[n][0]))
                      this.client.echo("Setting '" + SettingList[n][0] + "' is true", -7, -8, true, true);
                    else
                      this.client.echo("Setting '" + SettingList[n][0] + "' is false", -7, -8, true, true);
                    break;
                }
              }
            }
          }
          return null;
        case "profilelist":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          this.client.echo("\x1B[4mProfiles:\x1B[0m", -7, -8, true, true);
          const files = this.client.profiles.keys;
          al = files.length;
          for (i2 = 0; i2 < al; i2++) {
            if (this.client.profiles.items[files[i2]] && this.client.profiles.items[files[i2]].enabled)
              this.client.echo("   " + this.client.profiles.keys[i2] + " is enabled", -7, -8, true, true);
            else
              this.client.echo("   " + files[i2] + " is disabled", -7, -8, true, true);
          }
          return null;
        case "profile":
        case "pro":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          if (args.length === 0)
            throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "pro\x1B[0;-11;-12mfile name or \x1B[4m" + cmdChar + "pro\x1B[0;-11;-12mfile name enable/disable");
          else if (args.length === 1) {
            args[0] = this.parseInline(args[0]);
            this.client.toggleProfile(args[0]);
            if (!this.client.profiles.contains(args[0]))
              throw new Error("Profile not found");
            else if (this.client.profiles.length === 1)
              throw new Error(args[0] + " can not be disabled as it is the only one enabled");
            if (!this.client.profiles.contains(args[0].toLowerCase()))
              args = "Profile not found";
            else if (this.client.profiles.items[args[0].toLowerCase()].enabled)
              args = args[0] + " is enabled";
            else
              args = args[0] + " is disabled";
          } else {
            args[0] = this.parseInline(args[0]).toLowerCase();
            if (!this.client.profiles.contains(args[0]))
              throw new Error("Profile not found");
            if (!args[1])
              throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "pro\x1B[0;-11;-12mfile name or \x1B[4m" + cmdChar + "pro\x1B[0;-11;-12mfile name enable/disable");
            args[1] = this.parseInline(args[1]);
            switch (args[1].toLowerCase()) {
              case "enable":
              case "on":
              case "yes":
                if (this.client.profiles.items[args[0].toLowerCase()].enabled)
                  args = args[0] + " is already enabled";
                else {
                  this.client.toggleProfile(args[0]);
                  if (this.client.profiles.items[args[0].toLowerCase()].enabled !== -1)
                    args = args[0] + " is enabled";
                  else
                    args = args[0] + " remains disabled";
                }
                break;
              case "disable":
              case "off":
              case "no":
                if (!this.client.profiles.items[args[0].toLowerCase()].enabled)
                  args = args[0] + " is already disabled";
                else {
                  if (this.client.profiles.length === 1)
                    throw new Error(args[0] + " can not be disabled as it is the only one enabled");
                  this.client.toggleProfile(args[0]);
                  args = args[0] + " is disabled";
                }
                break;
              default:
                throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "pro\x1B[0;-11;-12mfile name or \x1B[4m" + cmdChar + "pro\x1B[0;-11;-12mfile name enable/disable");
            }
          }
          if (this.client.telnet.prompt)
            this.client.print("\n\x1B[-7;-8m" + args + "\x1B[0m\n", false);
          else
            this.client.print("\x1B[-7;-8m" + args + "\x1B[0m\n", false);
          this.client.telnet.prompt = false;
          return null;
        case "color":
        case "co":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          if (args.length > 1 && args.length < 4) {
            item = {
              profile: null,
              pattern: null,
              commands: null
            };
            item.pattern = args.shift();
            if (item.pattern.match(/^\{.*\}$/g))
              item.pattern = this.parseInline(item.pattern.substr(1, item.pattern.length - 2));
            else
              item.pattern = this.parseInline(this.stripQuotes(item.pattern));
            if (args.length === 2) {
              item.commands = cmdChar + "COLOR " + this.parseInline(args[0]);
              item.profile = this.stripQuotes(args[1]);
              if (item.profile.length !== 0)
                item.profile = this.parseInline(item.profile);
            } else
              item.commands = cmdChar + "COLOR " + this.parseInline(args[0]);
            this.createTrigger(item.pattern, item.commands, item.profile);
            return null;
          } else if (args.length !== 1)
            throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "co\x1B[0;-11;-12mlor color or \x1B[4m" + cmdChar + "co\x1B[0;-11;-12mlor {pattern} color \x1B[3mprofile\x1B[0;-11;-12m");
          if (args.length !== 1)
            throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "co\x1B[0;-11;-12mlor color or \x1B[4m" + cmdChar + "co\x1B[0;-11;-12mlor {pattern} color \x1B[3mprofile\x1B[0;-11;-12m");
          args[0] = this.parseInline(this.stripQuotes(args[0]));
          n = this.client.display.lines.length;
          if (args[0].trim().match(/^[-|+]?\d+$/g)) {
            setTimeout(() => {
              n = this.adjustLastLine(n);
              this.client.display.colorSubStrByLine(n, parseInt(args[0], 10));
            }, 0);
          } else if (args[0].trim().match(/^[-|+]?\d+\s*?,\s*?[-|+]?\d+$/g)) {
            args[0] = args[0].split(",");
            setTimeout(() => {
              n = this.adjustLastLine(n);
              this.client.display.colorSubStrByLine(n, parseInt(args[0][0], 10), parseInt(args[0][1], 10));
            }, 0);
          } else {
            args = args[0].toLowerCase().split(",");
            if (args.length === 1) {
              if (args[0] === "bold")
                i2 = 370;
              if (args[0].trim().match(/^#(?:[a-f0-9]{3}|[a-f0-9]{6})\b$/g))
                i2 = args[0].trim();
              else if (args[0].trim().match(/^[-|+]?\d+$/g))
                i2 = parseInt(args[0].trim(), 10);
              else {
                i2 = getAnsiColorCode(args[0]);
                if (i2 === -1) {
                  if (isMXPColor(args[0]))
                    i2 = args[0];
                  else
                    throw new Error("Invalid fore color");
                }
              }
              setTimeout(() => {
                n = this.adjustLastLine(n);
                this.client.display.colorSubStrByLine(n, i2);
              }, 0);
            } else if (args.length === 2) {
              if (args[0] === "bold" && args[1] === "bold")
                throw new Error("Invalid fore color");
              if (args[0] === "bold")
                i2 = 370;
              else if (args[0] === "current")
                i2 = null;
              else if (args[0].trim().match(/^#(?:[a-f0-9]{3}|[a-f0-9]{6})\b$/g))
                i2 = args[0].trim();
              else if (args[0].trim().match(/^[-|+]?\d+$/g))
                i2 = parseInt(args[0].trim(), 10);
              else {
                i2 = getAnsiColorCode(args[0]);
                if (i2 === -1) {
                  if (isMXPColor(args[0]))
                    i2 = args[0];
                  else
                    throw new Error("Invalid fore color");
                }
              }
              if (args[1] === "bold") {
                setTimeout(() => {
                  n = this.adjustLastLine(n);
                  if (i2 === 370)
                    this.client.display.colorSubStrByLine(n, i2);
                  else
                    this.client.display.colorSubStrByLine(n, i2 * 10);
                }, 0);
              } else {
                p = i2;
                if (args[1].trim().match(/^#(?:[a-f0-9]{3}|[a-f0-9]{6})\b$/g))
                  i2 = args[1].trim();
                else if (args[1].trim().match(/^[-|+]?\d+$/g))
                  i2 = parseInt(args[1].trim(), 10);
                else {
                  i2 = getAnsiColorCode(args[1], true);
                  if (i2 === -1) {
                    if (isMXPColor(args[1]))
                      i2 = args[1];
                    else
                      throw new Error("Invalid back color");
                  }
                }
                setTimeout(() => {
                  n = this.adjustLastLine(n);
                  this.client.display.colorSubStrByLine(n, p, i2);
                }, 0);
              }
            } else if (args.length === 3) {
              if (args[0] === "bold") {
                args.shift();
                args.push("bold");
              }
              if (args[0].trim() === "current")
                i2 = null;
              else if (args[0].trim().match(/^#(?:[a-f0-9]{3}|[a-f0-9]{6})\b$/g))
                i2 = args[0].trim();
              else if (args[0].trim().match(/^[-|+]?\d+$/g))
                i2 = parseInt(args[0].trim(), 10);
              else {
                i2 = getAnsiColorCode(args[0]);
                if (i2 === -1) {
                  if (isMXPColor(args[0]))
                    i2 = args[0];
                  else
                    throw new Error("Invalid fore color");
                }
              }
              if (args[2] !== "bold")
                throw new Error("Only bold is supported as third argument");
              else if (!i2)
                i2 = 370;
              else
                p = i2 * 10;
              if (args[1].trim().match(/^#(?:[a-f0-9]{3}|[a-f0-9]{6})\b$/g))
                i2 = args[1].trim();
              else if (args[1].trim().match(/^[-|+]?\d+$/g))
                i2 = parseInt(args[1].trim(), 10);
              else {
                i2 = getAnsiColorCode(args[1], true);
                if (i2 === -1) {
                  if (isMXPColor(args[1]))
                    i2 = args[0];
                  else
                    throw new Error("Invalid back color");
                }
              }
              setTimeout(() => {
                n = this.adjustLastLine(n);
                this.client.display.colorSubStrByLine(n, p, i2);
              }, 0);
            }
          }
          return null;
        case "cw":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          trigger = this.stack.regex;
          if (args.length > 1 && args.length < 4) {
            item = {
              profile: null,
              pattern: null,
              commands: null
            };
            item.pattern = args.shift();
            if (item.pattern.match(/^\{.*\}$/g))
              item.pattern = this.parseInline(item.pattern.substr(1, item.pattern.length - 2));
            else
              item.pattern = this.parseInline(this.stripQuotes(item.pattern));
            if (args.length === 2) {
              item.commands = cmdChar + "CW " + this.parseInline(args[0]);
              item.profile = this.stripQuotes(args[1]);
              if (item.profile.length !== 0)
                item.profile = this.parseInline(item.profile);
            } else
              item.commands = cmdChar + "CW " + this.parseInline(args[0]);
            this.createTrigger(item.pattern, item.commands, item.profile);
            return null;
          } else if (args.length !== 1)
            throw new Error("Invalid syntax use " + cmdChar + "cw color or " + cmdChar + "cw {pattern} color \x1B[3mprofile\x1B[0;-11;-12m");
          if (!trigger) return null;
          args[0] = this.parseInline(this.stripQuotes(args[0]));
          n = this.client.display.lines.length;
          if (args[0].trim().match(/^[-|+]?\d+$/g)) {
            setTimeout(() => {
              n = this.adjustLastLine(n);
              if (trigger.length === 1)
                this.client.display.colorSubStrByLine(n, parseInt(args[0], 10));
              else {
                trigger[1].lastIndex = 0;
                tmp = trigger[0].matchAll(trigger[1]);
                for (const match of tmp) {
                  this.client.display.colorSubStrByLine(n, parseInt(args[0], 10), null, match.index, match[0].length);
                }
              }
            }, 0);
          } else if (args[0].trim().match(/^[-|+]?\d+,[-|+]?\d+$/g)) {
            args[0] = args[0].split(",");
            setTimeout(() => {
              n = this.adjustLastLine(n);
              if (trigger.length === 1)
                this.client.display.colorSubStrByLine(n, parseInt(args[0][0], 10), parseInt(args[0][1], 10));
              else {
                trigger[1].lastIndex = 0;
                tmp = trigger[0].matchAll(trigger[1]);
                for (const match of tmp) {
                  this.client.display.colorSubStrByLine(n, parseInt(args[0], 10), parseInt(args[0][1], 10), match.index, match[0].length);
                }
              }
            }, 0);
          } else {
            args = args[0].toLowerCase().split(",");
            if (args.length === 1) {
              if (args[0] === "bold")
                i2 = 370;
              if (args[0].trim().match(/^#(?:[a-f0-9]{3}|[a-f0-9]{6})\b$/g))
                i2 = args[0].trim();
              else if (args[0].trim().match(/^[-|+]?\d+$/g))
                i2 = parseInt(args[0].trim(), 10);
              else {
                i2 = getAnsiColorCode(args[0]);
                if (i2 === -1) {
                  if (isMXPColor(args[0]))
                    i2 = args[0];
                  else
                    throw new Error("Invalid fore color");
                }
              }
              setTimeout(() => {
                n = this.adjustLastLine(n);
                if (trigger.length === 1)
                  this.client.display.colorSubStrByLine(n, i2);
                else {
                  trigger[1].lastIndex = 0;
                  tmp = trigger[0].matchAll(trigger[1]);
                  for (const match of tmp) {
                    this.client.display.colorSubStrByLine(n, i2, null, match.index, match[0].length);
                  }
                }
              }, 0);
            } else if (args.length === 2) {
              if (args[0] === "bold" && args[1] === "bold")
                throw new Error("Invalid fore color");
              if (args[0] === "bold")
                i2 = 370;
              else if (args[0] === "current")
                i2 = null;
              else if (args[0].trim().match(/^#(?:[a-f0-9]{3}|[a-f0-9]{6})\b$/g))
                i2 = args[0].trim();
              else if (args[0].trim().match(/^[-|+]?\d+$/g))
                i2 = parseInt(args[0].trim(), 10);
              else {
                i2 = getAnsiColorCode(args[0]);
                if (i2 === -1) {
                  if (isMXPColor(args[0]))
                    i2 = args[0];
                  else
                    throw new Error("Invalid fore color");
                }
              }
              if (args[1] === "bold") {
                setTimeout(() => {
                  n = this.adjustLastLine(n);
                  if (i2 !== 370)
                    i2 *= 10;
                  if (trigger.length === 1)
                    this.client.display.colorSubStrByLine(n, i2);
                  else {
                    trigger[1].lastIndex = 0;
                    tmp = trigger[0].matchAll(trigger[1]);
                    for (const match of tmp) {
                      this.client.display.colorSubStrByLine(n, i2, null, match.index, match[0].length);
                    }
                  }
                }, 0);
              } else {
                p = i2;
                if (args[1].trim().match(/^#(?:[a-f0-9]{3}|[a-f0-9]{6})\b$/g))
                  i2 = args[1].trim();
                else if (args[1].trim().match(/^[-|+]?\d+$/g))
                  i2 = parseInt(args[1].trim(), 10);
                else {
                  i2 = getAnsiColorCode(args[1], true);
                  if (i2 === -1) {
                    if (isMXPColor(args[1]))
                      i2 = args[1];
                    else
                      throw new Error("Invalid back color");
                  }
                }
                setTimeout(() => {
                  n = this.adjustLastLine(n);
                  if (trigger.length === 1)
                    this.client.display.colorSubStrByLine(n, p, i2);
                  else {
                    trigger[1].lastIndex = 0;
                    tmp = trigger[0].matchAll(trigger[1]);
                    for (const match of tmp) {
                      this.client.display.colorSubStrByLine(n, p, i2, match.index, match[0].length);
                    }
                  }
                }, 0);
              }
            } else if (args.length === 3) {
              if (args[0] === "bold") {
                args.shift();
                args.push("bold");
              }
              if (args[0].trim() === "current")
                i2 = null;
              else if (args[0].trim().match(/^#(?:[a-f0-9]{3}|[a-f0-9]{6})\b$/g))
                i2 = args[0].trim();
              else if (args[0].trim().match(/^[-|+]?\d+$/g))
                i2 = parseInt(args[0].trim(), 10);
              else {
                i2 = getAnsiColorCode(args[0]);
                if (i2 === -1) {
                  if (isMXPColor(args[0]))
                    i2 = args[0];
                  else
                    throw new Error("Invalid fore color");
                }
              }
              if (args[2] !== "bold")
                throw new Error("Only bold is supported as third argument");
              else if (!i2)
                i2 = 370;
              else
                p = i2 * 10;
              if (args[1].trim().match(/^#(?:[a-f0-9]{3}|[a-f0-9]{6})\b$/g))
                i2 = args[1].trim();
              else if (args[1].trim().match(/^[-|+]?\d+$/g))
                i2 = parseInt(args[1].trim(), 10);
              else {
                i2 = getAnsiColorCode(args[1], true);
                if (i2 === -1) {
                  if (isMXPColor(args[1]))
                    i2 = args[0];
                  else
                    throw new Error("Invalid back color");
                }
              }
              setTimeout(() => {
                n = this.adjustLastLine(n);
                if (trigger.length === 1)
                  this.client.display.colorSubStrByLine(n, p, i2);
                else {
                  trigger[1].lastIndex = 0;
                  tmp = trigger[0].matchAll(trigger[1]);
                  for (const match of tmp) {
                    this.client.display.colorSubStrByLine(n, p, i2, match.index, match[0].length);
                  }
                }
              }, 0);
            }
          }
          return null;
        case "pcol":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          if (args.length < 1 || args.length > 5)
            throw new Error("Invalid syntax use " + cmdChar + "pcol color \x1B[3mXStart, XEnd, YStart, YEnd\x1B[0;-11;-12m");
          if (args.length > 1) {
            tmp = [].concat(...args.slice(1).map((s) => this.parseInline(this.stripQuotes(s)).split(" ")));
            if (tmp.length > 4)
              throw new Error("Too many arguments use " + cmdChar + "pcol color \x1B[3mXStart, XEnd, YStart, YEnd\x1B[0;-11;-12m");
            item = { xStart: 0 };
            if (tmp.length > 0)
              item.xStart = parseInt(tmp[0], 10);
            if (tmp.length > 1)
              item.xEnd = parseInt(tmp[1], 10);
            if (tmp.length > 2)
              item.yStart = parseInt(tmp[2], 10);
            if (tmp.length > 3)
              item.yEnd = parseInt(tmp[3], 10);
            if (item.hasOwnProperty("yEnd") && item.yEnd > item.yStart)
              throw new Error("yEnd must be smaller or equal to yStart");
            if (item.hasOwnProperty("xEnd") && item.xEnd < item.xStart)
              throw new Error("xEnd must be larger or equal to xStart");
          } else
            item = { xStart: 0 };
          args[0] = this.parseInline(this.stripQuotes(args[0]));
          n = this.adjustLastLine(this.client.display.lines.length);
          if (args[0].trim().match(/^[-|+]?\d+$/g)) {
            setTimeout(() => {
              this._colorPosition(n, parseInt(args[0], 10), null, item);
            }, 0);
          } else if (args[0].trim().match(/^[-|+]?\d+\s*?,\s*?[-|+]?\d+$/g)) {
            args[0] = args[0].split(",");
            setTimeout(() => {
              this._colorPosition(n, parseInt(args[0][0], 10), parseInt(args[0][1], 10), item);
            }, 0);
          } else {
            args = args[0].toLowerCase().split(",");
            if (args.length === 1) {
              if (args[0] === "bold")
                i2 = 370;
              if (args[0].trim().match(/^#(?:[a-f0-9]{3}|[a-f0-9]{6})\b$/g))
                i2 = args[0].trim();
              else if (args[0].trim().match(/^[-|+]?\d+$/g))
                i2 = parseInt(args[0].trim(), 10);
              else {
                i2 = getAnsiColorCode(args[0]);
                if (i2 === -1) {
                  if (isMXPColor(args[0]))
                    i2 = args[0];
                  else
                    throw new Error("Invalid fore color");
                }
              }
              setTimeout(() => {
                this._colorPosition(n, i2, null, item);
              }, 0);
            } else if (args.length === 2) {
              if (args[0] === "bold" && args[1] === "bold")
                throw new Error("Invalid fore color");
              if (args[0] === "bold")
                i2 = 370;
              else if (args[0] === "current")
                i2 = null;
              else if (args[0].trim().match(/^#(?:[a-f0-9]{3}|[a-f0-9]{6})\b$/g))
                i2 = args[0].trim();
              else if (args[0].trim().match(/^[-|+]?\d+$/g))
                i2 = parseInt(args[0].trim(), 10);
              else {
                i2 = getAnsiColorCode(args[0]);
                if (i2 === -1) {
                  if (isMXPColor(args[0]))
                    i2 = args[0];
                  else
                    throw new Error("Invalid fore color");
                }
              }
              if (args[1] === "bold") {
                setTimeout(() => {
                  this._colorPosition(n, i2 === 370 ? i2 : i2 * 10, null, item);
                }, 0);
              } else {
                p = i2;
                if (args[1].trim().match(/^#(?:[a-f0-9]{3}|[a-f0-9]{6})\b$/g))
                  i2 = args[1].trim();
                else if (args[1].trim().match(/^[-|+]?\d+$/g))
                  i2 = parseInt(args[1].trim(), 10);
                else {
                  i2 = getAnsiColorCode(args[1], true);
                  if (i2 === -1) {
                    if (isMXPColor(args[1]))
                      i2 = args[1];
                    else
                      throw new Error("Invalid back color");
                  }
                }
                setTimeout(() => {
                  this._colorPosition(n, p, i2, item);
                }, 0);
              }
            } else if (args.length === 3) {
              if (args[0] === "bold") {
                args.shift();
                args.push("bold");
              }
              if (args[0].trim() === "current")
                i2 = null;
              else if (args[0].trim().match(/^#(?:[a-f0-9]{3}|[a-f0-9]{6})\b$/g))
                i2 = args[0].trim();
              else if (args[0].trim().match(/^[-|+]?\d+$/g))
                i2 = parseInt(args[0].trim(), 10);
              else {
                i2 = getAnsiColorCode(args[0]);
                if (i2 === -1) {
                  if (isMXPColor(args[0]))
                    i2 = args[0];
                  else
                    throw new Error("Invalid fore color");
                }
              }
              if (args[2] !== "bold")
                throw new Error("Only bold is supported as third argument");
              else if (!i2)
                i2 = 370;
              else
                p = i2 * 10;
              if (args[1].trim().match(/^#(?:[a-f0-9]{3}|[a-f0-9]{6})\b$/g))
                i2 = args[1].trim();
              else if (args[1].trim().match(/^[-|+]?\d+$/g))
                i2 = parseInt(args[1].trim(), 10);
              else {
                i2 = getAnsiColorCode(args[1], true);
                if (i2 === -1) {
                  if (isMXPColor(args[1]))
                    i2 = args[0];
                  else
                    throw new Error("Invalid back color");
                }
              }
              setTimeout(() => {
                this._colorPosition(n, p, i2, item);
              }, 0);
            }
          }
          return null;
        case "highlight":
        case "hi":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          if (args.length > 0 && args.length < 2) {
            item = {
              profile: null,
              pattern: null,
              commands: cmdChar + "HIGHLIGHT"
            };
            item.pattern = args.shift();
            if (item.pattern.match(/^\{.*\}$/g))
              item.pattern = this.parseInline(item.pattern.substr(1, item.pattern.length - 2));
            else
              item.pattern = this.parseInline(this.stripQuotes(item.pattern));
            if (args.length === 1)
              item.profile = this.parseInline(this.stripQuotes(args[0]));
            this.createTrigger(item.pattern, item.commands, item.profile);
            return null;
          } else if (args.length)
            throw new Error("Too many arguments use \x1B[4m" + cmdChar + "hi\x1B[0;-11;-12mghlight \x1B[3mpattern profile\x1B[0;-11;-12m");
          n = this.client.display.lines.length;
          setTimeout(() => {
            n = this.adjustLastLine(n);
            this.client.display.highlightSubStrByLine(n);
          }, 0);
          return null;
        case "break":
        case "br":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          if (args.length)
            throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "br\x1B[0;-11;-12meak\x1B[0;-11;-12m");
          if (!this.loops.length)
            throw new Error("\x1B[4m" + cmdChar + "br\x1B[0;-11;-12meak\x1B[0;-11;-12m must be used in a loop.");
          if (this.stack.break)
            this.stack.break++;
          else
            this.stack.break = 1;
          return -1;
        case "continue":
        case "cont":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          if (args.length)
            throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "cont\x1B[0;-11;-12minue\x1B[0;-11;-12m");
          if (!this.loops.length)
            throw new Error("\x1B[4m" + cmdChar + "cont\x1B[0;-11;-12minue\x1B[0;-11;-12m must be used in a loop.");
          this.stack.continue = true;
          return -2;
        case "if":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          if (!args.length || args.length > 3)
            throw new Error("Invalid syntax use " + cmdChar + "if {expression} {true-command} \x1B[3m{false-command}\x1B[0;-11;-12m");
          if (args[0].match(/^\{[\s\S]*\}$/g))
            args[0] = args[0].substr(1, args[0].length - 2);
          tmp = null;
          if (this.evaluate(this.parseInline(args[0]))) {
            if (args[1].match(/^\{[\s\S]*\}$/g))
              args[1] = args[1].substr(1, args[1].length - 2);
            tmp = this.parseOutgoing(args[1]);
          } else if (args.length > 2) {
            if (args[2].match(/^\{[\s\S]*\}$/g))
              args[2] = args[2].substr(1, args[2].length - 2);
            tmp = this.parseOutgoing(args[2]);
          }
          if (tmp != null && tmp.length > 0)
            return tmp;
          return null;
        case "case":
        case "ca":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          if (!args.length || args.length < 2)
            throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "ca\x1B[0;-11;-12mse\x1B[0;-11;-12m index {command 1} \x1B[3m{command n}\x1B[0;-11;-12m");
          if (args[0].match(/^\{[\s\S]*\}$/g))
            args[0] = args[0].substr(1, args[0].length - 2);
          n = this.evaluate(this.parseInline(args[0]));
          if (typeof n !== "number")
            return null;
          if (n > 0 && n < args.length) {
            if (args[n].match(/^\{[\s\S]*\}$/g))
              args[n] = args[n].substr(1, args[n].length - 2);
            tmp = this.parseOutgoing(args[n]);
            if (tmp != null && tmp.length > 0)
              return tmp;
          }
          return null;
        case "switch":
        case "sw":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          if (!args.length || args.length < 2)
            throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "sw\x1B[0;-11;-12mitch\x1B[0;-11;-12m (expression) {command} \x1B[3m(expression) {command} ... {else_command}\x1B[0;-11;-12m");
          if (args.length % 2 === 1)
            n = args.pop();
          else
            n = null;
          al = args.length;
          for (i2 = 0; i2 < al; i2 += 2) {
            if (args[i2].match(/^\{[\s\S]*\}$/g))
              args[i2] = args[i2].substr(1, args[i2].length - 2);
            if (this.evaluate(this.parseInline(args[i2]))) {
              if (args[i2 + 1].match(/^\{[\s\S]*\}$/g))
                args[i2 + 1] = args[i2 + 1].substr(1, args[i2 + 1].length - 2);
              tmp = this.parseOutgoing(args[i2 + 1]);
              if (tmp != null && tmp.length > 0)
                return tmp;
              return null;
            }
          }
          if (n) {
            if (n.match(/^\{[\s\S]*\}$/g))
              n = n.substr(1, n.length - 2);
            tmp = this.parseOutgoing(n);
            if (tmp != null && tmp.length > 0)
              return tmp;
          }
          return null;
        case "loop":
        case "loo":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          if (args.length < 2)
            throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "loo\x1B[0;-11;-12mp\x1B[0;-11;-12m range {commands}");
          n = this.parseInline(args.shift()).split(",");
          args = args.join(" ");
          if (args.match(/^\{[\s\S]*\}$/g))
            args = args.substr(1, args.length - 2);
          if (n.length === 1) {
            tmp = parseInt(n[0], 10);
            if (isNaN(tmp))
              throw new Error("Invalid loop range '" + n[0] + "' must be a number");
            return this._executeForLoop(0, tmp, args);
          }
          tmp = parseInt(n[0], 10);
          if (isNaN(tmp))
            throw new Error("Invalid loop min '" + n[0] + "' must be a number");
          i2 = parseInt(n[1], 10);
          if (isNaN(i2))
            throw new Error("Invalid loop max '" + n[1] + "' must be a number");
          if (tmp > i2) tmp++;
          else tmp--;
          return this._executeForLoop(tmp, i2, args);
        case "repeat":
        case "rep":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          if (args.length < 2)
            throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "rep\x1B[0;-11;-12meat\x1B[0;-11;-12m expression {commands}");
          i2 = args.shift();
          if (i2.match(/^\{[\s\S]*\}$/g))
            i2 = i2.substr(1, i2.length - 2);
          i2 = this.evaluate(this.parseInline(i2));
          if (typeof i2 !== "number")
            throw new Error("Arguments must be a number");
          args = args.join(" ");
          if (args.match(/^\{[\s\S]*\}$/g))
            args = args.substr(1, args.length - 2);
          if (i2 < 1)
            return this._executeForLoop(-i2 + 1, 1, args);
          return this._executeForLoop(0, i2, args);
        case "until":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          if (args.length < 2)
            throw new Error("Invalid syntax use " + cmdChar + "until expression {commands}");
          i2 = args.shift();
          if (i2.match(/^\{[\s\S]*\}$/g))
            i2 = i2.substr(1, i2.length - 2);
          args = args.join(" ");
          if (args.match(/^\{[\s\S]*\}$/g))
            args = args.substr(1, args.length - 2);
          tmp = [];
          this.loops.push(0);
          while (!this.evaluate(this.parseInline(i2))) {
            let out = this.parseOutgoing(args);
            if (out != null && out.length > 0)
              tmp.push(out);
            if (this.stack.continue) {
              this.stack.continue = false;
              continue;
            }
            if (this.stack.break) {
              this.stack.break--;
              break;
            }
          }
          this.loops.pop();
          if (tmp.length > 0)
            return tmp.map((v) => v.trim()).join("\n");
          return null;
        case "while":
        case "wh":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          if (args.length < 2)
            throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "wh\x1B[0;-11;-12mile expression {commands}");
          i2 = args.shift();
          if (i2.match(/^\{[\s\S]*\}$/g))
            i2 = i2.substr(1, i2.length - 2);
          args = args.join(" ");
          if (args.match(/^\{[\s\S]*\}$/g))
            args = args.substr(1, args.length - 2);
          tmp = [];
          this.loops.push(0);
          while (this.evaluate(this.parseInline(i2))) {
            let out = this.parseOutgoing(args);
            if (out != null && out.length > 0)
              tmp.push(out);
            if (this.stack.continue) {
              this.stack.continue = false;
              continue;
            }
            if (this.stack.break) {
              this.stack.break--;
              break;
            }
          }
          this.loops.pop();
          if (tmp.length > 0)
            return tmp.map((v) => v.trim()).join("\n");
          return null;
        case "forall":
        case "fo":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          if (args.length < 2)
            throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "fo\x1B[0;-11;-12mrall stringlist {commands}");
          i2 = args.shift();
          if (i2.match(/^\{[\s\S]*\}$/g))
            i2 = i2.substr(1, i2.length - 2);
          args = args.join(" ");
          if (args.match(/^\{[\s\S]*\}$/g))
            args = args.substr(1, args.length - 2);
          tmp = [];
          i2 = this.splitByQuotes(this.stripQuotes(this.parseInline(i2)), "|");
          al = i2.length;
          for (n = 0; n < al; n++) {
            this.loops.push(i2[n]);
            let out = this.parseOutgoing(args);
            if (out != null && out.length > 0)
              tmp.push(out);
            if (this.stack.continue) {
              this.stack.continue = false;
              continue;
            }
            if (this.stack.break) {
              this.stack.break--;
              break;
            }
            this.loops.pop();
          }
          if (tmp.length > 0)
            return tmp.map((v) => v.trim()).join("\n");
          return null;
        case "variable":
        case "var":
        case "va":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          if (args.length === 0) {
            i2 = Object.keys(this.client.variables);
            al = i2.length;
            tmp = [];
            for (n = 0; n < al; n++)
              tmp.push(i2[n] + " = " + this.client.variables[i2[n]]);
            return tmp.join("\n");
          }
          i2 = args.shift();
          if (i2.match(/^\{.*\}$/g))
            i2 = i2.substr(1, i2.length - 2);
          i2 = this.parseInline(i2);
          if (!isValidIdentifier(i2))
            throw new Error("Invalid variable name");
          if (args.length === 0)
            return this.client.variables[i2]?.toString();
          args = args.join(" ");
          if (args.match(/^\{[\s\S]*\}$/g))
            args = args.substr(1, args.length - 2);
          args = this.parseInline(args);
          if (args.match(/^\s*?[-|+]?\d+\s*?$/))
            this.client.variables[i2] = parseInt(args, 10);
          else if (args.match(/^\s*?[-|+]?\d+\.\d+\s*?$/))
            this.client.variables[i2] = parseFloat(args);
          else if (args === "true")
            this.client.variables[i2] = true;
          else if (args === "false")
            this.client.variables[i2] = false;
          else
            this.client.variables[i2] = this.stripQuotes(args);
          return null;
        case "unvar":
        case "unv":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          if (args.length !== 1)
            throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "unv\x1B[0;-11;-12mar name ");
          i2 = args.shift();
          if (i2.match(/^\{[\s\S]*\}$/g))
            i2 = i2.substr(1, i2.length - 2);
          i2 = this.parseInline(i2);
          delete this.client.variables[i2];
          return null;
        case "add":
        case "ad":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          if (args.length < 2)
            throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "ad\x1B[0;-11;-12md name value");
          i2 = args.shift();
          if (i2.match(/^\{[\s\S]*\}$/g))
            i2 = i2.substr(1, i2.length - 2);
          i2 = this.parseInline(i2);
          if (this.client.variables.hasOwnProperty(i2) && typeof this.client.variables[i2] !== "number")
            throw new Error(i2 + " is not a number for add");
          args = args.join(" ");
          if (args.match(/^\{[\s\S]*\}$/g))
            args = args.substr(1, args.length - 2);
          args = this.evaluate(this.parseInline(args));
          if (typeof args !== "number")
            throw new Error("Value is not a number for add");
          if (!this.client.variables.hasOwnProperty(i2))
            this.client.variables[i2] = args;
          else
            this.client.variables[i2] += args;
          return null;
        case "math":
        case "mat":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          if (args.length < 2)
            throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "mat\x1B[0;-11;-12mh name value");
          i2 = args.shift();
          if (i2.match(/^\{[\s\S]*\}$/g))
            i2 = i2.substr(1, i2.length - 2);
          i2 = this.parseInline(i2);
          args = args.join(" ");
          if (args.match(/^\{[\s\S]*\}$/g))
            args = args.substr(1, args.length - 2);
          args = this.evaluate(this.parseInline(args));
          if (typeof args !== "number")
            throw new Error("Value is not a number for add");
          this.client.variables[i2] = args;
          return null;
        case "evaluate":
        case "eva":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          if (args.length === 0)
            throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "eva\x1B[0;-11;-12mluate expression");
          args = this.evaluate(this.parseInline(args.join(" ")));
          if (this.client.getOption("ignoreEvalUndefined") && typeof args === "undefined")
            args = "";
          else
            args = "" + args;
          if (this.client.telnet.prompt)
            this.client.print("\n" + args + "\x1B[0m\n", false);
          else
            this.client.print(args + "\x1B[0m\n", false);
          this.client.telnet.prompt = false;
          return null;
        case "freeze":
        case "fr":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          if (args.length === 0) {
            this.scrollLock = !this.scrollLock;
            if (this.scrollLock) {
              if (this.client.display.scrollAtBottom)
                this.client.display.scrollUp();
            } else
              this.client.display.scrollDisplay();
          } else if (args.length === 1) {
            if (args[0] === "0" || args[0] === "false") {
              if (this.scrollLock) {
                this.scrollLock = false;
                this.client.display.scrollDisplay();
              }
            } else if (!this.scrollLock) {
              this.scrollLock = true;
              if (this.client.display.scrollAtBottom)
                this.client.display.scrollUp();
            }
          } else if (args.length > 1)
            throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "fr\x1B[0;-11;-12meeze \x1B[3mnumber\x1B[0;-11;-12m");
          return null;
        //#endregion freeze                
        case "clr":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          if (args.length)
            throw new Error("Invalid syntax use " + cmdChar + "CLR");
          if (this.client.display.lines.length === 0)
            return null;
          i2 = this.client.display.WindowSize.height + 2;
          n = this.client.display.lines.length;
          while (n-- && i2) {
            if (this.client.display.lines[n].text.length)
              break;
            i2--;
          }
          tmp = [];
          while (i2--)
            tmp.push("\n");
          this.client.print(tmp.join(""), true);
          return null;
        case "fire":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          args = this.parseInline(args.join(" ") + "\n");
          this.ExecuteTriggers(4 /* Regular */ | 8 /* Pattern */ | 128 /* LoopExpression */, args, args, false, false);
          return null;
        case "state":
        //#STATE id state profile
        case "sta":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          args = args.map((m) => {
            if (!m || !m.length)
              return m;
            if (m.match(/^\{.*\}$/g))
              return this.parseInline(m.substr(1, m.length - 2));
            return this.parseInline(this.stripQuotes(m));
          });
          switch (args.length) {
            case 0:
              throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "sta\x1B[0;-11;-12mte \x1B[3m name|pattern state profile\x1B[0;-11;-12m");
            case 1:
              if (args[0].match(/^\s*?[-|+]?\d+\s*?$/)) {
                if (!this._LastTrigger)
                  throw new Error("No trigger has fired yet, unable to set state");
                trigger = this._LastTrigger;
                n = trigger.state;
                trigger.state = parseInt(args[0], 10);
              } else {
                const keys = this.client.profiles.keys;
                let k = 0;
                const kl = keys.length;
                if (kl === 0)
                  return null;
                if (kl === 1) {
                  if (!this.client.profiles.items[keys[0]].enabled || !this.client.profiles.items[keys[0]].enableTriggers)
                    throw Error("No enabled profiles found!");
                  trigger = SortItemArrayByPriority(this.client.profiles.items[keys[k]].triggers);
                  trigger = trigger.find((t) => {
                    return t.name === args[0] || t.pattern === args[0];
                  });
                } else {
                  for (; k < kl; k++) {
                    if (!this.client.profiles.items[keys[k]].enabled || !this.client.profiles.items[keys[k]].enableTriggers || this.client.profiles.items[keys[k]].triggers.length === 0)
                      continue;
                    trigger = SortItemArrayByPriority(this.client.profiles.items[keys[k]].triggers);
                    trigger = trigger.find((t) => {
                      return t.name === args[0] || t.pattern === args[0];
                    });
                    if (trigger)
                      break;
                  }
                }
                if (!trigger)
                  throw new Error("Trigger not found: " + args[0]);
                n = trigger.state;
                trigger.state = 0;
              }
              break;
            case 2:
              if (args[0].match(/^\s*?[-|+]?\d+\s*?$/))
                throw new Error("Invalid argument to " + cmdChar + "state, first argument must be name|pattern");
              if (args[1].match(/^\s*?[-|+]?\d+\s*?$/)) {
                const keys = this.client.profiles.keys;
                let k = 0;
                const kl = keys.length;
                if (kl === 0)
                  return null;
                if (kl === 1) {
                  if (!this.client.profiles.items[keys[0]].enabled || !this.client.profiles.items[keys[0]].enableTriggers)
                    throw Error("No enabled profiles found!");
                  trigger = SortItemArrayByPriority(this.client.profiles.items[keys[k]].triggers);
                  trigger = trigger.find((t) => {
                    return t.name === args[0] || t.pattern === args[0];
                  });
                } else {
                  for (; k < kl; k++) {
                    if (!this.client.profiles.items[keys[k]].enabled || !this.client.profiles.items[keys[k]].enableTriggers || this.client.profiles.items[keys[k]].triggers.length === 0)
                      continue;
                    trigger = SortItemArrayByPriority(this.client.profiles.items[keys[k]].triggers);
                    trigger = trigger.find((t) => {
                      return t.name === args[0] || t.pattern === args[0];
                    });
                    if (trigger)
                      break;
                  }
                }
                if (!trigger)
                  throw new Error("Trigger not found: " + args[0]);
                n = trigger.state;
                trigger.state = parseInt(args[1], 10);
              } else {
                profile = args[1];
                if (this.client.profiles.contains(profile))
                  profile = this.client.profiles.items[profile.toLowerCase()];
                else
                  throw new Error("Profile not found: " + args[1]);
                trigger = SortItemArrayByPriority(profile.triggers);
                trigger = trigger.find((t) => {
                  return t.name === args[0] || t.pattern === args[0];
                });
                if (!trigger)
                  throw new Error("Trigger not found: " + args[0] + " in profile: " + profile.name);
                n = trigger.state;
                trigger.state = 0;
              }
              break;
            case 3:
              if (args[0].match(/^\s*?[-|+]?\d+\s*?$/))
                throw new Error("Invalid argument to " + cmdChar + "state, first argument must be name|pattern");
              profile = args[2];
              if (this.client.profiles.contains(profile))
                profile = this.client.profiles.items[profile.toLowerCase()];
              else
                throw new Error("Profile not found: " + args[2]);
              trigger = SortItemArrayByPriority(profile.triggers);
              trigger = trigger.find((t) => {
                return t.name === args[0] || t.pattern === args[0];
              });
              if (!trigger)
                throw new Error("Trigger not found: " + args[0]);
              n = trigger.state;
              trigger.state = parseInt(args[1], 10);
              break;
            default:
              throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "sta\x1B[0;-11;-12mte \x1B[3m name|pattern state profile\x1B[0;-11;-12m");
          }
          if (trigger.state < 0 || trigger.state > trigger.triggers.length) {
            trigger.state = n;
            throw new Error("Trigger state must be greater than or equal to 0 or less than or equal to " + trigger.triggers.length);
          }
          i2 = trigger.fired;
          trigger.fired = false;
          this.resetTriggerState(this._TriggerCache.indexOf(trigger), n, i2);
          this.client.restartAlarmState(trigger, n, trigger.state);
          this.client.saveProfiles();
          this.client.emit("item-updated", "trigger", trigger.profile.name, trigger.profile.triggers.indexOf(trigger), trigger);
          this.client.echo("Trigger state set to " + trigger.state + ".", -7, -8, true, true);
          return null;
        case "set":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          args = args.map((m) => {
            if (!m || !m.length)
              return m;
            if (m.match(/^\{.*\}$/g))
              return this.parseInline(m.substr(1, m.length - 2));
            return this.parseInline(this.stripQuotes(m));
          });
          n = 0;
          i2 = false;
          switch (args.length) {
            case 0:
              throw new Error("Invalid syntax use " + cmdChar + "set \x1B[3mname|pattern\x1B[0;-11;-12m state \x1B[3mvalue profile\x1B[0;-11;-12m");
            case 1:
              if (args[0].match(/^\s*?[-|+]?\d+\s*?$/)) {
                if (!this._LastTrigger)
                  throw new Error("No trigger has fired yet, unable to set state");
                trigger = this._LastTrigger;
                n = parseInt(args[0], 10);
                if (n < 0 || n > trigger.triggers.length)
                  throw new Error("Trigger state must be greater than or equal to 0 or less than or equal to " + trigger.triggers.length);
                if (n === 0) {
                  i2 = trigger.fired;
                  trigger.fired = true;
                } else {
                  i2 = trigger.triggers[n - 1].fired;
                  trigger.triggers[n - 1].fired = true;
                }
              } else
                throw new Error("Trigger state must be greater than or equal to 0 or less than or equal to " + trigger.triggers.length);
              break;
            case 2:
              if (args[0].match(/^\s*?[-|+]?\d+\s*?$/)) {
                if (!this._LastTrigger)
                  throw new Error("No trigger has fired yet, unable to set state");
                trigger = this._LastTrigger;
                n = parseInt(args[0], 10);
                if (n < 0 || n > trigger.triggers.length)
                  throw new Error("Trigger state must be greater than or equal to 0 or less than or equal to " + trigger.triggers.length);
                if (args[1] !== "0" && args[1] !== "1" && args[1] !== "true" && args[1] !== "false")
                  throw new Error("Value must be 0, 1, true, or false");
                if (n === 0) {
                  i2 = trigger.fired;
                  trigger.fired = args[1] === "1" || args[1] === "true";
                } else {
                  i2 = trigger.triggers[n - 1].fired;
                  trigger.triggers[n - 1].fired = args[1] === "1" || args[1] === "true";
                }
              } else {
                const keys = this.client.profiles.keys;
                let k = 0;
                const kl = keys.length;
                if (kl === 0)
                  return null;
                if (kl === 1) {
                  if (!this.client.profiles.items[keys[0]].enabled || !this.client.profiles.items[keys[0]].enableTriggers)
                    throw Error("No enabled profiles found!");
                  trigger = SortItemArrayByPriority(this.client.profiles.items[keys[k]].triggers);
                  trigger = trigger.find((t) => {
                    return t.name === args[0] || t.pattern === args[0];
                  });
                } else {
                  for (; k < kl; k++) {
                    if (!this.client.profiles.items[keys[k]].enabled || !this.client.profiles.items[keys[k]].enableTriggers || this.client.profiles.items[keys[k]].triggers.length === 0)
                      continue;
                    trigger = SortItemArrayByPriority(this.client.profiles.items[keys[k]].triggers);
                    trigger = trigger.find((t) => {
                      return t.name === args[0] || t.pattern === args[0];
                    });
                    if (trigger)
                      break;
                  }
                }
                if (!trigger)
                  throw new Error("Trigger not found: " + args[0]);
                n = parseInt(args[1], 10);
                if (n < 0 || n > trigger.triggers.length)
                  throw new Error("Trigger state must be greater than or equal to 0 or less than or equal to " + trigger.triggers.length);
                if (n === 0) {
                  i2 = trigger.fired;
                  trigger.fired = true;
                } else {
                  i2 = trigger.triggers[n - 1].fired;
                  trigger.triggers[n - 1].fired = true;
                }
              }
              break;
            case 3:
              if (args[2] === "0" && args[2] !== "1" && args[2] !== "true" && args[21] !== "false") {
                profile = args[2];
                if (this.client.profiles.contains(profile))
                  profile = this.client.profiles.items[profile.toLowerCase()];
                else
                  throw new Error("Profile not found: " + profile);
                trigger = SortItemArrayByPriority(profile.triggers);
                trigger = trigger.find((t) => {
                  return t.name === args[0] || t.pattern === args[0];
                });
                if (!trigger)
                  throw new Error("Trigger not found: " + args[0] + " in profile: " + profile.name);
                n = parseInt(args[1], 10);
                if (n < 0 || n > trigger.triggers.length)
                  throw new Error("Trigger state must be greater than or equal to 0 or less than or equal to " + trigger.triggers.length);
                if (n === 0) {
                  i2 = trigger.fired;
                  trigger.fired = true;
                } else {
                  i2 = trigger.triggers[n - 1].fired;
                  trigger.triggers[n - 1].fired = true;
                }
              } else {
                const keys = this.client.profiles.keys;
                let k = 0;
                const kl = keys.length;
                if (kl === 0)
                  return null;
                if (kl === 1) {
                  if (!this.client.profiles.items[keys[0]].enabled || !this.client.profiles.items[keys[0]].enableTriggers)
                    throw Error("No enabled profiles found!");
                  trigger = SortItemArrayByPriority(this.client.profiles.items[keys[k]].triggers);
                  trigger = trigger.find((t) => {
                    return t.name === args[0] || t.pattern === args[0];
                  });
                } else {
                  for (; k < kl; k++) {
                    if (!this.client.profiles.items[keys[k]].enabled || !this.client.profiles.items[keys[k]].enableTriggers || this.client.profiles.items[keys[k]].triggers.length === 0)
                      continue;
                    trigger = SortItemArrayByPriority(this.client.profiles.items[keys[k]].triggers);
                    trigger = trigger.find((t) => {
                      return t.name === args[0] || t.pattern === args[0];
                    });
                    if (trigger)
                      break;
                  }
                }
                if (!trigger)
                  throw new Error("Trigger not found: " + args[0]);
                n = parseInt(args[1], 10);
                if (n < 0 || n > trigger.triggers.length)
                  throw new Error("Trigger state must be greater than or equal to 0 or less than or equal to " + trigger.triggers.length);
                if (n === 0) {
                  i2 = trigger.fired;
                  trigger.fired = args[2] === "1" || args[2] === "true";
                } else {
                  i2 = trigger.triggers[n - 1].fired;
                  trigger.triggers[n - 1].fired = args[2] === "1" || args[2] === "true";
                }
              }
              break;
            case 4:
              profile = args[2];
              if (this.client.profiles.contains(profile))
                profile = this.client.profiles.items[profile.toLowerCase()];
              else
                throw new Error("Profile not found: " + profile);
              trigger = SortItemArrayByPriority(profile.triggers);
              trigger = trigger.find((t) => {
                return t.name === args[0] || t.pattern === args[0];
              });
              if (!trigger)
                throw new Error("Trigger not found: " + args[0] + " in profile: " + profile.name);
              if (args[2] !== "0" && args[2] !== "1" && args[2] !== "true" && args[2] !== "false")
                throw new Error("Value must be 0, 1, true, or false");
              if (n === 0) {
                i2 = trigger.fired;
                trigger.fired = args[2] === "1" || args[2] === "true";
              } else {
                i2 = trigger.triggers[n - 1].fired;
                trigger.triggers[n - 1].fired = args[2] === "1" || args[2] === "true";
              }
              break;
            default:
              throw new Error("Invalid syntax use " + cmdChar + "set \x1B[3mname|pattern\x1B[0;-11;-12m state \x1B[3mvalue profile\x1B[0;-11;-12m");
          }
          this.client.saveProfiles();
          this.client.emit("item-updated", "trigger", trigger.profile.name, trigger.profile.triggers.indexOf(trigger), trigger);
          this.resetTriggerState(this._TriggerCache.indexOf(trigger), n, i2);
          if (n === 0)
            this.client.echo("Trigger state 0 fired state set to " + trigger.fired + ".", -7, -8, true, true);
          else {
            this.client.echo("Trigger state " + n + " fired state set to " + trigger.triggers[n - 1].fired + ".", -7, -8, true, true);
            if (trigger.enabled && trigger.triggers[n - 1].enabled && trigger.triggers[n - 1].type === 65536 /* Manual */) {
              this._LastTriggered = "";
              this.ExecuteTrigger(trigger, [], false, this._TriggerCache.indexOf(trigger), 0, 0, trigger);
            }
          }
          return null;
        case "condition":
        case "cond":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          item = {
            profile: null,
            name: null,
            pattern: null,
            commands: null,
            options: { priority: 0 }
          };
          if (args.length < 2 || args.length > 5)
            throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "cond\x1B[0;-11;-12mition name|pattern {pattern} {commands} \x1B[3moptions profile\x1B[0;-11;-12m or \x1B[4m" + cmdChar + "cond\x1B[0;-11;-12mition {pattern} {commands} \x1B[3m{options} profile\x1B[0;-11;-12m");
          if (args[0].length === 0)
            throw new Error("Invalid trigger name or pattern");
          if (args[0].match(/^\{.*\}$/g)) {
            item.pattern = args.shift();
            item.pattern = this.parseInline(item.pattern.substr(1, item.pattern.length - 2));
          } else {
            item.name = this.parseInline(this.stripQuotes(args.shift()));
            if (!item.name || item.name.length === 0)
              throw new Error("Invalid trigger name");
            if (args[0].match(/^\{.*\}$/g)) {
              item.pattern = args.shift();
              item.pattern = this.parseInline(item.pattern.substr(1, item.pattern.length - 2));
            }
          }
          if (args.length !== 0) {
            if (args[0].match(/^\{[\s\S]*\}$/g)) {
              item.commands = args.shift();
              item.commands = item.commands.substr(1, item.commands.length - 2);
            }
            if (args.length === 1) {
              if (args[0].match(/^\{[\s\S]*\}$/g))
                args[0] = args[0].substr(1, args[0].length - 2);
              else
                args[0] = this.stripQuotes(args[0]);
              if (args[0].length !== 0) {
                this.parseInline(args[0]).split(",").forEach((o) => {
                  switch (o.trim()) {
                    case "nocr":
                    case "prompt":
                    case "case":
                    case "verbatim":
                    case "disable":
                    case "enable":
                    case "cmd":
                    case "temporary":
                    case "temp":
                    case "raw":
                    case "pattern":
                    case "regular":
                    case "alarm":
                    case "event":
                    case "cmdpattern":
                    case "loopexpression":
                    //case 'expression':
                    case "reparse":
                    case "reparsepattern":
                    case "manual":
                    case "skip":
                    case "looplines":
                    case "looppattern":
                    case "wait":
                    case "duration":
                    case "withinlines":
                      item.options[o.trim()] = true;
                      break;
                    default:
                      if (o.trim().startsWith("param=")) {
                        tmp = o.trim().split("=");
                        if (tmp.length !== 2)
                          throw new Error(`Invalid trigger param option '${o.trim()}'`);
                        item.options["params"] = tmp[1];
                      } else if (o.trim().startsWith("type=")) {
                        tmp = o.trim().split("=");
                        if (tmp.length !== 2)
                          throw new Error(`Invalid trigger type option '${o.trim()}'`);
                        if (!this._isTriggerType(tmp[1]))
                          throw new Error("Invalid trigger type");
                        item.options["type"] = tmp[1];
                      } else if (o.trim().startsWith("pri=") || o.trim().startsWith("priority=")) {
                        tmp = o.trim().split("=");
                        if (tmp.length !== 2)
                          throw new Error(`Invalid trigger priority option '${o.trim()}'`);
                        i2 = parseInt(tmp[1], 10);
                        if (isNaN(i2))
                          throw new Error("Invalid trigger priority value '" + tmp[1] + "' must be a number");
                        item.options["priority"] = i2;
                      } else
                        throw new Error(`Invalid trigger option '${o.trim()}'`);
                  }
                });
              } else
                throw new Error("Invalid trigger options");
            } else if (args.length === 2) {
              if (args[0].match(/^\{[\s\S]*\}$/g))
                args[0] = args[0].substr(1, args[0].length - 2);
              if (args[0].length !== 0) {
                this.parseInline(args[0]).split(",").forEach((o) => {
                  switch (o.trim()) {
                    case "nocr":
                    case "prompt":
                    case "case":
                    case "verbatim":
                    case "disable":
                    case "enable":
                    case "cmd":
                    case "temporary":
                    case "temp":
                    case "raw":
                    case "pattern":
                    case "regular":
                    case "alarm":
                    case "event":
                    case "cmdpattern":
                    case "loopexpression":
                    //case 'expression':
                    case "reparse":
                    case "reparsepattern":
                    case "manual":
                    case "skip":
                    case "looplines":
                    case "looppattern":
                    case "wait":
                    case "duration":
                    case "withinlines":
                      item.options[o.trim()] = true;
                      break;
                    default:
                      if (o.trim().startsWith("param=")) {
                        tmp = o.trim().split("=");
                        if (tmp.length !== 2)
                          throw new Error(`Invalid trigger param option '${o.trim()}'`);
                        item.options["params"] = tmp[1];
                      } else if (o.trim().startsWith("type=")) {
                        tmp = o.trim().split("=");
                        if (tmp.length !== 2)
                          throw new Error(`Invalid trigger type option '${o.trim()}'`);
                        if (!this._isTriggerType(tmp[1]))
                          throw new Error("Invalid trigger type");
                        item.options["type"] = tmp[1];
                      } else if (o.trim().startsWith("pri=") || o.trim().startsWith("priority=")) {
                        tmp = o.trim().split("=");
                        if (tmp.length !== 2)
                          throw new Error(`Invalid trigger priority option '${o.trim()}'`);
                        i2 = parseInt(tmp[1], 10);
                        if (isNaN(i2))
                          throw new Error("Invalid trigger priority value '" + tmp[1] + "' must be a number");
                        item.options["priority"] = i2;
                      } else
                        throw new Error(`Invalid trigger option '${o.trim()}'`);
                  }
                });
              } else
                throw new Error("Invalid trigger options");
              item.profile = this.stripQuotes(args[1]);
              if (item.profile.length !== 0)
                item.profile = this.parseInline(item.profile);
            }
          }
          this.createTrigger(item.pattern, item.commands, item.profile, item.options, item.name, true);
          return null;
        case "cr":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          this.client.sendBackground("\n");
          return null;
        case "send":
        case "se":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          if (args.length === 0)
            throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "se\x1B[0;-11;-12mnd file \x1B[3mprefix suffix\x1B[0;-11;-12m or \x1B[4m" + cmdChar + "se\x1B[0;-11;-12mnd text");
          args = args.join(" ");
          if (args.length === 0)
            throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "se\x1B[0;-11;-12mnd file \x1B[3mprefix suffix\x1B[0;-11;-12m or \x1B[4m" + cmdChar + "se\x1B[0;-11;-12mnd text");
          this.client.sendBackground(this.stripQuotes(args), this.client.getOption("allowCommentsFromCommand"));
          return null;
        //work around for send as can not access files so we open a file dialog and ask for the file they want to send instead
        case "sendfile":
        case "sendf":
          ((a, r) => {
            openFileDialog().then((files2) => {
              readFile(files2[0]).then((contents) => {
                if ((this.client.getOption("echo") & 4) === 4)
                  this.client.echo(r, -3, -4, true, true);
                p = "";
                i2 = "";
                if (a.length > 1)
                  p = this.stripQuotes(this.parseInline(a[0]));
                if (a.length > 2)
                  i2 = this.stripQuotes(this.parseInline(a[1]));
                items = contents.split(/\r?\n/);
                items.forEach((line2) => {
                  this.client.sendBackground(p + line2 + i2, null, this.client.getOption("allowCommentsFromCommand"));
                });
              }).catch(this.client.error);
            }).catch(() => {
            });
          })(args, raw);
          return null;
        //work around for sendraw as can not access files so we open a file dialog and ask for the file they want to send instead
        case "sendfileraw":
        case "sendfiler":
          ((a, r) => {
            openFileDialog().then((files2) => {
              readFile(files2[0]).then((contents) => {
                if ((this.client.getOption("echo") & 4) === 4)
                  this.client.echo(r, -3, -4, true, true);
                p = "";
                i2 = "";
                if (a.length > 1)
                  p = this.stripQuotes(this.parseInline(a[0]));
                if (a.length > 2)
                  i2 = this.stripQuotes(this.parseInline(a[1]));
                items = contents.split(/\r?\n/);
                items.forEach((line2) => {
                  this.client.sendRaw(p + line2 + i2);
                });
              }).catch(this.client.error);
            }).catch(() => {
            });
          })(args, raw);
          return null;
        case "sendraw":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          if (args.length === 0)
            throw new Error("Invalid syntax use " + cmdChar + "sendraw text or " + cmdChar + "sendraw file \x1B[3mprefix suffix\x1B[0;-11;-12m");
          args = args.join(" ");
          if (args.length === 0)
            throw new Error("Invalid syntax use " + cmdChar + "sendraw text or " + cmdChar + "sendraw file \x1B[3mprefix suffix\x1B[0;-11;-12m");
          if (!args.endsWith("\n"))
            args = args + "\n";
          this.client.sendRaw(args);
          return null;
        case "sendprompt":
        case "sendp":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          if (args.length === 0)
            throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "sendp\x1B[0;-11;-12mrompt text");
          args = args.join(" ");
          if (args.length === 0)
            throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "sendp\x1B[0;-11;-12mrompt text");
          this.client.sendRaw(args);
          return null;
        case "character":
        case "char":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          this.client.sendRaw(window.$character || "");
          return null;
        case "speak":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          if (args.length === 0)
            throw new Error("Invalid syntax use " + cmdChar + "speak text");
          args = args.join(" ");
          if (args.length === 0)
            throw new Error("Invalid syntax use " + cmdChar + "speak text");
          args = this.stripQuotes(this.parseInline(args));
          if (args.length !== 0)
            window.speechSynthesis.speak(new SpeechSynthesisUtterance(args));
          return null;
        case "speakstop":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          if (args.length !== 0)
            throw new Error("Invalid syntax use " + cmdChar + "speakstop");
          window.speechSynthesis.cancel();
          return null;
        case "speakpause":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          if (args.length !== 0)
            throw new Error("Invalid syntax use " + cmdChar + "speakpause");
          window.speechSynthesis.pause();
          return null;
        case "speakresume":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          if (args.length !== 0)
            throw new Error("Invalid syntax use " + cmdChar + "speakresume");
          window.speechSynthesis.resume();
          return null;
        case "comment":
        case "comm":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          return null;
        case "noop":
        case "no":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          if (args.length)
            this.parseInline(args.join(" "));
          return null;
        case "temp":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          item = {
            profile: null,
            name: null,
            pattern: null,
            commands: null,
            options: { priority: 0 }
          };
          if (args.length < 2 || args.length > 5)
            throw new Error("Invalid syntax use " + cmdChar + "temp name {pattern} {commands} \x1B[3moptions profile\x1B[0;-11;-12m or " + cmdChar + "temp {pattern} {commands} \x1B[3m{options} profile\x1B[0;-11;-12m");
          if (args[0].length === 0)
            throw new Error("Invalid temporary trigger or pattern");
          if (args[0].match(/^\{.*\}$/g)) {
            item.pattern = args.shift();
            item.pattern = this.parseInline(item.pattern.substr(1, item.pattern.length - 2));
          } else {
            item.name = this.parseInline(this.stripQuotes(args.shift()));
            if (!item.name || item.name.length === 0)
              throw new Error("Invalid temporary trigger name");
            if (args[0].match(/^\{.*\}$/g)) {
              item.pattern = args.shift();
              item.pattern = this.parseInline(item.pattern.substr(1, item.pattern.length - 2));
            }
          }
          if (args.length !== 0) {
            if (args[0].match(/^\{[\s\S]*\}$/g)) {
              item.commands = args.shift();
              item.commands = item.commands.substr(1, item.commands.length - 2);
            }
            if (args.length === 1) {
              if (args[0].match(/^\{[\s\S]*\}$/g))
                args[0] = args[0].substr(1, args[0].length - 2);
              else
                args[0] = this.stripQuotes(args[0]);
              if (args[0].length !== 0) {
                this.parseInline(args[0]).split(",").forEach((o) => {
                  switch (o.trim()) {
                    case "nocr":
                    case "prompt":
                    case "case":
                    case "verbatim":
                    case "disable":
                    case "enable":
                    case "cmd":
                    case "raw":
                    case "pattern":
                    case "regular":
                    case "alarm":
                    case "event":
                    case "cmdpattern":
                    case "loopexpression":
                      item.options[o.trim()] = true;
                      break;
                    default:
                      if (o.trim().startsWith("param=")) {
                        tmp = o.trim().split("=");
                        if (tmp.length !== 2)
                          throw new Error(`Invalid temporary trigger param option '${o.trim()}'`);
                        item.options["params"] = tmp[1];
                      } else if (o.trim().startsWith("type=")) {
                        tmp = o.trim().split("=");
                        if (tmp.length !== 2)
                          throw new Error(`Invalid temporary trigger type option '${o.trim()}'`);
                        if (!this._isTriggerType(tmp[1], 1 /* Main */))
                          throw new Error("Invalid temporary trigger type");
                        item.options["type"] = tmp[1];
                      } else if (o.trim().startsWith("pri=") || o.trim().startsWith("priority=")) {
                        tmp = o.trim().split("=");
                        if (tmp.length !== 2)
                          throw new Error(`Invalid temporary trigger priority option '${o.trim()}'`);
                        i2 = parseInt(tmp[1], 10);
                        if (isNaN(i2))
                          throw new Error("Invalid temporary trigger priority value '" + tmp[1] + "' must be a number");
                        item.options["priority"] = i2;
                      } else
                        throw new Error(`Invalid temporary trigger option '${o.trim()}'`);
                  }
                });
              } else
                throw new Error("Invalid temporary trigger options");
            } else if (args.length === 2) {
              if (args[0].match(/^\{[\s\S]*\}$/g))
                args[0] = args[0].substr(1, args[0].length - 2);
              if (args[0].length !== 0) {
                this.parseInline(args[0]).split(",").forEach((o) => {
                  switch (o.trim()) {
                    case "nocr":
                    case "prompt":
                    case "case":
                    case "verbatim":
                    case "disable":
                    case "enable":
                    case "cmd":
                    case "raw":
                    case "pattern":
                    case "regular":
                    case "alarm":
                    case "event":
                    case "cmdpattern":
                    case "loopexpression":
                      item.options[o.trim()] = true;
                      break;
                    default:
                      if (o.trim().startsWith("param=")) {
                        tmp = o.trim().split("=");
                        if (tmp.length !== 2)
                          throw new Error(`Invalid temporary trigger param option '${o.trim()}'`);
                        item.options["params"] = tmp[1];
                      } else if (o.trim().startsWith("type=")) {
                        tmp = o.trim().split("=");
                        if (tmp.length !== 2)
                          throw new Error(`Invalid temporary trigger type option '${o.trim()}'`);
                        if (!this._isTriggerType(tmp[1], 1 /* Main */))
                          throw new Error("Invalid temporary trigger type");
                        item.options["type"] = tmp[1];
                      } else if (o.trim().startsWith("pri=") || o.trim().startsWith("priority=")) {
                        tmp = o.trim().split("=");
                        if (tmp.length !== 2)
                          throw new Error(`Invalid temporary trigger priority option '${o.trim()}'`);
                        i2 = parseInt(tmp[1], 10);
                        if (isNaN(i2))
                          throw new Error("Invalid temporary trigger priority value '" + tmp[1] + "' must be a number");
                        item.options["priority"] = i2;
                      } else
                        throw new Error(`Invalid temporary trigger option '${o.trim()}'`);
                  }
                });
              } else
                throw new Error("Invalid temporary trigger options");
              item.profile = this.stripQuotes(args[1]);
              if (item.profile.length !== 0)
                item.profile = this.parseInline(item.profile);
            }
          }
          item.options.temporary = true;
          this.createTrigger(item.pattern, item.commands, item.profile, item.options, item.name);
          return null;
        case "wrap":
        case "wr":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          args = args.filter((a) => a);
          if (args.length > 1)
            throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "wr\x1B[0;-11;-12map or \x1B[4m" + cmdChar + "wr\x1B[0;-11;-12map number");
          if (args.length === 0) {
            this.client.setOption("display.wordWrap", !this.client.getOption("display.wordWrap"));
            this.client.display.wordWrap = this.client.getOption("display.wordWrap");
          } else {
            i2 = parseInt(this.parseInline(args[0]), 10);
            if (isNaN(i2))
              throw new Error("Invalid number '" + i2 + "' for wrap");
            if (i2 < 0)
              throw new Error("Must be greater then or equal to zero for wrap");
            this.client.setOption("display.wordWrap", true);
            this.client.setOption("display.wordWrap", i2);
            this.client.display.wordWrap = true;
            this.client.display.wrapAt = i2;
          }
          return null;
        case "prompt":
        case "pr":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          if (args.length === 0 || args.length > 4)
            throw new Error("Invalid syntax use \x1B[4m" + cmdChar + "pr\x1B[0;-11;-12mompt variable \x1B[3mmessage defaultValue mask\x1B[0;-11;-12m");
          else {
            i2 = args.shift();
            if (i2.match(/^\{.*\}$/g))
              i2 = i2.substr(1, i2.length - 2);
            i2 = this.parseInline(i2);
            if (!isValidIdentifier(i2))
              throw new Error("Invalid variable name");
            args = args.map((a) => this.parseInline(this.stripQuotes(a)));
            if (args.length === 3 && args[2] && args[2].toLowerCase() === "true")
              args[2] = true;
            args = window.prompt(...args);
            if (args?.match(/^\s*?[-|+]?\d+\s*?$/))
              this.client.variables[i2] = parseInt(args, 10);
            else if (args?.match(/^\s*?[-|+]?\d+\.\d+\s*?$/))
              this.client.variables[i2] = parseFloat(args);
            else if (args === "true")
              this.client.variables[i2] = true;
            else if (args === "false")
              this.client.variables[i2] = false;
            else
              this.client.variables[i2] = args;
          }
          return null;
        case "setmap":
          if ((this.client.getOption("echo") & 4) === 4)
            this.client.echo(raw, -3, -4, true, true);
          if (args.length === 0)
            throw new Error("Invalid syntax use " + cmdChar + "setmap file \x1B[3msetCharacter\x1B[0;-11;-12m");
          tmp = this.stripQuotes(this.parseInline(args.shift())) || "";
          if (!tmp || !tmp.length)
            throw new Error("Empty file\x1B[0;-11;-12m");
          if (args.length > 1)
            p = this.stripQuotes(this.parseInline(args.join(" "))).toLocaleLowerCase().trim();
          else
            p = "";
          this.emit("setmap", tmp, p === "true" || p === "yes", true);
          return null;
      }
      if (fun.match(/^[-|+]?\d+$/)) {
        if ((this.client.getOption("echo") & 4) === 4)
          this.client.echo(raw, -3, -4, true, true);
        i2 = parseInt(fun, 10);
        if (args.length === 0)
          throw new Error("Invalid syntax use " + cmdChar + "nnn commands");
        args = args.join(" ");
        if (args.match(/^\{[\s\S]*\}$/g))
          args = args.substr(1, args.length - 2);
        if (i2 < 1)
          return this._executeForLoop(-i2 + 1, 1, args);
        return this._executeForLoop(0, i2, args);
      }
      const data = { name: fun, args, raw, handled: false, return: null };
      this.client.emit("function", data);
      if (data.handled) {
        if ((this.client.getOption("echo") & 4) === 4)
          this.client.echo(raw, -3, -4, true, true);
        return data.return;
      }
      if (data.raw.startsWith(cmdChar))
        return cmdChar + this.parseOutgoing(data.raw.substr(1), null, null, null, true);
      return this.parseOutgoing(data.raw + "\n", null, null, null, true);
    }
    _executeForLoop(start, end, commands) {
      let tmp = [];
      let r;
      if (start > end) {
        for (r = start - 1; r >= end; r--) {
          this.loops.push(r);
          try {
            let out = this.parseOutgoing(commands);
            if (out != null && out.length > 0)
              tmp.push(out);
            if (this.stack.continue) {
              this.stack.continue = false;
              continue;
            }
            if (this.stack.break) {
              this.stack.break--;
              break;
            }
          } catch (e) {
            throw e;
          } finally {
            this.loops.pop();
          }
        }
      } else {
        for (r = start; r < end; r++) {
          this.loops.push(r + 1);
          try {
            let out = this.parseOutgoing(commands);
            if (out != null && out.length > 0)
              tmp.push(out);
            if (this.stack.continue) {
              this.stack.continue = false;
              continue;
            }
            if (this.stack.break) {
              this.stack.break--;
              break;
            }
          } catch (e) {
            throw e;
          } finally {
            this.loops.pop();
          }
        }
      }
      if (tmp.length > 0)
        return tmp.map((v) => v.trim()).join("\n");
      return null;
    }
    parseInline(text) {
      return this.parseOutgoing(text, false, null, false, true);
    }
    parseOutgoing(text, eAlias, stacking, append, noFunctions, noComments) {
      const tl = text.length;
      if (!this.enableParsing || text == null || tl === 0)
        return text;
      let str = "";
      let alias = "";
      let AliasesCached;
      let state = 0;
      const aliases = this.client.aliases;
      const stackingChar = this.client.getOption("commandStackingChar");
      const spChar = this.client.getOption("speedpathsChar");
      const ePaths = this.client.getOption("enableSpeedpaths");
      const eCmd = this.client.getOption("enableCommands");
      const cmdChar = this.client.getOption("commandChar");
      const eEscape = this.client.getOption("allowEscape");
      const escChar = this.client.getOption("escapeChar");
      const verbatimChar = this.client.getOption("verbatimChar");
      const eVerbatim = this.client.getOption("enableVerbatim");
      const eParamEscape = this.client.getOption("enableDoubleParameterEscaping");
      const paramChar = this.client.getOption("parametersChar");
      const eParam = this.client.getOption("enableParameters");
      const nParamChar = this.client.getOption("nParametersChar");
      const eNParam = this.client.getOption("enableNParameters");
      const eEval = this.client.getOption("allowEval");
      const iEval = this.client.getOption("ignoreEvalUndefined");
      const iComments = this.client.getOption("enableInlineComments") && !noComments;
      const bComments = this.client.getOption("enableBlockComments") && !noComments;
      const iCommentsStr = this.client.getOption("inlineCommentString").split("");
      const bCommentsStr = this.client.getOption("blockCommentString").split("");
      const bTrim = this.client.getOption("ignoreInputLeadingWhitespace");
      let sTrim = "";
      let args = [];
      let arg = "";
      let findAlias = true;
      let out = "";
      let a;
      let c;
      let al;
      let idx = 0;
      let tmp;
      let tmp2;
      let start = true;
      let _neg = false;
      let _pos = false;
      let _fall = false;
      let nest = 0;
      const pd = this.client.getOption("parseDoubleQuotes");
      const ps = this.client.getOption("parseSingleQuotes");
      if (eAlias == null)
        eAlias = aliases.length > 0;
      else
        eAlias = eAlias && aliases.length > 0;
      if (stackingChar.length === 0)
        stacking = false;
      else if (stacking == null)
        stacking = this.client.getOption("commandStacking");
      else
        stacking = stacking && this.client.getOption("commandStacking");
      for (idx = 0; idx < tl; idx++) {
        c = text.charAt(idx);
        switch (state) {
          case 1 /* doubleQuoted */:
            if (eEscape && c === escChar)
              state = 27 /* doubleQuotedEscape */;
            else {
              if (c === '"' && pd)
                state = 0 /* none */;
              if (eAlias && findAlias)
                alias += c;
              else
                str += c;
            }
            start = false;
            break;
          case 27 /* doubleQuotedEscape */:
            state = 1 /* doubleQuoted */;
            if (c !== '"' && c !== escChar) {
              idx--;
              if (eAlias && findAlias)
                alias += escChar;
              else
                str += escChar;
            } else if (eAlias && findAlias)
              alias += c;
            else
              str += c;
            break;
          case 2 /* singleQuoted */:
            if (eEscape && c === escChar)
              state = 27 /* doubleQuotedEscape */;
            else {
              if (c === "'" && ps)
                state = 0 /* none */;
              if (eAlias && findAlias)
                alias += c;
              else
                str += c;
            }
            start = false;
            break;
          case 28 /* singleQuotedEscape */:
            state = 2 /* singleQuoted */;
            if (c !== "'" && c !== escChar) {
              idx--;
              if (eAlias && findAlias)
                alias += escChar;
              else
                str += escChar;
            } else if (eAlias && findAlias)
              alias += c;
            else
              str += c;
            break;
          case 3 /* aliasArguments */:
            if (c === '"' && pd) {
              arg += c;
              state = 4 /* aliasArgumentsDouble */;
              start = false;
            } else if (c === "'" && ps) {
              arg += c;
              state = 5 /* aliasArgumentsSingle */;
              start = false;
            } else if (eEscape && c === escChar) {
              state = 17 /* aliasArgumentsEscape */;
              start = false;
            } else if (idx === tl - 1 || c === "\n" || stacking && c === stackingChar) {
              if (!(c === "\n" || stacking && c === stackingChar))
                arg += c;
              if (arg.length > 0)
                args.push(this.parseInline(arg));
              al = AliasesCached.length;
              for (a = 0; a < al; a++) {
                str = this.ExecuteAlias(AliasesCached[a], args);
                if (typeof str === "number") {
                  if (str >= 0)
                    this.executeWait(text.substr(idx + 1), str, eAlias, stacking, append, noFunctions, noComments);
                  if (out.length === 0) return null;
                  return out;
                }
                if (str !== null) out += str;
                str = "";
                if (!a.multi) break;
                if (this.stack.continue || this.stack.break) {
                  if (out.length === 0) return null;
                  return out;
                }
              }
              alias = "";
              state = 0 /* none */;
              AliasesCached = null;
              start = true;
            } else if (c === " ") {
              args.push(this.parseInline(arg));
              arg = "";
              start = false;
            } else {
              arg += c;
              start = false;
            }
            break;
          case 4 /* aliasArgumentsDouble */:
            if (c === '"')
              state = 3 /* aliasArguments */;
            arg += c;
            start = false;
            break;
          case 5 /* aliasArgumentsSingle */:
            if (c === "'")
              state = 3 /* aliasArguments */;
            arg += c;
            start = false;
            break;
          case 17 /* aliasArgumentsEscape */:
            state = 3 /* aliasArguments */;
            if (c === escChar || stacking && c === stackingChar || eVerbatim && c === verbatimChar || ePaths && c === spChar || eCmd && c === cmdChar || eParamEscape && c === paramChar || eNParam && c === nParamChar)
              arg += c;
            else if (iComments && c == iCommentsStr[0])
              tmp2 = c;
            else if (bComments && c == bCommentsStr[0])
              tmp2 = c;
            else if (`"'{`.indexOf(c) !== -1)
              arg += c;
            else
              arg += escChar + c;
            break;
          case 6 /* path */:
            if (eEscape && c === escChar) {
              state = 18 /* pathEscape */;
              start = false;
            } else if (c === "\n" || stacking && c === stackingChar) {
              state = 0 /* none */;
              str = this.ProcessPath(str);
              if (str !== null) out += str;
              str = "";
              start = true;
              if (this.stack.continue || this.stack.break) {
                if (out.length === 0) return null;
                return out;
              }
            } else if (idx === 1 && c === spChar) {
              state = 0 /* none */;
              idx--;
              start = false;
            } else {
              str += c;
              start = false;
            }
            break;
          case 18 /* pathEscape */:
            state = 6 /* path */;
            if (c === escChar || stacking && c === stackingChar || eVerbatim && c === verbatimChar || ePaths && c === spChar || eCmd && c === cmdChar || eParamEscape && c === paramChar || eNParam && c === nParamChar)
              str += c;
            else if (iComments && c == iCommentsStr[0])
              tmp2 = c;
            else if (bComments && c == bCommentsStr[0])
              tmp2 = c;
            else if (`"'{`.indexOf(c) !== -1)
              str += c;
            else
              str += escChar + c;
            break;
          case 7 /* function */:
            if (c === "{") {
              start = false;
              str += c;
              nest++;
            } else if (c === "}") {
              start = false;
              str += c;
              nest--;
            } else if (nest === 0 && eEscape && c === escChar) {
              state = 19 /* functionEscape */;
              start = false;
            } else if (nest === 0 && (c === "\n" || stacking && c === stackingChar)) {
              state = 0 /* none */;
              str = this.executeScript(cmdChar + str);
              if (typeof str === "number") {
                if (str >= 0)
                  this.executeWait(text.substr(idx + 1), str, eAlias, stacking, append, noFunctions, noComments);
                if (out.length === 0) return null;
                return out;
              }
              if (str !== null) {
                out += sTrim + str + "\n";
              }
              if (this.stack.continue || this.stack.break) {
                if (out.length === 0) return null;
                return out;
              }
              str = "";
              start = true;
            } else {
              str += c;
              start = false;
            }
            break;
          case 19 /* functionEscape */:
            state = 7 /* function */;
            str += escChar + c;
            break;
          case 8 /* paramsP */:
            if (c === "{" && arg.length === 0) {
              state = 9 /* paramsPBlock */;
              continue;
            }
            switch (c) {
              case paramChar:
                if (arg.length === 0) {
                  if (eAlias && findAlias)
                    alias += paramChar;
                  else
                    str += paramChar;
                  state = 0 /* none */;
                  if (!eParamEscape)
                    idx--;
                }
                break;
              case "*":
                if (arg.length === 0) {
                  if (this.stack.args) {
                    if (eAlias && findAlias)
                      alias += this.stack.args.slice(1).join(" ");
                    else
                      str += this.stack.args.slice(1).join(" ");
                    this.stack.used = this.stack.args.length;
                  } else if (eAlias && findAlias)
                    alias += paramChar + "*";
                  else
                    str += paramChar + "*";
                  state = 0 /* none */;
                  break;
                }
              case "-":
                if (arg.length === 0) {
                  _neg = true;
                  break;
                } else if (_pos && arg.length == 1) {
                  _neg = true;
                  break;
                } else
                  _fall = true;
              case "0":
              case "1":
              case "2":
              case "3":
              case "4":
              case "5":
              case "6":
              case "7":
              case "8":
              case "9":
                if (!_fall) {
                  arg += c;
                  break;
                }
              case "x":
                if (!_fall && arg.length === 0) {
                  _pos = true;
                  break;
                }
              default:
                if (this.stack.args && arg.length > 0) {
                  tmp = parseInt(arg, 10);
                  if (_pos) {
                    if (_neg && this.stack.args.indices && tmp < this.stack.args.length)
                      tmp = this.stack.indices.slice(tmp).map((v) => v ? v[0] + " " + v[1] : "0 0").join(" ");
                    else if (this.stack.args.indices && tmp < this.stack.args.length)
                      tmp = this.stack.args.indices[tmp] ? this.stack.args.indices[tmp][0] + " " + this.stack.args.indices[tmp][1] : "0 0";
                    else if (_neg)
                      tmp = paramChar + "x-" + tmp;
                    else
                      tmp = paramChar + "x" + tmp;
                  } else {
                    if (_neg && tmp < this.stack.args.length)
                      tmp = this.stack.args.slice(arg).join(" ");
                    else if (tmp < this.stack.args.length)
                      tmp = this.stack.args[tmp];
                    else if (_neg)
                      tmp = paramChar + "-" + tmp;
                    else
                      tmp = paramChar + tmp;
                    if (_neg)
                      this.stack.used = this.stack.args.length;
                    else if (arg > this.stack.used)
                      this.stack.used = parseInt(arg, 10);
                  }
                  if (eAlias && findAlias)
                    alias += tmp;
                  else
                    str += tmp;
                  idx--;
                } else {
                  if (arg.length === 0 && this.loops.length > 0) {
                    tmp = c.charCodeAt(0) - 105;
                    if (tmp >= 0 && tmp < 18 && tmp < this.loops.length) {
                      if (eAlias && findAlias)
                        alias += this.loops[tmp];
                      else
                        str += this.loops[tmp];
                      state = 0 /* none */;
                      break;
                    }
                  }
                  if (eAlias && findAlias) {
                    alias += paramChar;
                    if (_neg)
                      alias += "-";
                    if (_pos)
                      alias += "x";
                  } else {
                    str += paramChar;
                    if (_neg)
                      str += "-";
                    if (_pos)
                      str += "x";
                  }
                  idx = idx - arg.length - 1;
                }
                state = 0 /* none */;
                arg = "";
                break;
            }
            break;
          case 26 /* paramsPNamed */:
            if (c.match(/[^a-zA-Z0-9_]/g)) {
              if (this.stack.named.hasOwnProperty(arg)) {
                if (eAlias && findAlias)
                  alias += this.stack.named[arg];
                else
                  str += this.stack.named[arg];
              } else if (eAlias && findAlias)
                alias += paramChar + arg;
              else
                str += paramChar + arg;
              idx--;
              state = 0 /* none */;
              arg = "";
            } else
              arg += c;
            break;
          case 9 /* paramsPBlock */:
            if (c === "}" && nest === 0) {
              if (arg === "i")
                tmp2 = this.loops[0];
              else if (arg === "repeatnum")
                tmp2 = this.repeatnum;
              else if (this.stack.args && arg === "*") {
                tmp2 = this.stack.args.slice(1).join(" ");
                this.stack.used = this.stack.args.length;
              } else if (this.stack.named && this.stack.named.hasOwnProperty(arg))
                tmp2 = this.stack.named[arg];
              else {
                if (this.stack.args && !isNaN(arg)) {
                  tmp = parseInt(arg, 10);
                  if (tmp < 0) {
                    if (-tmp >= this.stack.args.length) {
                      if (eEval)
                        tmp2 = tmp;
                      else {
                        tmp2 = paramChar;
                        idx = idx - tmp.length - 2;
                      }
                    } else {
                      tmp2 = this.stack.args.slice(tmp).join(" ");
                      this.stack.used = this.stack.args.length;
                    }
                  } else if (tmp < this.stack.args.length) {
                    tmp2 = this.stack.args[tmp];
                    if (arg > this.stack.used)
                      this.stack.used = tmp;
                  } else if (eEval)
                    tmp2 = tmp;
                  else {
                    tmp2 = paramChar;
                    idx = idx - arg.length - 2;
                  }
                } else if (this.stack.args && this.stack.args.indices && arg.match(/^x[-|+]?\d+$/)) {
                  tmp = parseInt(arg.substring(1), 10);
                  if (tmp < 0) {
                    if (-tmp >= this.stack.args.length) {
                      tmp2 = paramChar;
                      idx = idx - tmp.length - 2;
                    } else
                      tmp2 = this.stack.indices.slice(tmp).map((v) => v ? v[0] + " " + v[1] : "0 0").join(" ");
                  } else if (tmp < this.stack.args.length)
                    tmp2 = this.stack.args.indices[tmp] ? this.stack.args.indices[tmp][0] + " " + this.stack.args.indices[tmp][1] : "0 0";
                  else {
                    tmp2 = paramChar;
                    idx = idx - arg.length - 2;
                  }
                } else {
                  tmp = this.parseVariable(arg);
                  if (tmp != null)
                    tmp2 = tmp;
                  else if (eEval) {
                    tmp2 = this.evaluate(this.parseInline(arg));
                    if (iEval && typeof tmp2 === "undefined")
                      tmp2 = null;
                    else
                      tmp2 = "" + tmp2;
                  } else {
                    tmp2 = paramChar;
                    idx = idx - arg.length - 2;
                  }
                }
              }
              if (tmp2 != null && eAlias && findAlias)
                alias += tmp2;
              else if (tmp2 != null)
                str += tmp2;
              state = 0;
              arg = "";
            } else if (c === "{") {
              nest++;
              arg += c;
            } else if (c === "}") {
              nest--;
              arg += c;
            } else
              arg += c;
            break;
          /*
          case ParseState.paramsPEscape:
              if (c === '{')
                  tmp2 = paramChar+'{';
              else if (c === escChar)
                  tmp2 = paramChar + escChar;
              else {
                  tmp2 = paramChar + escChar;
                  idx--;
              }
              if (eAlias && findAlias)
                  alias += tmp2;
              else
                  str += tmp2;
              state = ParseState.none;
              break;
          */
          case 11 /* paramsN */:
            if (c === "{")
              state = 12 /* paramsNBlock */;
            else if (c.match(/[^a-zA-Z_$]/g)) {
              state = 0 /* none */;
              idx--;
              if (eAlias && findAlias)
                alias += nParamChar;
              else
                str += nParamChar;
            } else {
              arg = c;
              state = 14 /* paramsNNamed */;
            }
            break;
          case 14 /* paramsNNamed */:
            if (c.match(/[^a-zA-Z0-9_]/g)) {
              if (this.stack.named && this.stack.named.hasOwnProperty(arg)) {
                if (eAlias && findAlias)
                  alias += this.stack.named[arg];
                else
                  str += this.stack.named[arg];
              } else if (this.client.variables.hasOwnProperty(arg)) {
                if (eAlias && findAlias)
                  alias += this.client.variables[arg];
                else
                  str += this.client.variables[arg];
              } else if (eAlias && findAlias)
                alias += nParamChar + arg;
              else
                str += nParamChar + arg;
              idx--;
              state = 0 /* none */;
              arg = "";
            } else
              arg += c;
            break;
          /*
                          case ParseState.paramsNEscape:
                              if (c === '{')
                                  tmp2 = `\{`;
                              else if (c === escChar) 
                                  tmp2 = escChar;
                              else {
                                  tmp2 = nParamChar + escChar;
                                  idx--;
                              }
                              if (eAlias && findAlias)
                                  alias += tmp2;
                              else
                                  str += tmp2;
                              state = ParseState.none;
                              break;
                              */
          case 12 /* paramsNBlock */:
            if (c === "}" && nest === 0) {
              tmp2 = null;
              if (arg === "i")
                tmp2 = this.loops[0];
              else if (arg === "repeatnum")
                tmp2 = this.repeatnum;
              else if (this.stack.args && arg === "*") {
                tmp2 = this.stack.args.slice(1).join(" ");
                this.stack.used = this.stack.args.length;
              } else if (this.stack.named && this.stack.named.hasOwnProperty(arg))
                tmp2 = this.stack.named[arg];
              else {
                if (this.stack.args && !isNaN(arg)) {
                  tmp = parseInt(arg, 10);
                  if (tmp < 0) {
                    if (-tmp >= this.stack.args.length) {
                      if (eEval)
                        tmp2 = tmp;
                      else {
                        tmp2 = nParamChar;
                        idx = idx - arg.length - 2;
                      }
                    } else {
                      tmp2 = this.stack.args.slice(tmp).join(" ");
                      this.stack.used = this.stack.args.length;
                    }
                  } else if (tmp < this.stack.args.length) {
                    tmp2 = this.stack.args[tmp];
                    if (tmp > this.stack.used)
                      this.stack.used = tmp;
                  } else if (eEval)
                    tmp2 = tmp;
                  else {
                    tmp2 = nParamChar;
                    idx = idx - arg.length - 2;
                  }
                } else if (this.stack.args && this.stack.args.indices && arg.match(/^x[-|+]?\d+$/)) {
                  tmp = parseInt(arg.substring(1), 10);
                  if (tmp < 0) {
                    if (-tmp >= this.stack.args.length) {
                      tmp2 = nParamChar;
                      idx = idx - arg.length - 2;
                    } else
                      tmp2 = this.stack.indices.slice(tmp).map((v) => v ? v[0] + " " + v[1] : "0 0").join(" ");
                  } else if (tmp < this.stack.args.length)
                    tmp2 = this.stack.args.indices[tmp] ? this.stack.args.indices[tmp][0] + " " + this.stack.args.indices[tmp][1] : "0 0";
                  else {
                    tmp2 = nParamChar;
                    idx = idx - arg.length - 2;
                  }
                } else {
                  c = this.parseVariable(arg);
                  if (c != null)
                    tmp2 = c;
                  else if (eEval) {
                    tmp2 = this.evaluate(this.parseInline(arg));
                    if (iEval && typeof tmp2 === "undefined")
                      tmp2 = null;
                    else
                      tmp2 = "" + tmp2;
                  } else {
                    tmp2 = nParamChar;
                    idx = idx - arg.length - 2;
                  }
                }
              }
              if (tmp2 != null && eAlias && findAlias)
                alias += tmp2;
              else if (tmp2 != null)
                str += tmp2;
              state = 0 /* none */;
              arg = "";
            } else if (c === "{") {
              nest++;
              arg += c;
            } else if (c === "}") {
              nest--;
              arg += c;
            } else
              arg += c;
            break;
          case 15 /* escape */:
            if (c === escChar || stacking && c === stackingChar || eVerbatim && c === verbatimChar || ePaths && c === spChar || eCmd && c === cmdChar || eParamEscape && c === paramChar || eNParam && c === nParamChar)
              tmp2 = c;
            else if (iComments && c == iCommentsStr[0])
              tmp2 = c;
            else if (bComments && c == bCommentsStr[0])
              tmp2 = c;
            else if (`"'{`.indexOf(c) !== -1)
              tmp2 = c;
            else
              tmp2 = escChar + c;
            if (eAlias && findAlias)
              alias += tmp2;
            else
              str += tmp2;
            state = 0 /* none */;
            break;
          case 16 /* verbatim */:
            if (c === "\n") {
              state = 0 /* none */;
              out += str + c;
              str = "";
              start = true;
            } else {
              str += c;
              start = false;
            }
            break;
          case 20 /* comment */:
            if (iComments && c === iCommentsStr[1])
              state = 22 /* inlineComment */;
            else if (bComments && c === bCommentsStr[1])
              state = 24 /* blockComment */;
            else {
              state = 0 /* none */;
              if (eAlias && findAlias)
                alias += iCommentsStr[0];
              else
                str += iCommentsStr[0];
              idx--;
            }
            break;
          case 21 /* inlineCommentStart */:
            if (c === iCommentsStr[1])
              state = 22 /* inlineComment */;
            else {
              state = 0 /* none */;
              if (eAlias && findAlias)
                alias += iCommentsStr[0];
              else
                str += iCommentsStr[0];
              idx--;
            }
            break;
          case 23 /* blockCommentStart */:
            if (bComments && c === bCommentsStr[1])
              state = 25 /* blockCommentEnd */;
            else {
              state = 0 /* none */;
              if (eAlias && findAlias)
                alias += bCommentsStr[0];
              else
                str += bCommentsStr[0];
              idx--;
            }
            break;
          case 22 /* inlineComment */:
            if (c === "\n") {
              state = 0 /* none */;
              if (!start)
                idx--;
              else {
                alias = "";
                findAlias = true;
                start = true;
              }
            }
            break;
          case 24 /* blockComment */:
            if (bCommentsStr.length === 1) {
              if (c === bCommentsStr[0])
                state = 0 /* none */;
            } else if (c === bCommentsStr[1])
              state = 25 /* blockCommentEnd */;
            break;
          case 25 /* blockCommentEnd */:
            if (c === bCommentsStr[0])
              state = 0 /* none */;
            else
              state = 24 /* blockComment */;
            break;
          default:
            if ((iComments || bComments) && c === iCommentsStr[0] && c === bCommentsStr[0]) {
              if (iComments && iCommentsStr.length === 1)
                state = 22 /* inlineComment */;
              else if (bComments && bCommentsStr.length === 1)
                state = 24 /* blockComment */;
              else
                state = 20 /* comment */;
              continue;
            } else if (iComments && c === iCommentsStr[0]) {
              if (iCommentsStr.length === 1)
                state = 22 /* inlineComment */;
              else
                state = 21 /* inlineCommentStart */;
              continue;
            } else if (bComments && c === bCommentsStr[0]) {
              if (bCommentsStr.length === 1)
                state = 24 /* blockComment */;
              else
                state = 23 /* blockCommentStart */;
              continue;
            } else if (eEscape && c === escChar) {
              state = 15 /* escape */;
              start = false;
              continue;
            } else if (eParam && c === paramChar) {
              state = 8 /* paramsP */;
              _neg = false;
              _pos = false;
              _fall = false;
              arg = "";
              start = false;
            } else if (eNParam && c === nParamChar) {
              state = 11 /* paramsN */;
              _neg = false;
              _pos = false;
              _fall = false;
              arg = "";
              start = false;
            } else if (!noFunctions && eCmd && start && c === cmdChar) {
              state = 7 /* function */;
              start = false;
              if (alias.length) {
                sTrim = alias;
                alias = "";
              } else {
                sTrim = str || "";
                str = "";
              }
            } else if (eVerbatim && start && c === verbatimChar) {
              state = 16 /* verbatim */;
              start = false;
            } else if (ePaths && start && c === spChar) {
              state = 6 /* path */;
              start = false;
            } else if (c === '"' && pd) {
              if (eAlias && findAlias)
                alias += c;
              else
                str += c;
              state = 1 /* doubleQuoted */;
              start = false;
            } else if (c === "'" && ps) {
              if (eAlias && findAlias)
                alias += c;
              else
                str += c;
              state = 2 /* singleQuoted */;
              start = false;
            } else if (start && bTrim && (c === " " || c === "	" || c === "\f" || c === "\r" || c === "\v" || c === " " || c === "\xA0" || c === "\u1680" || c === "\u2000-" || c === "\u200A" || c === "\u2028" || c === "\u2029" || c === "\u202F" || c === "\u205F" || c === "\u3000" || c === "\uFEFF")) {
              if (eAlias && findAlias)
                alias += c;
              else
                str += c;
            } else if (eAlias && findAlias && c === " ") {
              AliasesCached = FilterArrayByKeyValue(aliases, "pattern", bTrim ? alias.trimStart() : alias);
              if (AliasesCached.length > 0) {
                state = 3 /* aliasArguments */;
                args.length = 0;
                arg = "";
                args.push(bTrim ? alias.trimStart() : alias);
              } else {
                str += alias + " ";
                alias = "";
                AliasesCached = null;
              }
              findAlias = false;
              start = false;
            } else if (c === "\n" || stacking && c === stackingChar) {
              if (eAlias && findAlias && alias.length > 0) {
                AliasesCached = FilterArrayByKeyValue(aliases, "pattern", bTrim ? alias.trimStart() : alias);
                if (AliasesCached.length > 0) {
                  args.push(bTrim ? alias.trimStart() : alias);
                  al = AliasesCached.length;
                  for (a = 0; a < al; a++) {
                    str = this.ExecuteAlias(AliasesCached[a], args);
                    if (typeof str === "number") {
                      if (str >= 0)
                        this.executeWait(text.substr(idx + 1), str, eAlias, stacking, append, noFunctions, noComments);
                      if (out.length === 0) return null;
                      return out;
                    }
                    if (str !== null) out += str;
                    if (!a.multi) break;
                    if (this.stack.continue || this.stack.break) {
                      if (out.length === 0) return null;
                      return out;
                    }
                  }
                  str = "";
                  args.length = 0;
                  arg = "";
                } else {
                  str = this.ExecuteTriggers(1 /* CommandInputRegular */ | 16 /* CommandInputPattern */, alias, alias, false, true);
                  if (typeof str === "number") {
                    if (str >= 0)
                      this.executeWait(text.substr(idx + 1), str, eAlias, stacking, append, noFunctions, noComments);
                    if (out.length === 0) return null;
                    return out;
                  }
                  if (str !== null) out += str + "\n";
                  str = "";
                  AliasesCached = null;
                }
              } else {
                str = this.ExecuteTriggers(1 /* CommandInputRegular */ | 16 /* CommandInputPattern */, str, str, false, true);
                if (typeof str === "number") {
                  if (str >= 0)
                    this.executeWait(text.substr(idx + 1), str, eAlias, stacking, append, noFunctions, noComments);
                  if (out.length === 0) return null;
                  return out;
                }
                if (str !== null) out += str + "\n";
                str = "";
              }
              if (this.stack.continue || this.stack.break) {
                if (out.length === 0) return null;
                return out;
              }
              alias = "";
              findAlias = true;
              start = true;
            } else if (eAlias && findAlias) {
              alias += c;
              start = false;
            } else {
              str += c;
              start = false;
            }
            break;
        }
      }
      if (state === 15 /* escape */)
        str += escChar;
      else if (state === 14 /* paramsNNamed */ && arg.length > 0) {
        if (this.stack.named && this.stack.named[arg])
          str += this.stack.named[arg];
        else if (this.client.variables.hasOwnProperty(arg))
          str += this.client.variables[arg];
        else {
          arg = this.parseInline(arg);
          str += nParamChar;
          if (arg != null) str += arg;
        }
      } else if (state === 8 /* paramsP */ && arg.length > 0) {
        if (this.stack.args) {
          arg = parseInt(arg, 10);
          if (_pos && this.stack.args.indices && arg < this.stack.args.length)
            str += this.stack.args.indices[arg] ? this.stack.args.indices[arg][0] + " " + this.stack.args.indices[arg][1] : "0 0";
          else {
            if (_neg && arg < this.stack.args.length)
              str += this.stack.args.slice(arg).join(" ");
            else if (arg < this.stack.args.length)
              str += this.stack.args[arg];
            if (_neg)
              this.stack.used = this.stack.args.length;
            else if (arg > this.stack.used)
              this.stack.used = arg;
          }
        } else {
          arg = this.parseInline(arg);
          str += paramChar;
          if (_neg)
            str += "-";
          if (_pos)
            str += "x";
          if (arg != null) str += arg;
        }
      } else if (state === 9 /* paramsPBlock */) {
        arg = this.parseInline(arg);
        str += paramChar + "{";
        if (arg != null) str += arg;
      } else if (state === 11 /* paramsN */ && arg.length > 0) {
        if (this.stack.named) {
          if (this.stack.named.hasOwnProperty(arg)) {
            str += this.stack.named[arg];
          } else {
            arg = this.parseInline(arg);
            str += nParamChar;
            if (arg != null) str += arg;
          }
        } else {
          arg = this.parseInline(arg);
          str += nParamChar;
          if (arg != null) str += arg;
        }
      } else if (state === 12 /* paramsNBlock */) {
        arg = this.parseInline(arg);
        str += `${nParamChar}{`;
        if (arg != null) str += arg;
      } else if (state === 6 /* path */) {
        str = this.ProcessPath(str);
        if (str !== null) out += str;
        str = "";
      } else if (state === 20 /* comment */) {
        str += iCommentsStr[0];
        idx--;
      } else if (state === 21 /* inlineCommentStart */) {
        str += iCommentsStr[0];
        idx--;
      } else if (state === 23 /* blockCommentStart */) {
        str += bCommentsStr[0];
        idx--;
      }
      if (!noFunctions && state === 7 /* function */) {
        str = this.executeScript(cmdChar + str);
        if (typeof str === "number") {
          if (str >= 0)
            this.executeWait(text.substr(idx + 1), str, eAlias, stacking, append, noFunctions, noComments);
          if (out.length === 0) return null;
          return out;
        }
        if (str !== null) {
          if (append && eAlias && this.stack.args && this.stack.append && this.stack.args.length - 1 > 0 && this.stack.used + 1 < this.stack.args.length) {
            let r = false;
            if (str.endsWith("\n")) {
              str = str.substring(0, str.length - 1);
              r = true;
            }
            if (!str.endsWith(" "))
              str += " ";
            if (this.stack.used < 1)
              str += this.stack.args.slice(1).join(" ");
            else
              str += this.stack.args.slice(this.stack.used + 1).join(" ");
            this.stack.used = this.stack.args.length;
            if (r) str += "\n";
          }
          out += sTrim + str;
        } else if (out.length === 0) return null;
        if (this.stack.continue || this.stack.break) {
          if (out.length === 0) return null;
          return out;
        }
      } else if (state === 16 /* verbatim */) {
        if (append && eAlias && this.stack.args && this.stack.append && this.stack.args.length - 1 > 0 && this.stack.used + 1 < this.stack.args.length) {
          let r = false;
          if (str.endsWith("\n")) {
            str = str.substring(0, str.length - 1);
            r = true;
          }
          if (!str.endsWith(" "))
            str += " ";
          if (this.stack.used < 1)
            str += this.stack.args.slice(1).join(" ");
          else
            str += this.stack.args.slice(this.stack.used + 1).join(" ");
          this.stack.used = this.stack.args.length;
          if (r) str += "\n";
        }
        out += str;
      } else if (alias.length > 0 && eAlias && findAlias) {
        if (append && eAlias && this.stack.args && this.stack.append && this.stack.args.length - 1 > 0 && this.stack.used + 1 < this.stack.args.length) {
          let r = false;
          if (str.endsWith("\n")) {
            str = str.substring(0, str.length - 1);
            r = true;
          }
          if (!str.endsWith(" "))
            str += " ";
          if (this.stack.used < 1)
            str += this.stack.args.slice(1).join(" ");
          else
            str += this.stack.args.slice(this.stack.used + 1).join(" ");
          this.stack.used = this.stack.args.length;
          if (r) str += "\n";
        }
        if (str.length > 0)
          alias += str;
        AliasesCached = FilterArrayByKeyValue(aliases, "pattern", bTrim ? alias.trimStart() : alias);
        if (AliasesCached.length > 0) {
          args.push(bTrim ? alias.trimStart() : alias);
          al = AliasesCached.length;
          for (a = 0; a < al; a++) {
            str = this.ExecuteAlias(AliasesCached[a], args);
            if (typeof str === "number") {
              if (str >= 0)
                this.executeWait(text.substr(idx + 1), str, eAlias, stacking, append, noFunctions, noComments);
              if (out.length === 0) return null;
              return out;
            }
            if (str !== null) out += str;
            else if (out.length === 0) return null;
            if (this.stack.continue || this.stack.break) {
              return out;
            }
            if (!a.multi) break;
          }
        } else {
          str = this.ExecuteTriggers(1 /* CommandInputRegular */ | 16 /* CommandInputPattern */, alias, alias, false, true);
          if (typeof str === "number") {
            if (str >= 0)
              this.executeWait(text.substr(idx + 1), str, eAlias, stacking, append, noFunctions, noComments);
            if (out.length === 0) return null;
            return out;
          }
          if (str !== null) out += str;
          else if (out.length === 0) return null;
          if (this.stack.continue || this.stack.break) {
            return out;
          }
        }
        AliasesCached = null;
      } else if (alias.length > 0) {
        if (str.length > 0)
          alias += str;
        str = this.ExecuteTriggers(1 /* CommandInputRegular */ | 16 /* CommandInputPattern */, alias, alias, false, true);
        if (typeof str === "number") {
          if (str >= 0)
            this.executeWait(text.substr(idx + 1), str, eAlias, stacking, append, noFunctions, noComments);
          if (out.length === 0) return null;
          return out;
        }
        if (str !== null) {
          if (append && eAlias && this.stack.args && this.stack.append && this.stack.args.length - 1 > 0 && this.stack.used + 1 < this.stack.args.length) {
            let r = false;
            if (str.endsWith("\n")) {
              str = str.substring(0, str.length - 1);
              r = true;
            }
            if (!str.endsWith(" "))
              str += " ";
            if (this.stack.used < 1)
              str += this.stack.args.slice(1).join(" ");
            else
              str += this.stack.args.slice(this.stack.used + 1).join(" ");
            this.stack.used = this.stack.args.length;
            if (r) str += "\n";
          }
          out += str;
        } else if (out.length === 0) return null;
        if (this.stack.continue || this.stack.break) {
          if (out.length === 0) return null;
          return out;
        }
      } else if (str.length > 0) {
        str = this.ExecuteTriggers(1 /* CommandInputRegular */ | 16 /* CommandInputPattern */, str, str, false, true);
        if (typeof str === "number") {
          if (str >= 0)
            this.executeWait(text.substr(idx + 1), str, eAlias, stacking, append, noFunctions, noComments);
          if (out.length === 0) return null;
          return out;
        }
        if (str !== null) {
          if (append && eAlias && this.stack.args && this.stack.append && this.stack.args.length - 1 > 0 && this.stack.used + 1 < this.stack.args.length) {
            let r = false;
            if (str.endsWith("\n")) {
              str = str.substring(0, str.length - 1);
              r = true;
            }
            if (!str.endsWith(" "))
              str += " ";
            if (this.stack.used < 1)
              str += this.stack.args.slice(1).join(" ");
            else
              str += this.stack.args.slice(this.stack.used + 1).join(" ");
            if (r) str += "\n";
          }
          out += str;
        } else if (out.length === 0) return null;
        if (this.stack.continue || this.stack.break) {
          if (out.length === 0) return null;
          return out;
        }
      }
      args.length = 0;
      args = null;
      arg = null;
      alias = null;
      return out;
    }
    parseVariable(text) {
      let c;
      switch (text) {
        case "esc":
          return "\x1B";
        case "cr":
          return "\n";
        case "lf":
          return "\r";
        case "crlf":
          return "\r\n";
        case "copied":
          return window.$copied;
        case "copied.lower":
          return window.$copied.toLowerCase();
        case "copied.upper":
          return window.$copied.toUpperCase();
        case "copied.proper":
          return ProperCase(window.$copied);
        case "i":
          return this.loops[0];
        case "repeatnum":
          return this.vStack["$repeatnum"] || this.repeatnum;
        case "character":
          return window.$character;
        case "character.lower":
          return window.$character.toLowerCase();
        case "character.upper":
          return window.$character.toUpperCase();
        case "character.proper":
          return ProperCase(window.$character);
        case "selected":
        case "selectedurl":
        case "selectedline":
        case "selectedword":
        case "selurl":
        case "selline":
        case "selword":
        case "action":
        case "trigger":
          return this.vStack["$" + text] || window["$" + text] || "";
        case "selected.lower":
        case "selectedurl.lower":
        case "selectedline.lower":
        case "selectedword.lower":
        case "selurl.lower":
        case "selline.lower":
        case "selword.lower":
          return (this.vStack["$" + text.substr(0, text.length - 6)] || window["$" + text.substr(0, text.length - 6)] || "").toLowerCase();
        case "selected.upper":
        case "selectedurl.upper":
        case "selectedline.upper":
        case "selectedword.upper":
        case "selurl.upper":
        case "selline.upper":
        case "selword.upper":
          return (this.vStack["$" + text.substr(0, text.length - 6)] || window["$" + text.substr(0, text.length - 6)] || "").toUpperCase();
        case "selected.proper":
        case "selectedurl.proper":
        case "selectedline.proper":
        case "selectedword.proper":
        case "selurl.proper":
        case "selline.proper":
        case "selword.proper":
          return ProperCase(this.vStack["$" + text.substr(0, text.length - 7)] || window["$" + text.substr(0, text.length - 7)]);
        case "random":
          return mathjs().randomInt(0, 100);
      }
      if (WindowVariables.indexOf(text) !== -1)
        return this.vStack["$" + text] || window["$" + text] || "";
      if (this.loops.length && text.length === 1) {
        let i2 = text.charCodeAt(0) - 105;
        if (i2 >= 0 && i2 < 18 && i2 < this.loops.length)
          return this.loops[i2];
      }
      const re = new RegExp("^([a-zA-Z]+)\\((.*)\\)$", "g");
      let res = re.exec(text);
      if (!res || !res.length) {
        const data2 = { raw: text, name: text, args: [], handled: false, return: null };
        this.client.emit("variable", data2);
        if (data2.handled)
          return data2.return;
        return null;
      }
      let sides;
      let mod;
      let args;
      let min;
      let max2;
      let escape2 = this.client.getOption("allowEscape") ? this.client.getOption("escapeChar") : "";
      switch (res[1]) {
        case "time":
          if (!moment) return (/* @__PURE__ */ new Date()).toISOString();
          if (res[2] && res[2].length > 0)
            return moment().format(this.stripQuotes(this.parseInline(res[2])));
          return moment().format();
        case "clip":
          if (res[2] && res[2].length > 0) {
            this.client.writeClipboard(this.stripQuotes(this.parseInline(res[2])));
            return null;
          }
          return this.client.readClipboard();
        case "lower":
          return this.stripQuotes(this.parseInline(res[2]).toLowerCase());
        case "upper":
          return this.stripQuotes(this.parseInline(res[2]).toUpperCase());
        case "proper":
          return ProperCase(this.stripQuotes(this.parseInline(res[2])));
        case "eval":
          args = this.evaluate(this.parseInline(res[2]));
          if (this.client.getOption("ignoreEvalUndefined") && typeof args === "undefined")
            return null;
          return "" + args;
        case "dice":
          args = this.parseInline(res[2]).split(",");
          if (args.length === 0) throw new Error("Invalid dice");
          if (args.length === 1) {
            res = /(\d+)\s*?d(F|f|%|\d+)(\s*?[-|+|*|\/]?\s*?\d+)?/g.exec(args[0]);
            if (!res || res.length < 3) return null;
            c = parseInt(res[1]);
            sides = res[2];
            if (res.length > 3)
              mod = res[3];
          } else if (args.length < 4) {
            c = parseInt(args[0]);
            sides = args[1].trim();
            if (args.length > 2)
              mod = args[2].trim();
          } else
            throw new Error("Too many arguments for dice");
          if (sides === "F" || sides === "f")
            sides = "F";
          else if (sides !== "%")
            sides = parseInt(sides);
          let sum = 0;
          for (let i2 = 0; i2 < c; i2++) {
            if (sides === "F" || sides === "f")
              sum += fudgeDice();
            else if (sides === "%")
              sum += ~~(Math.random() * 100) + 1;
            else
              sum += ~~(Math.random() * sides) + 1;
          }
          if (sides === "%")
            sum /= 100;
          if (mod)
            return this.evaluate(sum + mod);
          return "" + sum;
        case "diceavg":
          args = this.parseInline(res[2]).split(",");
          if (args.length === 0) throw new Error("Invalid dice for diceavg");
          if (args.length === 1) {
            res = /(\d+)d(F|f|%|\d+)([-|+|*|/]?\d+)?/g.exec(args[0]);
            if (!res || res.length < 3) return null;
            c = parseInt(res[1]);
            sides = res[2];
            if (res.length > 3)
              mod = res[3];
          } else if (args.length < 4) {
            c = parseInt(args[0]);
            sides = args[1].trim();
            if (args.length > 2)
              mod = args[2].trim();
          } else
            throw new Error("Too many arguments for diceavg");
          min = 1;
          if (sides === "F" || sides === "f") {
            min = -1;
            max2 = 1;
          } else if (sides === "%") {
            min = 0;
            max2 = 1;
          } else
            max2 = parseInt(sides);
          if (mod)
            return this.evaluate((min + max2) / 2 * c + mod);
          return "" + (min + max2) / 2 * c;
        case "dicemin":
          args = this.parseInline(res[2]).split(",");
          if (args.length === 0) throw new Error("Invalid dice for dicemin");
          if (args.length === 1) {
            res = /(\d+)d(F|f|%|\d+)([-|+|*|/]?\d+)?/g.exec(args[0]);
            if (!res || res.length < 3) return null;
            c = parseInt(res[1]);
            sides = res[2];
            if (res.length > 3)
              mod = res[3];
          } else if (args.length < 4) {
            c = parseInt(args[0]);
            sides = args[1].trim();
            if (args.length > 2)
              mod = args[2];
          } else
            throw new Error("Too many arguments for dicemin");
          min = 1;
          if (sides === "F" || sides === "f")
            min = -1;
          else if (sides === "%")
            min = 0;
          if (mod)
            return this.evaluate(min * c + mod);
          return "" + min * c;
        case "dicemax":
          args = this.parseInline(res[2]).split(",");
          if (args.length === 0) throw new Error("Invalid dice for dicemax");
          if (args.length === 1) {
            res = /(\d+)d(F|f|%|\d+)([-|+|*|/]?\d+)?/g.exec(args[0]);
            if (!res || res.length < 3) return null;
            c = parseInt(res[1]);
            sides = res[2];
            if (res.length > 3)
              mod = res[3];
          } else if (args.length < 4) {
            c = parseInt(args[0]);
            sides = args[1].trim();
            if (args.length > 2)
              mod = args[2].trim();
          } else
            throw new Error("Too many arguments for dicemax");
          if (sides === "F" || sides === "f")
            max2 = 1;
          else if (sides === "%")
            max2 = 1;
          else
            max2 = parseInt(sides);
          if (mod)
            return this.evaluate(max2 * c + mod);
          return "" + max2 * c;
        case "zdicedev":
        case "dicedev":
          const fun = res[1];
          args = this.parseInline(res[2]).split(",");
          if (args.length === 0) throw new Error("Invalid dice for " + fun);
          if (args.length === 1) {
            res = /(\d+)d(F|f|%|\d+)([-|+|*|/]?\d+)?/g.exec(args[0]);
            if (!res || res.length < 3) return null;
            c = parseInt(res[1]);
            sides = res[2];
            if (res.length > 3)
              mod = res[3];
          } else if (args.length < 4) {
            c = parseInt(args[0]);
            sides = args[1].trim();
            if (args.length > 2)
              mod = args[2].trim();
          } else
            throw new Error("Too many arguments for " + fun);
          if (sides === "F" || sides === "f")
            max2 = 6;
          else if (sides === "%")
            max2 = 1;
          else
            max2 = parseInt(sides);
          if (fun === "zdicedev")
            max2--;
          if (mod)
            return this.evaluate(Math.sqrt((max2 * max2 - 1) / 12 * c) + mod);
          return "" + Math.sqrt((max2 * max2 - 1) / 12 * c);
        case "color":
          args = this.parseInline(res[2]).split(",");
          if (args.length === 0)
            throw new Error("Missing arguments for color");
          else if (args.length === 1) {
            if (args[0] === "bold")
              return "370";
            c = getAnsiColorCode(args[0]);
            if (c === -1)
              throw new Error("Invalid fore color");
            return c.toString();
          } else if (args.length === 2) {
            if (args[0] === "bold")
              c = 370;
            else {
              c = getAnsiColorCode(args[0]);
              if (c === -1)
                throw new Error("Invalid fore color");
              if (args[1] === "bold")
                return (c * 10).toString();
            }
            sides = c.toString();
            c = getAnsiColorCode(args[1], true);
            if (c === -1)
              throw new Error("Invalid back color");
            return sides + "," + c.toString();
          } else if (args.length === 3) {
            if (args[0] === "bold") {
              args.shift();
              args.push("bold");
            }
            if (args[2] !== "bold")
              throw new Error("Only bold is supported as third argument for color");
            c = getAnsiColorCode(args[0]);
            if (c === -1)
              throw new Error("Invalid fore color");
            sides = (c * 10).toString();
            c = getAnsiColorCode(args[1], true);
            if (c === -1)
              throw new Error("Invalid back color");
            return sides + "," + c.toString();
          }
          throw new Error("Too many arguments");
        case "zcolor":
          args = this.parseInline(res[2]).split(",");
          if (args.length === 0)
            throw new Error("Missing arguments for zcolor");
          else if (args.length > 1)
            throw new Error("Too many arguments for zcolor");
          return getColorCode(parseInt(args[0], 10));
        case "ansi":
          args = this.parseInline(res[2]).split(",");
          if (args.length === 0)
            throw new Error("Missing arguments for ansi");
          c = args.length;
          mod = [];
          min = {};
          for (sides = 0; sides < c; sides++) {
            if (args[sides].trim() === "current")
              mod.push(args[sides].trim());
            else {
              max2 = getAnsiCode(args[sides].trim());
              if (max2 === -1)
                throw new Error("Invalid color or style for ansi");
              if (max2 >= 0 && max2 < 30)
                min[max2] = 1;
              else
                mod.push(args[sides]);
            }
          }
          if (mod.length > 2)
            throw new Error("Too many colors for ansi");
          if (mod.length > 1) {
            if (mod[1] === "current")
              mod[1] = "";
            else
              mod[1] = getAnsiCode(mod[1], true);
          }
          if (mod.length > 0) {
            if (min[1] && mod[0] === "white")
              mod[0] = "";
            else if (mod[0] === "current")
              mod[0] = "";
            else
              mod[0] = getAnsiCode(mod[0]);
          }
          min = [...Object.keys(min), ...mod];
          if (!min.length)
            throw new Error("Invalid colors or styles for ansi");
          min = min.filter((f) => f !== "");
          return `\x1B[${min.join(";")}m`;
        case "random":
          args = this.parseInline(res[2]).split(",");
          if (args.length === 0) throw new Error("Invalid random");
          if (args.length === 1)
            return mathjs().randomInt(0, parseInt(args[0], 10) + 1);
          else if (args.length === 2)
            return mathjs().randomInt(parseInt(args[0], 10), parseInt(args[1], 10) + 1);
          else
            throw new Error("Too many arguments for random");
        case "case":
          args = this.splitByQuotes(this.parseInline(res[2]), ",");
          if (args.length === 0)
            throw new Error("Missing arguments for case");
          c = this.evaluate(this.parseInline(args[0]));
          if (typeof c !== "number")
            return "";
          if (c > 0 && c < args.length)
            return this.stripQuotes(args[c]);
          return "";
        case "switch":
          args = this.splitByQuotes(this.parseInline(res[2]), ",");
          if (args.length === 0)
            throw new Error("Missing arguments for switch");
          if (args.length % 2 === 1)
            throw new Error("All expressions must have a value for switch");
          sides = args.length;
          for (c = 0; c < sides; c += 2) {
            if (this.evaluate(args[c]))
              return this.stripQuotes(args[c + 1]);
          }
          return "";
        case "if":
          args = this.splitByQuotes(this.parseInline(res[2]), ",");
          if (args.length < 3)
            throw new Error("Missing arguments for if");
          if (args.length !== 3)
            throw new Error("Too many arguments for if");
          if (this.evaluate(args[0]))
            return this.stripQuotes(args[1].trim());
          return this.stripQuotes(args[2].trim());
        case "ascii":
          args = this.parseInline(res[2]).split(",");
          if (args.length === 0)
            throw new Error("Missing arguments for ascii");
          else if (args.length > 1)
            throw new Error("Too many arguments for ascii");
          if (args[0].trim().length === 0)
            throw new Error("Invalid argument, empty string for ascii");
          return args[0].trim().charCodeAt(0);
        case "char":
          args = this.parseInline(res[2]).split(",");
          if (args.length === 0)
            throw new Error("Missing arguments for char");
          else if (args.length > 1)
            throw new Error("Too many arguments for char");
          c = parseInt(args[0], 10);
          if (isNaN(c))
            throw new Error("Invalid argument '" + args[0] + "' must be a number for char");
          return String.fromCharCode(c);
        case "begins":
          args = this.splitByQuotes(this.parseInline(res[2]), ",");
          if (args.length < 2)
            throw new Error("Missing arguments for begins");
          else if (args.length > 2)
            throw new Error("Too many arguments for begins");
          return this.stripQuotes(args[0]).startsWith(this.stripQuotes(args[1]));
        case "ends":
          args = this.splitByQuotes(this.parseInline(res[2]), ",");
          if (args.length < 2)
            throw new Error("Missing arguments for ends");
          else if (args.length > 2)
            throw new Error("Too many arguments for ends");
          return this.stripQuotes(args[0]).endsWith(this.stripQuotes(args[1]));
        case "len":
          return this.stripQuotes(this.parseInline(res[2])).length;
        case "stripansi":
          const ansiRegex = new RegExp("[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))", "g");
          return this.stripQuotes(this.parseInline(res[2])).replace(ansiRegex, "");
        case "pos":
          args = this.splitByQuotes(this.parseInline(res[2]), ",");
          if (args.length < 2)
            throw new Error("Missing arguments for pos");
          else if (args.length > 2)
            throw new Error("Too many arguments for pos");
          return this.stripQuotes(args[1]).indexOf(this.stripQuotes(args[0])) + 1;
        case "ipos":
          args = this.splitByQuotes(this.parseInline(res[2]), ",");
          if (args.length < 2)
            throw new Error("Missing arguments for ipos");
          else if (args.length > 2)
            throw new Error("Too many arguments for ipos");
          return this.stripQuotes(args[1]).toLowerCase().indexOf(this.stripQuotes(args[0]).toLowerCase()) + 1;
        case "regex":
          args = this.splitByQuotes(res[2], ",");
          if (args.length < 2)
            throw new Error("Missing arguments for regex");
          c = new RegExp(this.stripQuotes(args[1]), "gd");
          c = c.exec(this.stripQuotes(this.parseInline(args[0])));
          args.shift();
          args.shift();
          if (c == null || c.length === 0)
            return 0;
          if (args.length) {
            for (sides = 1; sides < c.length; sides++) {
              if (!args.length)
                break;
              this.client.variables[this.stripQuotes(this.parseInline(args[0]))] = c[sides];
              args.shift();
            }
            if (args.length)
              this.client.variables[this.stripQuotes(this.parseInline(args[0]))] = c[0].length;
          }
          if (!c.indices[0])
            return 1;
          return c.indices[0][0] + 1;
        case "trim":
          return this.stripQuotes(this.parseInline(res[2])).trim();
        case "trimleft":
          return this.stripQuotes(this.parseInline(res[2])).trimLeft();
        case "trimright":
          return this.stripQuotes(this.parseInline(res[2])).trimRight();
        case "bitand":
          args = this.parseInline(res[2]).split(",");
          if (args.length === 0)
            throw new Error("Missing arguments for bitand");
          else if (args.length !== 2)
            throw new Error("Too many arguments for bitand");
          c = parseInt(args[0], 10);
          if (isNaN(c))
            throw new Error("Invalid argument '" + args[0] + "' must be a number for bitand");
          sides = parseInt(args[1], 10);
          if (isNaN(sides))
            throw new Error("Invalid argument '" + args[1] + "' must be a number for bitand");
          return c & sides;
        case "bitnot":
          args = this.parseInline(res[2]).split(",");
          if (args.length === 0)
            throw new Error("Missing arguments for bitnot");
          else if (args.length !== 1)
            throw new Error("Too many arguments for bitnot");
          c = parseInt(args[0], 10);
          if (isNaN(c))
            throw new Error("Invalid argument '" + args[0] + "' must be a number for bitnot");
          return ~c;
        case "bitor":
          args = this.parseInline(res[2]).split(",");
          if (args.length === 0)
            throw new Error("Missing arguments for bitor");
          else if (args.length !== 2)
            throw new Error("Too many arguments for bitor");
          c = parseInt(args[0], 10);
          if (isNaN(c))
            throw new Error("Invalid argument '" + args[0] + "' must be a number for bitor");
          sides = parseInt(args[1], 10);
          if (isNaN(sides))
            throw new Error("Invalid argument '" + args[1] + "' must be a number for bitor");
          return c | sides;
        case "bitset":
          args = this.parseInline(res[2]).split(",");
          if (args.length === 0)
            throw new Error("Missing arguments for bitset");
          else if (args.length > 3)
            throw new Error("Too many arguments for bitset");
          c = parseInt(args[0], 10);
          if (isNaN(c))
            throw new Error("Invalid argument '" + args[0] + "' must be a number for bitset");
          sides = parseInt(args[1], 10);
          if (isNaN(sides))
            throw new Error("Invalid argument '" + args[1] + "' must be a number for bitset");
          sides--;
          mod = 1;
          if (args.length === 3) {
            mod = parseInt(args[2], 10);
            if (isNaN(mod))
              throw new Error("Invalid argument '" + args[2] + "' must be a number for bitset");
          }
          return c & ~(1 << sides) | (mod ? 1 : 0) << sides;
        case "bitshift":
          args = this.parseInline(res[2]).split(",");
          if (args.length === 0)
            throw new Error("Missing arguments for bitshift");
          else if (args.length !== 2)
            throw new Error("Too many arguments for bitshift");
          c = parseInt(args[0], 10);
          if (isNaN(c))
            throw new Error("Invalid argument '" + args[0] + "' must be a number for bitshift");
          sides = parseInt(args[1], 10);
          if (isNaN(sides))
            throw new Error("Invalid argument '" + args[1] + "' must be a number for bitshift");
          if (sides < 0)
            return c >> -sides;
          return c << sides;
        case "bittest":
          args = this.parseInline(res[2]).split(",");
          if (args.length === 0)
            throw new Error("Missing arguments for bittest");
          else if (args.length !== 2)
            throw new Error("Too many arguments for bittest");
          c = parseInt(args[0], 10);
          if (isNaN(c))
            throw new Error("Invalid argument '" + args[0] + "' must be a number for bittest");
          sides = parseInt(args[1], 10);
          if (isNaN(sides))
            throw new Error("Invalid argument '" + args[1] + "' must be a number for bittest");
          sides--;
          return (c >> sides) % 2 != 0 ? 1 : 0;
        case "bitxor":
          args = this.parseInline(res[2]).split(",");
          if (args.length === 0)
            throw new Error("Missing arguments for bitxor");
          else if (args.length !== 2)
            throw new Error("Too many arguments for bitxor");
          c = parseInt(args[0], 10);
          if (isNaN(c))
            throw new Error("Invalid argument '" + args[0] + "' must be a number for bitxor");
          sides = parseInt(args[1], 10);
          if (isNaN(sides))
            throw new Error("Invalid argument '" + args[1] + "' must be a number for bitxor");
          return c ^ sides;
        case "number":
          args = this.splitByQuotes(this.parseInline(res[2]), ",");
          if (args.length === 0)
            throw new Error("Missing arguments for number");
          else if (args.length > 1)
            throw new Error("Too many arguments for number");
          args[0] = this.stripQuotes(args[0], true);
          if (args[0].match(/^\s*?[-|+]?\d+\s*?$/))
            return parseInt(args[0], 10);
          else if (args[0].match(/^\s*?[-|+]?\d+\.\d+\s*?$/))
            return parseFloat(args[0]);
          else if (args[0] === "true")
            return 1;
          else if (args[0] === "false")
            return 0;
          return 0;
        case "isfloat":
          args = this.splitByQuotes(this.parseInline(res[2]), ",");
          if (args.length === 0)
            throw new Error("Missing arguments for isfloat");
          else if (args.length > 1)
            throw new Error("Too many arguments for isfloat");
          if (args[0].match(/^\s*?[-|+]?\d+\.\d+\s*?$/))
            return 1;
          return 0;
        case "isnumber":
          args = this.splitByQuotes(this.parseInline(res[2]), ",");
          if (args.length === 0)
            throw new Error("Missing arguments for isnumber");
          else if (args.length > 1)
            throw new Error("Too many arguments for isnumber");
          if (args[0].match(/^\s*?[-|+]?\d+\s*?$/) || args[0].match(/^\s*?[-|+]?\d+\.\d+\s*?$/))
            return 1;
          return 0;
        case "string":
          args = this.splitByQuotes(this.parseInline(res[2]), ",");
          if (args.length === 0)
            throw new Error("Missing arguments for string");
          else if (args.length > 1)
            throw new Error("Too many arguments for string");
          return `"${this.stripQuotes(args[0]), true}"`;
        case "float":
          args = this.splitByQuotes(this.parseInline(res[2]), ",");
          if (args.length === 0)
            throw new Error("Missing arguments for float");
          else if (args.length > 1)
            throw new Error("Too many arguments for float");
          args[0] = this.stripQuotes(args[0], true);
          if (args[0].match(/^\s*?[-|+]?\d+\s*?$/) || args[0].match(/^\s*?[-|+]?\d+\.\d+\s*?$/))
            return parseFloat(args[0]);
          else if (args[0] === "true")
            return 1;
          else if (args[0] === "false")
            return 0;
          return 0;
        case "isdefined":
          args = this.splitByQuotes(this.parseInline(res[2]), ",");
          if (args.length === 0)
            throw new Error("Missing arguments for isdefined");
          else if (args.length > 1)
            throw new Error("Too many arguments for isdefined");
          args[0] = this.stripQuotes(args[0], true);
          if (this.client.variables.hasOwnProperty(args[0]))
            return 1;
          return 0;
        case "defined":
          args = this.splitByQuotes(this.parseInline(res[2]), ",");
          if (args.length === 0)
            throw new Error("Missing arguments for defined");
          else if (args.length === 1) {
            args[0] = this.stripQuotes(args[0], true);
            const keys = this.client.profiles.keys;
            let k = 0;
            const kl = keys.length;
            if (kl === 0) return 0;
            for (; k < kl; k++) {
              sides = SortItemArrayByPriority(this.client.profiles.items[keys[k]].aliases);
              sides = sides.find((i2) => {
                return i2.pattern === args[0];
              });
              if (sides) return 1;
              sides = SortItemArrayByPriority(this.client.profiles.items[keys[k]].triggers);
              sides = sides.find((i2) => {
                return i2.pattern === args[0] || i2.name === args[0];
              });
              if (sides) return 1;
              sides = SortItemArrayByPriority(this.client.profiles.items[keys[k]].macros);
              sides = sides.find((i2) => {
                return MacroDisplay(i2).toLowerCase() === args[0].toLowerCase() || i2.name === args[0];
              });
              if (sides) return 1;
              sides = SortItemArrayByPriority(this.client.profiles.items[keys[k]].aliases);
              sides = sides.find((i2) => {
                return i2.caption === args[0] || i2.name === args[0];
              });
              if (sides) return 1;
            }
            return this.client.variables.hasOwnProperty(args[0]);
          } else if (args.length === 2) {
            args[0] = this.stripQuotes(args[0], true);
            args[1] = this.stripQuotes(args[1], true).toLowerCase();
            const keys = this.client.profiles.keys;
            let k = 0;
            const kl = keys.length;
            if (kl === 0) return 0;
            for (; k < kl; k++) {
              switch (args[1]) {
                case "alias":
                  sides = SortItemArrayByPriority(this.client.profiles.items[keys[k]].aliases);
                  sides = sides.find((i2) => {
                    return i2.pattern === args[0];
                  });
                  if (sides) return 1;
                  return 0;
                case "event":
                  sides = SortItemArrayByPriority(this.client.profiles.items[keys[k]].triggers);
                  sides = sides.find((i2) => {
                    return i2.type === 2 /* Event */ && (i2.pattern === args[0] || i2.name === args[0]);
                  });
                  if (sides) return 1;
                  return 0;
                case "trigger":
                  sides = SortItemArrayByPriority(this.client.profiles.items[keys[k]].triggers);
                  sides = sides.find((i2) => {
                    return i2.pattern === args[0] || i2.name === args[0];
                  });
                  if (sides) return 1;
                  return 0;
                case "macro":
                  sides = SortItemArrayByPriority(this.client.profiles.items[keys[k]].macros);
                  sides = sides.find((i2) => {
                    return MacroDisplay(i2).toLowerCase() === args[0].toLowerCase() || i2.name === args[0];
                  });
                  if (sides) return 1;
                  return 0;
                case "button":
                  sides = SortItemArrayByPriority(this.client.profiles.items[keys[k]].aliases);
                  sides = sides.find((i2) => {
                    return i2.caption === args[0] || i2.name === args[0];
                  });
                  if (sides) return 1;
                  return 0;
              }
            }
            if (args[1] === "variable")
              return this.client.variables.hasOwnProperty(args[0]);
          } else
            throw new Error("Too many arguments for defined");
          return 0;
        case "escape":
          args = this.stripQuotes(this.parseInline(res[2]));
          if (this.client.getOption("allowEscape")) {
            c = escape2;
            if (escape2 === "\\")
              c += escape2;
            if (this.client.getOption("parseDoubleQuotes"))
              c += '"';
            if (this.client.getOption("parseSingleQuotes"))
              c += "'";
            if (this.client.getOption("commandStacking"))
              c += this.client.getOption("commandStackingChar");
            if (this.client.getOption("enableSpeedpaths"))
              c += this.client.getOption("speedpathsChar");
            if (this.client.getOption("enableCommands"))
              c += this.client.getOption("commandChar");
            if (this.client.getOption("enableVerbatim"))
              c += this.client.getOption("verbatimChar");
            if (this.client.getOption("enableDoubleParameterEscaping"))
              c += this.client.getOption("parametersChar");
            if (this.client.getOption("enableNParameters"))
              c += this.client.getOption("nParametersChar");
            return args.replace(new RegExp(`[${c}]`, "g"), escape2 + "$&");
          }
          return args.replace(/[\\"']/g, "$&");
        case "unescape":
          args = this.stripQuotes(this.parseInline(res[2]));
          if (this.client.getOption("allowEscape")) {
            c = escape2;
            if (escape2 === "\\")
              c += escape2;
            if (this.client.getOption("parseDoubleQuotes"))
              c += '"';
            if (this.client.getOption("parseSingleQuotes"))
              c += "'";
            if (this.client.getOption("commandStacking"))
              c += this.client.getOption("commandStackingChar");
            if (this.client.getOption("enableSpeedpaths"))
              c += this.client.getOption("speedpathsChar");
            if (this.client.getOption("enableCommands"))
              c += this.client.getOption("commandChar");
            if (this.client.getOption("enableVerbatim"))
              c += this.client.getOption("verbatimChar");
            if (this.client.getOption("enableDoubleParameterEscaping"))
              c += this.client.getOption("parametersChar");
            if (this.client.getOption("enableNParameters"))
              c += this.client.getOption("nParametersChar");
            if (escape2 === "\\")
              return args.replace(new RegExp(`\\\\[${c}]`, "g"), (m) => m.substr(1));
            return args.replace(new RegExp(`${escape2}[${c}]`, "g"), (m) => m.substr(1));
          }
          return args.replace(/\\[\\"']/g, (m) => m.substr(1));
        case "alarm":
          args = this.splitByQuotes(this.parseInline(res[2]), ",");
          if (args.length === 0)
            throw new Error("Missing arguments for alarm");
          if (args.length > 3)
            throw new Error("Too many arguments for alarm");
          args[0] = this.stripQuotes(args[0]);
          sides = this.client.alarms;
          max2 = sides.length;
          if (max2 === 0)
            throw new Error("No alarms set.");
          c = 0;
          if (args.length === 1) {
            for (; c < max2; c++) {
              if (sides[c].type !== 3 /* Alarm */) continue;
              if (sides[c].name === args[0] || sides[c].pattern === args[0]) {
                if (sides[c].suspended)
                  return 0;
                return this.client.getRemainingAlarmTime(c);
              }
            }
          } else if (args.length === 2) {
            mod = parseInt(args[1], 10);
            if (isNaN(mod)) {
              args[1] = this.stripQuotes(args[1].trim());
              for (; c < max2; c++) {
                if (sides[c].type !== 3 /* Alarm */) continue;
                if (sides[c].name === args[0] || sides[c].pattern === args[0]) {
                  if (sides[c].profile.name.toUpperCase() !== args[1].toUpperCase())
                    continue;
                  if (sides[c].suspended)
                    return 0;
                  return this.client.getRemainingAlarmTime(c);
                }
              }
              throw Error("Alarm not found in profile: " + args[1] + ".");
            } else {
              for (; c < max2; c++) {
                if (sides[c].type !== 3 /* Alarm */) continue;
                if (sides[c].name === args[0] || sides[c].pattern === args[0]) {
                  if (!sides[c].suspended)
                    this.client.setAlarmTempTime(c, mod);
                  return mod;
                }
              }
              throw Error("Alarm not found.");
            }
          } else if (args.length === 3) {
            mod = parseInt(args[1], 10);
            if (isNaN(mod))
              throw new Error("Invalid time for alarm");
            args[2] = this.stripQuotes(args[2].trim());
            for (; c < max2; c++) {
              if (sides[c].type !== 3 /* Alarm */) continue;
              if (sides[c].name === args[0] || sides[c].pattern === args[0]) {
                if (sides[c].profile.name.toUpperCase() !== args[2].toUpperCase())
                  continue;
                if (!sides[c].suspended)
                  this.client.setAlarmTempTime(c, mod);
                return mod;
              }
            }
            throw Error("Could not set time, alarm not found in profile: " + args[2] + ".");
          }
          return 0;
        case "state":
          args = this.splitByQuotes(this.parseInline(res[2]), ",");
          if (args.length === 0)
            throw new Error("Missing arguments for state");
          if (args.length > 2)
            throw new Error("Too many arguments for state");
          args[0] = this.stripQuotes(args[0]);
          mod = null;
          if (args.length === 1) {
            const keys = this.client.profiles.keys;
            let k = 0;
            const kl = keys.length;
            if (kl === 0)
              return null;
            if (kl === 1) {
              if (!this.client.profiles.items[keys[0]].enabled || !this.client.profiles.items[keys[0]].enableTriggers)
                throw Error("No enabled profiles found!");
              sides = SortItemArrayByPriority(this.client.profiles.items[keys[k]].triggers);
              sides = sides.find((t) => {
                return t.name === args[0] || t.pattern === args[0];
              });
            } else {
              for (; k < kl; k++) {
                if (!this.client.profiles.items[keys[k]].enabled || !this.client.profiles.items[keys[k]].enableTriggers || this.client.profiles.items[keys[k]].triggers.length === 0)
                  continue;
                sides = SortItemArrayByPriority(this.client.profiles.items[keys[k]].triggers);
                sides = sides.find((t) => {
                  return t.name === args[0] || t.pattern === args[0];
                });
                if (sides)
                  break;
              }
            }
          } else if (args.length === 2) {
            args[1] = this.stripQuotes(args[1].trim());
            if (this.client.profiles.contains(args[1]))
              mod = this.client.profiles.items[args[1].toLowerCase()];
            else
              throw new Error("Profile not found: " + args[1]);
            sides = SortItemArrayByPriority(mod.triggers);
            sides = sides.find((t) => {
              return t.name === args[0] || t.pattern === args[0];
            });
          }
          if (sides)
            return sides.triggers && sides.triggers.length ? sides.state : 0;
          throw new Error("Trigger not found");
        case "isnull":
          args = this.splitByQuotes(this.parseInline(res[2]), ",");
          if (args.length === 0)
            return null;
          if (args.length !== 1)
            throw new Error("Too many arguments for null");
          return this.evaluate(args[0]) === null ? 1 : 0;
        case "prompt":
          args = this.splitByQuotes(this.parseInline(res[2]), ",");
          if (args.length === 0)
            return window.prompt() || "";
          if (args.length > 3)
            throw new Error("Too many arguments");
          args = args.map((a) => this.stripQuotes(a));
          return window.prompt(...args) || "";
      }
      const data = { raw: text, name: res[1], args: res[2] && res[2].length ? this.parseOutgoing(res[2]).split(",") : [], handled: false, return: null };
      this.client.emit("variable", data);
      if (data.handled)
        return data.return;
      return null;
    }
    GetNamedArguments(str, args, append) {
      if (str === "*")
        return args;
      if (append == null) append = false;
      if (str == null || str.length === 0)
        return append ? args : [];
      const n = str.split(",");
      const nl = n.length;
      const al = args.length;
      if (nl === 0)
        return append ? args : [];
      let named;
      if (append)
        named = args.slice();
      else
        named = [];
      for (let s = 0; s < nl; s++) {
        n[s] = $.trim(n[s]);
        if (n[s].length < 1) continue;
        if (n[s].startsWith("$")) n[s] = n[s].substring(1);
        if (!n[s].match(/^[a-zA-Z0-9_][a-zA-Z0-9_]+$/g)) continue;
        if (!isValidIdentifier(n[s])) continue;
        if (named[n[s]]) continue;
        named[n[s]] = s + 1 < al ? args[s + 1] : "";
      }
      return named;
    }
    ExecuteAlias(alias, args) {
      if (!alias.enabled) return;
      let ret;
      if (alias.value.length)
        switch (alias.style) {
          case 1:
            this._stack.push({ loops: [], args, named: this.GetNamedArguments(alias.params, args), append: alias.append, used: 0 });
            ret = this.parseOutgoing(alias.value, null, null, true);
            this._stack.pop();
            break;
          case 2:
            if ((this.client.getOption("echo") & 2) === 2)
              this.client.echo(alias.value, -7, -8, true, true);
            const named = this.GetNamedArguments(alias.params, args);
            if (named)
              ret = Object.keys(named).map((v) => `let ${v} = this.input.stack.named["${v}"];`).join("") + "\n";
            else
              ret = "";
            const f = new Function("try { " + ret + alias.value + "\n} catch (e) { if(this.getOption('showScriptErrors')) this.error(e);}");
            this._stack.push({ loops: [], args, named, append: alias.append, used: 0 });
            try {
              ret = f.apply(this.client, args);
            } catch (e) {
              throw e;
            } finally {
              this._stack.pop();
            }
            if (typeof ret === "string")
              ret = this.parseOutgoing(ret, null, null, true);
            break;
          default:
            ret = alias.value;
            break;
        }
      if (ret == null || ret === void 0)
        return null;
      ret = this.ExecuteTriggers(1 /* CommandInputRegular */ | 16 /* CommandInputPattern */, ret, ret, false, true);
      if (ret == null || ret === void 0)
        return null;
      if (typeof ret !== "string")
        ret = ret.toString();
      if (ret.length === 0 && !this.client.getOption("returnNewlineOnEmptyValue"))
        return null;
      if (ret.endsWith("\n"))
        return ret;
      return ret + "\n";
    }
    ProcessMacros(keycode, alt, ctrl, shift, meta) {
      if (!keycode || keycode > 9 && keycode < 19) return false;
      if (!this.client.profiles) return false;
      const macros = this._MacroCache[keycode] || (this._MacroCache[keycode] = FilterArrayByKeyValue(this.client.macros, "key", keycode));
      let m = 0;
      const ml = macros.length;
      let mod = 0 /* None */;
      if (alt)
        mod |= 2 /* Alt */;
      if (ctrl)
        mod |= 4 /* Ctrl */;
      if (shift)
        mod |= 8 /* Shift */;
      if (meta)
        mod |= 16 /* Meta */;
      for (; m < ml; m++) {
        if (!macros[m].enabled || mod !== macros[m].modifiers) continue;
        if (this.ExecuteMacro(macros[m]))
          return true;
      }
      return false;
    }
    ExecuteMacro(macro) {
      if (!macro.enabled) return false;
      let ret;
      if (macro.value.length)
        switch (macro.style) {
          case 1:
            this._stack.push({ loops: [], args: 0, named: 0, used: 0 });
            try {
              ret = this.parseOutgoing(macro.value);
            } catch (e) {
              throw e;
            } finally {
              this._stack.pop();
            }
            break;
          case 2:
            if ((this.client.getOption("echo") & 2) === 2)
              this.client.echo(macro.value, -7, -8, true, true);
            const f = new Function("try { " + macro.value + "\n} catch (e) { if(this.getOption('showScriptErrors')) this.error(e);}");
            this._stack.push({ loops: [], args: 0, named: 0, used: 0 });
            try {
              ret = f.apply(this.client);
            } catch (e) {
              throw e;
            } finally {
              this._stack.pop();
            }
            break;
          default:
            ret = macro.value;
            break;
        }
      if (ret == null || ret === void 0)
        return true;
      if (typeof ret !== "string")
        ret = ret.toString();
      if (ret.length === 0 && !this.client.getOption("returnNewlineOnEmptyValue"))
        return null;
      if (macro.send) {
        if (!ret.endsWith("\n"))
          ret += "\n";
        if (macro.chain && this.client.commandInput.value.endsWith(" ")) {
          this.client.commandInput.value = this.client.commandInput.value + ret;
          this.client.sendCommand(null, null, this.client.getOption("allowCommentsFromCommand"));
        } else
          this.client.send(ret, true);
      } else if (macro.append)
        this.client.commandInput.value = this.client.commandInput.value + ret;
      return true;
    }
    ProcessPath(str, replace) {
      if (str.length === 0)
        return "";
      let out = [];
      let state = 0;
      let cmd = "";
      let num = "";
      let idx = 0;
      let c;
      let i2;
      let t;
      let p;
      let n = 0;
      const tl = str.length;
      for (; idx < tl; idx++) {
        c = str.charAt(idx);
        i2 = str.charCodeAt(idx);
        switch (state) {
          case 1:
            if (i2 > 47 && i2 < 58)
              num += c;
            else if (c === "\\")
              state = 2;
            else {
              state = 0;
              cmd = c;
            }
            break;
          case 2:
            if (i2 > 47 && i2 < 58)
              cmd += c;
            else {
              cmd += "\\";
              idx--;
            }
            state = 0;
            break;
          case 3:
            if (n === 0 && c === ")")
              state = 0;
            else {
              if (c === "(")
                n++;
              else if (c === ")")
                n--;
              cmd += c;
            }
            break;
          case 4:
            if (n === 0 && c === "}")
              state = 0;
            else {
              if (c === "{")
                n++;
              else if (c === "}")
                n--;
              cmd += c;
            }
            break;
          default:
            if (i2 > 47 && i2 < 58) {
              if (cmd.length > 0) {
                if (num.length === 0)
                  t = 1;
                else
                  t = parseInt(num, 10);
                for (p = 0; p < t; p++)
                  out.push(cmd);
                cmd = "";
              }
              state = 1;
              num = c;
            } else if (c === "(") {
              state = 3;
              n = 0;
            } else if (c === "{") {
              state = 4;
              n = 0;
            } else if (c === "\\")
              state = 2;
            else
              cmd += c;
            break;
        }
      }
      if (cmd.length > 0) {
        if (num.length === 0)
          t = 1;
        else
          t = parseInt(num, 10);
        for (p = 0; p < t; p++)
          out.push(cmd);
      }
      if (replace && this._pathQueue.length) {
        this._pathQueue[0] = {
          id: str,
          current: out,
          previous: []
        };
      } else
        this._pathQueue.push({
          id: str,
          current: out,
          previous: []
        });
      this.ExecutePath();
      return null;
    }
    ExecutePath() {
      if (this._pathTimeout || !this._pathQueue.length || this._pathPaused) return;
      let delay = this.client.getOption("pathDelay");
      if (delay < 0) delay = 0;
      this._pathTimeout = setTimeout(() => {
        const pPath = this.client.getOption("parseSpeedpaths");
        const ePath = this.client.getOption("echoSpeedpaths");
        let cnt = this.client.getOption("pathDelayCount");
        if (cnt < 1) cnt = 1;
        const current = this._pathQueue[0];
        while (cnt--) {
          let cmd = current.current.shift();
          current.previous.push(cmd);
          if (pPath)
            this.client.sendBackground(cmd + "\n", !ePath);
          else
            this.client.send(cmd + "\n", !ePath);
          if (!current.current.length) break;
        }
        if (!current.current.length)
          this._pathQueue.shift();
        this._pathTimeout = null;
        if (this._pathQueue.length && this._pathQueue[0].manual)
          return;
        this.ExecutePath();
      }, delay);
    }
    toggleScrollLock() {
      this.scrollLock = !this.scrollLock;
    }
    /*
    private _hasTriggerType(types: TriggerTypes | SubTriggerTypes, type: TriggerType | SubTriggerTypes): boolean {
        if (type === TriggerType.Alarm && (types & TriggerTypes.Alarm) == TriggerTypes.Alarm)
            return true;
        if (type === TriggerType.CommandInputPattern && (types & TriggerTypes.CommandInputPattern) == TriggerTypes.CommandInputPattern)
            return true;
        if (type === TriggerType.CommandInputRegular && (types & TriggerTypes.CommandInputRegular) == TriggerTypes.CommandInputRegular)
            return true;
        if (type === TriggerType.Event && (types & TriggerTypes.Event) == TriggerTypes.Event)
            return true;
        if (type === TriggerType.Pattern && (types & TriggerTypes.Pattern) == TriggerTypes.Pattern)
            return true;
        if (type === TriggerType.Regular && (types & TriggerTypes.Regular) == TriggerTypes.Regular)
            return true;
        if (type === TriggerType.LoopExpression && (types & TriggerTypes.LoopExpression) == TriggerTypes.LoopExpression)
            return true;
        //if (type === TriggerType.Expression && (types & TriggerTypes.Expression) == TriggerTypes.Expression)
        //return true;            
        return false;
    }
    */
    _isSubTriggerType(type) {
      if ((type & 512 /* Skip */) == 512 /* Skip */)
        return true;
      if ((type & 1024 /* Wait */) == 1024 /* Wait */)
        return true;
      if ((type & 4096 /* LoopPattern */) == 4096 /* LoopPattern */)
        return true;
      if ((type & 8192 /* LoopLines */) == 8192 /* LoopLines */)
        return true;
      if ((type & 16384 /* Duration */) == 16384 /* Duration */)
        return true;
      if ((type & 32768 /* WithinLines */) == 32768 /* WithinLines */)
        return true;
      if ((type & 65536 /* Manual */) == 65536 /* Manual */)
        return true;
      if ((type & 131072 /* ReParse */) == 131072 /* ReParse */)
        return true;
      if ((type & 262144 /* ReParsePattern */) == 262144 /* ReParsePattern */)
        return true;
      return false;
    }
    _getTriggerType(type) {
      if (type === 0 /* Regular */)
        return 4 /* Regular */;
      if (type === 3 /* Alarm */)
        return 32 /* Alarm */;
      return type;
    }
    ExecuteTriggers(type, line2, raw, frag, ret, subtypes) {
      if (!this.enableTriggers || line2 == null) return line2;
      if (ret == null) ret = false;
      if (frag == null) frag = false;
      raw = raw || line2;
      this.buildTriggerCache();
      let t = 0;
      let pattern;
      let changed = false;
      let val;
      const triggers = this._TriggerCache;
      const tl = triggers.length;
      const states = this._TriggerStates;
      const rCache = this._TriggerRegExCache;
      let tType;
      for (; t < tl; t++) {
        let trigger = triggers[t];
        const parent = trigger;
        if (!trigger.enabled) continue;
        if (!parent.triggers || !parent.triggers.length || trigger.state > parent.triggers.length)
          parent.state = 0;
        if (trigger.state !== 0 && parent.triggers && parent.triggers.length) {
          trigger = parent.triggers[trigger.state - 1];
          while (!trigger.enabled && parent.state !== 0) {
            parent.state++;
            if (parent.state > parent.triggers.length) {
              parent.state = 0;
              trigger = parent;
              break;
            }
            if (parent.state)
              trigger = parent.triggers[parent.state - 1];
            else
              trigger = parent;
            changed = true;
          }
          if (changed) {
            if (this.client.getOption("saveTriggerStateChanges"))
              this.client.saveProfiles();
            this.client.emit("item-updated", "trigger", parent.profile.name, parent.profile.triggers.indexOf(parent), parent);
          }
          if (!trigger.enabled) continue;
        }
        tType = this._getTriggerType(trigger.type);
        if (trigger.type !== void 0 && (type & tType) !== tType) {
          if (!subtypes || subtypes && !this._isSubTriggerType(trigger.type))
            continue;
        }
        if (trigger.type === 65536 /* Manual */) continue;
        if (frag && !trigger.triggerPrompt) continue;
        if (!frag && !trigger.triggerNewline && trigger.triggerNewline !== void 0)
          continue;
        if (states[t]) {
          if (states[t].type === 1024 /* Wait */) {
            if (states[t].time > Date.now())
              continue;
            delete states[t];
          } else if (states[t].type === 16384 /* Duration */) {
            if (states[t].time < Date.now()) {
              delete states[t];
              this._advanceTrigger(trigger, parent, t);
              if (!states[t])
                states[t] = { reParse: true };
              else
                states[t].reParse = true;
              t = this.cleanUpTriggerState(t);
              continue;
            }
          } else if (states[t].type === 512 /* Skip */) {
            if (states[t].lineCount > 0)
              continue;
            delete states[t];
          } else if (states[t].type === 8192 /* LoopLines */) {
            if (states[t].lineCount < 1) {
              this._advanceTrigger(trigger, parent, t);
              if (!states[t])
                states[t] = { reParse: true };
              else
                states[t].reParse = true;
              t = this.cleanUpTriggerState(t);
              continue;
            }
          } else if (states[t].type === 32768 /* WithinLines */) {
            if (states[t].lineCount < 1) {
              this._advanceTrigger(trigger, parent, t);
              if (!states[t])
                states[t] = { reParse: true };
              else
                states[t].reParse = true;
              t = this.cleanUpTriggerState(t);
              continue;
            }
          }
        }
        try {
          if (trigger.type === 128 /* LoopExpression */) {
            if (this.evaluate(this.parseInline(trigger.pattern))) {
              if (!states[t]) {
                const state = this.createTriggerState(trigger, false, parent);
                if (state)
                  states[t] = state;
              } else if (states[t].loop !== -1 && states[t].lineCount < 1)
                continue;
              this._LastTriggered = trigger.raw ? raw : line2;
              val = this.ExecuteTrigger(trigger, [this._LastTriggered], ret, t, [this._LastTriggered], 0, parent);
            } else {
              this._advanceTrigger(trigger, parent, t);
              continue;
            }
          } else if (trigger.verbatim) {
            if (!trigger.caseSensitive && (trigger.raw ? raw : line2).toLowerCase() !== trigger.pattern.toLowerCase()) {
              if (!states[t] && (trigger.type === 131072 /* ReParse */ || trigger.type === 262144 /* ReParsePattern */)) {
                this._advanceTrigger(trigger, parent, t);
                t = this.cleanUpTriggerState(t);
              }
              continue;
            } else if (trigger.caseSensitive && (trigger.raw ? raw : line2) !== trigger.pattern) {
              if (!states[t] && (trigger.type === 131072 /* ReParse */ || trigger.type === 262144 /* ReParsePattern */)) {
                this._advanceTrigger(trigger, parent, t);
                t = this.cleanUpTriggerState(t);
              }
              continue;
            }
            this._LastTriggered = trigger.raw ? raw : line2;
            val = this.ExecuteTrigger(trigger, [this._LastTriggered], ret, t, [this._LastTriggered], 0, parent);
          } else {
            let re;
            if (trigger.type === 8 /* Pattern */ || trigger.type === 16 /* CommandInputPattern */ || trigger.type === 262144 /* ReParsePattern */)
              pattern = convertPattern(trigger.pattern, this.client);
            else
              pattern = trigger.pattern;
            if (trigger.caseSensitive)
              re = rCache["g" + pattern] || (rCache["g" + pattern] = new RegExp(pattern, "gd"));
            else
              re = rCache["gi" + pattern] || (rCache["gi" + pattern] = new RegExp(pattern, "gid"));
            re.lastIndex = 0;
            const res = re.exec(trigger.raw ? raw : line2);
            if (!res || !res.length) {
              if (!states[t] && (trigger.type === 131072 /* ReParse */ || trigger.type === 262144 /* ReParsePattern */)) {
                this._advanceTrigger(trigger, parent, t);
                t = this.cleanUpTriggerState(t);
              }
              continue;
            }
            let args;
            this._LastTriggered = trigger.raw ? raw : line2;
            if ((trigger.raw ? raw : line2) === res[0] || !this.client.getOption("prependTriggeredLine"))
              args = res;
            else {
              args = [this._LastTriggered, ...res];
              args.indices = [[0, args[0].length], ...res.indices];
            }
            if (res.groups)
              Object.keys(res.groups).map((v) => this.client.variables[v] = res.groups[v]);
            val = this.ExecuteTrigger(trigger, args, ret, t, [this._LastTriggered, re], res.groups, parent);
          }
          if (states[t] && states[t].reParse) {
            if (!states[t].type || states[t].type === 131072 /* ReParse */ || states[t].type === 262144 /* ReParsePattern */)
              delete states[t];
            else
              delete states[t].reParse;
            t--;
          } else if (ret) return val;
        } catch (e) {
          if (this.client.getOption("disableTriggerOnError")) {
            trigger.enabled = false;
            setTimeout(() => {
              this.client.saveProfiles();
              this.emit("item-updated", "trigger", parent.profile, parent.profile.triggers.indexOf(parent), parent);
            });
          }
          if (this.client.getOption("showScriptErrors"))
            this.client.error(e);
          else
            this.client.debug(e);
        }
      }
      return line2;
    }
    TestTrigger(trigger, parent, t, line2, raw, frag) {
      let pattern;
      try {
        if (trigger.verbatim) {
          if (!trigger.caseSensitive && (trigger.raw ? raw : line2).toLowerCase() !== trigger.pattern.toLowerCase()) {
            if (!this._TriggerStates[t]) {
              this._advanceTrigger(trigger, parent, t);
              t = this.cleanUpTriggerState(t);
            }
            return t;
          } else if (trigger.caseSensitive && (trigger.raw ? raw : line2) !== trigger.pattern) {
            if (!this._TriggerStates[t]) {
              this._advanceTrigger(trigger, parent, t);
              t = this.cleanUpTriggerState(t);
            }
            return t;
          }
          this._LastTriggered = trigger.raw ? raw : line2;
          this.ExecuteTrigger(trigger, [this._LastTriggered], false, t, [this._LastTriggered], 0, parent);
        } else {
          let re;
          if (trigger.type === 8 /* Pattern */ || trigger.type === 16 /* CommandInputPattern */ || trigger.type === 262144 /* ReParsePattern */)
            pattern = convertPattern(trigger.pattern, this.client);
          else
            pattern = trigger.pattern;
          if (trigger.caseSensitive)
            re = this._TriggerRegExCache["g" + pattern] || (this._TriggerRegExCache["g" + pattern] = new RegExp(pattern, "gd"));
          else
            re = this._TriggerRegExCache["gi" + pattern] || (this._TriggerRegExCache["gi" + pattern] = new RegExp(pattern, "gid"));
          re.lastIndex = 0;
          const res = re.exec(trigger.raw ? raw : line2);
          if (!res || !res.length) {
            if (!this._TriggerStates[t] && (trigger.type === 131072 /* ReParse */ || trigger.type === 262144 /* ReParsePattern */)) {
              this._advanceTrigger(trigger, parent, t);
              t = this.cleanUpTriggerState(t);
            }
            return t;
          }
          let args;
          this._LastTriggered = trigger.raw ? raw : line2;
          if ((trigger.raw ? raw : line2) === res[0] || !this.client.getOption("prependTriggeredLine"))
            args = res;
          else {
            args = [this._LastTriggered, ...res];
            args.indices = [[0, args[0].length], ...res.indices];
          }
          if (res.groups)
            Object.keys(res.groups).map((v) => this.client.variables[v] = res.groups[v]);
          this.ExecuteTrigger(trigger, args, false, t, [this._LastTriggered, re], res.groups, parent);
        }
        t = this.cleanUpTriggerState(t);
      } catch (e) {
        if (this.client.getOption("disableTriggerOnError")) {
          trigger.enabled = false;
          setTimeout(() => {
            this.client.saveProfiles();
            this.emit("item-updated", "trigger", parent.profile, parent.profile.triggers.indexOf(parent), parent);
          });
        }
        if (this.client.getOption("showScriptErrors"))
          this.client.error(e);
        else
          this.client.debug(e);
      }
      return t;
    }
    ExecuteTrigger(trigger, args, r, idx, regex, named, parent) {
      if (r == null) r = false;
      if (!trigger.enabled) return "";
      if (this._TriggerStates[idx] && this._TriggerStates[idx].type === 16384 /* Duration */)
        delete this._TriggerStates[idx];
      if (trigger.fired) {
        trigger.fired = false;
        this._advanceTrigger(trigger, parent, idx);
        if (this._TriggerStates[idx])
          this._TriggerStates[idx].reParse = true;
        else
          this._TriggerStates[idx] = { reParse: true };
        return "";
      }
      this._LastTrigger = trigger;
      let ret;
      if (trigger.temp) {
        if (parent.triggers.length) {
          if (parent.state === 0) {
            const item = parent.triggers.shift();
            item.triggers = parent.triggers;
            item.state = parent.state;
            item.name = parent.name;
            item.profile = parent.profile;
            if (item.state > item.triggers.length)
              item.state = 0;
            if (idx >= 0)
              this._TriggerCache[idx] = item;
            this.client.saveProfiles();
            const pIdx = parent.profile.triggers.indexOf(parent);
            parent.profile.triggers[pIdx] = item;
            this.client.emit("item-updated", "trigger", parent.profile.name, pIdx, item);
          } else {
            parent.triggers.splice(parent.state - 1, 1);
            if (parent.state > parent.triggers.length)
              parent.state = 0;
            this.client.saveProfiles();
            this.client.emit("item-updated", "trigger", parent.profile.name, parent.profile.triggers.indexOf(parent), parent);
          }
        } else {
          if (idx >= 0)
            this._TriggerCache.splice(idx, 1);
          if (this._TriggerStates[idx])
            this.clearTriggerState(idx);
          this.client.removeTrigger(parent);
        }
      } else if (parent.triggers.length)
        this._advanceTrigger(trigger, parent, idx);
      if ((this.client.getOption("echo") & 8) === 8)
        this.client.echo("Trigger fired: " + trigger.pattern, -7, -8, true, true);
      if (trigger.value.length)
        switch (trigger.style) {
          case 1:
            this._stack.push({ loops: [], args, named: 0, used: 0, regex });
            try {
              ret = this.parseOutgoing(trigger.value);
            } catch (e) {
              throw e;
            } finally {
              this._stack.pop();
            }
            break;
          case 2:
            if ((this.client.getOption("echo") & 2) === 2)
              this.client.echo(trigger.value, -7, -8, true, true);
            if (trigger.temp) {
              ret = new Function("try { " + trigger.value + "\n} catch (e) { if(this.getOption('showScriptErrors')) this.error(e);}");
              ret = ret.apply(this.client, args);
            } else {
              if (!this._TriggerFunctionCache[idx]) {
                if (named)
                  ret = Object.keys(named).map((v) => `let ${v} = this.variables["${v}"];`).join("") + "\n";
                else
                  ret = "";
                this._TriggerFunctionCache[idx] = new Function("try { " + ret + trigger.value + "\n} catch (e) { if(this.getOption('showScriptErrors')) this.error(e);}");
              }
              this._stack.push({ loops: [], args, named: 0, used: 0, regex, indices: args.indices });
              try {
                ret = this._TriggerFunctionCache[idx].apply(this.client, args);
              } catch (e) {
                throw e;
              } finally {
                this._stack.pop();
              }
            }
            if (typeof ret === "string")
              ret = this.parseOutgoing(ret);
            break;
          default:
            ret = trigger.value;
            break;
        }
      if (ret == null || ret === void 0)
        return null;
      if (r)
        return ret;
      if (typeof ret !== "string")
        ret = ret.toString();
      if (ret.length === 0 && !this.client.getOption("returnNewlineOnEmptyValue"))
        return null;
      if (!ret.endsWith("\n"))
        ret += "\n";
      if (this.client.connected)
        this.client.telnet.sendData(ret);
      if (this.client.telnet.echo && this.client.getOption("commandEcho")) {
        setTimeout(() => {
          this.client.echo(ret);
        }, 1);
      }
    }
    _advanceTrigger(trigger, parent, idx) {
      if (this._TriggerStates[idx]) {
        if (this._TriggerStates[idx].type === 4096 /* LoopPattern */) {
          this._TriggerStates[idx].loop--;
          if (this._TriggerStates[idx].loop > 0)
            return;
          this.clearTriggerState(idx);
        } else if (this._TriggerStates[idx].type === 8192 /* LoopLines */) {
          if (this._TriggerStates[idx].lineCount > 0)
            return;
          this.clearTriggerState(idx);
        } else if (this._TriggerStates[idx].type === 32768 /* WithinLines */)
          this.clearTriggerState(idx);
        else if (this._TriggerStates[idx].type === 128 /* LoopExpression */) {
          if (this._TriggerStates[idx].loop === -1)
            return;
          if (this._TriggerStates[idx].lineCount > 0)
            return;
        }
      }
      parent.state++;
      if (parent.state > parent.triggers.length)
        parent.state = 0;
      if (this.client.getOption("saveTriggerStateChanges"))
        this.client.saveProfiles();
      this.client.emit("item-updated", "trigger", parent.profile.name, parent.profile.triggers.indexOf(parent), parent);
      if (parent.state !== 0) {
        const state = this.createTriggerState(parent.triggers[parent.state - 1]);
        if (state)
          this._TriggerStates[idx] = state;
      }
    }
    createTriggerState(trigger, reparse, parent) {
      let params;
      let state;
      switch (trigger.type) {
        case 131072 /* ReParse */:
        case 262144 /* ReParsePattern */:
          state = { reParse: true };
          break;
        case 16384 /* Duration */:
        case 1024 /* Wait */:
          params = trigger.params;
          if (params && params.length) {
            params = parseInt(params, 10);
            if (isNaN(params))
              params = 0;
          } else
            params = 0;
          state = { time: Date.now() + params };
          break;
        case 32768 /* WithinLines */:
        case 8192 /* LoopLines */:
        case 512 /* Skip */:
          params = trigger.params;
          if (params && params.length) {
            params = parseInt(params, 10);
            if (isNaN(params))
              params = 1;
          } else
            params = 1;
          state = { lineCount: params + 1 };
          break;
        /*          
            params = trigger.params;
            if (params && params.length) {
                params = parseInt(params, 10);
                if (isNaN(params))
                    params = 1;
            }
            else
                params = 1;
            state = { remoteCount: params + 1 };
            break;
        */
        case 4096 /* LoopPattern */:
          params = trigger.params;
          if (params && params.length) {
            params = parseInt(params, 10);
            if (isNaN(params))
              params = 0;
          } else
            params = 0;
          state = { loop: params };
          break;
        case 128 /* LoopExpression */:
          params = trigger.params;
          if (params && params.length) {
            params = parseInt(params, 10);
            if (isNaN(params))
              params = 1;
            if (parent === trigger)
              state = { lineCount: params - 1 };
            else
              state = { lineCount: params };
          } else
            state = { loop: -1 };
          break;
      }
      if (state)
        state.type = trigger.type;
      if (!state && reparse)
        return { reParse: true };
      else if (reparse)
        state.reparse = true;
      return state;
    }
    updateTriggerState(trigger, idx) {
      if (!this._TriggerStates[idx]) return;
      let params;
      switch (this._TriggerStates[idx].type) {
        case 1024 /* Wait */:
        case 16384 /* Duration */:
          params = trigger.params;
          if (params && params.length) {
            params = parseInt(params, 10);
            if (isNaN(params))
              params = 0;
          } else
            params = 0;
          this._TriggerStates[idx].time = Date.now() + params;
          break;
        case 32768 /* WithinLines */:
        case 512 /* Skip */:
        case 8192 /* LoopLines */:
          params = trigger.params;
          if (params && params.length) {
            params = parseInt(params, 10);
            if (isNaN(params))
              params = 0;
          } else
            params = 0;
          this._TriggerStates[idx].lineCount = params;
          break;
        /*
                        params = trigger.params;
                        if (params && params.length) {
                            params = parseInt(params, 10);
                            if (isNaN(params))
                                params = 0;
                        }
                        else
                            params = 0;
                        this._TriggerStates[idx].remoteCount = params;
                        break;
        */
        case 4096 /* LoopPattern */:
          params = trigger.params;
          if (params && params.length) {
            params = parseInt(params, 10);
            if (isNaN(params))
              params = 0;
          } else
            params = 0;
          this._TriggerStates[idx].loop = params;
          break;
        case 128 /* LoopExpression */:
          params = trigger.params;
          if (params && params.length) {
            params = parseInt(params, 10);
            if (isNaN(params))
              params = 1;
            this._TriggerStates[idx].lineCount = params + 1;
          } else
            this._TriggerStates[idx].loop = -1;
          break;
      }
    }
    getTriggerState(idx) {
      return this._TriggerStates[idx];
    }
    cleanUpTriggerState(idx) {
      if (this._TriggerStates[idx] && this._TriggerStates[idx].reParse) {
        if (!this._TriggerStates[idx].type || this._TriggerStates[idx].type === 131072 /* ReParse */ || this._TriggerStates[idx].type === 262144 /* ReParsePattern */)
          delete this._TriggerStates[idx];
        else
          delete this._TriggerStates[idx].reParse;
        if (idx < 0)
          idx++;
        else
          idx--;
      }
      return idx;
    }
    clearTriggerState(idx) {
      delete this._TriggerStates[idx];
    }
    setTriggerState(idx, data) {
      this._TriggerStates[idx] = data;
    }
    clearTriggerCache() {
      this._TriggerCache = null;
      this._TriggerStates = {};
      this._TriggerFunctionCache = {};
      this._TriggerRegExCache = {};
    }
    resetTriggerState(idx, oldState, oldFire) {
      if (idx === -1) return;
      if (idx < 0 || idx >= this._TriggerCache.length) return;
      let trigger = this._TriggerCache[idx];
      const parent = trigger;
      let reParse = false;
      if (parent.state !== 0)
        trigger = parent.triggers[parent.state - 1];
      if (oldState === parent.state) {
        if (this._TriggerStates[idx]) {
          if (!trigger.fired)
            this.updateTriggerState(trigger, idx);
          else
            this.clearTriggerState(idx);
        } else {
          if (!trigger.fired)
            this.updateTriggerState(trigger, idx);
        }
      } else {
        if (this._TriggerStates[idx]) {
          if (!this._TriggerStates[idx].type || this._TriggerStates[idx].type !== 262144 /* ReParsePattern */ && this._TriggerStates[idx].type !== 131072 /* ReParse */)
            reParse = this._TriggerStates[idx].reParse;
        }
        this.clearTriggerState(idx);
        if (!trigger.fired) {
          const state = this.createTriggerState(trigger, reParse);
          if (state)
            this._TriggerStates[idx] = state;
        } else
          this._TriggerStates[idx] = { reParse: true };
      }
    }
    buildTriggerCache() {
      if (this._TriggerCache == null) {
        this._TriggerCache = this.client.triggers.filter((a) => {
          if (a && a.enabled && a.triggers.length) {
            if (a.type !== 3 /* Alarm */) return true;
            for (let s = 0, sl = a.triggers.length; s < sl; s++)
              if (a.triggers[s].enabled && a.triggers[s].type !== 3 /* Alarm */)
                return true;
            return false;
          }
          return a.enabled && a.type !== 3 /* Alarm */;
        });
      }
    }
    clearCaches() {
      this._TriggerCache = null;
      this._TriggerStates = {};
      this._TriggerFunctionCache = {};
      this._TriggerRegExCache = {};
      this._gamepadCaches = null;
      this._lastSuspend = -1;
      this._MacroCache = {};
    }
    triggerEvent(event2, args) {
      if (!this.enableTriggers) return;
      this.buildTriggerCache();
      let t = 0;
      if (!args)
        args = [event2];
      else if (!Array.isArray(args))
        args = [event2, args];
      else
        args.unshift(event2);
      const tl = this._TriggerCache.length;
      for (; t < tl; t++) {
        let trigger = this._TriggerCache[t];
        const parent = trigger;
        let changed = false;
        if (!trigger.enabled) continue;
        if (trigger.state > parent.triggers.length)
          trigger.state = 0;
        if (trigger.state !== 0 && parent.triggers && parent.triggers.length) {
          trigger = parent.triggers[trigger.state - 1];
          while (!trigger.enabled && parent.state !== 0) {
            parent.state++;
            if (parent.state > parent.triggers.length) {
              parent.state = 0;
              trigger = parent;
              break;
            }
            if (parent.state)
              trigger = parent.triggers[parent.state - 1];
            else
              trigger = parent;
            changed = true;
          }
          if (changed) {
            if (this.client.getOption("saveTriggerStateChanges"))
              this.client.saveProfiles();
            this.client.emit("item-updated", "trigger", parent.profile.name, parent.profile.triggers.indexOf(parent), parent);
          }
          if (!trigger.enabled) continue;
        }
        if (trigger.type === 131072 /* ReParse */ || trigger.type === 262144 /* ReParsePattern */) {
          const val = this.adjustLastLine(this.client.display.lines.length, true);
          const line2 = this.client.display.lines[val];
          t = this.TestTrigger(trigger, parent, t, line2, this.client.display.lines[val].raw || line2, val === this.client.display.lines.length - 1);
          continue;
        }
        if (trigger.type !== 2 /* Event */) continue;
        if (trigger.caseSensitive && event2 !== trigger.pattern) continue;
        if (!trigger.caseSensitive && event2.toLowerCase() !== trigger.pattern.toLowerCase()) continue;
        this._LastTriggered = event2;
        this.ExecuteTrigger(trigger, args, false, t, 0, 0, parent);
        t = this.cleanUpTriggerState(t);
      }
    }
    executeWait(text, delay, eAlias, stacking, append, noFunctions, noComments) {
      if (!text || text.length === 0) return;
      const s = { loops: this.loops.splice(0), args: 0, named: 0, used: this.stack.used, append: this.stack.append };
      if (this.stack.args)
        s.args = this.stack.args.slice();
      if (this.stack.named)
        s.named = this.stack.named.slice();
      if (delay < 0)
        delay = 0;
      setTimeout(() => {
        this._stack.push(s);
        let ret = this.parseOutgoing(text, eAlias, stacking, append, noFunctions, noComments);
        this._stack.pop();
        if (ret == null || typeof ret === "undefined" || ret.length === 0) return;
        if (!ret.endsWith("\n"))
          ret = ret + "\n";
        this.client.send(ret, true);
      }, delay);
    }
    stripQuotes(str, force, forceSingle) {
      if (!str || str.length === 0)
        return str;
      if (force || this.client.getOption("parseDoubleQuotes"))
        str = str.replace(/^\"(.*)\"$/g, (v, e, w) => {
          return e.replace(/\\\"/g, '"');
        });
      if (forceSingle || this.client.getOption("parseSingleQuotes"))
        str = str.replace(/^\'(.*)\'$/g, (v, e, w) => {
          return e.replace(/\\\'/g, "'");
        });
      return str;
    }
    splitByQuotes(str, sep, force, forceSingle) {
      let t = 0;
      let e = 0;
      if (!str || str.length === 0)
        return [];
      if (force || this.client.getOption("parseDoubleQuotes")) {
        t |= 2;
        e |= this.client.getOption("allowEscape") ? 2 : 0;
      }
      if (forceSingle || this.client.getOption("parseSingleQuotes")) {
        t |= 1;
        e |= this.client.getOption("allowEscape") ? 1 : 0;
      }
      return splitQuoted(str, sep, t, e, this.client.getOption("escapeChar"));
    }
    createTrigger(pattern, commands, profile, options, name2, subTrigger) {
      let trigger;
      let sTrigger;
      let reload = true;
      let isNew = false;
      if (!pattern && !name2)
        throw new Error(`Trigger '${name2 || ""}' not found`);
      if (!profile) {
        const keys = this.client.profiles.keys;
        let k = 0;
        const kl = keys.length;
        if (kl === 0)
          return;
        if (kl === 1) {
          if (!this.client.profiles.items[keys[0]].enabled || !this.client.profiles.items[keys[0]].enableTriggers)
            throw Error("No enabled profiles found!");
          profile = this.client.profiles.items[keys[0]];
          if (subTrigger) {
            if (!name2) {
              if (!this.client.profiles.items[keys[k]].triggers.length)
                throw new Error(`No triggers exist`);
              trigger = this.client.profiles.items[keys[k]].triggers[this.client.profiles.items[keys[k]].triggers.length - 1];
            } else
              trigger = this.client.profiles.items[keys[k]].findAny("triggers", { name: name2, pattern: name2 });
          } else if (name2 !== null)
            trigger = this.client.profiles.items[keys[k]].find("triggers", "name", name2);
          else
            trigger = this.client.profiles.items[keys[k]].find("triggers", "pattern", pattern);
        } else {
          for (; k < kl; k++) {
            if (!this.client.profiles.items[keys[k]].enabled || !this.client.profiles.items[keys[k]].enableTriggers || this.client.profiles.items[keys[k]].triggers.length === 0)
              continue;
            if (subTrigger) {
              if (!name2) {
                if (!this.client.profiles.items[keys[k]].triggers.length)
                  throw new Error(`No triggers exist`);
                trigger = this.client.profiles.items[keys[k]].triggers[this.client.profiles.items[keys[k]].triggers.length - 1];
              } else
                trigger = this.client.profiles.items[keys[k]].findAny("triggers", { name: name2, pattern: name2 });
            } else if (name2 !== null)
              trigger = this.client.profiles.items[keys[k]].find("triggers", "name", name2);
            else
              trigger = this.client.profiles.items[keys[k]].find("triggers", "pattern", pattern);
            if (trigger) {
              profile = this.client.profiles.items[keys[k]];
              break;
            }
          }
          if (!profile)
            profile = this.client.activeProfile;
        }
      } else if (typeof profile === "string") {
        if (this.client.profiles.contains(profile.toLowerCase()))
          profile = this.client.profiles.items[profile.toLowerCase()];
        else
          throw new Error("Profile not found: " + profile);
        if (subTrigger) {
          if (!name2) {
            if (!profile.triggers.length)
              throw new Error(`No triggers exist`);
            trigger = profile.triggers[profile.triggers.length - 1];
          } else
            trigger = profile.findAny("triggers", { name: name2, pattern: name2 });
        } else if (name2 !== null)
          trigger = profile.find("triggers", "name", name2);
        else
          trigger = profile.find("triggers", "pattern", pattern);
      }
      if (subTrigger) {
        if (!trigger)
          throw new Error(`Trigger '${name2 || ""}' not found`);
        sTrigger;
        sTrigger = new Trigger();
        sTrigger.pattern = pattern;
        reload = false;
        if (pattern !== null)
          sTrigger.pattern = pattern;
        if (commands !== null)
          sTrigger.value = commands;
        if (options) {
          if (options.cmd)
            sTrigger.type = 1 /* CommandInputRegular */;
          if (options.pattern)
            sTrigger.type = 8 /* Pattern */;
          if (options.regular)
            sTrigger.type = 0 /* Regular */;
          if (options.alarm)
            sTrigger.type = 3 /* Alarm */;
          if (options.event)
            sTrigger.type = 2 /* Event */;
          if (options.cmdpattern)
            sTrigger.type = 16 /* CommandInputPattern */;
          if (options.loopexpression)
            sTrigger.type = 128 /* LoopExpression */;
          if (options.reparse)
            sTrigger.type = 131072 /* ReParse */;
          if (options.reparsepattern)
            sTrigger.type = 262144 /* ReParsePattern */;
          if (options.manual)
            sTrigger.type = 65536 /* Manual */;
          if (options.skip)
            sTrigger.type = 512 /* Skip */;
          if (options.looplines)
            sTrigger.type = 8192 /* LoopLines */;
          if (options.looppattern)
            sTrigger.type = 4096 /* LoopPattern */;
          if (options.wait)
            sTrigger.type = 1024 /* Wait */;
          if (options.duration)
            sTrigger.type = 16384 /* Duration */;
          if (options.withinlines)
            sTrigger.type = 32768 /* WithinLines */;
          if (options.prompt)
            sTrigger.triggerPrompt = true;
          if (options.nocr)
            sTrigger.triggerNewline = false;
          if (options.case)
            sTrigger.caseSensitive = true;
          if (options.raw)
            sTrigger.raw = true;
          if (options.verbatim)
            sTrigger.verbatim = true;
          if (options.disable)
            sTrigger.enabled = false;
          else if (options.enable)
            sTrigger.enabled = true;
          if (options.temporary || options.temp)
            sTrigger.temp = true;
          if (options.params)
            sTrigger.params = options.params;
          if (options.type) {
            if (this._isTriggerType(options.type))
              sTrigger.type = this._convertTriggerType(options.type);
            else
              throw new Error("Invalid trigger type");
          }
        }
        trigger.triggers.push(sTrigger);
        this.client.echo("Trigger sub state added.", -7, -8, true, true);
      } else {
        if (!trigger) {
          if (!pattern)
            throw new Error(`Trigger '${name2 || ""}' not found`);
          trigger = new Trigger();
          trigger.name = name2 || "";
          trigger.pattern = pattern;
          profile.triggers.push(trigger);
          this.client.echo("Trigger added.", -7, -8, true, true);
          isNew = true;
        } else
          this.client.echo("Trigger updated.", -7, -8, true, true);
        if (pattern !== null)
          trigger.pattern = pattern;
        if (commands !== null)
          trigger.value = commands;
        if (options) {
          if (options.cmd)
            trigger.type = 1 /* CommandInputRegular */;
          if (options.pattern)
            trigger.type = 8 /* Pattern */;
          if (options.regular)
            trigger.type = 0 /* Regular */;
          if (options.alarm)
            trigger.type = 3 /* Alarm */;
          if (options.event)
            trigger.type = 2 /* Event */;
          if (options.cmdpattern)
            trigger.type = 16 /* CommandInputPattern */;
          if (options.loopexpression)
            trigger.type = 128 /* LoopExpression */;
          if (options.prompt)
            trigger.triggerPrompt = true;
          if (options.nocr)
            trigger.triggerNewline = false;
          if (options.case)
            trigger.caseSensitive = true;
          if (options.raw)
            trigger.raw = true;
          if (options.verbatim)
            trigger.verbatim = true;
          if (options.disable)
            trigger.enabled = false;
          else if (options.enable)
            trigger.enabled = true;
          if (options.temporary || options.temp)
            trigger.temp = true;
          if (options.params)
            trigger.params = options.params;
          if (options.type) {
            if (this._isTriggerType(options.type, 1 /* Main */))
              trigger.type = this._convertTriggerType(options.type);
            else
              throw new Error("Invalid trigger type");
          }
          trigger.priority = options.priority;
        } else
          trigger.priority = 0;
      }
      this.client.saveProfiles();
      if (reload)
        this.client.clearCache();
      if (isNew)
        this.emit("item-added", "trigger", profile.name, trigger);
      else
        this.emit("item-updated", "trigger", profile.name, profile.triggers.indexOf(trigger), trigger);
      profile = null;
    }
    _isTriggerType(type, filter) {
      if (!filter) filter = 3 /* All */;
      switch (type.replace(/ /g, "").toUpperCase()) {
        case "REGULAREXPRESSION":
        case "COMMANDINPUTREGULAREXPRESSION":
          return (filter & 1 /* Main */) === 1 /* Main */ ? true : false;
        case "0":
        case "1":
        case "2":
        case "3":
        case "8":
        case "16":
        //case '64':
        case "128":
        case "REGULAR":
        case "COMMANDINPUTREGULAR":
        case "EVENT":
        case "ALARM":
        case "COMMAND":
        case "COMMANDINPUTPATTERN":
        case "LOOPEXPRSSION":
          return (filter & 1 /* Main */) === 1 /* Main */ ? true : false;
        case "SKIP":
        case "512":
        case "WAIT":
        case "1024":
        case "LOOPPATTERN":
        case "4096":
        case "LOOPLINES":
        case "8192":
        case "DURATION":
        case "16384":
        case "WITHINLINES":
        case "32768":
        case "MANUAL":
        case "65536":
        case "REPARSE":
        case "131072":
        case "REPARSEPATTERN":
        case "262144":
          return (filter & 2 /* Sub */) === 2 /* Sub */ ? true : false;
      }
      return false;
    }
    _convertTriggerType(type) {
      switch (type.replace(/ /g, "").toUpperCase()) {
        case "REGULAREXPRESSION":
          return 0 /* Regular */;
        case "COMMANDINPUTREGULAREXPRESSION":
          return 1 /* CommandInputRegular */;
        case "0":
        case "1":
        case "2":
        case "3":
        case "8":
        case "16":
        case "128":
          return TriggerType[parseInt(type, 10)];
        case "REGULAR":
        case "COMMANDINPUTREGULAR":
        case "EVENT":
        case "ALARM":
        case "COMMAND":
        case "COMMANDINPUTPATTERN":
        case "LOOPEXPRSSION":
          return TriggerType[type];
        case "512":
        case "1024":
        case "4096":
        case "8192":
        case "16384":
        case "32768":
        case "65536":
        case "131072":
        case "262144":
          return SubTriggerTypes[parseInt(type, 10)];
        case "SKIP":
        case "WAIT":
        case "LOOPPATTERN":
        case "LOOPLINES":
        case "DURATION":
        case "WITHINLINES":
        case "MANUAL":
        case "REPARSE":
        case "REPARSEPATTERN":
          return SubTriggerTypes[type];
      }
      throw new Error("Invalid trigger type");
    }
    _colorPosition(n, fore, back, item) {
      n = this.adjustLastLine(n);
      if (!item.hasOwnProperty("yStart"))
        this.client.display.colorSubStringByLine(n, fore, back, item.xStart, item.hasOwnProperty("xEnd") && item.xEnd >= 0 ? item.xEnd : null);
      else {
        const xEnd = item.hasOwnProperty("xEnd") && item.xEnd >= 0 ? item.xEnd : null;
        const xStart = item.xStart;
        let line2 = n - item.yStart;
        let end = n;
        if (item.hasOwnProperty("yEnd"))
          end = n - item.yEnd;
        while (line2 <= end) {
          this.client.display.colorSubStringByLine(line2, fore, back, xStart, xEnd);
          line2++;
        }
      }
    }
  };

  // src/lib/rgbcolor.js
  function RGBColor(color_string) {
    this.ok = false;
    if (color_string.charAt(0) == "#") {
      color_string = color_string.substr(1, 6);
    }
    color_string = color_string.replace(/ /g, "");
    color_string = color_string.toLowerCase();
    var simple_colors = {
      aliceblue: "f0f8ff",
      antiquewhite: "faebd7",
      aqua: "00ffff",
      aquamarine: "7fffd4",
      azure: "f0ffff",
      beige: "f5f5dc",
      bisque: "ffe4c4",
      black: "000000",
      blanchedalmond: "ffebcd",
      blue: "0000ff",
      blueviolet: "8a2be2",
      brown: "a52a2a",
      burlywood: "deb887",
      cadetblue: "5f9ea0",
      chartreuse: "7fff00",
      chocolate: "d2691e",
      coral: "ff7f50",
      cornflowerblue: "6495ed",
      cornsilk: "fff8dc",
      crimson: "dc143c",
      cyan: "00ffff",
      darkblue: "00008b",
      darkcyan: "008b8b",
      darkgoldenrod: "b8860b",
      darkgray: "a9a9a9",
      darkgreen: "006400",
      darkkhaki: "bdb76b",
      darkmagenta: "8b008b",
      darkolivegreen: "556b2f",
      darkorange: "ff8c00",
      darkorchid: "9932cc",
      darkred: "8b0000",
      darksalmon: "e9967a",
      darkseagreen: "8fbc8f",
      darkslateblue: "483d8b",
      darkslategray: "2f4f4f",
      darkturquoise: "00ced1",
      darkviolet: "9400d3",
      deeppink: "ff1493",
      deepskyblue: "00bfff",
      dimgray: "696969",
      dodgerblue: "1e90ff",
      feldspar: "d19275",
      firebrick: "b22222",
      floralwhite: "fffaf0",
      forestgreen: "228b22",
      fuchsia: "ff00ff",
      gainsboro: "dcdcdc",
      ghostwhite: "f8f8ff",
      gold: "ffd700",
      goldenrod: "daa520",
      gray: "808080",
      green: "008000",
      greenyellow: "adff2f",
      honeydew: "f0fff0",
      hotpink: "ff69b4",
      indianred: "cd5c5c",
      indigo: "4b0082",
      ivory: "fffff0",
      khaki: "f0e68c",
      lavender: "e6e6fa",
      lavenderblush: "fff0f5",
      lawngreen: "7cfc00",
      lemonchiffon: "fffacd",
      lightblue: "add8e6",
      lightcoral: "f08080",
      lightcyan: "e0ffff",
      lightgoldenrodyellow: "fafad2",
      lightgrey: "d3d3d3",
      lightgreen: "90ee90",
      lightpink: "ffb6c1",
      lightsalmon: "ffa07a",
      lightseagreen: "20b2aa",
      lightskyblue: "87cefa",
      lightslateblue: "8470ff",
      lightslategray: "778899",
      lightsteelblue: "b0c4de",
      lightyellow: "ffffe0",
      lime: "00ff00",
      limegreen: "32cd32",
      linen: "faf0e6",
      magenta: "ff00ff",
      maroon: "800000",
      mediumaquamarine: "66cdaa",
      mediumblue: "0000cd",
      mediumorchid: "ba55d3",
      mediumpurple: "9370d8",
      mediumseagreen: "3cb371",
      mediumslateblue: "7b68ee",
      mediumspringgreen: "00fa9a",
      mediumturquoise: "48d1cc",
      mediumvioletred: "c71585",
      midnightblue: "191970",
      mintcream: "f5fffa",
      mistyrose: "ffe4e1",
      moccasin: "ffe4b5",
      navajowhite: "ffdead",
      navy: "000080",
      oldlace: "fdf5e6",
      olive: "808000",
      olivedrab: "6b8e23",
      orange: "ffa500",
      orangered: "ff4500",
      orchid: "da70d6",
      palegoldenrod: "eee8aa",
      palegreen: "98fb98",
      paleturquoise: "afeeee",
      palevioletred: "d87093",
      papayawhip: "ffefd5",
      peachpuff: "ffdab9",
      peru: "cd853f",
      pink: "ffc0cb",
      plum: "dda0dd",
      powderblue: "b0e0e6",
      purple: "800080",
      red: "ff0000",
      rosybrown: "bc8f8f",
      royalblue: "4169e1",
      saddlebrown: "8b4513",
      salmon: "fa8072",
      sandybrown: "f4a460",
      seagreen: "2e8b57",
      seashell: "fff5ee",
      sienna: "a0522d",
      silver: "c0c0c0",
      skyblue: "87ceeb",
      slateblue: "6a5acd",
      slategray: "708090",
      snow: "fffafa",
      springgreen: "00ff7f",
      steelblue: "4682b4",
      tan: "d2b48c",
      teal: "008080",
      thistle: "d8bfd8",
      tomato: "ff6347",
      turquoise: "40e0d0",
      violet: "ee82ee",
      violetred: "d02090",
      wheat: "f5deb3",
      white: "ffffff",
      whitesmoke: "f5f5f5",
      yellow: "ffff00",
      yellowgreen: "9acd32"
    };
    for (var key in simple_colors) {
      if (color_string == key) {
        color_string = simple_colors[key];
      }
    }
    var color_defs = [
      {
        re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
        example: ["rgb(123, 234, 45)", "rgb(255,234,245)"],
        process: function(bits2) {
          return [
            parseInt(bits2[1], 10),
            parseInt(bits2[2], 10),
            parseInt(bits2[3], 10)
          ];
        }
      },
      {
        re: /^(\w{2})(\w{2})(\w{2})$/,
        example: ["#00ff00", "336699"],
        process: function(bits2) {
          return [
            parseInt(bits2[1], 16),
            parseInt(bits2[2], 16),
            parseInt(bits2[3], 16)
          ];
        }
      },
      {
        re: /^(\w{1})(\w{1})(\w{1})$/,
        example: ["#fb0", "f0f"],
        process: function(bits2) {
          return [
            parseInt(bits2[1] + bits2[1], 16),
            parseInt(bits2[2] + bits2[2], 16),
            parseInt(bits2[3] + bits2[3], 16)
          ];
        }
      }
    ];
    for (var i2 = 0, cl = color_defs.length; i2 < cl; i2++) {
      var re = color_defs[i2].re;
      var processor = color_defs[i2].process;
      var bits = re.exec(color_string);
      if (bits) {
        var channels = processor(bits);
        this.r = channels[0];
        this.g = channels[1];
        this.b = channels[2];
        this.ok = true;
      }
    }
    this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r;
    this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g;
    this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b;
    this.toRGB = function() {
      return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
    };
    this.toHex = function() {
      var r = this.r.toString(16);
      var g = this.g.toString(16);
      var b = this.b.toString(16);
      if (r.length == 1) r = "0" + r;
      if (g.length == 1) g = "0" + g;
      if (b.length == 1) b = "0" + b;
      return "#" + r + g + b;
    };
  }

  // src/parser.ts
  var MXPTag = /* @__PURE__ */ ((MXPTag2) => {
    MXPTag2[MXPTag2["None"] = 0] = "None";
    MXPTag2[MXPTag2["B"] = 1] = "B";
    MXPTag2[MXPTag2["BOLD"] = 2] = "BOLD";
    MXPTag2[MXPTag2["STRONG"] = 3] = "STRONG";
    MXPTag2[MXPTag2["I"] = 4] = "I";
    MXPTag2[MXPTag2["ITALIC"] = 5] = "ITALIC";
    MXPTag2[MXPTag2["EM"] = 6] = "EM";
    MXPTag2[MXPTag2["U"] = 7] = "U";
    MXPTag2[MXPTag2["UNDERLINE"] = 8] = "UNDERLINE";
    MXPTag2[MXPTag2["S"] = 9] = "S";
    MXPTag2[MXPTag2["STRIKEOUT"] = 10] = "STRIKEOUT";
    MXPTag2[MXPTag2["STRIKE"] = 11] = "STRIKE";
    MXPTag2[MXPTag2["C"] = 12] = "C";
    MXPTag2[MXPTag2["COLOR"] = 13] = "COLOR";
    MXPTag2[MXPTag2["H"] = 14] = "H";
    MXPTag2[MXPTag2["HIGH"] = 15] = "HIGH";
    MXPTag2[MXPTag2["FONT"] = 16] = "FONT";
    MXPTag2[MXPTag2["HR"] = 17] = "HR";
    MXPTag2[MXPTag2["NOBR"] = 18] = "NOBR";
    MXPTag2[MXPTag2["P"] = 19] = "P";
    MXPTag2[MXPTag2["BR"] = 20] = "BR";
    MXPTag2[MXPTag2["SBR"] = 21] = "SBR";
    MXPTag2[MXPTag2["A"] = 22] = "A";
    MXPTag2[MXPTag2["SEND"] = 23] = "SEND";
    MXPTag2[MXPTag2["EXPIRE"] = 24] = "EXPIRE";
    MXPTag2[MXPTag2["VERSION"] = 25] = "VERSION";
    MXPTag2[MXPTag2["SUPPORT"] = 26] = "SUPPORT";
    MXPTag2[MXPTag2["RESET"] = 27] = "RESET";
    MXPTag2[MXPTag2["H1"] = 28] = "H1";
    MXPTag2[MXPTag2["H2"] = 29] = "H2";
    MXPTag2[MXPTag2["H3"] = 30] = "H3";
    MXPTag2[MXPTag2["H4"] = 31] = "H4";
    MXPTag2[MXPTag2["H5"] = 32] = "H5";
    MXPTag2[MXPTag2["H6"] = 33] = "H6";
    MXPTag2[MXPTag2["V"] = 34] = "V";
    MXPTag2[MXPTag2["VAR"] = 35] = "VAR";
    MXPTag2[MXPTag2["USER"] = 36] = "USER";
    MXPTag2[MXPTag2["PASSWORD"] = 37] = "PASSWORD";
    MXPTag2[MXPTag2["Custom"] = 38] = "Custom";
    MXPTag2[MXPTag2["GAUGE"] = 39] = "GAUGE";
    MXPTag2[MXPTag2["STAT"] = 40] = "STAT";
    return MXPTag2;
  })(MXPTag || {});
  var MXPState = class {
    constructor() {
      this.on = false;
      this.lineType = 0;
      this.locked = false;
      this.paragraph = false;
      this.noBreak = false;
      this.expanded = false;
      this.lineExpanded = false;
      this.capture = 0;
      this.captured = [];
      this.gagged = false;
    }
  };
  var Entity = class {
    constructor(remote) {
      this.name = "";
      this.value = "";
      this.description = "";
      this.publish = false;
      this.remote = false;
      this.remote = remote == null ? false : remote;
    }
  };
  var Element = class {
    constructor(remote) {
      this.name = "";
      this.definition = "";
      this.closeDefinition = "";
      this.attributes = {};
      this.attributeIndexes = [];
      this.tag = -1 /* None */;
      this.flag = "";
      this.open = false;
      this.empty = false;
      this.remote = false;
      this.gagged = false;
      this.remote = remote == null ? false : remote;
    }
  };
  var Tag = class {
    constructor(index, fore, back, remote) {
      this.index = -1 /* None */;
      this.window = "";
      this.gag = false;
      this.fore = "";
      this.back = "";
      this.enabled = true;
      this.remote = false;
      this.element = "";
      this.definition = "";
      this.closeDefinition = "";
      if (index != null) this.index = index;
      if (fore != null) this.fore = fore;
      if (back != null) this.back = back;
      if (remote != null) this.remote = remote;
    }
  };
  var MXPStyle = class {
    constructor(style, fore, back, high, open) {
      this.tag = 0 /* None */;
      this.custom = "";
      this.font = null;
      this.fontSize = null;
      this.style = 0 /* None */;
      this.fore = "";
      this.back = "";
      this.high = false;
      this.obj = null;
      this.gagged = false;
      this.open = false;
      this.properties = null;
      if (style != null) this.style = style;
      if (fore != null) this.fore = fore;
      if (back != null) this.back = back;
      this.high = high || false;
      this.open = open || false;
    }
  };
  var Parser = class extends EventEmitter {
    constructor(options) {
      super();
      /** @private */
      this._parsing = [];
      /** @private */
      /* Web detection protocols that are just followed by a :*/
      this._protocols = [["m", "a", "i", "l", "t", "o"], ["s", "k", "y", "p", "e"], ["a", "i", "m"], ["c", "a", "l", "l", "t", "o"], ["g", "t", "a", "l", "k"], ["i", "m"], ["i", "t", "m", "s"], ["m", "s", "n", "i", "m"], ["t", "e", "l"], ["y", "m", "s", "g", "r"]];
      /** @private */
      this._ColorTable = null;
      /** @private */
      this._CurrentForeColor = 37;
      /** @private */
      this._CurrentBackColor = 40;
      /** @private */
      this._CurrentAttributes = 0 /* None */;
      /** @private */
      this._SplitBuffer = "";
      /** @private */
      this._mxpState = new MXPState();
      /** @private */
      this._mxpStyles = [];
      /** @private */
      this._mxpEntities = {};
      /** @private */
      this._mxpElements = {};
      /** @private */
      this._mxpLines = [];
      /** @private */
      this._iMXPDefaultMode = 0 /* Open */;
      this.displayControlCodes = false;
      this.emulateControlCodes = true;
      this.StyleVersion = "";
      this.EndOfLine = false;
      this.textLength = 0;
      this.rawLength = 0;
      this.enableMXP = true;
      this.DefaultImgUrl = "";
      this.enableDebug = false;
      this.showInvalidMXPTags = false;
      this.enableLinks = true;
      this.enableMSP = true;
      this.enableURLDetection = true;
      this.window = new Size(0, 0);
      this.enableFlashing = false;
      this.emulateTerminal = false;
      this.enableBell = true;
      this.display = null;
      this.tabWidth = 8;
      this.busy = false;
      if (options != null) {
        if (options.DefaultImageURL)
          this.DefaultImgUrl = options.DefaultImageURL;
        if (options.enableMXP != null)
          this.enableMXP = options.enableMXP;
        if (options.enableDebug != null)
          this.enableDebug = options.enableDebug;
        if (options.showInvalidMXPTags != null)
          this.showInvalidMXPTags = options.showInvalidMXPTags;
        if (options.enableMSP != null)
          this.enableMSP = options.enableMSP;
        if (options.enableURLDetection != null)
          this.enableURLDetection = options.enableURLDetection;
        if (options.window != null)
          this.window = options.window;
        if (options.enableFlashing != null)
          this.enableFlashing = options.enableFlashing;
        if (options.emulateTerminal != null)
          this.emulateTerminal = options.emulateTerminal;
        if (options.enableBell != null)
          this.enableBell = options.enableBell;
        if (options.display != null)
          this.display = options.display;
        if (options.enableLinks)
          this.enableLinks = options.enableLinks;
      }
    }
    _getColors(mxp) {
      if (typeof mxp === "undefined")
        mxp = this._GetCurrentStyle();
      let f;
      let b;
      let fc = -1;
      let bc = -1;
      if (mxp.fore.length > 0) {
        if ((this._CurrentAttributes & 1 /* Bold */) === 1 /* Bold */)
          f = this.IncreaseColor(mxp.fore, 0.5);
        else if ((this._CurrentAttributes & 2 /* Faint */) === 2 /* Faint */)
          f = this.DecreaseColor(mxp.fore, 0.5);
        else
          f = mxp.fore;
      } else if (typeof this._CurrentForeColor === "string")
        f = "rgb(" + this._CurrentForeColor.replace(/;/g, ",") + ")";
      else {
        f = this._CurrentForeColor;
        if ((this._CurrentAttributes & 1 /* Bold */) === 1 /* Bold */) {
          if (f > 999)
            f /= 1e3;
          if (f >= 0 && f < 99)
            f *= 10;
          fc = f;
          if (f <= -16)
            f = this.IncreaseColor(this.GetColor(f), 0.5);
        } else if ((this._CurrentAttributes & 2 /* Faint */) === 2 /* Faint */) {
          if (f > 99 && f < 999)
            f /= 10;
          if (f >= 0 && f < 999)
            f *= 100;
          fc = f;
          if (f <= -16)
            f = this.DecreaseColor(this.GetColor(f), 0.15);
        } else {
          fc = f;
        }
      }
      if (mxp.high) {
        if (typeof f === "number")
          f = this.IncreaseColor(this.GetColor(f), 0.25);
        else
          f = this.IncreaseColor(f, 0.25);
      }
      if (mxp.back.length > 0)
        b = mxp.back;
      else if (typeof this._CurrentBackColor === "string")
        b = "rgb(" + this._CurrentBackColor.replace(/;/g, ",") + ")";
      else
        b = bc = this._CurrentBackColor;
      if ((this._CurrentAttributes & 64 /* Inverse */) === 64 /* Inverse */ || (mxp.style & 64 /* Inverse */) === 64 /* Inverse */)
        return { fore: b, back: f, foreCode: bc, backCode: fc };
      return { fore: f, back: b, foreCode: fc, backCode: bc };
    }
    _getFormatBlock(offset2) {
      const mxp = this._GetCurrentStyle();
      const colors = this._getColors(mxp);
      return {
        formatType: 0 /* Normal */,
        offset: offset2,
        color: colors.fore || 0,
        background: colors.back || 0,
        size: mxp.fontSize || 0,
        font: mxp.font || 0,
        style: mxp.style | this._CurrentAttributes & ~1 /* Bold */,
        unicode: false
      };
    }
    _ResetColors() {
      this._CurrentForeColor = 37;
      this._CurrentBackColor = 40;
      this._CurrentAttributes = 0 /* None */;
    }
    _ProcessAnsiColorParams(params) {
      let p = 0;
      const pl = params.length;
      let i2;
      let rgb;
      for (; p < pl; p++) {
        i2 = +params[p] || 0;
        switch (i2) {
          case 0:
            this._ResetColors();
            break;
          case 1:
            this._CurrentAttributes |= 1 /* Bold */;
            this._CurrentAttributes &= ~2 /* Faint */;
            break;
          case 2:
            this._CurrentAttributes |= 2 /* Faint */;
            this._CurrentAttributes &= ~1 /* Bold */;
            break;
          case 3:
            this._CurrentAttributes |= 4 /* Italic */;
            break;
          case 4:
            this._CurrentAttributes |= 8 /* Underline */;
            break;
          case 5:
            this._CurrentAttributes |= 16 /* Slow */;
            break;
          case 6:
            this._CurrentAttributes |= 32 /* Rapid */;
            break;
          case 7:
            this._CurrentAttributes |= 64 /* Inverse */;
            break;
          case 8:
            this._CurrentAttributes |= 128 /* Hidden */;
            break;
          case 9:
            this._CurrentAttributes |= 256 /* Strikeout */;
            break;
          /*
          10 primary(default) font
          11 first alternative font
          12 second alternative font
          13 third alternative font
          14 fourth alternative font
          15 fifth alternative font
          16 sixth alternative font
          17 seventh alternative font
          18 eighth alternative font
          19 ninth alternative font
          20 Fraktur(Gothic)
          */
          case 21:
            this._CurrentAttributes |= 512 /* DoubleUnderline */;
            break;
          case 22:
            this._CurrentAttributes &= ~1 /* Bold */;
            this._CurrentAttributes &= ~2 /* Faint */;
            break;
          case 23:
            this._CurrentAttributes &= ~4 /* Italic */;
            break;
          case 24:
            this._CurrentAttributes &= ~8 /* Underline */;
            this._CurrentAttributes &= ~512 /* DoubleUnderline */;
            break;
          case 25:
            this._CurrentAttributes &= ~16 /* Slow */;
            break;
          case 26:
            this._CurrentAttributes &= ~32 /* Rapid */;
            break;
          case 27:
            this._CurrentAttributes &= ~64 /* Inverse */;
            break;
          case 28:
            this._CurrentAttributes &= ~128 /* Hidden */;
            break;
          case 29:
            this._CurrentAttributes &= ~256 /* Strikeout */;
            break;
          case -11:
          //error color
          case -7:
          //info color
          case -3:
          //local echo
          case 30:
          //set foreground color to black
          case 31:
          //set foreground color to red
          case 32:
          //set foreground color to green
          case 33:
          //set foreground color to yellow
          case 34:
          //set foreground color to blue
          case 35:
          //set foreground color to magenta (purple)
          case 36:
          //set foreground color to cyan
          case 37:
            this._CurrentForeColor = i2;
            break;
          case 38:
            if (p + 2 < pl && params[p + 1] === "5") {
              this._CurrentForeColor = +params[p + 2];
              if (isNaN(this._CurrentForeColor))
                this._CurrentForeColor = 37;
              else {
                this._CurrentForeColor += 16;
                this._CurrentForeColor *= -1;
              }
              p += 2;
            } else if (p + 4 < pl && params[p + 1] === "2") {
              i2 = +params[p + 2] || 0;
              if (i2 < 0 || i2 > 255)
                continue;
              rgb = i2 + ";";
              i2 = +params[p + 3] || 0;
              if (i2 < 0 || i2 > 255)
                continue;
              rgb += i2 + ";";
              i2 = +params[p + 4] || 0;
              if (i2 < 0 || i2 > 255)
                continue;
              rgb += i2;
              this._CurrentForeColor = rgb;
              p += 4;
            }
            break;
          case 39:
            this._CurrentForeColor = -1;
            break;
          case -12:
          //error color
          case -8:
          case -4:
          case 40:
          case 41:
          case 42:
          case 43:
          case 44:
          case 45:
          case 46:
          case 47:
            this._CurrentBackColor = i2;
            break;
          case 48:
            if (p + 2 < pl && params[p + 1] === "5") {
              this._CurrentBackColor = +params[p + 2];
              if (isNaN(this._CurrentBackColor))
                this._CurrentBackColor = 40;
              else {
                this._CurrentBackColor += 16;
                this._CurrentBackColor *= -1;
              }
              p += 2;
            } else if (p + 4 < pl && params[p + 1] === "2") {
              i2 = +params[p + 2] || 0;
              if (i2 < 0 || i2 > 255)
                continue;
              rgb = i2 + ";";
              i2 = +params[p + 3] || 0;
              if (i2 < 0 || i2 > 255)
                continue;
              rgb += i2 + ";";
              i2 = +params[p + 4] || 0;
              if (i2 < 0 || i2 > 255)
                continue;
              rgb += i2;
              this._CurrentBackColor = rgb;
              p += 4;
            }
            break;
          case 49:
            this._CurrentBackColor = -2;
            break;
          //zMUD log colors, seems zMUD uses the 50s for display info for bold colors, standards use it to control borders and other effects
          //don't need zMUD colors here as we never need to open fonts, replace with the frames/overlined/etc... if it can be done in css
          case 53:
            this._CurrentAttributes |= 1024 /* Overline */;
            break;
          case 55:
            this._CurrentAttributes &= ~1024 /* Overline */;
            break;
          case 50:
          //Reserved
          case 51:
          //Framed believe this adds a border all the way around block of text
          case 52:
          //Encircled, not sure maybe draws a circle around text?
          case 54:
          //Not framed or encircled, turns off framed/encircled
          case 56:
          //Reserved
          case 57:
          //Reserved
          case 58:
          //Reserved
          case 59:
            this._CurrentForeColor = i2 - 20;
            this._CurrentAttributes |= 1 /* Bold */;
            break;
          //xterm 16 but color
          //Assume that xterm?s resources are set so that the ISO color codes are the first 8 of a set of 16.
          //Then the aixterm colors are the bright versions of the ISO colors:
          case 90:
          case 91:
          case 92:
          case 93:
          case 94:
          case 95:
          case 96:
          case 97:
            this._CurrentForeColor = i2;
            break;
          case 100:
          case 101:
          case 102:
          case 103:
          case 104:
          case 105:
          case 106:
          case 107:
            this._CurrentBackColor = i2;
            break;
        }
      }
    }
    _buildColorTable() {
      const _ColorTable = [];
      let r;
      let g;
      let b;
      let idx;
      for (r = 0; r < 6; r++) {
        for (g = 0; g < 6; g++) {
          for (b = 0; b < 6; b++) {
            idx = 16 + r * 36 + g * 6 + b;
            _ColorTable[idx] = "rgb(";
            if (r > 0)
              _ColorTable[idx] += r * 40 + 55;
            else
              _ColorTable[idx] += "0";
            _ColorTable[idx] += ",";
            if (g > 0)
              _ColorTable[idx] += g * 40 + 55;
            else
              _ColorTable[idx] += "0";
            _ColorTable[idx] += ",";
            if (b > 0)
              _ColorTable[idx] += b * 40 + 55;
            else
              _ColorTable[idx] += "0";
            _ColorTable[idx] += ")";
          }
        }
      }
      for (r = 232; r <= 255; r++) {
        g = (r - 232) * 10 + 8;
        _ColorTable[r] = ["rgb(", g, ",", g, ",", g, ")"].join("");
      }
      _ColorTable[0] = "rgb(0,0,0)";
      _ColorTable[1] = "rgb(128, 0, 0)";
      _ColorTable[2] = "rgb(0, 128, 0)";
      _ColorTable[3] = "rgb(128, 128, 0)";
      _ColorTable[4] = "rgb(0, 0, 238)";
      _ColorTable[5] = "rgb(128, 0, 128)";
      _ColorTable[6] = "rgb(0, 128, 128)";
      _ColorTable[7] = "rgb(187, 187, 187)";
      _ColorTable[8] = "rgb(128, 128, 128)";
      _ColorTable[9] = "rgb(255, 0, 0)";
      _ColorTable[10] = "rgb(0, 255, 0)";
      _ColorTable[11] = "rgb(255, 255, 0)";
      _ColorTable[12] = "rgb(92, 92, 255)";
      _ColorTable[13] = "rgb(255, 0, 255)";
      _ColorTable[14] = "rgb(0, 255, 255)";
      _ColorTable[15] = "rgb(255, 255, 255)";
      _ColorTable[256] = "rgb(0, 0, 0)";
      _ColorTable[257] = "rgb(118, 0, 0)";
      _ColorTable[258] = "rgb(0, 108, 0)";
      _ColorTable[259] = "rgb(145, 136, 0)";
      _ColorTable[260] = "rgb(0, 0, 167)";
      _ColorTable[261] = "rgb(108, 0, 108)";
      _ColorTable[262] = "rgb(0, 108, 108)";
      _ColorTable[263] = "rgb(161, 161, 161)";
      _ColorTable[264] = "rgb(0, 0, 0)";
      _ColorTable[265] = "rgb(128, 0, 0)";
      _ColorTable[266] = "rgb(0, 128, 0)";
      _ColorTable[267] = "rgb(128, 128, 0)";
      _ColorTable[268] = "rgb(0, 0, 238)";
      _ColorTable[269] = "rgb(128, 0, 128)";
      _ColorTable[270] = "rgb(0, 128, 128)";
      _ColorTable[271] = "rgb(187, 187, 187)";
      _ColorTable[272] = "rgb(0,0,0)";
      _ColorTable[273] = "rgb(0, 255, 255)";
      _ColorTable[274] = "rgb(0,0,0)";
      _ColorTable[275] = "rgb(255, 255, 0)";
      _ColorTable[276] = "rgb(0, 0, 0)";
      _ColorTable[277] = "rgb(229, 229, 229)";
      _ColorTable[278] = "rgb(205, 0, 0)";
      _ColorTable[279] = "rgb(229, 229, 229)";
      _ColorTable[280] = "rgb(255,255,255)";
      this._ColorTable = _ColorTable;
    }
    GetColor(code) {
      if (this._ColorTable == null)
        this._buildColorTable();
      switch (code) {
        case -12:
          return this._ColorTable[279];
        //ErrorBack
        case -11:
          return this._ColorTable[278];
        //ErrorFore
        case -10:
          return this._ColorTable[280];
        //DefaultBrightFore
        case -8:
          return this._ColorTable[272];
        //InfoBackground
        case -7:
          return this._ColorTable[273];
        //InfoText
        case -4:
          return this._ColorTable[274];
        //LocalEchoBackground
        case -3:
          return this._ColorTable[275];
        //LocalEchoText
        case 49:
        case -2:
          return this._ColorTable[276];
        //DefaultBack
        case 39:
        case -1:
          return this._ColorTable[277];
        //DefaultBack
        case 0:
        case 30:
          return this._ColorTable[0];
        case 1:
        case 31:
          return this._ColorTable[1];
        case 2:
        case 32:
          return this._ColorTable[2];
        case 3:
        case 33:
          return this._ColorTable[3];
        case 4:
        case 34:
          return this._ColorTable[4];
        case 5:
        case 35:
          return this._ColorTable[5];
        case 6:
        case 36:
          return this._ColorTable[6];
        case 7:
        case 37:
          return this._ColorTable[7];
        case 40:
          return this._ColorTable[264];
        case 41:
          return this._ColorTable[265];
        case 42:
          return this._ColorTable[266];
        case 43:
          return this._ColorTable[267];
        case 44:
          return this._ColorTable[268];
        case 45:
          return this._ColorTable[269];
        case 46:
          return this._ColorTable[270];
        case 47:
          return this._ColorTable[271];
        case 8:
        case 90:
        case 100:
        case 300:
        //set foreground color to black
        case 400:
          return this._ColorTable[8];
        case 9:
        case 91:
        case 101:
        case 310:
        //set foreground color to red
        case 410:
          return this._ColorTable[9];
        case 10:
        case 92:
        case 102:
        case 320:
        //set foreground color to green
        case 420:
          return this._ColorTable[10];
        case 11:
        case 93:
        case 103:
        case 330:
        //set foreground color to yellow
        case 430:
          return this._ColorTable[11];
        case 12:
        case 94:
        case 104:
        case 340:
        //set foreground color to blue
        case 440:
          return this._ColorTable[12];
        case 13:
        case 95:
        case 105:
        case 350:
        //set foreground color to magenta (purple)
        case 450:
          return this._ColorTable[13];
        case 14:
        case 96:
        case 106:
        case 360:
        //set foreground color to cyan
        case 460:
          return this._ColorTable[14];
        case 15:
        case 97:
        case 107:
        case 370:
        //set foreground color to white
        case 470:
          return this._ColorTable[15];
        case 4e3:
        case 3e3:
          return this._ColorTable[256];
        case 4100:
        case 3100:
          return this._ColorTable[257];
        case 4200:
        case 3200:
          return this._ColorTable[258];
        case 4300:
        case 3300:
          return this._ColorTable[259];
        case 4400:
        case 3400:
          return this._ColorTable[260];
        case 4500:
        case 3500:
          return this._ColorTable[261];
        case 4600:
        case 3600:
          return this._ColorTable[262];
        case 4700:
        case 3700:
          return this._ColorTable[263];
        default:
          if (code <= -16) {
            code += 16;
            code *= -1;
          }
          if (code >= 0 && code < 281)
            return this._ColorTable[code];
          return this._ColorTable[277];
      }
    }
    SetColor(code, color) {
      if (this._ColorTable == null)
        this._buildColorTable();
      if (code < 0 || code >= this._ColorTable.length)
        return;
      color = new RGBColor(color);
      if (!color.ok) return;
      this._ColorTable[code] = color.toRGB();
    }
    _AddLine(line2, raw, fragment, skip, formats, remote) {
      const data = { raw, line: line2, fragment, gagged: skip, formats: this._pruneFormats(formats, line2.length, fragment), remote };
      this.emit("add-line", data);
      this.EndOfLine = !fragment;
    }
    _pruneFormats(formats, textLen, fragment) {
      if (!formats || formats.length < 2) return formats;
      const l2 = formats.length;
      const nF = [];
      for (let f = 0; f < l2; f++) {
        const format = formats[f];
        let end;
        if (f < l2 - 1) {
          const nFormat = formats[f + 1];
          if (format.offset === nFormat.offset && nFormat.formatType === format.formatType)
            continue;
          end = nFormat.offset;
          if (format.formatType === 1 /* Link */ && end - format.offset === 0 && nFormat.formatType === 2 /* LinkEnd */)
            continue;
          if (format.formatType === 7 /* MXPSend */ && end - format.offset === 0 && nFormat.formatType === 8 /* MXPSendEnd */)
            continue;
          if (format.formatType === 3 /* MXPLink */ && end - format.offset === 0 && nFormat.formatType === 4 /* MXPLinkEnd */)
            continue;
        } else if (!fragment && format.offset === textLen && textLen !== 0 && (format.formatType === 0 /* Normal */ && !format.hr || format.formatType === 1 /* Link */ || format.formatType === 7 /* MXPSend */ || format.formatType === 3 /* MXPLink */))
          continue;
        nF.push(format);
      }
      return nF;
    }
    _GetEntity(entity) {
      if (entity === "text")
        return entity;
      if (this._mxpEntities[entity]) {
        this._mxpState.expanded = true;
        return this._mxpEntities[entity].value;
      }
      return entity;
    }
    _ClearMXPToTag(tag, custom, secure) {
      if (custom == null) custom = "";
      let tmp = new MXPStyle();
      tmp.tag = 0 /* None */;
      let ml = this._mxpStyles.length - 1;
      for (; ml >= 0; ml--) {
        if (this._mxpStyles[ml].tag !== tag && this._mxpStyles[ml].custom !== custom) {
          if (!this._mxpStyles[ml].open && !secure) continue;
          tmp = this._mxpStyles.splice(ml, 1)[0];
        } else
          break;
      }
      if (ml >= 0 && this._mxpStyles.length > 0)
        tmp = this._mxpStyles.splice(ml, 1)[0];
      else if (this._mxpStyles.length === 0)
        this.ResetMXP();
      return tmp;
    }
    _ClearMXPOpen() {
      let ml = this._mxpStyles.length;
      while (ml--) {
        if (!this._mxpStyles[ml].open) continue;
        this._mxpStyles.splice(ml, 1);
      }
      if (this._mxpStyles.length === 0)
        this.ResetMXP();
    }
    _getMXPOpenFormatBlocks() {
      if (!this._mxpState.on) return [];
      let m = 0;
      const ml = this._mxpStyles.length;
      const formats = [];
      for (; m < ml; m++) {
        if (this._mxpStyles[m].tag === 22 /* A */ || this._mxpStyles[m].tag === 23 /* SEND */)
          formats.push(Object.assign({}, this._mxpStyles[m].properties));
      }
      return formats;
    }
    _getMXPCloseFormatBlocks() {
      if (!this._mxpState.on) return [];
      let ml = this._mxpStyles.length;
      const formats = [];
      while (ml--) {
        if (this._mxpStyles[ml].tag === 22 /* A */)
          formats.push({ formatType: 4 /* MXPLinkEnd */ });
        else if (this._mxpStyles[ml].tag === 23 /* SEND */)
          formats.push({ formatType: 8 /* MXPSendEnd */ });
      }
      return formats;
    }
    _getMXPBlock(tag, args, remote, oTag, blocks) {
      let tmp;
      let arg;
      let sArg;
      let sArgs;
      let color;
      let x2;
      let xl = args.length;
      let e;
      let sl;
      let s;
      let href = "";
      let hint = "";
      let expire = "";
      let prompt = false;
      tag = tag.toUpperCase();
      if (this.enableDebug) {
        this.emit("debug", "MXP Tag: " + tag);
        this.emit("debug", "MXP Tag Args: " + args);
      }
      switch (tag) {
        case "C":
        case "COLOR":
          tmp = this._CloneCurrentStyle();
          tmp.tag = MXPTag[tag];
          tmp.open = true;
          if (xl > 0) {
            arg = args[0].split("=");
            if (arg.length > 1) {
              color = new RGBColor(stripQuotes(arg[1]));
              if (!color.ok) return null;
              if (arg[0].toUpperCase() === "BACK")
                tmp.back = color.toRGB();
              else
                tmp.fore = color.toRGB();
            } else {
              color = new RGBColor(stripQuotes(arg[0]));
              if (color.ok)
                tmp.fore = color.toRGB();
            }
          }
          if (xl > 1) {
            arg = args[1].split("=");
            if (arg.length > 1) {
              color = new RGBColor(stripQuotes(arg[1]));
              if (!color.ok) return null;
              if (arg[0].toUpperCase() === "FORE")
                tmp.fore = color.toRGB();
              else
                tmp.back = color.toRGB();
            } else {
              color = new RGBColor(stripQuotes(arg[0]));
              if (color.ok)
                tmp.back = color.toRGB();
            }
          }
          tmp.custom = "";
          this._mxpStyles.push(tmp);
          return null;
        case "B":
        case "BOLD":
        case "STRONG":
          tmp = this._CloneCurrentStyle();
          tmp.open = true;
          tmp.tag = MXPTag[tag];
          tmp.style |= 1 /* Bold */;
          tmp.custom = "";
          this._mxpStyles.push(tmp);
          return null;
        case "FONT":
          tmp = this._CloneCurrentStyle();
          tmp.open = true;
          tmp.tag = MXPTag[tag];
          for (x2 = 0; x2 < xl; x2++) {
            arg = args[x2].split("=");
            if (arg.length > 1) {
              switch (arg[0].toUpperCase()) {
                case "SIZE":
                  if (this._isNumber(arg[1]))
                    tmp.fontSize = arg[1] + "pt";
                  else
                    tmp.fontSize = arg[1] || 0;
                  break;
                case "COLOR":
                  sArgs = arg[1].split(",");
                  color = new RGBColor(stripQuotes(sArgs[0]));
                  if (color.ok) tmp.fore = color.toRGB();
                  for (s = 1, sl = sArgs.length; s < sl; s++) {
                    switch (sArgs[s].toLowerCase()) {
                      case "bold":
                        tmp.style |= 1 /* Bold */;
                        break;
                      case "italic":
                        tmp.style |= 4 /* Italic */;
                        break;
                      case "underline":
                        tmp.style |= 8 /* Underline */;
                        break;
                      case "blink":
                        tmp.style |= 16 /* Slow */;
                        break;
                      case "inverse":
                        tmp.style |= 64 /* Inverse */;
                        break;
                      case "hidden":
                        tmp.style |= 128 /* Hidden */;
                        break;
                      case "strikeout":
                        tmp.style |= 256 /* Strikeout */;
                        break;
                      case "overline":
                        tmp.style |= 1024 /* Overline */;
                        break;
                      case "doubleunderline":
                        tmp.style |= 512 /* DoubleUnderline */;
                        break;
                    }
                  }
                  break;
                case "BACK":
                  color = new RGBColor(stripQuotes(arg[1]));
                  if (color.ok) tmp.back = color.toRGB();
                  break;
                case "FACE":
                  tmp.font = stripQuotes(arg[1]) || 0;
                  break;
                default:
                  if (this.enableDebug) this.emit("debug", "Invalid Argument for " + tag + ": " + arg[0]);
                  break;
              }
            } else if (x2 === 0) {
              tmp.font = stripQuotes(args[x2]) || 0;
            } else if (x2 === 1) {
              if (this._isNumber(args[x2]))
                tmp.fontSize = args[x2] + "pt";
              else
                tmp.fontSize = args[x2] || 0;
            } else if (x2 === 2) {
              color = new RGBColor(stripQuotes(args[x2]));
              if (color.ok) tmp.fore = color.toRGB();
            } else if (x2 === 3) {
              color = new RGBColor(stripQuotes(args[x2]));
              if (color.ok) tmp.back = color.toRGB();
            }
          }
          tmp.custom = "";
          this._mxpStyles.push(tmp);
          return null;
        case "H":
        case "HIGH":
          tmp = this._CloneCurrentStyle();
          tmp.open = true;
          tmp.tag = MXPTag[tag];
          tmp.high = true;
          tmp.custom = "";
          this._mxpStyles.push(tmp);
          return null;
        case "I":
        case "ITALIC":
        case "EM":
          tmp = this._CloneCurrentStyle();
          tmp.open = true;
          tmp.tag = MXPTag[tag];
          tmp.style |= 4 /* Italic */;
          tmp.custom = "";
          this._mxpStyles.push(tmp);
          return null;
        case "U":
        case "UNDERLINE":
          tmp = this._CloneCurrentStyle();
          tmp.open = true;
          tmp.tag = MXPTag[tag];
          tmp.style |= 8 /* Underline */;
          tmp.custom = "";
          this._mxpStyles.push(tmp);
          return null;
        case "S":
        case "STRIKEOUT":
          tmp = this._CloneCurrentStyle();
          tmp.open = true;
          tmp.tag = MXPTag[tag];
          tmp.style |= 256 /* Strikeout */;
          tmp.custom = "";
          this._mxpStyles.push(tmp);
          return null;
        case "/B":
        case "/BOLD":
        case "/STRONG":
        case "/H":
        case "/HIGH":
        case "/I":
        case "/ITALIC":
        case "/EM":
        case "/U":
        case "/UNDERLINE":
        case "/S":
        case "/STRIKEOUT":
        case "/C":
        case "/COLOR":
        case "/FONT":
          this._ClearMXPToTag(MXPTag[tag.substring(1)]);
          return null;
      }
      if (this._mxpState.lineType === 1 /* Secure */ || this._mxpState.lineType === 6 /* LockSecure */ || this._mxpState.lineType === 4 /* TempSecure */) {
        switch (tag) {
          case "IMAGE":
            e = {
              formatType: 5 /* Image */,
              name: "",
              url: this.DefaultImgUrl,
              t: "",
              h: "",
              w: "",
              hspace: "",
              vspace: "",
              align: "bottom",
              ismap: false
            };
            for (x2 = 0; x2 < xl; x2++) {
              arg = args[x2].split("=");
              switch (arg[0].toUpperCase()) {
                case "FNAME":
                  e.name = stripQuotes(arg[1]);
                  break;
                case "URL":
                  e.url = stripQuotes(arg[1]);
                  break;
                case "TYPE":
                case "T":
                  if (arg[1].length > 0)
                    e.type = arg[1];
                  break;
                case "HEIGHT":
                case "H":
                  e.h = stripQuotes(arg[1]);
                  break;
                case "WIDTH":
                case "W":
                  e.w = stripQuotes(arg[1]);
                  break;
                case "HSPACE":
                  e.hspace = arg[1];
                  break;
                case "VSPACE":
                  e.vspace = arg[1];
                  break;
                case "ALIGN":
                  e.align = arg[1].toLowerCase();
                  break;
                case "ISMAP":
                  e.ismap = true;
                  break;
                default:
                  if (x2 === 0)
                    e.name = stripQuotes(args[x2]);
                  else if (x2 === 1)
                    e.url = stripQuotes(args[x2]);
                  else if (x2 === 2 && args[x2].length > 0)
                    e.type = args[x2];
                  else if (x2 === 3)
                    e.h = stripQuotes(args[x2]);
                  else if (x2 === 4)
                    e.w = stripQuotes(args[x2]);
                  else if (x2 === 5)
                    e.hspace = args[x2];
                  else if (x2 === 6)
                    e.vspace = args[x2];
                  else if (x2 === 7)
                    e.align = args[x2].toLowerCase();
                  break;
              }
            }
            return { format: e, text: null };
          case "!AT":
          case "!ATTLIST":
            if (args.length === 0) return null;
            e = args[0];
            if (!this._mxpElements[e] || this._mxpEntities[e].remote !== e.remote && !this._mxpEntities[e].open)
              return null;
            this._mxpElements[e].attributes = {};
            this._mxpElements[e].attributeIndexes = [];
            for (x2 = 1; x2 < xl; x2++) {
              sArgs = args[x2].split("=");
              if (sArgs.length > 1)
                this._mxpElements[e].attributes[sArgs[0].toLowerCase()] = sArgs[1];
              else
                this._mxpElements[e].attributes[sArgs[0].toLowerCase()] = "";
              this._mxpElements[e].attributeIndexes.push(sArgs[0].toLowerCase());
            }
            break;
          case "!TAG":
            e = new Tag();
            e.remote = remote;
            for (x2 = 0; x2 < xl; x2++) {
              arg = args[x2].split("=");
              switch (arg[0].toUpperCase()) {
                case "WINDOWNAME":
                  e.window = stripQuotes(arg[1]);
                  break;
                case "FORE":
                  color = new RGBColor(stripQuotes(arg[1]));
                  if (color.ok) e.fore = color.toRGB();
                  break;
                case "BACK":
                  color = new RGBColor(stripQuotes(arg[1]));
                  if (color.ok) e.back = color.toRGB();
                  break;
                case "GAG":
                  e.gag = true;
                  break;
                case "ENABLE":
                  e.enabled = true;
                  break;
                case "DISABLE":
                  e.enabled = false;
                  break;
                default:
                  if (x2 === 0) {
                    tmp = +args[x2];
                    if (!isNaN(tmp)) e.index = tmp;
                  } else if (x2 === 1)
                    e.window = stripQuotes(args[x2]);
                  else if (x2 === 2) {
                    color = new RGBColor(stripQuotes(args[x2]));
                    if (color.ok) e.fore = color.toRGB();
                  } else if (x2 === 3) {
                    color = new RGBColor(stripQuotes(args[x2]));
                    if (color.ok) e.back = color.toRGB();
                  }
                  break;
              }
            }
            if (e.fore.length > 0 && e.back.length > 0)
              e.definition = `<C "${e.fore}" "${e.back}">`;
            else if (e.fore.length > 0)
              e.definition = `<C "${e.fore}">`;
            else if (e.back.length > 0)
              e.definition = `<C BACK="${e.fore}">`;
            if (e.definition.length > 0)
              e.closeDefinition = "</C>";
            if (this._mxpLines[e.index]) {
              if (e.remote || this._mxpLines[e.index].remote === e.remote)
                this._mxpLines[e.index] = e;
            } else
              this._mxpLines[e.index] = e;
            break;
          case "!EL":
          case "!ELEMENT":
            e = new Element(remote);
            for (x2 = 0; x2 < xl; x2++) {
              if (args[x2].toUpperCase().startsWith("ATT=")) {
                arg = stripQuotes(args[x2]).substring(4).split(" ");
                for (s = 0, sl = arg.length; s < sl; s++) {
                  sArgs = stripQuotes(arg[s]).split("=");
                  if (sArgs.length > 1)
                    e.attributes[sArgs[0].toLowerCase()] = stripQuotes(sArgs[1]);
                  else
                    e.attributes[sArgs[0].toLowerCase()] = "";
                  e.attributeIndexes.push(sArgs[0].toLowerCase());
                }
                continue;
              }
              arg = args[x2].split("=");
              switch (arg[0].toUpperCase()) {
                case "TAG":
                  tmp = +arg[1];
                  if (!isNaN(tmp)) e.tag = tmp;
                  break;
                case "FLAG":
                  e.flag = stripQuotes(arg[1]);
                  break;
                case "OPEN":
                  e.open = true;
                  break;
                case "DELETE":
                  if (this._mxpElements[e.name] && (this._mxpEntities[e.name].remote === e.remote || this._mxpEntities[e.name].open))
                    delete this._mxpEntities[e.name];
                  return null;
                case "EMPTY":
                  e.empty = true;
                  break;
                /*
                case "HIDDEN":
                  e.hidden = true;
                  break;
                  */
                case "SECURE":
                  e.open = false;
                  break;
                default:
                  if (x2 === 0)
                    e.name = stripQuotes(args[x2]).toUpperCase();
                  else if (x2 === 1) {
                    e.definition = stripQuotes(args[x2]);
                    e.closeDefinition = this._GetCloseTags(e.definition);
                    if (this.enableDebug) this.emit("debug", "MXP close definition: " + e.closeDefinition);
                  } else if (x2 === 2) {
                    arg = args[x2].substring(4).split(" ");
                    for (s = 0, sl = arg.length; s < sl; s++) {
                      sArgs = arg[s].split("=");
                      if (sArgs.length > 1)
                        e.attributes[sArgs[0]] = sArgs[1];
                      else
                        e.attributes[sArgs[0]] = "";
                      e.attributeIndexes.push(sArgs[0]);
                    }
                  } else if (x2 === 3) {
                    tmp = +args[x2];
                    if (!isNaN(tmp)) e.tag = tmp;
                  } else if (x2 === 4)
                    e.flag = stripQuotes(args[x2]);
                  break;
              }
            }
            if (e.tag > 19 && e.tag < 100) {
              tmp = new Tag(e.tag);
              tmp.element = e.name;
              if (this._mxpLines[tmp.index]) {
                if (e.remote || this._mxpLines[tmp.index].remote === e.remote)
                  this._mxpLines[tmp.index] = tmp;
              } else
                this._mxpLines[tmp.index] = tmp;
            }
            if (this._mxpElements[e.name]) {
              if (this._mxpElements[e.name].remote === e.remote || this._mxpEntities[e.name].open)
                this._mxpElements[e.name] = e;
            } else
              this._mxpElements[e.name] = e;
            break;
          case "!EN":
          case "!ENTITY":
            e = new Entity(remote);
            for (x2 = 0; x2 < xl; x2++) {
              arg = args[x2].split("=");
              switch (arg[0].toUpperCase()) {
                case "DESC":
                  e.description = stripQuotes(arg[1]);
                  break;
                case "PRIVATE":
                  e.publish = false;
                  break;
                case "PUBLISH":
                  e.publish = true;
                  break;
                case "DELETE":
                  if (this._mxpEntities[e.name] && this._mxpEntities[e.name].remote === e.remote)
                    delete this._mxpEntities[e.name];
                  return null;
                case "ADD":
                  if (this._mxpEntities[e.name] && this._mxpEntities[e.name].remote === e.remote) {
                    if (!this._mxpEntities[e.name].value)
                      this._mxpEntities[e.name].value = e.value;
                    else
                      this._mxpEntities[e.name].value += "|" + e.value;
                    return null;
                  }
                  break;
                case "REMOVE":
                  if (this._mxpEntities[e.name] && this._mxpEntities[e.name].remote === e.remote) {
                    if (this._mxpEntities[e.name].value) {
                      sArgs = this._mxpEntities[e.name].value.split("|");
                      sArg = [];
                      for (s = 0, sl = sArgs.length; s < sl; s++) {
                        if (sArgs[s] !== e.value)
                          sArg.push(sArgs[s]);
                      }
                      this._mxpEntities[e.name].value = sArg.join("|");
                    }
                  }
                  return null;
                default:
                  if (x2 === 0)
                    e.name = stripQuotes(args[x2]);
                  else if (x2 === 1)
                    e.value = stripQuotes(args[x2]);
                  else if (x2 === 2)
                    e.description = stripQuotes(args[x2]);
                  break;
              }
            }
            if (this._mxpEntities[e.name]) {
              if (this._mxpEntities[e.name].remote === e.remote)
                this._mxpEntities[e.name] = e;
            } else
              this._mxpEntities[e.name] = e;
            break;
          case "/V":
          case "/VAR":
            tmp = this._ClearMXPToTag(MXPTag[tag.substring(1)]);
            e = new Entity(remote);
            if (this._mxpState.captured.length > 0)
              e.value = this._mxpState.captured.pop().join("");
            else
              e.value = "";
            this._mxpState.capture--;
            if (this.enableDebug) this.emit("debug", "MXP captured: " + e.value);
            args = tmp.obj;
            xl = args.length;
            for (x2 = 0; x2 < xl; x2++) {
              arg = args[x2].split("=");
              switch (arg[0].toUpperCase()) {
                case "DESC":
                  e.description = stripQuotes(arg[1]);
                  break;
                case "PRIVATE":
                  e.publish = false;
                  break;
                case "PUBLISH":
                  e.publish = true;
                  break;
                case "DELETE":
                  if (this._mxpEntities[e.name] && this._mxpEntities[e.name].remote === e.remote)
                    delete this._mxpEntities[e.name];
                  return null;
                case "ADD":
                  if (this._mxpEntities[e.name] && this._mxpEntities[e.name].remote === e.remote) {
                    if (!this._mxpEntities[e.name].value)
                      this._mxpEntities[e.name].value = e.value;
                    else
                      this._mxpEntities[e.name].value += "|" + e.value;
                    return null;
                  }
                  break;
                case "REMOVE":
                  if (this._mxpEntities[e.name] && this._mxpEntities[e.name].remote === e.remote) {
                    if (this._mxpEntities[e.name].value) {
                      sArgs = this._mxpEntities[e.name].value.split("|");
                      sArg = [];
                      for (s = 0, sl = sArgs.length; s < sl; s++) {
                        if (sArgs[s] !== e.value)
                          sArg.push(sArgs[s]);
                      }
                      this._mxpEntities[e.name].value = sArg.join("|");
                    }
                  }
                  return null;
                default:
                  if (x2 === 0)
                    e.name = stripQuotes(args[x2]);
                  else if (x2 === 1)
                    e.description = stripQuotes(args[x2]);
                  break;
              }
            }
            if (this._mxpEntities[e.name]) {
              if (this._mxpEntities[e.name].remote === e.remote)
                this._mxpEntities[e.name] = e;
            } else
              this._mxpEntities[e.name] = e;
            break;
          case "V":
          case "VAR":
            this._mxpState.captured.push([]);
            this._mxpState.capture++;
            tmp = this._CloneCurrentStyle();
            tmp.open = false;
            tmp.tag = MXPTag[tag];
            tmp.obj = args;
            tmp.custom = "";
            this._mxpStyles.push(tmp);
            return null;
          case "GAUGE":
            e = { value: 0, max: 1, caption: "", color: 0 };
            for (x2 = 0; x2 < xl; x2++) {
              arg = args[x2].split("=");
              if (arg.length > 1) {
                switch (arg[0].toUpperCase()) {
                  case "VALUE":
                    tmp = parseFloat(this._GetEntity(arg[1]));
                    if (isNaN(tmp))
                      tmp = this._GetEntity(arg[1]);
                    e.value = tmp;
                    break;
                  case "MAX":
                    tmp = parseFloat(this._GetEntity(arg[1]));
                    if (isNaN(tmp))
                      tmp = this._GetEntity(arg[1]);
                    e.max = tmp;
                    break;
                  case "CAPTION":
                    if (arg[1].length > 0)
                      e.caption = stripQuotes(arg[1]);
                    break;
                  case "COLOR":
                    color = new RGBColor(stripQuotes(arg[1]));
                    if (color.ok) e.color = color.toRGB();
                    break;
                }
              } else if (x2 === 0) {
                tmp = parseFloat(this._GetEntity(args[x2]));
                if (isNaN(tmp))
                  tmp = this._GetEntity(args[x2]);
                e.value = tmp;
              } else if (x2 === 1) {
                tmp = parseFloat(this._GetEntity(args[x2]));
                if (isNaN(tmp))
                  tmp = this._GetEntity(args[x2]);
                e.max = tmp;
              } else if (x2 === 2 && args[x2].length > 0)
                e.caption = stripQuotes(args[x2]);
              else if (x2 === 3 && args[x2].length > 0) {
                color = new RGBColor(stripQuotes(arg[1]));
                if (color.ok) e.color = color.toRGB();
              }
            }
            this._mxpState.expanded = false;
            this.emit("gauge", e);
            break;
          case "STAT":
            e = { value: 0, max: 1, caption: "" };
            for (x2 = 0; x2 < xl; x2++) {
              arg = args[x2].split("=");
              if (arg.length > 1) {
                switch (arg[0].toUpperCase()) {
                  case "VALUE":
                    tmp = parseFloat(this._GetEntity(arg[1]));
                    if (isNaN(tmp))
                      tmp = this._GetEntity(arg[1]);
                    e.value = tmp;
                    break;
                  case "MAX":
                    tmp = parseFloat(this._GetEntity(arg[1]));
                    if (isNaN(tmp))
                      tmp = this._GetEntity(arg[1]);
                    e.max = tmp;
                    break;
                  case "CAPTION":
                    if (arg[1].length > 0)
                      e.caption = stripQuotes(arg[1]);
                    break;
                }
              } else if (x2 === 0) {
                tmp = parseFloat(this._GetEntity(args[x2]));
                if (isNaN(tmp))
                  tmp = this._GetEntity(args[x2]);
                e.value = tmp;
              } else if (x2 === 1) {
                tmp = parseFloat(this._GetEntity(args[x2]));
                if (isNaN(tmp))
                  tmp = this._GetEntity(args[x2]);
                e.max = tmp;
              } else if (x2 === 2 && args[x2].length > 0)
                e.caption = stripQuotes(args[x2]);
            }
            this._mxpState.expanded = false;
            this.emit("stat", e);
            break;
          case "MUSIC":
            e = { off: false, file: "", url: "", volume: 100, repeat: 1, priority: 50, type: "", continue: true };
            for (x2 = 0; x2 < xl; x2++) {
              arg = args[x2].split("=");
              if (arg.length > 1) {
                switch (arg[0].toUpperCase()) {
                  case "FNAME":
                    e.file = stripQuotes(arg[1]);
                    if (e.file.toLowerCase() === "off") {
                      e.off = true;
                      e.file = "";
                    }
                    break;
                  case "V":
                    tmp = +arg[1];
                    if (isNaN(tmp))
                      tmp = 100;
                    e.volume = tmp;
                    break;
                  case "L":
                    tmp = +arg[1];
                    if (isNaN(tmp))
                      tmp = 1;
                    e.repeat = tmp;
                    break;
                  case "C":
                    e.continue = arg[1] !== "0";
                    break;
                  case "T":
                    if (arg[1].length > 0)
                      e.type = arg[1];
                    break;
                  case "U":
                    e.url = stripQuotes(arg[1]);
                    if (!e.url.endsWith("/") && e.url.length > 0)
                      e.url += "/";
                    break;
                }
              } else if (x2 === 0) {
                e.file = stripQuotes(args[x2]);
                if (e.file.toLowerCase() === "off") {
                  e.off = true;
                  e.file = "";
                }
              } else if (x2 === 1) {
                tmp = +args[x2];
                if (isNaN(tmp))
                  tmp = 100;
                e.volume = tmp;
              } else if (x2 === 2) {
                tmp = +args[x2];
                if (isNaN(tmp))
                  tmp = 1;
                e.repeat = tmp;
              } else if (x2 === 3)
                e.continue = args[x2] !== "0";
              else if (x2 === 4) {
                if (args[x2].length > 0)
                  e.type = args[x2];
              } else if (x2 === 5) {
                e.url = stripQuotes(args[x2]);
                if (!e.url.endsWith("/") && e.url.length > 0)
                  e.url += "/";
              }
            }
            this.emit("music", e);
            break;
          case "SOUND":
            e = { off: false, file: "", url: "", volume: 100, repeat: 1, priority: 50, type: "", continue: true };
            for (x2 = 0; x2 < xl; x2++) {
              arg = args[x2].split("=");
              if (arg.length > 1) {
                switch (arg[0].toUpperCase()) {
                  case "FNAME":
                    e.file = stripQuotes(arg[1]);
                    if (e.file.toLowerCase() === "off") {
                      e.off = true;
                      e.file = "";
                    }
                    break;
                  case "V":
                    tmp = +arg[1];
                    if (isNaN(tmp))
                      tmp = 100;
                    e.volume = tmp;
                    break;
                  case "L":
                    tmp = +arg[1];
                    if (isNaN(tmp))
                      tmp = 1;
                    e.repeat = tmp;
                    break;
                  case "P":
                    tmp = +arg[1];
                    if (isNaN(tmp))
                      tmp = 1;
                    e.priority = tmp;
                    break;
                  case "T":
                    if (arg[1].length > 0)
                      e.type = arg[1];
                    break;
                  case "U":
                    e.url = stripQuotes(arg[1]);
                    if (!e.url.endsWith("/") && e.url.length > 0)
                      e.url += "/";
                    break;
                }
              } else if (x2 === 0) {
                e.file = stripQuotes(args[x2]);
                if (e.file.toLowerCase() === "off") {
                  e.off = true;
                  e.file = "";
                }
              } else if (x2 === 1) {
                tmp = +args[x2];
                if (isNaN(tmp))
                  tmp = 100;
                e.volume = tmp;
              } else if (x2 === 2) {
                tmp = +args[x2];
                if (isNaN(tmp))
                  tmp = 1;
                e.repeat = tmp;
              } else if (x2 === 3) {
                tmp = +args[x2];
                if (isNaN(tmp))
                  tmp = 1;
                e.priority = tmp;
              } else if (x2 === 4) {
                if (args[x2].length > 0)
                  e.type = args[x2];
              } else if (x2 === 5) {
                e.url = stripQuotes(args[x2]);
                if (!e.url.endsWith("/") && e.url.length > 0)
                  e.url += "/";
              }
            }
            this.emit("sound", e);
            break;
          case "EXPIRE":
            this.emit("expire-links", args);
            this._cleanMXPExpired(blocks, args?.[0] || "");
            break;
          case "VERSION":
            if (xl > 0)
              this.StyleVersion = args[0];
            else
              this.emit("MXP-tag-reply", tag, []);
            break;
          case "USER":
          case "PASSWORD":
            this.emit("MXP-tag-reply", tag, args);
            break;
          case "SUPPORT":
            sArgs = [];
            if (xl > 0) {
              for (x2 = 0; x2 < xl; x2++) {
                arg = stripQuotes(args[x2]);
                if (arg.indexOf(".") === -1) {
                  arg = arg.toUpperCase();
                  switch (arg) {
                    //TODO re-enable once font size/face  are supported
                    //case 'FONT':
                    case "IMAGE":
                    case "HR":
                    case "A":
                    case "SEND":
                    case "B":
                    case "I":
                    case "COLOR":
                    case "C":
                    case "EM":
                    case "ITALIC":
                    case "STRONG":
                    case "BOLD":
                    case "UNDERLINE":
                    case "U":
                    case "S":
                    case "STRIKEOUT":
                    case "STRIKE":
                    case "H":
                    case "HIGH":
                    case "EXPIRE":
                    case "VERSION":
                    case "SUPPORT":
                    case "NOBR":
                    case "P":
                    case "BR":
                    case "SBR":
                    case "SOUND":
                    case "MUSIC":
                    case "VAR":
                    case "USER":
                    case "PASSWORD":
                    case "H1":
                    case "H2":
                    case "H3":
                    case "H4":
                    case "H5":
                    case "H6":
                    case "RESET":
                    case "GAUGE":
                    case "STAT":
                      sArgs.push("+" + name);
                      break;
                    default:
                      sArgs.push("-" + name);
                      break;
                  }
                } else {
                  arg = args[x2].split(".");
                  arg[0] = arg[0].toUpperCase();
                  switch (arg[0]) {
                    case "IMAGE":
                      if (arg[1] !== "*")
                        sArgs.push("+" + arg[0] + "." + arg[1]);
                      else {
                        sArgs.push("+image.fname");
                        sArgs.push("+image.url");
                        sArgs.push("+image.t");
                        sArgs.push("+image.h");
                        sArgs.push("+image.w");
                        sArgs.push("+image.hspace");
                        sArgs.push("+image.vspace");
                        sArgs.push("+image.align");
                        sArgs.push("+image.ismap");
                      }
                      break;
                    case "SOUND":
                      if (arg[1] !== "*")
                        sArgs.push("+" + arg[0] + "." + arg[1]);
                      else {
                        sArgs.push("+sound.v");
                        sArgs.push("+sound.l");
                        sArgs.push("+sound.p");
                        sArgs.push("+sound.t");
                        sArgs.push("+sound.u");
                      }
                      break;
                    case "MUSIC":
                      if (arg[1] !== "*")
                        sArgs.push("+" + arg[0] + "." + arg[1]);
                      else {
                        sArgs.push("+music.v");
                        sArgs.push("+music.l");
                        sArgs.push("+music.c");
                        sArgs.push("+music.t");
                        sArgs.push("+music.u");
                      }
                      break;
                    case "A":
                      if (arg[1] !== "*")
                        sArgs.push("+" + arg[0] + "." + arg[1]);
                      else {
                        sArgs.push("+a.href");
                        sArgs.push("+a.hint");
                        sArgs.push("+a.expire");
                      }
                      break;
                    case "SEND":
                      if (arg[1] !== "*")
                        sArgs.push("+" + arg[0] + "." + arg[1]);
                      else {
                        sArgs.push("+send.href");
                        sArgs.push("+send.hint");
                        sArgs.push("+send.prompt");
                        sArgs.push("+send.expire");
                      }
                      break;
                    case "COLOR":
                      if (arg[1] !== "*")
                        sArgs.push("+" + arg[0] + "." + arg[1]);
                      else {
                        sArgs.push("+color.fore");
                        sArgs.push("+color.back");
                      }
                      break;
                    case "C":
                      if (arg[1] !== "*")
                        sArgs.push("+" + arg[0] + "." + arg[1]);
                      else {
                        sArgs.push("+c.fore");
                        sArgs.push("+c.back");
                      }
                      break;
                    case "FONT":
                      if (arg[1] !== "*")
                        sArgs.push("+" + arg[0] + "." + arg[1]);
                      else {
                        sArgs.push("-font.face");
                        sArgs.push("-font.size");
                        sArgs.push("+font.color");
                        sArgs.push("+font.back");
                      }
                      break;
                    case "EXPIRE":
                      if (arg[1] !== "*")
                        sArgs.push("+" + arg[0] + "." + arg[1]);
                      else
                        sArgs.push("+expire.Name");
                      break;
                    case "GAUGE":
                      if (arg[1] !== "*")
                        sArgs.push("+" + arg[0] + "." + arg[1]);
                      else {
                        sArgs.push("+gauge.max");
                        sArgs.push("+gauge.caption");
                        sArgs.push("+gauge.color");
                      }
                      break;
                    case "STAT":
                      if (arg[1] !== "*")
                        sArgs.push("+" + arg[0] + "." + arg[1]);
                      else {
                        sArgs.push("+stat.max");
                        sArgs.push("+stat.caption");
                      }
                      break;
                    default:
                      if (arg[1] !== "*")
                        sArgs.push("-" + arg[0] + "." + arg[1]);
                      else
                        sArgs.push("-" + arg[0]);
                      break;
                  }
                }
              }
            } else
              sArgs = ["+A", "+SEND", "+B", "+I", "+COLOR", "+C", "+EM", "+ITALIC", "+STRONG", "+BOLD", "+UNDERLINE", "+U", "+S", "+STRIKEOUT", "+H", "+HIGH", "-FONT", "+EXPIRE", "+VERSION", "+SUPPORT", "+NOBR", "+P", "+BR", "+SBR", "+VAR", "+SOUND", "+MUSIC", "+USER", "+PASSWORD", "+RESET", "+STRIKE", "+H1", "+H2", "+H3", "+H4", "+H5", "+H6", "+IMAGE", "+STAT", "+GAUGE"];
            this.emit("MXP-tag-reply", tag, sArgs);
            break;
          case "A":
            tmp = this._CloneCurrentStyle();
            tmp.open = false;
            tmp.tag = MXPTag[tag];
            for (x2 = 0; x2 < xl; x2++) {
              arg = args[x2].split("=");
              if (arg.length > 1) {
                switch (arg[0].toUpperCase()) {
                  case "HREF":
                    href = stripQuotes(arg[1]);
                    break;
                  case "HINT":
                    hint = stripQuotes(arg[1]);
                    break;
                  case "EXPIRE":
                    expire = stripQuotes(arg[1]);
                    break;
                  default:
                    if (this.enableDebug) this.emit("debug", "Invalid Argument for " + tag + ": " + arg[0]);
                    break;
                }
              } else if (x2 === 0)
                href = stripQuotes(args[x2]);
              else if (x2 === 1)
                hint = stripQuotes(args[x2]);
              else if (x2 === 2)
                expire = stripQuotes(args[x2]);
            }
            tmp.custom = "";
            tmp.properties = {
              formatType: 3 /* MXPLink */,
              href,
              hint,
              expire
            };
            this._mxpStyles.push(tmp);
            if (hint.length === 0)
              hint = href;
            return {
              format: {
                formatType: 3 /* MXPLink */,
                href,
                hint,
                expire
              },
              text: null
            };
          case "SEND":
            tmp = this._CloneCurrentStyle();
            tmp.open = false;
            tmp.tag = MXPTag[tag];
            for (x2 = 0; x2 < xl; x2++) {
              arg = args[x2].split("=");
              if (arg[0] === "PROMPT")
                prompt = true;
              else if (arg.length > 1) {
                switch (arg[0].toUpperCase()) {
                  case "HREF":
                    href = stripQuotes(arg[1]);
                    break;
                  case "HINT":
                    hint = stripQuotes(arg[1]);
                    break;
                  case "EXPIRE":
                    expire = stripQuotes(arg[1]);
                    break;
                  case "PROMPT":
                    prompt = true;
                    break;
                  default:
                    if (this.enableDebug) this.emit("debug", "Invalid Argument for " + tag + ": " + arg[0]);
                    break;
                }
              } else if (x2 === 0)
                href = stripQuotes(args[x2]);
              else if (x2 === 1)
                hint = stripQuotes(args[x2]);
              else if (x2 === 2)
                prompt = true;
              else if (x2 === 3)
                expire = stripQuotes(args[x2]);
            }
            tmp.custom = "";
            this._mxpStyles.push(tmp);
            if (href.length === 0)
              href = "&text;";
            if (hint.length === 0)
              hint = href;
            const cmds = href.split("|");
            let tt;
            if (cmds.length > 1) {
              const caps = hint.split("|");
              if (caps.length === cmds.length + 1) {
                hint = caps[0];
                caps.shift();
                tt = "['" + caps.join("','") + "']";
              }
              href = "['" + cmds.join("','") + "']";
            } else
              href = "'" + href + "'";
            tmp.properties = {
              formatType: 7 /* MXPSend */,
              href,
              hint,
              expire,
              prompt,
              tt: tt || ""
            };
            return {
              format: {
                formatType: 7 /* MXPSend */,
                href,
                hint,
                expire,
                prompt,
                tt: tt || ""
              },
              text: null
            };
          case "H1":
          case "H2":
          case "H3":
          case "H4":
          case "H5":
          case "H6":
            tmp = this._CloneCurrentStyle();
            tmp.open = true;
            tmp.tag = MXPTag[tag];
            tmp.style |= 1 /* Bold */;
            tmp.custom = "";
            this._mxpStyles.push(tmp);
            return null;
          case "/A":
            this._ClearMXPToTag(MXPTag[tag.substring(1)]);
            return {
              format: {
                formatType: 4 /* MXPLinkEnd */
              },
              text: null
            };
          case "/SEND":
            this._ClearMXPToTag(MXPTag[tag.substring(1)]);
            return {
              format: {
                formatType: 8 /* MXPSendEnd */
              },
              text: null
            };
          case "/H1":
          case "/H2":
          case "/H3":
          case "/H4":
          case "/H5":
          case "/H6":
            this._ClearMXPToTag(MXPTag[tag.substring(1)]);
            return null;
          case "NOBR":
            this._mxpState.noBreak = true;
            return null;
          case "/P":
            this._ClearMXPToTag(MXPTag[tag.substring(1)]);
            this._mxpState.paragraph = false;
            return null;
          case "P":
            tmp = this._CloneCurrentStyle();
            tmp.open = false;
            tmp.tag = MXPTag[tag];
            tmp.custom = "";
            this._mxpStyles.push(tmp);
            this._mxpState.paragraph = true;
            return null;
          case "SBR":
            return {
              format: null,
              text: " \u200B"
            };
          case "RESET":
            this.ResetMXP();
            return null;
          case "HR":
            const mxp = this._GetCurrentStyle();
            const colors = this._getColors(mxp);
            return {
              format: {
                formatType: 0 /* Normal */,
                offset: 0,
                color: colors.fore,
                background: colors.back,
                size: mxp.fontSize,
                font: mxp.font,
                style: mxp.style | this._CurrentAttributes & ~1 /* Bold */,
                hr: true
              },
              text: null
            };
        }
      }
      if (this._mxpElements[tag]) {
        e = this._mxpElements[tag];
        if (!e.open && this._mxpState.lineType !== 1 /* Secure */ && this._mxpState.lineType !== 6 /* LockSecure */ && this._mxpState.lineType !== 4 /* TempSecure */)
          return null;
        tmp = this._CloneCurrentStyle();
        tmp.open = e.open;
        tmp.tag = 38 /* Custom */;
        tmp.custom = e.name;
        arg = e.definition;
        sArgs = {};
        for (s = 0, sl = e.attributeIndexes.length; s < sl; s++)
          sArgs[e.attributeIndexes[s]] = e.attributes[e.attributeIndexes[s]];
        for (x2 = 0; x2 < xl; x2++) {
          sArg = args[x2].split("=");
          sArg[0] = sArg[0].toLowerCase();
          if (e.attributes[sArg[0]])
            sArgs[sArg[0]] = sArg[1];
          else if (x2 < e.attributeIndexes.length)
            sArgs[e.attributeIndexes[x2]] = sArg[0];
        }
        for (sArg in sArgs) {
          if (!sArgs.hasOwnProperty(sArg)) continue;
          arg = arg.replace("&" + sArg + ";", sArgs[sArg]);
        }
        if (!e.empty) {
          this._mxpState.captured.push([]);
          this._mxpState.capture++;
        }
        if (e.tag > 19 && e.tag < 100 && this._mxpLines[e.tag].enabled && this._mxpLines[e.tag].definition.length > 0) {
          arg = this._mxpLines[e.tag].definition + arg;
          tmp.gagged = this._mxpLines[e.tag].gag;
        }
        this._mxpState.gagged = tmp.gagged;
        this._mxpState.expanded = true;
        return { format: null, text: arg };
      } else if (tag.startsWith("/") && this._mxpElements[tag.substring(1)] && !this._mxpElements[tag.substring(1)].empty) {
        tag = tag.substring(1);
        e = this._mxpElements[tag];
        if (!e.open && this._mxpState.lineType !== 1 /* Secure */ && this._mxpState.lineType !== 6 /* LockSecure */ && this._mxpState.lineType !== 4 /* TempSecure */)
          return null;
        if (!e.empty && this._mxpState.capture > 0) {
          if (this._mxpState.captured.length > 0)
            sArg = this._mxpState.captured.pop().join("");
          this._mxpState.capture--;
        }
        arg = e.closeDefinition;
        if (e.flag.length > 0) {
          if (e.flag.length > 4 && e.flag.toLowerCase().startsWith("set "))
            this.emit("set-variable", e.flag.substring(4), sArg);
          this.emit("MXP-flag", e.flag, sArg);
        }
        if (e.tag > 19 && e.tag < 100 && this._mxpLines[e.tag].enabled && this._mxpLines[e.tag].closeDefinition.length > 0)
          arg += this._mxpLines[e.tag].closeDefinition;
        this._mxpState.gagged = !e.gagged;
        if (e.empty)
          return null;
        this._mxpState.expanded = true;
        return { format: null, text: arg };
      }
      if (this.showInvalidMXPTags) {
        switch (tag) {
          case "IMAGE":
          case "!AT":
          case "!ATTLIST":
          case "!TAG":
          case "!EL":
          case "!ELEMENT":
          case "!EN":
          case "!ENTITY":
          case "/V":
          case "/VAR":
          case "V":
          case "VAR":
          case "GAUGE":
          case "STAT":
          case "MUSIC":
          case "SOUND":
          case "EXPIRE":
          case "VERSION":
          case "USER":
          case "PASSWORD":
          case "SUPPORT":
          case "A":
          case "SEND":
          case "H1":
          case "H2":
          case "H3":
          case "H4":
          case "H5":
          case "H6":
          case "/A":
          case "/SEND":
          case "/H1":
          case "/H2":
          case "/H3":
          case "/H4":
          case "/H5":
          case "/H6":
          case "NOBR":
          case "/P":
          case "P":
          case "SBR":
          case "RESET":
          case "HR":
            return null;
        }
        return { format: null, text: "<" + oTag + ">" };
      }
      return null;
    }
    _cleanMXPExpired(blocks, args) {
      if (!blocks || blocks.length === 0 || args === null)
        return;
      const bl = blocks.length;
      for (let b = 0; b < bl; b++) {
        let format = blocks[b];
        if (format.formatType !== 7 /* MXPSend */ && format.formatType !== 3 /* MXPLink */)
          continue;
        if (args.length === 0 || format.expire === args) {
          let eType, n = 0, f = 0;
          let type = format.formatType;
          if (format.formatType === 3 /* MXPLink */)
            eType = 4 /* MXPLinkEnd */;
          else
            eType = 8 /* MXPSendEnd */;
          format.formatType = 9 /* MXPExpired */;
          for (; f < bl; f++) {
            if (blocks[f].formatType === eType) {
              if (n === 0) {
                blocks[f].formatType = 10 /* MXPSkip */;
                break;
              } else
                n--;
            } else if (blocks[f] === type)
              n++;
          }
        }
      }
    }
    _GetCloseTags(tag) {
      if (typeof tag === "undefined" || tag.length === 0)
        return "";
      let idx = 0;
      const tl = tag.length;
      const ts = [];
      let str = [];
      let c;
      let state = 0;
      for (; idx < tl; idx++) {
        c = tag.charAt(idx);
        switch (state) {
          case 1:
            if (c === " ") {
              ts.push(str.join(""));
              str = [];
              state = 2;
            } else if (c === ">") {
              ts.push(str.join(""));
              str = [];
              state = 0;
            } else
              str.push(c);
            break;
          case 2:
            if (c === ">")
              state = 0;
            break;
          default:
            if (c === "<")
              state = 1;
            break;
        }
      }
      if (state === 1)
        ts.push(str.join(""));
      if (ts.length === 0)
        return "";
      return "</" + ts.reverse().join("></") + ">";
    }
    _CloneCurrentStyle() {
      let tmp;
      if (this._mxpStyles.length === 0)
        this._mxpStyles.push(new MXPStyle(0 /* None */, "", "", false));
      tmp = this._mxpStyles[this._mxpStyles.length - 1];
      if (this._mxpLines[this._mxpState.lineType] && this._mxpLines[this._mxpState.lineType].enabled)
        tmp.gagged = this._mxpLines[this._mxpState.lineType].gag;
      return Object.assign({}, tmp);
    }
    _GetCurrentStyle() {
      let tmp;
      if (this._mxpStyles.length === 0)
        this._mxpStyles.push(new MXPStyle(0 /* None */, "", "", false));
      tmp = this._mxpStyles[this._mxpStyles.length - 1];
      if (this._mxpLines[this._mxpState.lineType] && this._mxpLines[this._mxpState.lineType].enabled)
        tmp.gagged = this._mxpLines[this._mxpState.lineType].gag;
      return tmp;
    }
    DecreaseColor(clr, p) {
      const color = new RGBColor(clr);
      if (!color.ok) return clr;
      color.b -= Math.ceil(color.b * p);
      if (color.b < 0)
        color.b = 0;
      color.g -= Math.ceil(color.g * p);
      if (color.g < 0)
        color.g = 0;
      color.r -= Math.ceil(color.r * p);
      if (color.r < 0)
        color.r = 0;
      return color.toRGB();
    }
    IncreaseColor(clr, p) {
      const color = new RGBColor(clr);
      if (!color.ok) return clr;
      color.b += Math.ceil(color.b * p);
      if (color.b > 255)
        color.b = 255;
      color.g += Math.ceil(color.g * p);
      if (color.g > 255)
        color.g = 255;
      color.r += Math.ceil(color.r * p);
      if (color.r > 255)
        color.r = 255;
      return color.toRGB();
    }
    _MXPCapture(str) {
      if (this._mxpState.capture < 1) return;
      const il = this._mxpState.captured.length;
      for (let i2 = 0; i2 < il; i2++)
        this._mxpState.captured[i2].push(str);
    }
    _MXPDeCapture(cnt) {
      if (this._mxpState.capture < 1) return;
      const il = this._mxpState.captured.length;
      for (let i2 = 0; i2 < il; i2++) {
        for (let p = 0; p < cnt; p++)
          this._mxpState.captured[i2].pop();
      }
    }
    _isNumber(str) {
      return /^\d+$/.test(str);
    }
    /**
     * CurrentAnsiCode - return an ansi formatted code based on current ansi state
     *
     * @returns {String}
     */
    CurrentAnsiCode() {
      let ansi = "\x1B[";
      if (typeof this._CurrentForeColor === "string")
        ansi += "38;2;" + this._CurrentForeColor;
      else if (this._CurrentForeColor <= -16)
        ansi += "38;5;" + (this._CurrentForeColor * -1 - 16) + ";";
      else
        ansi += this._CurrentForeColor + ";";
      if (typeof this._CurrentBackColor === "string")
        ansi += "48;2;" + this._CurrentBackColor;
      else if (this._CurrentBackColor <= -16)
        ansi += "38;5;" + (this._CurrentBackColor * -1 - 16) + ";";
      else
        ansi += this._CurrentBackColor + ";";
      if (this._CurrentAttributes > 0) {
        if ((this._CurrentAttributes & 64 /* Inverse */) === 64 /* Inverse */)
          ansi += "7;";
        if ((this._CurrentAttributes & 1 /* Bold */) === 1 /* Bold */)
          ansi += "1;";
        if ((this._CurrentAttributes & 4 /* Italic */) === 4 /* Italic */)
          ansi += "3;";
        if ((this._CurrentAttributes & 8 /* Underline */) === 8 /* Underline */)
          ansi += "4;";
        if ((this._CurrentAttributes & 16 /* Slow */) === 16 /* Slow */)
          ansi += "5;";
        if ((this._CurrentAttributes & 32 /* Rapid */) === 32 /* Rapid */)
          ansi += "6;";
        if ((this._CurrentAttributes & 256 /* Strikeout */) === 256 /* Strikeout */)
          ansi += "9;";
        if ((this._CurrentAttributes & 2 /* Faint */) === 2 /* Faint */)
          ansi += "2;";
        if ((this._CurrentAttributes & 512 /* DoubleUnderline */) === 512 /* DoubleUnderline */)
          ansi += "21;";
        if ((this._CurrentAttributes & 1024 /* Overline */) === 1024 /* Overline */)
          ansi += "53;";
      }
      return ansi + "m";
    }
    get parseQueueLength() {
      return this._parsing.length;
    }
    get parseQueueEndOfLine() {
      if (this._parsing.length)
        return this._parsing[this._parsing.length - 1][0].endsWith("\n");
      return false;
    }
    parse(text, remote, force, prependSplit) {
      if (text == null || text.length === 0)
        return text;
      if (remote == null) remote = false;
      if (this._parsing.length > 0 && !force) {
        this._parsing.push([text, remote, prependSplit]);
        return;
      }
      let _TermTitle = "";
      let _TermTitleType = null;
      let _AnsiParams = null;
      let stringBuilder = [];
      let formatBuilder = [];
      let rawBuilder = [];
      let state = 0 /* None */;
      let pState = 0 /* None */;
      let lineLength = 0;
      let iTmp;
      let mOffset = 0;
      let _MXPTag;
      let _MXPOTag;
      let _MXPEntity;
      let _MXPComment;
      let _MXPArgs;
      let skip = false;
      this.busy = true;
      this._parsing.unshift([text, remote, prependSplit]);
      let format;
      if (this._SplitBuffer.length > 0) {
        if (prependSplit)
          text = text + this._SplitBuffer;
        else
          text = this._SplitBuffer + text;
        this._SplitBuffer = "";
      }
      if (!this.EndOfLine && (this.textLength > 0 || this.rawLength > 0)) {
        let lines = this.display.lines;
        if (lines.length > 0) {
          iTmp = this.display.lines[lines.length - 1].text;
          _MXPComment = this.display.lines[lines.length - 1].raw;
          formatBuilder.push.apply(formatBuilder, this.display.lines[lines.length - 1].formats);
          this.display.removeLine(lines.length - 1, true);
          format = formatBuilder[formatBuilder.length - 1];
          if (format.formatType === 1 /* Link */) {
            formatBuilder.pop();
            format = formatBuilder[formatBuilder.length - 1];
          }
          format.width = 0;
          format.height = 0;
          format.marginWidth = 0;
          format.marginHeight = 0;
          lineLength = format.offset;
          if (format.offset !== 0) {
            stringBuilder.push(iTmp.substring(0, format.offset));
            iTmp = iTmp.substring(format.offset);
            if (this._mxpState.locked || this._mxpState.on)
              mOffset = iTmp.length;
            text = iTmp + text;
          } else {
            if (this._mxpState.locked || this._mxpState.on)
              mOffset = iTmp.length;
            text = iTmp + text;
          }
          if (_MXPComment.endsWith(iTmp))
            rawBuilder.push(_MXPComment.substr(0, _MXPComment.length - iTmp.length));
          else
            rawBuilder.push(_MXPComment);
        } else
          formatBuilder.push(format = this._getFormatBlock(lineLength));
        lines = null;
      } else
        formatBuilder.push(format = this._getFormatBlock(lineLength));
      let idx = 0;
      let tl = text.length;
      let c;
      let i2;
      const e = this.emulateControlCodes;
      const d2 = this.displayControlCodes;
      const f = this.emulateTerminal;
      const u = this.enableURLDetection;
      const s = this.enableMSP;
      const tabWidth = this.tabWidth;
      let lnk = 0;
      let fLnk = 0;
      let lnkOffset = 0;
      let lLnk = 0;
      let lNest = null;
      let p;
      const pl = this._protocols.length;
      try {
        for (idx = 0; idx < tl; idx++) {
          c = text.charAt(idx);
          i2 = text.charCodeAt(idx);
          if (idx >= mOffset)
            rawBuilder.push(c);
          this.rawLength++;
          switch (state) {
            case 2 /* AnsiParams */:
              if (c === "C" || //Move cursor # spaces
              c === "K" || //Clear screen Left/Right
              c === "s" || //save cursor position: non-standard
              c === "u" || //save cursor position: non-standard
              c === "l" || //XTerm ?#l Private Mode Reset/Reset Mode #l
              c === "h" || //XTerm ?#h Private Mode/Set Mode #h
              c === "A" || //Move cursor up N lines
              c === "B" || //Move cursor down N lines
              c === "D" || //Move cursor left N spaces
              c === "E" || //Moves cursor to beginning of the line n (default 1) lines down (next line).
              c === "F" || //Moves cursor to beginning of the line n (default 1) lines up (previous line).
              c === "f" || //Moves the cursor to row n, column m. Both default to 1 if omitted. Same as CUP
              c === "G" || //Moves the cursor to column n.
              c === "H" || //Moves the cursor to row n, column m. The values are 1-based, and default to 1 (top left corner) if omitted. A sequence such as CSI ;5H is a synonym for CSI 1;5H as well as CSI 17;H is the same as CSI 17H and CSI 17;1H
              c === "n" || //Reports the cursor position to the application as (as though typed at the keyboard) ESC[n;mR, where n is the row and m is the column. (May not work on MS-DOS.)
              c === "S" || //Scroll whole page up by n (default 1) lines. New lines are added at the bottom. (not ANSI.SYS)
              c === "T" || //Scroll whole page down by n (default 1) lines. New lines are added at the top. (not ANSI.SYS)
              c === "r") {
                this._ClearMXPOpen();
                this._SplitBuffer = "";
                _AnsiParams = null;
                state = 0 /* None */;
              } else if (c === "z") {
                _MXPTag = _AnsiParams.split(";");
                _AnsiParams = 0;
                for (let mt = _MXPTag.length - 1; mt >= 0; mt--) {
                  if (_MXPTag[mt].length > 0) {
                    _AnsiParams = _MXPTag[0];
                    break;
                  }
                }
                iTmp = +_AnsiParams;
                if (isNaN(iTmp)) iTmp = 0;
                this._mxpState.on = true;
                this._mxpState.noBreak = false;
                this._mxpState.paragraph = false;
                if (this._mxpState.lineType === 0 /* Open */)
                  this._ClearMXPOpen();
                switch (iTmp) {
                  case 2:
                    this._mxpState.on = false;
                    this._mxpState.locked = false;
                    this._mxpState.lineType = 2 /* Locked */;
                    this._ClearMXPOpen();
                    break;
                  case 3:
                    this.ResetMXP();
                    break;
                  case 4:
                    this._mxpState.lineType = 4 /* TempSecure */;
                    if (idx + 1 >= tl) {
                      this._SplitBuffer += c;
                      break;
                    }
                    const ct = text.charAt(idx + 1);
                    if (ct !== "<") {
                      this._mxpState.lineType = 0 /* Open */;
                      this._mxpState.on = false;
                    }
                    this._mxpState.locked = false;
                    this._ClearMXPOpen();
                    break;
                  case 5:
                    this._iMXPDefaultMode = 0 /* Open */;
                    this._mxpState.locked = true;
                    this._mxpState.lineType = 5 /* LockOpen */;
                    this._ClearMXPOpen();
                    break;
                  case 6:
                    this._iMXPDefaultMode = 1 /* Secure */;
                    this._mxpState.lineType = 6 /* LockSecure */;
                    this._mxpState.locked = true;
                    this._ClearMXPOpen();
                    break;
                  case 7:
                    this._iMXPDefaultMode = 2 /* Locked */;
                    this._mxpState.lineType = 7 /* LockLocked */;
                    this._mxpState.locked = true;
                    this._ClearMXPOpen();
                    break;
                  default:
                    if (iTmp < 0 || iTmp > 99)
                      this._ClearMXPOpen();
                    else {
                      this._mxpState.lineType = iTmp;
                      this._mxpState.locked = false;
                      if (this._mxpLines[this._mxpState.lineType] && this._mxpLines[this._mxpState.lineType].enabled) {
                        iTmp = "";
                        if (this._mxpLines[this._mxpState.lineType].element.length > 0)
                          iTmp += "<" + this._mxpLines[this._mxpState.lineType].element + ">";
                        if (this._mxpLines[this._mxpState.lineType].definition.length > 0)
                          iTmp += this._mxpLines[this._mxpState.lineType].definition;
                        if (iTmp.length > 0) {
                          text = text.splice(idx + 1, iTmp);
                          tl = text.length;
                        }
                      }
                    }
                    break;
                }
                this._SplitBuffer = "";
                _AnsiParams = null;
                state = 0 /* None */;
              } else if (c === "J") {
                this._ClearMXPOpen();
                if (_AnsiParams.length > 0) {
                  if (+_AnsiParams === 2) {
                    lineLength = 0;
                    iTmp = this.window.height;
                    formatBuilder.push(...this._getMXPCloseFormatBlocks());
                    this._AddLine(stringBuilder.join(""), rawBuilder.join(""), false, false, formatBuilder, remote);
                    stringBuilder = [];
                    rawBuilder = [];
                    formatBuilder = [...this._getMXPOpenFormatBlocks(), format = this._getFormatBlock(lineLength), ...this._getMXPCloseFormatBlocks()];
                    for (let j2 = 0; j2 < iTmp; j2++) {
                      this._AddLine("", "\n", false, false, formatBuilder, remote);
                      this._MXPCapture("\n");
                    }
                    this.textLength += iTmp;
                    this._mxpState.noBreak = false;
                  }
                }
                formatBuilder = [...this._getMXPOpenFormatBlocks(), format = this._getFormatBlock(lineLength)];
                this._SplitBuffer = "";
                _AnsiParams = null;
                state = 0 /* None */;
              } else if (c === "m") {
                this._ProcessAnsiColorParams(_AnsiParams.split(";"));
                formatBuilder.push(format = this._getFormatBlock(lineLength));
                this._SplitBuffer = "";
                _AnsiParams = null;
                state = 0 /* None */;
              } else if (c === "\n" || c === "\x1B") {
                idx--;
                rawBuilder.pop();
                this.rawLength--;
                state = 0 /* None */;
                this._SplitBuffer = "";
                if (this._mxpState.on && c === "\n")
                  this._ClearMXPOpen();
              } else {
                this._SplitBuffer += c;
                _AnsiParams += c;
              }
              break;
            case 3 /* XTermTitle */:
              if (i2 === 7) {
                this._SplitBuffer = "";
                this.emit("set-title", _TermTitle, _TermTitleType == null ? 0 : _TermTitleType);
                _TermTitle = "";
                _TermTitleType = null;
                state = 0 /* None */;
              } else if (c === ";" && _TermTitleType == null) {
                _TermTitleType = +_TermTitle;
                if (isNaN(_TermTitleType))
                  _TermTitleType = 0;
                _TermTitle = "";
                this._SplitBuffer += c;
              } else if (c === "\x1B") {
                if (this._SplitBuffer.charAt(this._SplitBuffer.length - 1) === "\n")
                  this._SplitBuffer = "";
              } else {
                this._SplitBuffer += c;
                _TermTitle += c;
              }
              break;
            case 1 /* Ansi */:
              if (c === "[") {
                this._SplitBuffer += c;
                _AnsiParams = "";
                state = 2 /* AnsiParams */;
              } else if (c === "]") {
                this._SplitBuffer += c;
                _TermTitle = "";
                state = 3 /* XTermTitle */;
              } else if (c === "D" || //Index ( down one line, scroll if at bottom )
              c === "E" || //Next line ( move to column 1 of next line, scroll up if at bottom )
              c === "M" || //Reverse index	( up one line, scroll down if at top )
              c === "1" || //Graphic proc. option ON
              c === "2" || //Graphic proc. option OFF
              c === "7" || //Save cursor & attributes
              c === "8" || //Restore cursor & attributes
              c === ">" || //Keypad mode		Numeric
              c === "=" || //Keypad mode		Application
              /*
              *LINE SIZE COMMANDS
              *<ESC>#3 Change current line to double-height top half
              *<ESC>#4 Change current line to double-height bottom half
              *<ESC>#5 Change current line to single-width single-height (normal)
              *<ESC>#6 Change current line to double-width single-height
              */
              c === "#") {
                if (d2) {
                  stringBuilder.push("\u241B");
                  if (i2 < 16) {
                    stringBuilder.push(String.fromCharCode(parseInt("240" + i2.toString(16), 16)));
                    this._MXPCapture("&#x241B&#x240" + i2.toString(16) + ";");
                  } else {
                    stringBuilder.push(String.fromCharCode(parseInt("24" + i2.toString(16), 16)));
                    this._MXPCapture("&#x241B&#x24" + i2.toString(16) + ";");
                  }
                  lineLength += 2;
                  this.textLength += 2;
                  this._mxpState.noBreak = false;
                }
                state = 0 /* None */;
                this._SplitBuffer = "";
              }
              break;
            case 4 /* MXPTag */:
              if (_MXPTag === "!--") {
                idx--;
                rawBuilder.pop();
                this.rawLength--;
                pState = 0 /* None */;
                state = 8 /* MXPComment */;
                _MXPComment = "<!--";
                _MXPTag = "";
                _MXPArgs = [];
              } else if (_MXPTag.endsWith("<!--")) {
                idx--;
                rawBuilder.pop();
                this.rawLength--;
                pState = state;
                state = 8 /* MXPComment */;
                _MXPComment = "<!--";
                _MXPTag = _MXPTag.substring(0, _MXPTag.length - 4);
                _MXPArgs = [];
              } else if (c === '"') {
                state = 6 /* MXPTagDblQuoted */;
                _MXPArgs[_MXPArgs.length - 1] += c;
                this._SplitBuffer += c;
              } else if (c === "'") {
                state = 5 /* MXPTagQuoted */;
                _MXPArgs[_MXPArgs.length - 1] += c;
                this._SplitBuffer += c;
              } else if (c === "&") {
                _MXPEntity = "";
                pState = state;
                state = 7 /* MXPEntity */;
                this._SplitBuffer = "";
              } else if (c === "\n" || c === "\x1B") {
                idx--;
                rawBuilder.pop();
                this.rawLength--;
                state = 0 /* None */;
                this._SplitBuffer = "";
                if (this._mxpState.on && c === "\n")
                  this._ClearMXPOpen();
              } else if (c === " ") {
                state = 9 /* MXPTagArg */;
                _MXPArgs.push("");
                this._SplitBuffer += c;
              } else if (c === ">") {
                _MXPOTag = _MXPTag;
                _MXPTag = _MXPTag.toUpperCase();
                if (_MXPTag === "HR" && (this._mxpState.lineType === 1 /* Secure */ || this._mxpState.lineType === 6 /* LockSecure */ || this._mxpState.lineType === 4 /* TempSecure */)) {
                  if (lineLength > 0) {
                    lineLength = 0;
                    this._MXPCapture("\n");
                    formatBuilder.push(...this._getMXPCloseFormatBlocks());
                    this._AddLine(stringBuilder.join(""), rawBuilder.join(""), false, false, formatBuilder, remote);
                    stringBuilder = [];
                    rawBuilder = [];
                    formatBuilder = [...this._getMXPOpenFormatBlocks(), format = this._getFormatBlock(lineLength)];
                  }
                  _MXPTag = this._getMXPBlock(_MXPTag, [], remote);
                  if (_MXPTag && _MXPTag.format) {
                    _MXPTag.format.offset = lineLength;
                    formatBuilder.push(_MXPTag.format);
                    formatBuilder[0].hr = _MXPTag.format.hr;
                  }
                  formatBuilder.push(...this._getMXPCloseFormatBlocks());
                  this._AddLine(stringBuilder.join(""), rawBuilder.join(""), false, false, formatBuilder, remote);
                  this.textLength++;
                  stringBuilder = [];
                  rawBuilder = [];
                  formatBuilder = [...this._getMXPOpenFormatBlocks(), format = this._getFormatBlock(lineLength)];
                } else if (_MXPTag === "BR" && (this._mxpState.lineType === 1 /* Secure */ || this._mxpState.lineType === 6 /* LockSecure */ || this._mxpState.lineType === 4 /* TempSecure */)) {
                  this._MXPCapture("\n");
                  formatBuilder.push(...this._getMXPCloseFormatBlocks());
                  this._AddLine(stringBuilder.join(""), rawBuilder.join(""), false, false, formatBuilder, remote);
                  skip = false;
                  lineLength = 0;
                  stringBuilder = [];
                  rawBuilder = [];
                  formatBuilder = [...this._getMXPOpenFormatBlocks(), format = this._getFormatBlock(lineLength)];
                  this.textLength++;
                } else if (_MXPTag === "IMAGE" && (this._mxpState.lineType === 1 /* Secure */ || this._mxpState.lineType === 6 /* LockSecure */ || this._mxpState.lineType === 4 /* TempSecure */)) {
                  _MXPTag = this._getMXPBlock(_MXPTag, _MXPArgs, remote);
                  if (_MXPTag && _MXPTag.format !== null) {
                    formatBuilder.push(_MXPTag.format);
                    lineLength += _MXPTag.length;
                    this.textLength += _MXPTag.length;
                  }
                  formatBuilder.push(format = this._getFormatBlock(lineLength));
                } else {
                  _MXPTag = this._getMXPBlock(_MXPTag, [], remote, _MXPOTag, formatBuilder);
                  if (this._mxpState.expanded) {
                    if (_MXPTag && _MXPTag.text !== null) text = text.splice(idx + 1, _MXPTag.text);
                    tl = text.length;
                    this._mxpState.expanded = false;
                    state = 0 /* None */;
                    _MXPTag = "";
                    this._SplitBuffer = "";
                    continue;
                  }
                  if (_MXPTag) {
                    if (_MXPTag.format) {
                      _MXPTag.format.offset = lineLength;
                      formatBuilder.push(_MXPTag.format);
                    }
                    formatBuilder.push(format = this._getFormatBlock(lineLength));
                    if (_MXPTag.text !== null && _MXPTag.text.length > 0) {
                      stringBuilder.push(_MXPTag.text);
                      lineLength += _MXPTag.text.length;
                      this.textLength += _MXPTag.text.length;
                    }
                  } else
                    formatBuilder.push(format = this._getFormatBlock(lineLength));
                }
                state = 0 /* None */;
                this._SplitBuffer = "";
              } else if (c === "<") {
                if (this.enableDebug)
                  this.emit("debug", "Malformed MXP Tag: " + _MXPTag);
                idx--;
                rawBuilder.pop();
                this.rawLength--;
                stringBuilder.push("<" + _MXPTag);
                lineLength += _MXPTag.length + 1;
                this.textLength += _MXPTag.length + 1;
                state = 0 /* None */;
                this._SplitBuffer = "";
              } else {
                this._SplitBuffer += c;
                _MXPTag += c;
              }
              break;
            case 5 /* MXPTagQuoted */:
              if (c === "'") {
                state = 9 /* MXPTagArg */;
                this._SplitBuffer += c;
                _MXPArgs[_MXPArgs.length - 1] += c;
              } else {
                this._SplitBuffer += c;
                _MXPArgs[_MXPArgs.length - 1] += c;
              }
              break;
            case 6 /* MXPTagDblQuoted */:
              if (c === '"') {
                state = 9 /* MXPTagArg */;
                this._SplitBuffer += c;
                _MXPArgs[_MXPArgs.length - 1] += c;
              } else {
                this._SplitBuffer += c;
                _MXPArgs[_MXPArgs.length - 1] += c;
              }
              break;
            case 9 /* MXPTagArg */:
              if (c === "'") {
                state = 5 /* MXPTagQuoted */;
                _MXPArgs[_MXPArgs.length - 1] += c;
                this._SplitBuffer += c;
              } else if (c === '"') {
                state = 6 /* MXPTagDblQuoted */;
                _MXPArgs[_MXPArgs.length - 1] += c;
                this._SplitBuffer += c;
              } else if (c === "\n" || c === "\x1B") {
                idx--;
                rawBuilder.pop();
                this.rawLength--;
                state = 0 /* None */;
                this._SplitBuffer = "";
                if (this._mxpState.on && c === "\n")
                  this._ClearMXPOpen();
              } else if (c === " ") {
                state = 9 /* MXPTagArg */;
                _MXPArgs.push("");
                this._SplitBuffer += c;
              } else if (c === ">") {
                if (_MXPTag.toUpperCase() === "IMAGE" && (this._mxpState.lineType === 1 /* Secure */ || this._mxpState.lineType === 6 /* LockSecure */ || this._mxpState.lineType === 4 /* TempSecure */)) {
                  _MXPTag = this._getMXPBlock(_MXPTag, _MXPArgs, remote, _MXPTag);
                  if (_MXPTag !== null && _MXPTag.format !== null) {
                    _MXPTag.format.offset = lineLength;
                    formatBuilder.push(_MXPTag.format);
                  }
                  formatBuilder.push(format = this._getFormatBlock(lineLength));
                } else {
                  _MXPTag = this._getMXPBlock(_MXPTag, _MXPArgs, remote, _MXPTag, formatBuilder);
                  if (this._mxpState.expanded) {
                    if (_MXPTag !== null) text = text.splice(idx + 1, _MXPTag.text);
                    tl = text.length;
                    this._mxpState.expanded = false;
                    state = 0 /* None */;
                    this._SplitBuffer = "";
                    continue;
                  }
                  if (_MXPTag !== null) {
                    if (_MXPTag !== null && _MXPTag.format) {
                      _MXPTag.format.offset = lineLength;
                      formatBuilder.push(_MXPTag.format);
                    }
                    formatBuilder.push(format = this._getFormatBlock(lineLength));
                    if (_MXPTag.text !== null) {
                      stringBuilder.push(_MXPTag.text);
                      lineLength += _MXPTag.text.length;
                      this.textLength += _MXPTag.text.length;
                    }
                  } else
                    formatBuilder.push(format = this._getFormatBlock(lineLength));
                }
                state = 0 /* None */;
                this._SplitBuffer = "";
              } else {
                this._SplitBuffer += c;
                _MXPArgs[_MXPArgs.length - 1] += c;
              }
              break;
            case 7 /* MXPEntity */:
              if (c === "\n" || c === "\x1B") {
                idx--;
                rawBuilder.pop();
                this.rawLength--;
                if (this.enableDebug) this.emit("debug", "MXP Entity: " + _MXPEntity);
                if (pState === 4 /* MXPTag */) {
                  _MXPTag += "&" + _MXPEntity;
                  state = pState;
                } else {
                  _MXPEntity = this._GetEntity(_MXPEntity);
                  if (this._mxpState.expanded) {
                    if (_MXPTag !== null)
                      text = text.splice(idx + 1, _MXPEntity);
                    tl = text.length;
                    this._mxpState.expanded = false;
                    state = 0 /* None */;
                    this._SplitBuffer = "";
                    continue;
                  }
                  _MXPOTag = htmlDecode("&" + _MXPEntity);
                  stringBuilder.push(_MXPOTag);
                  this._MXPCapture("&" + _MXPEntity);
                  lineLength += _MXPOTag.length;
                  this.textLength += _MXPOTag.length;
                  this._mxpState.noBreak = false;
                  state = 0 /* None */;
                  this._SplitBuffer = "";
                  format.unicode = true;
                }
                if (this._mxpState.on && c === "\n")
                  this._ClearMXPOpen();
              } else if (c === ";") {
                if (this.enableDebug) this.emit("debug", "MXP Entity: " + _MXPEntity);
                if (pState !== 4 /* MXPTag */) {
                  _MXPEntity = this._GetEntity(_MXPEntity);
                  if (this._mxpState.expanded) {
                    text = text.splice(idx + 1, _MXPEntity);
                    tl = text.length;
                    this._mxpState.expanded = false;
                    state = pState;
                    this._SplitBuffer = "";
                    continue;
                  }
                  _MXPOTag = htmlDecode("&" + _MXPEntity + ";");
                  stringBuilder.push(_MXPOTag);
                  this._MXPCapture("&");
                  this._MXPCapture(_MXPEntity);
                  this._MXPCapture(";");
                  lineLength += _MXPOTag.length;
                  this.textLength += _MXPOTag.length;
                  this._mxpState.noBreak = false;
                  this._SplitBuffer = "";
                } else
                  _MXPTag += "&" + _MXPEntity + ";";
                format.unicode = true;
                state = pState;
              } else if (c === "&") {
                if (this.enableDebug) this.emit("debug", "Malformed MXP Entity: " + _MXPEntity);
                if (pState !== 4 /* MXPTag */) {
                  stringBuilder.push("&" + _MXPEntity);
                  this._MXPCapture("&");
                  this._MXPCapture(_MXPEntity);
                  lineLength += _MXPEntity.length + 1;
                  this.textLength += _MXPEntity.length + 1;
                  this._mxpState.noBreak = false;
                  this._SplitBuffer = "";
                  idx--;
                  rawBuilder.pop();
                  this.rawLength--;
                } else
                  _MXPTag += "&" + _MXPEntity;
                format.unicode = true;
                state = pState;
              } else {
                this._SplitBuffer += c;
                _MXPEntity += c;
              }
              break;
            case 8 /* MXPComment */:
              if (_MXPComment.endsWith("-->")) {
                if (this.enableDebug) this.emit("debug", "MXP Comment: " + _MXPComment);
                idx--;
                rawBuilder.pop();
                this.rawLength--;
                state = pState;
                if (state === 0 /* None */)
                  this._SplitBuffer = "";
                _MXPComment = "";
              } else if (c === "\n" || c === "\x1B") {
                if (this.enableDebug) this.emit("debug", "MXP Comment: " + _MXPComment);
                idx--;
                rawBuilder.pop();
                this.rawLength--;
                state = pState;
                _MXPComment = "";
                if (this._mxpState.on && c === "\n")
                  this._ClearMXPOpen();
              } else
                _MXPComment += c;
              break;
            case 10 /* URL */:
              if (idx > lnk + 2) {
                stringBuilder.pop();
                stringBuilder.pop();
                rawBuilder.pop();
                rawBuilder.pop();
                this.rawLength -= 2;
                lineLength -= 2;
                this.textLength -= 2;
                this._MXPDeCapture(2);
                idx = lnk;
                state = 0 /* None */;
              } else if (c === "/") {
                stringBuilder.push(c);
                this._MXPCapture(c);
                lineLength++;
                this.textLength++;
                if (idx === lnk + 2) {
                  state = 11 /* URLFound */;
                  lnk = stringBuilder.length - 4;
                  lLnk = stringBuilder.length - 1;
                  fLnk = formatBuilder.length;
                  lnkOffset -= 2;
                  while (lnk > 0 && CharAllowedInURL(stringBuilder[lnk], true)) {
                    lnk--;
                    lnkOffset--;
                  }
                  if (!CharAllowedInURL(stringBuilder[lnk], true)) {
                    lnk++;
                    lnkOffset++;
                  }
                  lNest = [];
                  if (lnk > 0 && stringBuilder[lnk - 1] === "(")
                    lNest.push(")");
                  if (lnk > 0 && stringBuilder[lnk - 1] === "[")
                    lNest.push("]");
                }
              } else if (idx > lnk + 1) {
                stringBuilder.pop();
                rawBuilder.pop();
                this.rawLength--;
                lineLength--;
                this.textLength--;
                this._MXPDeCapture(1);
                idx = lnk;
                state = 0 /* None */;
              } else {
                idx = lnk;
                state = 0 /* None */;
                rawBuilder.pop();
                this.rawLength--;
              }
              break;
            case 11 /* URLFound */:
              if (!CharAllowedInURL(c, false)) {
                if (lLnk !== stringBuilder.length - 1) {
                  _MXPComment += stringBuilder.slice(lnk).join("");
                  if (this.enableDebug) this.emit("debug", "URL Found: " + _MXPComment);
                  formatBuilder.splice(
                    fLnk,
                    0,
                    {
                      formatType: 1 /* Link */,
                      offset: lnkOffset,
                      href: _MXPComment
                    }
                  );
                  formatBuilder.push({
                    formatType: 2 /* LinkEnd */,
                    offset: lineLength,
                    href: _MXPComment
                  });
                  formatBuilder.push(format = this._getFormatBlock(lineLength));
                }
                state = 0 /* None */;
                idx--;
                rawBuilder.pop();
                this.rawLength--;
              } else {
                if (lNest.length > 1 && lNest[lNest.length - 1] === c) {
                  lNest.pop();
                  stringBuilder.push(c);
                  this._MXPCapture(c);
                  lineLength++;
                  this.textLength++;
                  if (i2 > 255)
                    format.unicode = true;
                } else if (lNest.length > 0 && c === "(") {
                  lNest.push(")");
                  stringBuilder.push(c);
                  this._MXPCapture(c);
                  lineLength++;
                  this.textLength++;
                  if (i2 > 255)
                    format.unicode = true;
                } else if (lNest.length > 0 && c === "[") {
                  lNest.push("]");
                  stringBuilder.push(c);
                  this._MXPCapture(c);
                  lineLength++;
                  this.textLength++;
                  if (i2 > 255)
                    format.unicode = true;
                } else if (lNest.length === 1 && lNest[lNest.length - 1] === c) {
                  if (lLnk !== stringBuilder.length - 1) {
                    _MXPComment += stringBuilder.slice(lnk).join("");
                    if (this.enableDebug) this.emit("debug", "URL Found: " + _MXPComment);
                    formatBuilder.splice(
                      fLnk,
                      0,
                      {
                        formatType: 1 /* Link */,
                        href: _MXPComment,
                        offset: lnkOffset
                      }
                    );
                    formatBuilder.push({
                      formatType: 2 /* LinkEnd */,
                      href: _MXPComment,
                      offset: lineLength
                    });
                    formatBuilder.push(format = this._getFormatBlock(lineLength));
                  }
                  state = 0 /* None */;
                  idx--;
                  rawBuilder.pop();
                  this.rawLength--;
                } else {
                  if (i2 > 255)
                    format.unicode = true;
                  stringBuilder.push(c);
                  this._MXPCapture(c);
                  lineLength++;
                  this.textLength++;
                }
              }
              break;
            case 12 /* MSPSound */:
              if (c === ")") {
                lnk = this._mxpState.lineType;
                this._mxpState.lineType = 4 /* TempSecure */;
                this._getMXPBlock("SOUND", _MXPArgs, remote);
                this._mxpState.lineType = lnk;
                state = 0 /* None */;
                if (idx + 1 < tl && text.charAt(idx + 1) === "\n") {
                  idx++;
                  skip = false;
                  stringBuilder = [];
                  formatBuilder = [...this._getMXPOpenFormatBlocks(), format = this._getFormatBlock(lineLength)];
                  this._mxpState.noBreak = false;
                  lineLength = 0;
                } else if (idx + 2 < tl && text[idx + 1] === "\r" && text[idx + 2] === "\n") {
                  idx += 2;
                  skip = false;
                  stringBuilder = [];
                  formatBuilder = [...this._getMXPOpenFormatBlocks(), format = this._getFormatBlock(lineLength)];
                  this._mxpState.noBreak = false;
                  lineLength = 0;
                }
              } else if (c === " ")
                _MXPArgs.push("");
              else
                _MXPArgs[_MXPArgs.length - 1] += c;
              break;
            case 13 /* MSPMusic */:
              if (c === ")") {
                lnk = this._mxpState.lineType;
                this._mxpState.lineType = 4 /* TempSecure */;
                this._getMXPBlock("MUSIC", _MXPArgs, remote);
                this._mxpState.lineType = lnk;
                state = 0 /* None */;
                if (idx + 1 < tl && text.charAt(idx + 1) === "\n") {
                  idx++;
                  skip = false;
                  stringBuilder = [];
                  formatBuilder = [...this._getMXPOpenFormatBlocks(), format = this._getFormatBlock(lineLength)];
                  this._mxpState.noBreak = false;
                  lineLength = 0;
                } else if (idx + 2 < tl && text[idx + 1] === "\r" && text[idx + 2] === "\n") {
                  idx += 2;
                  skip = false;
                  stringBuilder = [];
                  formatBuilder = [...this._getMXPOpenFormatBlocks(), format = this._getFormatBlock(lineLength)];
                  this._mxpState.noBreak = false;
                  lineLength = 0;
                }
              } else if (c === " ")
                _MXPArgs.push("");
              else
                _MXPArgs[_MXPArgs.length - 1] += c;
              break;
            default:
              if (e && i2 === 7) {
                if (f) {
                  c = "\u2407";
                  stringBuilder.push(c);
                  this._MXPCapture(c);
                  lineLength++;
                  this.textLength++;
                  this._mxpState.noBreak = false;
                } else if (d2) {
                  stringBuilder.push(c);
                  this._MXPCapture("&#x2407;");
                  lineLength++;
                  this.textLength++;
                  this._mxpState.noBreak = false;
                }
                this.emit("bell");
              } else if (e && c === "\b") {
                skip = false;
                if (lineLength > 0) {
                  if (stringBuilder.length) {
                    while (stringBuilder[stringBuilder.length - 1].length === 0)
                      stringBuilder.pop();
                    if (stringBuilder[stringBuilder.length - 1].length === 1)
                      stringBuilder.pop();
                    else
                      stringBuilder[stringBuilder.length - 1] = stringBuilder[stringBuilder.length - 1].substring(0, stringBuilder[stringBuilder.length - 1].length - 1);
                  }
                  if (format.offset === lineLength)
                    format.offset--;
                  lineLength--;
                  this.textLength--;
                }
                if (d2) {
                  c = "\u25D8";
                  stringBuilder.push(c);
                  this._MXPCapture(c);
                  lineLength++;
                  this.textLength++;
                }
                this._mxpState.noBreak = false;
              } else if (e && c === "	") {
                const _Tab = tabWidth - lineLength % tabWidth;
                if (_Tab > 0) {
                  stringBuilder.push(Array(_Tab + 1).join(" "));
                  this._MXPCapture(Array(_Tab + 1).join(" "));
                  lineLength += _Tab;
                  this.textLength += _Tab;
                  this._mxpState.noBreak = false;
                }
              } else if (c === "\n") {
                if (this._mxpState.noBreak || this._mxpState.paragraph) continue;
                if (!this._mxpState.locked) {
                  if (this._mxpState.lineType !== 0 /* Open */)
                    this.emit("MXP-tag-end", this._mxpState.lineType, stringBuilder.join(""), formatBuilder);
                  if (!this._mxpState.lineExpanded && this._mxpLines[this._mxpState.lineType] && this._mxpLines[this._mxpState.lineType].enabled) {
                    iTmp = "";
                    if (this._mxpLines[this._mxpState.lineType].element.length > 0)
                      iTmp += "</" + this._mxpLines[this._mxpState.lineType].element + ">";
                    if (this._mxpLines[this._mxpState.lineType].closeDefinition.length > 0)
                      iTmp += this._mxpLines[this._mxpState.lineType].closeDefinition;
                    if (iTmp.length > 0) {
                      text = text.splice(idx, iTmp);
                      tl = text.length;
                      idx--;
                      rawBuilder.pop();
                      this.rawLength--;
                      this._mxpState.lineExpanded = true;
                      continue;
                    }
                  }
                  this._mxpState.lineExpanded = false;
                  formatBuilder.push(...this._getMXPCloseFormatBlocks());
                  if (this._mxpState.on)
                    this._ClearMXPOpen();
                  this._mxpState.on = false;
                  if (this._mxpLines[this._mxpState.lineType] && this._mxpLines[this._mxpState.lineType].enabled && this._mxpLines[this._mxpState.lineType].gag)
                    skip = true;
                  this._mxpState.lineType = this._iMXPDefaultMode;
                  if (this._mxpState.lineType !== 2 && !this.enableMXP)
                    this.ResetMXP();
                } else {
                  formatBuilder.push(...this._getMXPCloseFormatBlocks());
                  if (this._mxpState.on)
                    this._ClearMXPOpen();
                }
                lineLength = 0;
                if (!skip)
                  this._MXPCapture("\n");
                this._AddLine(stringBuilder.join(""), rawBuilder.join(""), false, skip, formatBuilder, remote);
                skip = false;
                stringBuilder = [];
                rawBuilder = [];
                formatBuilder = [...this._getMXPOpenFormatBlocks(), format = this._getFormatBlock(lineLength)];
                this.textLength++;
                this._mxpState.noBreak = false;
              } else if (e && c === "\r") {
                continue;
              } else if (e && c === "\x1B") {
                this._SplitBuffer += c;
                state = 1 /* Ansi */;
              } else if (i2 < 32 || i2 === 127) {
                if (f) {
                  if (i2 === 1)
                    c = "\u263A";
                  else if (i2 === 2)
                    c = "\u263B";
                  else if (i2 === 3)
                    c = "\u2665";
                  else if (i2 === 4)
                    c = "\u2666";
                  else if (i2 === 5)
                    c = "\u2663";
                  else if (i2 === 6)
                    c = "\u2660";
                  else if (i2 === 7)
                    c = "\u2407";
                  else if (i2 === 8)
                    c = "\u25D8";
                  else if (i2 === 9)
                    c = "\u25CB";
                  else if (i2 === 10)
                    c = "\u25D9";
                  else if (i2 === 11)
                    c = "\u2642";
                  else if (i2 === 12)
                    c = "\u2640";
                  else if (i2 === 13)
                    c = "\u266A";
                  else if (i2 === 14)
                    c = "\u266B";
                  else if (i2 === 15)
                    c = "\u263C";
                  else if (i2 === 16)
                    c = "\u25BA";
                  else if (i2 === 17)
                    c = "\u25C4";
                  else if (i2 === 18)
                    c = "\u2195";
                  else if (i2 === 19)
                    c = "\u203C";
                  else if (i2 === 20)
                    c = "\xB6";
                  else if (i2 === 21)
                    c = "\xA7";
                  else if (i2 === 22)
                    c = "\u25AC";
                  else if (i2 === 23)
                    c = "\u21A8";
                  else if (i2 === 24)
                    c = "\u2191";
                  else if (i2 === 25)
                    c = "\u2193";
                  else if (i2 === 26)
                    c = "\u2192";
                  else if (i2 === 27)
                    c = "\u2190";
                  else if (i2 === 28)
                    c = "\u221F";
                  else if (i2 === 29)
                    c = "\u2194";
                  else if (i2 === 30)
                    c = "\u25B2";
                  else if (i2 === 31)
                    c = "\u25BC";
                  else if (i2 === 127)
                    c = "\u2302";
                  stringBuilder.push(c);
                  this._MXPCapture(c);
                  lineLength++;
                  this.textLength++;
                  this._mxpState.noBreak = false;
                } else if (d2) {
                  i2 = 9216 + i2;
                  stringBuilder.push(String.fromCharCode(i2));
                  this._MXPCapture("&#");
                  this._MXPCapture(i2.toString());
                  this._MXPCapture(";");
                  lineLength++;
                  this.textLength++;
                  this._mxpState.noBreak = false;
                } else
                  continue;
              } else if (c === " " || this._CurrentAttributes > 0 && (this._CurrentAttributes & 128 /* Hidden */) === 128 /* Hidden */) {
                stringBuilder.push(" ");
                this._MXPCapture(" ");
                lineLength++;
                this.textLength++;
                this._mxpState.noBreak = false;
              } else if (c === "<" && idx >= mOffset) {
                if (this.enableMXP && this._mxpState.on) {
                  _MXPTag = "";
                  _MXPArgs = [];
                  this._SplitBuffer += c;
                  state = 4 /* MXPTag */;
                } else {
                  stringBuilder.push("<");
                  this._MXPCapture("&lt;");
                  lineLength++;
                  this.textLength++;
                }
              } else if (c === ">") {
                stringBuilder.push(">");
                this._MXPCapture("&gt;");
                lineLength++;
                this.textLength++;
                this._mxpState.noBreak = false;
              } else if (c === "&" && idx >= mOffset) {
                if (this.enableMXP && this._mxpState.on) {
                  _MXPEntity = "";
                  this._SplitBuffer += c;
                  pState = state;
                  state = 7 /* MXPEntity */;
                } else {
                  stringBuilder.push(c);
                  lineLength++;
                  this.textLength++;
                  this._mxpState.noBreak = false;
                }
              } else if (c === '"') {
                stringBuilder.push(c);
                this._MXPCapture("&quot;");
                lineLength++;
                this.textLength++;
                this._mxpState.noBreak = false;
              } else if (c === "'") {
                stringBuilder.push(c);
                this._MXPCapture("&apos;");
                lineLength++;
                this.textLength++;
                this._mxpState.noBreak = false;
              } else if (c === ":") {
                stringBuilder.push(c);
                this._MXPCapture(c);
                lineLength++;
                this.textLength++;
                this._mxpState.noBreak = false;
                if (u) {
                  _MXPComment = "";
                  let psk;
                  let pFnd = false;
                  for (p = 0; p < pl; p++) {
                    if (idx - this._protocols[p].length < 0)
                      continue;
                    psk = false;
                    const nl = this._protocols[p].length;
                    for (let n = 0; n < nl; n++) {
                      if (text[idx - (nl - n)] !== this._protocols[p][n]) {
                        psk = true;
                        break;
                      }
                    }
                    if (psk)
                      continue;
                    lnk = stringBuilder.length;
                    lnkOffset = lineLength;
                    fLnk = formatBuilder.length;
                    if (lnk > 1 + nl && stringBuilder[lnk - (2 + nl)].length === 1 && /\S/.test(stringBuilder[lnk - (2 + nl)]) && stringBuilder[lnk - (2 + nl)] !== "(" && stringBuilder[lnk - (2 + nl)] !== "[")
                      continue;
                    lNest = [];
                    lnk = stringBuilder.length - (1 + nl);
                    lnkOffset -= 1 + nl;
                    lLnk = stringBuilder.length - 1;
                    if (lnk > 0 && stringBuilder[lnk - 1] === "(")
                      lNest.push(")");
                    if (lnk > 0 && stringBuilder[lnk - 1] === "[")
                      lNest.push("]");
                    state = 11 /* URLFound */;
                    pFnd = true;
                    if (pFnd)
                      break;
                  }
                  if (!pFnd) {
                    state = 10 /* URL */;
                    lnk = idx;
                    lnkOffset = lineLength;
                  }
                }
              } else if (c === ".") {
                stringBuilder.push(c);
                this._MXPCapture(c);
                lineLength++;
                this.textLength++;
                this._mxpState.noBreak = false;
                if (u && idx - 3 >= 0) {
                  _MXPComment = "http://";
                  if ((text[idx - 1] === "w" || idx[lnk - 1] === "W") && (text[idx - 2] === "w" || idx[lnk - 2] === "W") && (text[idx - 3] === "w" || idx[lnk - 3] === "W")) {
                    lnk = stringBuilder.length;
                    lnkOffset = lineLength;
                    fLnk = formatBuilder.length;
                    if (lnk > 4 && stringBuilder[lnk - 5].length === 1 && /\S/.test(stringBuilder[lnk - 5]) && stringBuilder[lnk - 5] !== "(" && stringBuilder[lnk - 5] !== "[")
                      continue;
                    lNest = [];
                    lnk = stringBuilder.length - 4;
                    lnkOffset -= 4;
                    lLnk = stringBuilder.length - 1;
                    if (lnk > 0 && stringBuilder[lnk - 1] === "(")
                      lNest.push(")");
                    if (lnk > 0 && stringBuilder[lnk - 1] === "[")
                      lNest.push("]");
                    state = 11 /* URLFound */;
                  }
                }
              } else if (s && lineLength === 0 && text.substring(idx, idx + 8) === "!!MUSIC(") {
                _MXPArgs = [""];
                state = 13 /* MSPMusic */;
                idx += 7;
                this._mxpState.noBreak = false;
              } else if (s && lineLength === 0 && text.substring(idx, idx + 8) === "!!SOUND(") {
                _MXPArgs = [""];
                state = 12 /* MSPSound */;
                idx += 7;
                this._mxpState.noBreak = false;
              } else {
                if (f && i2 > 127 && i2 < 255) {
                  if (i2 === 128)
                    c = "\xC7";
                  else if (i2 === 129)
                    c = "\xFC";
                  else if (i2 === 130)
                    c = "\xE9";
                  else if (i2 === 131)
                    c = "\xE2";
                  else if (i2 === 132)
                    c = "\xE4";
                  else if (i2 === 133)
                    c = "\xE0";
                  else if (i2 === 134)
                    c = "\xE5";
                  else if (i2 === 135)
                    c = "\xE7";
                  else if (i2 === 136)
                    c = "\xEA";
                  else if (i2 === 137)
                    c = "\xEB";
                  else if (i2 === 138)
                    c = "\xE8";
                  else if (i2 === 139)
                    c = "\xEF";
                  else if (i2 === 140)
                    c = "\xEE";
                  else if (i2 === 141)
                    c = "\xEC";
                  else if (i2 === 142)
                    c = "\xC4";
                  else if (i2 === 143)
                    c = "\xC5";
                  else if (i2 === 144)
                    c = "\xC9";
                  else if (i2 === 145)
                    c = "\xE6";
                  else if (i2 === 146)
                    c = "\xC6";
                  else if (i2 === 147)
                    c = "\xF4";
                  else if (i2 === 148)
                    c = "\xF6";
                  else if (i2 === 149)
                    c = "\xF2";
                  else if (i2 === 150)
                    c = "\xFB";
                  else if (i2 === 151)
                    c = "\xF9";
                  else if (i2 === 152)
                    c = "\xFF";
                  else if (i2 === 153)
                    c = "\xD6";
                  else if (i2 === 154)
                    c = "\xDC";
                  else if (i2 === 155)
                    c = "\xA2";
                  else if (i2 === 156)
                    c = "\xA3";
                  else if (i2 === 157)
                    c = "\xA5";
                  else if (i2 === 158)
                    c = "\u20A7";
                  else if (i2 === 159)
                    c = "\u0192";
                  else if (i2 === 160)
                    c = "\xE1";
                  else if (i2 === 161)
                    c = "\xED";
                  else if (i2 === 162)
                    c = "\xF3";
                  else if (i2 === 163)
                    c = "\xFA";
                  else if (i2 === 164)
                    c = "\xF1";
                  else if (i2 === 165)
                    c = "\xD1";
                  else if (i2 === 166)
                    c = "\xAA";
                  else if (i2 === 167)
                    c = "\xBA";
                  else if (i2 === 168)
                    c = "\xBF";
                  else if (i2 === 169)
                    c = "\u2310";
                  else if (i2 === 170)
                    c = "\xAC";
                  else if (i2 === 171)
                    c = "\xBD";
                  else if (i2 === 172)
                    c = "\xBC";
                  else if (i2 === 173)
                    c = "\xA1";
                  else if (i2 === 174)
                    c = "\xAB";
                  else if (i2 === 175)
                    c = "\xBB";
                  else if (i2 === 176)
                    c = "\u2591";
                  else if (i2 === 177)
                    c = "\u2592";
                  else if (i2 === 178)
                    c = "\u2593";
                  else if (i2 === 179)
                    c = "\u2502";
                  else if (i2 === 180)
                    c = "\u2524";
                  else if (i2 === 181)
                    c = "\u2561";
                  else if (i2 === 182)
                    c = "\u2562";
                  else if (i2 === 183)
                    c = "\u2556";
                  else if (i2 === 184)
                    c = "\u2555";
                  else if (i2 === 185)
                    c = "\u2563";
                  else if (i2 === 186)
                    c = "\u2551";
                  else if (i2 === 187)
                    c = "\u2557";
                  else if (i2 === 188)
                    c = "\u255D";
                  else if (i2 === 189)
                    c = "\u255C";
                  else if (i2 === 190)
                    c = "\u255B";
                  else if (i2 === 191)
                    c = "\u2510";
                  else if (i2 === 192)
                    c = "\u2514";
                  else if (i2 === 193)
                    c = "\u2534";
                  else if (i2 === 194)
                    c = "\u252C";
                  else if (i2 === 195)
                    c = "\u251C";
                  else if (i2 === 196)
                    c = "\u2500";
                  else if (i2 === 197)
                    c = "\u253C";
                  else if (i2 === 198)
                    c = "\u255E";
                  else if (i2 === 199)
                    c = "\u255F";
                  else if (i2 === 200)
                    c = "\u255A";
                  else if (i2 === 201)
                    c = "\u2554";
                  else if (i2 === 202)
                    c = "\u2569";
                  else if (i2 === 203)
                    c = "\u2566";
                  else if (i2 === 204)
                    c = "\u2560";
                  else if (i2 === 205)
                    c = "\u2550";
                  else if (i2 === 206)
                    c = "\u256C";
                  else if (i2 === 207)
                    c = "\u2567";
                  else if (i2 === 208)
                    c = "\u2568";
                  else if (i2 === 209)
                    c = "\u2564";
                  else if (i2 === 210)
                    c = "\u2565";
                  else if (i2 === 211)
                    c = "\u2559";
                  else if (i2 === 212)
                    c = "\u2558";
                  else if (i2 === 213)
                    c = "\u2552";
                  else if (i2 === 214)
                    c = "\u2553";
                  else if (i2 === 215)
                    c = "\u256B";
                  else if (i2 === 216)
                    c = "\u256A";
                  else if (i2 === 217)
                    c = "\u2518";
                  else if (i2 === 218)
                    c = "\u250C";
                  else if (i2 === 219)
                    c = "\u2588";
                  else if (i2 === 220)
                    c = "\u2584";
                  else if (i2 === 221)
                    c = "\u258C";
                  else if (i2 === 222)
                    c = "\u2590";
                  else if (i2 === 223)
                    c = "\u2580";
                  else if (i2 === 224)
                    c = "\u03B1";
                  else if (i2 === 225)
                    c = "\u03B2";
                  else if (i2 === 226)
                    c = "\u0393";
                  else if (i2 === 227)
                    c = "\u03C0";
                  else if (i2 === 228)
                    c = "\u03A3";
                  else if (i2 === 229)
                    c = "\u03C3";
                  else if (i2 === 230)
                    c = "\xB5";
                  else if (i2 === 231)
                    c = "\u03C4";
                  else if (i2 === 232)
                    c = "\u03A6";
                  else if (i2 === 233)
                    c = "\u0398";
                  else if (i2 === 234)
                    c = "\u03A9";
                  else if (i2 === 235)
                    c = "\u03B4";
                  else if (i2 === 236)
                    c = "\u221E";
                  else if (i2 === 237)
                    c = "\u2205";
                  else if (i2 === 238)
                    c = "\u2208";
                  else if (i2 === 239)
                    c = "\u2229";
                  else if (i2 === 240)
                    c = "\u2261";
                  else if (i2 === 241)
                    c = "\xB1";
                  else if (i2 === 242)
                    c = "\u2265";
                  else if (i2 === 243)
                    c = "\u2264";
                  else if (i2 === 244)
                    c = "\u2320";
                  else if (i2 === 245)
                    c = "\u2321";
                  else if (i2 === 246)
                    c = "\xF7";
                  else if (i2 === 247)
                    c = "\u2248";
                  else if (i2 === 248)
                    c = "\xB0";
                  else if (i2 === 249)
                    c = "\u2219";
                  else if (i2 === 250)
                    c = "\xB7";
                  else if (i2 === 251)
                    c = "\u221A";
                  else if (i2 === 252)
                    c = "\u207F";
                  else if (i2 === 253)
                    c = "\xB2";
                  else if (i2 === 254)
                    c = "\u25A0";
                } else if (i2 > 255)
                  format.unicode = true;
                stringBuilder.push(c);
                this._MXPCapture(c);
                lineLength++;
                this.textLength++;
                this._mxpState.noBreak = false;
              }
              break;
          }
        }
        if (this._SplitBuffer.length) {
          this.rawLength -= this._SplitBuffer.length;
          rawBuilder.splice(rawBuilder.length - this._SplitBuffer.length, this._SplitBuffer.length);
        }
        formatBuilder.push(...this._getMXPCloseFormatBlocks());
        if (state === 11 /* URLFound */) {
          formatBuilder.splice(
            fLnk,
            0,
            {
              formatType: 1 /* Link */,
              offset: lnkOffset,
              href: _MXPComment += stringBuilder.slice(lnk).join("")
            }
          );
        }
        this._AddLine(stringBuilder.join(""), rawBuilder.join(""), true, false, formatBuilder, remote);
      } catch (ex2) {
        if (this.enableDebug) this.emit("debug", ex2);
      }
      this.busy = false;
      this.emit("parse-done");
      this._parsing.shift();
      if (this._parsing.length > 0)
        setTimeout(this._parseNext(), 0);
    }
    _parseNext() {
      const iTmp = this._parsing.shift();
      return () => {
        this.parse(iTmp[0], iTmp[1], true, iTmp[2]);
      };
    }
    updateWindow(width, height) {
      this.window = { width, height };
    }
    Clear() {
      this._ResetColors();
      this.textLength = 0;
      this._SplitBuffer = "";
    }
    ClearMXP() {
      this._mxpEntities = {};
      this.ResetMXP();
      this._mxpElements = {};
      this._mxpState = new MXPState();
    }
    ResetMXP() {
      this._mxpStyles = [];
      this._mxpStyles.push(new MXPStyle(0 /* None */, "", "", false));
    }
    ResetMXPLine() {
      this._iMXPDefaultMode = 0 /* Open */;
      this._mxpState.lineType = 0 /* Open */;
    }
    //public interface, as client can only access publicly marked entities
    GetPublicEntity(entity) {
      if (this._mxpEntities[entity] && this._mxpEntities[entity].publish)
        return this._mxpEntities[entity].value;
      return entity;
    }
  };

  // src/display.ts
  var Display = class extends EventEmitter {
    //#endregion
    constructor(container, options) {
      super();
      this._updating = 0 /* none */;
      this._enableDebug = false;
      this._maxView = 0;
      this._padding = [0, 0, 0, 0];
      this._enableColors = true;
      this._enableBackgroundColors = true;
      this._hideTrailingEmptyLine = true;
      this._maxLines = 500;
      this._wordWrap = false;
      this._indent = 4;
      this._indentPadding = 0;
      this._wrapAt = 0;
      this._scrollAtEnd = false;
      this._lineCache = [];
      this._expireCache = [];
      this._timestamp = 0 /* None */;
      this._timestampFormat = "[[]MM-DD HH:mm:ss.SSS[]] ";
      this._timestampWidth = (/* @__PURE__ */ new Date()).toISOString().length + 1;
      this._mouseDown = false;
      //#endregion
      //#region Public properties
      this.scrollLock = false;
      if (!container)
        throw new Error("Container must be a selector, element, jquery object or display options");
      if (typeof container === "object" && "container" in container) {
        options = Object.assign(options || {}, container);
        container = options.container;
        delete options.container;
      }
      if (typeof container === "string") {
        this._container = document.querySelector(container);
        if (!this._container)
          throw new Error("Invalid selector for display.");
      } else if (container instanceof $)
        this._container = container[0];
      else if (container instanceof HTMLElement)
        this._container = container;
      else if (container.ownerDocument.defaultView && container instanceof container.ownerDocument.defaultView.HTMLElement)
        this._container = container;
      else
        throw new Error("Container must be a selector, element or jquery object");
      this._document = this._container.ownerDocument;
      this._window = this._document.defaultView;
      this._styles = this._document.createElement("style");
      this._container.appendChild(this._styles);
      this._character = this._document.createElement("span");
      this._character.id = this.id + "-Character";
      this._character.className = "line";
      this._character.innerHTML = '<span style="border-bottom: 1px solid rgb(0, 0, 0);">W</span>';
      this._character.style.visibility = "hidden";
      this._container.appendChild(this._character);
      this._view = this._document.createElement("div");
      this._view.className = "view";
      this._view.addEventListener("scroll", () => {
        this._scrollAtEnd = this._view.clientHeight + this._view.scrollTop >= this._view.scrollHeight;
      });
      this._view.addEventListener("click", (e) => {
        this.emit("click", e);
      });
      this._view.addEventListener("contextmenu", (e) => {
        this.emit("contextmenu", e);
      });
      this._view.addEventListener("mousedown", (e) => {
        this.emit("mousedown", e);
        this._mouseDown = true;
      });
      this._view.addEventListener("mouseup", (e) => {
        this.emit("mouseup", e);
        if (this._mouseDown)
          this.emit("selection-done");
        this._mouseDown = false;
      });
      this._container.appendChild(this._view);
      this._charHeight = parseFloat(this._window.getComputedStyle(this._character).height);
      this._charWidth = parseFloat(this._window.getComputedStyle(this._character.firstElementChild).width);
      if (!options)
        options = { display: this };
      else
        options.display = this;
      this.model = new DisplayModel(options);
      this._wResize = (e) => {
        if (this._scrollAtEnd)
          this.scrollDisplay();
        debounce(() => {
          this._doUpdate(1 /* update */ | 16 /* updateWindow */);
        }, 250, "resize");
      };
      this._selection = (e) => {
        if (this._mouseDown)
          debounce(() => {
            this.emit("selection-changed");
          }, 250, "selection-changed");
      };
      this._window.addEventListener("resize", this._wResize.bind(this));
      this._document.addEventListener("selectionchange", this._selection.bind(this));
      this._resizeObserver = new ResizeObserver((entries, observer) => {
        if (entries.length === 0) return;
        if (!entries[0].contentRect || entries[0].contentRect.width === 0 || entries[0].contentRect.height === 0)
          return;
        debounce(() => {
          if (!this._resizeObserverCache || this._resizeObserverCache.width !== entries[0].contentRect.width || this._resizeObserverCache.height !== entries[0].contentRect.height) {
            if (this._scrollAtEnd)
              this.scrollDisplay();
            this._resizeObserverCache = { width: entries[0].contentRect.width, height: entries[0].contentRect.height };
            this._doUpdate(1 /* update */ | 16 /* updateWindow */);
            this.emit("resize");
          }
        }, 250, "resize");
      });
      this._resizeObserver.observe(this._container);
      this._observer = new MutationObserver((mutationsList) => {
        let mutation;
        for (mutation of mutationsList) {
          if (mutation.type === "attributes" && mutation.attributeName === "style") {
            if (this._scrollAtEnd)
              this.scrollDisplay();
            this._doUpdate(1 /* update */ | 16 /* updateWindow */);
            this.emit("resize");
          }
        }
      });
      this._observer.observe(this._container, { attributes: true, attributeOldValue: true, attributeFilter: ["style"] });
      if (!moment || this._timestamp !== 2 /* Format */)
        this._timestampWidth = (/* @__PURE__ */ new Date()).toISOString().length + 1;
      else
        this._timestampWidth = moment().format(this._timestampFormat).length;
      this.updateFont();
    }
    get showTimestamp() {
      return this._timestamp;
    }
    set showTimestamp(value) {
      if (value === this._timestamp) return;
      if (typeof value === "boolean")
        this._timestamp = value ? 2 /* Format */ : 0 /* None */;
      this._timestamp = value;
      if (!moment || this._timestamp !== 2 /* Format */)
        this._timestampWidth = (/* @__PURE__ */ new Date()).toISOString().length + 1;
      else
        this._timestampWidth = moment().format(this._timestampFormat).length;
      this._buildStyleSheet();
      this._doUpdate(2 /* display */ | 1 /* update */ | 32 /* rebuildLines */);
    }
    get timestampFormat() {
      return this._timestampFormat;
    }
    set timestampFormat(value) {
      if (this._timestampFormat === value) return;
      this._timestampFormat = value;
      if (!moment || this._timestamp !== 2 /* Format */)
        this._timestampWidth = (/* @__PURE__ */ new Date()).toISOString().length + 1;
      else
        this._timestampWidth = moment().format(this._timestampFormat).length;
      this._doUpdate(2 /* display */ | 32 /* rebuildLines */ | 16 /* updateWindow */ | 1 /* update */);
    }
    get wordWrap() {
      return this._wordWrap;
    }
    set wordWrap(value) {
      if (value === this._wordWrap) return;
      this._wordWrap = value;
      this._buildStyleSheet();
      this._doUpdate(1 /* update */);
    }
    get wrapAt() {
      return this._wrapAt;
    }
    set wrapAt(value) {
      if (value === this._wrapAt) return;
      this._wrapAt = value;
      this._buildStyleSheet();
      this._doUpdate(1 /* update */ | 2 /* display */);
    }
    get indent() {
      return this._indent;
    }
    set indent(value) {
      if (value === this._indent)
        return;
      this._indent = value;
      this._buildStyleSheet();
      this._doUpdate(1 /* update */ | 2 /* display */);
    }
    get linkFunction() {
      return this._linkFunction || "doLink";
    }
    set linkFunction(val) {
      this._linkFunction = val;
    }
    get mxpLinkFunction() {
      return this._mxpLinkFunction || "doMXPLink";
    }
    set mxpLinkFunction(val) {
      this._mxpLinkFunction = val;
    }
    get mxpSendFunction() {
      return this._mxpSendFunction || "doMXPSend";
    }
    set mxpSendFunction(val) {
      this._mxpSendFunction = val;
    }
    get mxpTooltipFunction() {
      return this._mxpTooltipFunction || "doMXPTooltip";
    }
    set mxpTooltipFunction(val) {
      this._mxpTooltipFunction = val;
    }
    get id() {
      if (this._container) return this._container.id;
      return "";
    }
    get container() {
      return this._container;
    }
    get lines() {
      return this._model.lines;
    }
    get model() {
      return this._model;
    }
    set model(value) {
      if (this._model === value) return;
      if (this._model)
        this._model.removeAllListeners();
      this._model = value;
      this._model.on("debug", this.debug, this);
      this._model.on("bell", () => {
        this.emit("bell");
      });
      this._model.on("add-line", (data) => {
        this.emit("add-line", data);
      });
      this._model.on("add-line-done", (data) => {
        this.emit("add-line-done", data);
      });
      this._model.on("line-added", (data, noUpdate) => {
        this._lineCache.push(this.getLineHTML(data.idx));
      });
      this._model.on("expire-links", (args) => {
        if (this._expireCache.length) {
          for (let x2 = 0, xl = this._expireCache.length; x2 < xl; x2++)
            this._rebuildLine(this._expireCache[x2]);
        }
        this._expireCache = [];
        this.emit("expire-links");
      });
      this._model.on("parse-done", () => {
        this._view.insertAdjacentHTML("beforeend", this._lineCache.join(""));
        this._lineCache = [];
        this._doUpdate(2 /* display */);
        this.emit("parse-done");
      });
      this._model.on("set-title", (title, type) => {
        this.emit("set-title", title, type);
      });
      this._model.on("music", (data) => {
        this.emit("music", data);
      });
      this._model.on("sound", (data) => {
        this.emit("sound", data);
      });
      this._model.on("MXP-tag-reply", (tag, args) => {
        this.emit("MXP-tag-reply", tag, args);
      });
      this._model.on("expire-link-line", (idx) => {
        this._expireCache.push(idx);
        this._doUpdate(2 /* display */);
      });
    }
    get maxLines() {
      return this._maxLines;
    }
    set maxLines(value) {
      if (value !== this._maxLines) {
        this._maxLines = value;
        this._doUpdate(4 /* trim */);
      }
    }
    get enableDebug() {
      return this._enableDebug;
    }
    get enableColors() {
      return this._enableColors;
    }
    set enableColors(value) {
      if (value === this._enableColors) return;
      this._enableColors = value;
      this._buildStyleSheet();
    }
    get enableBackgroundColors() {
      return this._enableBackgroundColors;
    }
    set enableBackgroundColors(value) {
      if (value === this._enableBackgroundColors) return;
      this._enableBackgroundColors = value;
      this._buildStyleSheet();
    }
    get hideTrailingEmptyLine() {
      return this._hideTrailingEmptyLine;
    }
    set hideTrailingEmptyLine(value) {
      if (value === this._hideTrailingEmptyLine) return;
      this._hideTrailingEmptyLine = value;
      this._doUpdate(2 /* display */);
    }
    set enableDebug(enable) {
      this._enableDebug = enable;
      this._model.enableDebug = enable;
    }
    get tabWidth() {
      return this._model.tabWidth;
    }
    set tabWidth(value) {
      this._model.tabWidth = value;
    }
    get textLength() {
      return this._model.textLength;
    }
    get EndOfLine() {
      return this._model.EndOfLine;
    }
    get parseQueueLength() {
      return this._model.parseQueueLength;
    }
    get parseQueueEndOfLine() {
      return this._model.parseQueueEndOfLine;
    }
    get EndOfLineLength() {
      if (this.lines.length === 0)
        return 0;
      return this.lines[this.lines.length - 1].text.length;
    }
    set enableFlashing(value) {
      this._model.enableFlashing = value;
    }
    get enableFlashing() {
      return this._model.enableFlashing;
    }
    set enableMXP(value) {
      this._model.enableMXP = value;
    }
    get enableMXP() {
      return this._model.enableMXP;
    }
    set showInvalidMXPTags(value) {
      this._model.showInvalidMXPTags = value;
    }
    get showInvalidMXPTags() {
      return this._model.showInvalidMXPTags;
    }
    set enableBell(value) {
      this._model.enableBell = value;
    }
    get enableBell() {
      return this._model.enableBell;
    }
    set enableURLDetection(value) {
      this._model.enableURLDetection = value;
    }
    get enableURLDetection() {
      return this._model.enableURLDetection;
    }
    set enableMSP(value) {
      this._model.enableMSP = value;
    }
    get enableMSP() {
      return this._model.enableMSP;
    }
    set displayControlCodes(value) {
      this._model.displayControlCodes = value;
    }
    get displayControlCodes() {
      return this._model.displayControlCodes;
    }
    set emulateTerminal(value) {
      this._model.emulateTerminal = value;
    }
    get emulateTerminal() {
      return this._model.emulateTerminal;
    }
    set emulateControlCodes(value) {
      this._model.emulateControlCodes = value;
    }
    get emulateControlCodes() {
      return this._model.emulateControlCodes;
    }
    set MXPStyleVersion(value) {
      this._model.MXPStyleVersion = value;
    }
    get MXPStyleVersion() {
      return this._model.MXPStyleVersion;
    }
    get WindowSize() {
      return new Size(this.WindowWidth, this.WindowHeight);
    }
    get WindowWidth() {
      return Math.trunc(this._maxView / this._charWidth);
    }
    get WindowHeight() {
      if (this._view.scrollWidth > this._view.clientWidth)
        return Math.trunc((this._innerHeight - getScrollbarWidth() - this._padding[0] - this._padding[2]) / this._charHeight);
      return Math.trunc((this._innerHeight - this._padding[0] - this._padding[2]) / this._charHeight);
    }
    get html() {
      const l2 = this.lines.length;
      const html = [];
      for (let idx = 0; idx < l2; idx++)
        html.push(this.getLineHTML(idx));
      return html.join("");
    }
    get text() {
      return this._model.text;
    }
    get raw() {
      return this._model.raw;
    }
    get scrollAtBottom() {
      return this._scrollAtEnd;
    }
    debug(msg) {
      this.emit("debug", msg);
    }
    scrollDisplay() {
      if (!this.scrollLock)
        this._view.scrollTop = this._view.scrollHeight;
    }
    scrollTo(x2, y2) {
      this._view.scrollTo(x2, y2);
    }
    scrollToCharacter(x2, y2) {
      this._view.scrollTo(x2 * this._charHeight, y2 * this._charWidth);
    }
    scrollBy(x2, y2) {
      this._view.scrollBy(x2, y2);
    }
    scrollUp() {
      this._view.scrollBy(0, -this._charHeight);
    }
    scrollDown() {
      this._view.scrollBy(0, this._charHeight);
    }
    pageUp() {
      this._view.scrollBy(0, -this._view.clientHeight);
    }
    pageDown() {
      this._view.scrollBy(0, this._view.clientHeight);
    }
    trimLines() {
      if (this._maxLines === -1)
        return;
      if (this.lines.length > this._maxLines) {
        const amt = this.lines.length - this._maxLines;
        let r = amt;
        while (r-- > 0)
          this._view.removeChild(this._view.firstChild);
        this._model.removeLines(0, amt);
      }
    }
    append(txt, remote, force, prependSplit) {
      this._model.append(txt, remote || false, force || false, prependSplit || false);
    }
    CurrentAnsiCode() {
      return this._model.CurrentAnsiCode();
    }
    removeLine(line2, noUpdate) {
      if (line2 < 0 || line2 >= this.lines.length) return;
      this.emit("line-removed", line2, this.lines[line2].text);
      const id = this._model.getLineID(line2);
      const elLine = this._document.querySelector(`[data-id="${id}"]`);
      this._view.removeChild(elLine);
      this._model.removeLine(line2);
    }
    removeLines(line2, amt) {
      if (line2 < 0 || line2 >= this.lines.length) return;
      if (amt < 1) amt = 1;
      this.emit("lines-removed", line2, this.lines.slice(line2, line2 + amt - 1));
      this._view.replaceChildren(...[].slice.call(this._view.children, 0, line2), ...[].slice.call(this._view.children, line2 + amt));
      this._model.removeLines(line2, amt);
    }
    _updateDisplay() {
      this._view.classList.remove("animate");
      this._doUpdate(4 /* trim */);
      if (this._hideTrailingEmptyLine && this.lines.length && this.lines[this.lines.length - 1].text.length === 0)
        this._view.lastChild.style.display = "none";
      this._doUpdate(8 /* scrollEnd */ | 16 /* updateWindow */);
      this._view.classList.add("animate");
    }
    updateWindow(width, height) {
      if (width === void 0) {
        width = this.WindowWidth;
        height = this.WindowHeight;
      }
      this._model.updateWindow(width, height);
      this.emit("update-window", width, height);
    }
    clear() {
      this._model.clear();
      this._view.innerHTML = "";
    }
    dispose() {
      this._document.body.removeChild(this._character);
      this._document.body.removeChild(this._styles);
      while (this._container.firstChild)
        this._view.removeChild(this._view.firstChild);
      this._window.removeEventListener("resize", this._wResize);
      this._document.removeEventListener("selectionchange", this._selection);
    }
    _update() {
      const scrollWidth = getScrollbarWidth();
      this._maxView = this._view.clientWidth - this._padding[1] - this._padding[3] - scrollWidth - this._indentPadding;
      if (this._timestamp !== 0 /* None */)
        this._maxView -= this._timestampWidth * this._charWidth;
      this._innerHeight = this._view.clientHeight;
    }
    updateFont(font, size) {
      if (!font || font.length === 0)
        font = '"Courier New", Courier, monospace';
      else
        font += ", monospace";
      if (!size || size.length === 0)
        size = "1em";
      if (font !== this._container.style.fontFamily || size !== this._container.style.fontSize) {
        this._container.style.fontSize = size;
        this._container.style.fontFamily = font;
        this._character.style.fontSize = size;
        this._character.style.fontFamily = font;
        this._charHeight = parseFloat(this._window.getComputedStyle(this._character).height);
        this._charWidth = parseFloat(this._window.getComputedStyle(this._character.firstElementChild).width);
        setTimeout(() => {
          this._charHeight = parseFloat(this._window.getComputedStyle(this._character).height);
          this._charWidth = parseFloat(this._window.getComputedStyle(this._character.firstElementChild).width);
        }, 250);
        this._buildStyleSheet();
        this._doUpdate(8 /* scrollEnd */ | 16 /* updateWindow */ | 1 /* update */);
      }
      const pc = this._window.getComputedStyle(this._view);
      const padding = [
        parseInt(pc.getPropertyValue("padding-top")) || 0,
        parseInt(pc.getPropertyValue("padding-right")) || 0,
        parseInt(pc.getPropertyValue("padding-bottom")) || 0,
        parseInt(pc.getPropertyValue("padding-left")) || 0
      ];
      if (padding[0] !== this._padding[0] || padding[1] !== this._padding[1] || padding[2] !== this._padding[2] || padding[3] !== this._padding[3]) {
        this._padding = padding;
        this._doUpdate(1 /* update */);
      }
    }
    _buildStyleSheet() {
      let styles = "";
      if (!this._enableColors)
        styles += ".view > span span {color: inherit !important;}";
      if (!this._enableColors || !this._enableBackgroundColors)
        styles += ".background > span span {background-color: inherit !important;}";
      if (this._wordWrap)
        styles += ".view {white-space: break-spaces; }";
      else if (this._wrapAt > 0)
        styles += `.view {white-space: break-spaces; } .line {width: ${this._wrapAt * this._charWidth}px !important;max-width:  ${this._wrapAt * this._charWidth}px;min-width:  ${this._wrapAt * this._charWidth}px;display: block;}`;
      if ((this._wordWrap || this._wrapAt > 0) && this._indent > 0)
        styles += `.view {  padding-left: 0px !important; text-indent: ${this._indent * this._charWidth}px hanging; }`;
      styles += `.line > span { min-height: ${this._charHeight}}`;
      if (this._timestamp !== 0 /* None */)
        styles += ".timestamp { display: inline-block; }";
      this._styles.innerHTML = styles;
      if ((this._wordWrap || this._wrapAt > 0) && this._indent > 0)
        this._indentPadding = parseFloat(this._window.getComputedStyle(this._view).paddingLeft) / 2;
      else
        this._indentPadding = 0;
    }
    getLineHTML(idx, start, len, inner) {
      if (idx === void 0 || idx >= this.lines.length)
        idx = this.lines.length - 1;
      else if (idx < 0)
        idx = 0;
      if (start === void 0 || start < 0)
        start = 0;
      if (len === void 0 || len === -1)
        len = this.lines[idx].text.length;
      const parts = [];
      let offset2 = 0;
      let style = "";
      let fCls = "";
      const text = this.lines[idx].text;
      const formats = this.lines[idx].formats;
      const fLen = formats.length;
      let right = false;
      const id = this._model.getLineID(idx);
      if (this._timestamp === 2 /* Format */ && moment)
        parts.push('<span class="timestamp" style="color:', this._model.GetColor(-7), ";background:", this._model.GetColor(-8), ';"', fCls, ">", moment(this.lines[idx].timestamp).format(this._timestampFormat), "</span>");
      else if (this._timestamp !== 0 /* None */)
        parts.push('<span class="timestamp" style="color:', this._model.GetColor(-7), ";background:", this._model.GetColor(-8), ';"', fCls, ">", new Date(this.lines[idx].timestamp).toISOString(), " </span>");
      for (let f = 0; f < fLen; f++) {
        const format = formats[f];
        let nFormat;
        let end;
        const td = [];
        if (f < fLen - 1) {
          nFormat = formats[f + 1];
          if (format.offset === nFormat.offset && nFormat.formatType === format.formatType)
            continue;
          end = nFormat.offset;
        } else
          end = text.length;
        offset2 = format.offset;
        if (end > len)
          end = len;
        if (offset2 < start)
          offset2 = start;
        if (format.formatType === 0 /* Normal */) {
          style = [];
          fCls = [];
          if (typeof format.background === "number")
            style.push("background:", this._model.GetColor(format.background), ";");
          else if (format.background)
            style.push("background:", format.background, ";");
          if (typeof format.color === "number")
            style.push("color:", this._model.GetColor(format.color), ";");
          else if (format.color)
            style.push("color:", format.color, ";");
          if (format.font)
            style.push("font-family: ", format.font, ";");
          if (format.size)
            style.push("font-size: ", format.size, ";");
          if (format.style !== 0 /* None */) {
            if ((format.style & 1 /* Bold */) === 1 /* Bold */)
              style.push("font-weight: bold;");
            if ((format.style & 4 /* Italic */) === 4 /* Italic */)
              style.push("font-style: italic;");
            if ((format.style & 1024 /* Overline */) === 1024 /* Overline */)
              td.push("overline ");
            if ((format.style & 512 /* DoubleUnderline */) === 512 /* DoubleUnderline */ || (format.style & 8 /* Underline */) === 8 /* Underline */)
              td.push("underline ");
            if ((format.style & 512 /* DoubleUnderline */) === 512 /* DoubleUnderline */)
              style.push("border-bottom: 1px solid ", typeof format.color === "number" ? this._model.GetColor(format.color) : format.color, ";");
            else
              style.push("border-bottom: 1px solid ", typeof format.background === "number" ? this._model.GetColor(format.background) : format.background, ";");
            if ((format.style & 32 /* Rapid */) === 32 /* Rapid */ || (format.style & 16 /* Slow */) === 16 /* Slow */) {
              if (this.enableFlashing)
                fCls.push(" ansi-blink");
              else if ((format.style & 512 /* DoubleUnderline */) !== 512 /* DoubleUnderline */ && (format.style & 8 /* Underline */) !== 8 /* Underline */)
                td.push("underline ");
            }
            if ((format.style & 256 /* Strikeout */) === 256 /* Strikeout */)
              td.push("line-through ");
            if (td.length > 0)
              style.push("text-decoration:", td.join("").trim(), ";");
          } else
            style.push("border-bottom: 1px solid ", typeof format.background === "number" ? this._model.GetColor(format.background) : format.background, ";");
          if (offset2 < start || end < start)
            continue;
          style = style.join("").trim();
          if (fCls.length !== 0)
            fCls = ' class="' + fCls.join("").trim() + '"';
          else
            fCls = "";
          if (format.hr)
            parts.push('<span style="', style, 'min-width:100%;width:100%;"', fCls, '><div style="position:relative;top: 50%;transform: translateY(-50%);height:4px;width:100%; background-color:', typeof format.color === "number" ? this._model.GetColor(format.color) : format.color, '"></div></span>');
          else if (end - offset2 !== 0)
            parts.push('<span style="', style, '"', fCls, ">", htmlEncode(text.substring(offset2, end)), "</span>");
        } else if (format.formatType === 1 /* Link */) {
          if (offset2 < start || end < start)
            continue;
          parts.push('<a draggable="false" class="URLLink" href="javascript:void(0);" title="');
          parts.push(format.href.replace(/"/g, "&quot;"));
          parts.push('" onclick="', this.linkFunction, "('", format.href.replace(/\\/g, "\\\\").replace(/"/g, "&quot;"), `');return false;">`);
          if (end - offset2 === 0) continue;
          parts.push('<span style="', style, '"', fCls, ">");
          parts.push(htmlEncode(text.substring(offset2, end)));
          parts.push("</span>");
        } else if (format.formatType === 2 /* LinkEnd */ || format.formatType === 4 /* MXPLinkEnd */ || format.formatType === 8 /* MXPSendEnd */) {
          if (offset2 < start || end < start)
            continue;
          parts.push("</a>");
        } else if (format.formatType === 3 /* MXPLink */) {
          if (offset2 < start || end < start)
            continue;
          parts.push('<a draggable="false" class="MXPLink" href="javascript:void(0);" title="');
          parts.push(format.href.replace(/"/g, "&quot;"));
          parts.push('"');
          if (format.expire && format.expire.length)
            parts.push(` data-expire="${format.expire}"`);
          parts.push(' onclick="', this.mxpLinkFunction, "(this, '", format.href.replace(/\\/g, "\\\\").replace(/"/g, "&quot;"), `');return false;">`);
          if (end - offset2 === 0) continue;
          parts.push('<span style="', style, '"', fCls, ">");
          parts.push(htmlEncode(text.substring(offset2, end)));
          parts.push("</span>");
        } else if (format.formatType === 7 /* MXPSend */) {
          if (offset2 < start || end < start)
            continue;
          parts.push('<a draggable="false" class="MXPLink" href="javascript:void(0);" title="');
          parts.push(format.hint.replace(/"/g, "&quot;"));
          parts.push('"');
          if (format.expire && format.expire.length)
            parts.push(` data-expire="${format.expire}"`);
          parts.push(' onmouseover="', this.mxpTooltipFunction, '(this);"');
          parts.push(' onclick="', this.mxpSendFunction, "(event||window.event, this, ", format.href.replace(/\\/g, "\\\\").replace(/"/g, "&quot;"), ", ", format.prompt ? "1" : "0", ", ", format.tt.replace(/\\/g, "\\\\").replace(/"/g, "&quot;"), ');return false;">');
          if (end - offset2 === 0) continue;
          parts.push('<span style="', style, '"', fCls, ">");
          parts.push(htmlEncode(text.substring(offset2, end)));
          parts.push("</span>");
        } else if (format.formatType === 9 /* MXPExpired */ && end - offset2 !== 0) {
          if (offset2 < start || end < start)
            continue;
          parts.push('<span style="', style, '"', fCls, ">");
          parts.push(htmlEncode(text.substring(offset2, end)));
          parts.push("</span>");
        } else if (format.formatType === 5 /* Image */) {
          if (offset2 < start || end < start)
            continue;
          let tmp = "";
          parts.push('<img src="');
          if (format.url.length > 0) {
            parts.push(format.url);
            tmp += format.url;
            if (!format.url.endsWith("/")) {
              parts.push("/");
              tmp += "/";
            }
          }
          if (format.t.length > 0) {
            parts.push(format.t);
            tmp += format.t;
            if (!format.t.endsWith("/")) {
              parts.push("/");
              tmp += "/";
            }
          }
          tmp += format.name;
          parts.push(format.name, '"  style="');
          if (format.w.length > 0)
            parts.push("width:", formatUnit(format.w, this._charWidth), ";");
          if (format.h.length > 0)
            parts.push("height:", formatUnit(format.h, this._charHeight), ";");
          switch (format.align.toLowerCase()) {
            case "left":
              parts.push("float:left;");
              break;
            case "right":
              parts.push("float:right;");
              right = true;
              break;
            case "top":
            case "middle":
            case "bottom":
              parts.push("vertical-align:", format.align, ";");
              break;
          }
          if (format.hspace.length > 0 && format.vspace.length > 0) {
            parts.push("margin:");
            parts.push(formatUnit(format.vspace, this._charWidth), " ");
            parts.push(formatUnit(format.hspace, this._charHeight), ";");
          } else if (format.hspace.length > 0) {
            parts.push("margin:");
            parts.push("0px ", formatUnit(format.hspace, this._charHeight), ";");
          } else if (format.vspace.length > 0) {
            parts.push("margin:");
            parts.push(formatUnit(format.vspace, this._charWidth), " 0px;");
          }
          parts.push('"');
          if (format.ismap) parts.push(' ismap onclick="return false;"');
          parts.push(`src="${tmp}"/>`);
        }
      }
      if (inner) {
        if (right && len < this.lines[idx].text.length)
          return parts.join("");
        if (right)
          return parts.join("") + "<br>";
        if (len < this.lines[idx].text.length)
          return parts.join("");
        return parts.join("") + "<br>";
      }
      if (right && len < this.lines[idx].text.length)
        return `<span data-id="${id}" class="line" style="min-width:100%">${parts.join("")}</span>`;
      if (right)
        return `<span data-id="${id}" class="line" style="min-width:100%">${parts.join("")}<br></span>`;
      if (len < this.lines[idx].text.length)
        return `<span data-id="${id}" class="line">${parts.join("")}</span>`;
      return `<span  data-id="${id}" class="line">${parts.join("")}<br></span>`;
    }
    getLineText(line2, full) {
      if (line2 < 0 || line2 >= this.lines.length || !this.lines[line2]) return "";
      return this.lines[line2].text;
    }
    _rebuildLine(start) {
      this._rebuildLines(start, start);
    }
    _rebuildLines(start, end) {
      if (!this.lines.length) return;
      if (start === void 0 || start < 0)
        start = 0;
      if (end === void 0 || end === -1 || end >= this.lines.length)
        end = this.lines.length - 1;
      let _html = [];
      let line2 = start;
      for (; line2 <= end; line2++) {
        _html.push(this.getLineHTML(line2));
      }
      if (start === 0 && end === this.lines.length - 1)
        this._view.innerHTML = _html.join("");
      else {
        this._view.replaceChildren(...[].slice.call(this._view.children, 0, start), ...[].slice.call(this._view.children, end + 1));
        if (start === 0)
          this._view.firstElementChild.insertAdjacentHTML("beforebegin", _html.join(""));
        else {
          this._view.children[start - 1].insertAdjacentHTML("afterend", _html.join(""));
        }
      }
    }
    _doUpdate(type) {
      if (!type) return;
      this._updating |= type;
      if (this._updating === 0 /* none */)
        return;
      this._window.requestAnimationFrame(() => {
        if (this._updating === 0 /* none */)
          return;
        if ((this._updating & 32 /* rebuildLines */) === 32 /* rebuildLines */) {
          this._rebuildLines();
          this._updating &= ~32 /* rebuildLines */;
        }
        if ((this._updating & 1 /* update */) === 1 /* update */) {
          this._update();
          this._updating &= ~1 /* update */;
        }
        if ((this._updating & 2 /* display */) === 2 /* display */) {
          this._updateDisplay();
          this._updating &= ~2 /* display */;
        }
        if ((this._updating & 4 /* trim */) === 4 /* trim */) {
          this.trimLines();
          this._updating &= ~4 /* trim */;
        }
        if ((this._updating & 8 /* scrollEnd */) === 8 /* scrollEnd */) {
          this.scrollDisplay();
          this._updating &= ~8 /* scrollEnd */;
        }
        if ((this._updating & 16 /* updateWindow */) === 16 /* updateWindow */) {
          this.updateWindow();
          this._updating &= ~16 /* updateWindow */;
        }
        this._doUpdate(this._updating);
      });
    }
    colorSubStrByLine(idx, fore, back, start, len, style) {
      this.colorSubStringByLine(idx, fore, back, start, (start || 0) + (len || 0), style);
    }
    colorSubStringByLine(idx, fore, back, start, end, style) {
      if (!this._model.colorSubStringByLine(idx, fore, back, start, end, style))
        return;
      this._rebuildLine(idx);
    }
    removeStyleSubStrByLine(idx, style, start, len) {
      this.removeStyleSubStringByLine(idx, style, start, (start || 0) + (len || 0));
    }
    //color like javascript.substring using 0 index for start and end
    removeStyleSubStringByLine(idx, style, start, end) {
      if (!this._model.removeStyleSubStringByLine(idx, style, start, end))
        return;
      this._rebuildLine(idx);
    }
    highlightSubStrByLine(idx, start, len) {
      this.highlightStyleSubStringByLine(idx, start, (start || 0) + (len || 0));
    }
    //color like javascript.substring using 0 index for start and end
    highlightStyleSubStringByLine(idx, start, end, color) {
      if (!this._model.highlightStyleSubStringByLine(idx, start, end, color))
        return;
      this._rebuildLine(idx);
    }
    SetColor(code, color) {
      this._model.SetColor(code, color);
    }
    ClearMXP() {
      this._model.ClearMXP();
    }
    ResetMXPLine() {
      this._model.ResetMXPLine();
    }
    get hasSelection() {
      const selection = this._window.getSelection();
      if (selection.rangeCount > 0) {
        const range = selection.getRangeAt(0);
        return this._view.contains(range.commonAncestorContainer) && selection.toString().length !== 0;
      }
      return false;
    }
    get selection() {
      if (this._window.getSelection) {
        const selection = this._window.getSelection();
        if (selection.rangeCount > 0) {
          const range = selection.getRangeAt(0);
          if (this._view.contains(range.startContainer) || this._view.contains(range.endContainer)) {
            return selection.toString();
          }
        }
      }
      return "";
    }
    get selectionAsHTML() {
      var range;
      if (this._window.getSelection) {
        var selection = this._window.getSelection();
        if (selection.rangeCount > 0) {
          range = selection.getRangeAt(0);
          if (!this._view.contains(range.startContainer) && !this._view.contains(range.endContainer))
            return "";
          var clonedSelection = range.cloneContents();
          var div = this._document.createElement("div");
          div.appendChild(clonedSelection);
          return div.innerHTML;
        } else {
          return "";
        }
      } else if (this._document.selection && this._document.selection.createRange) {
        range = this._document.selection.createRange();
        return range.htmlText;
      } else {
        return "";
      }
    }
    selectAll() {
      let range;
      if (this._window.getSelection) {
        if (this._window.getSelection().selectAllChildren)
          this._window.getSelection().selectAllChildren(this._view);
        else {
          range = this._document.createRange();
          range.selectNode(this._view);
          this._window.getSelection().addRange(range);
        }
      } else if (this._document.selection) {
        range = this._document.body.createTextRange();
        range.moveToElementText(this._view);
        range.select();
      }
    }
    clearSelection() {
      const selection = this._window.getSelection();
      if (selection.rangeCount > 0) {
        const range = selection.getRangeAt(0);
        if (this._view.contains(range.startContainer) || this._view.contains(range.endContainer)) {
          selection.removeAllRanges();
        }
      }
    }
    getLineOffset(x2, y2) {
      const elements = this._document.elementsFromPoint(x2, y2);
      let element;
      for (let e = 0, el = elements.length; e < el; e++) {
        if (this._view === elements[e]) break;
        if (this._view.contains(elements[e])) {
          element = elements[e];
          break;
        }
      }
      if (!element || !this._view.contains(element) && this._view != element)
        return { x: -1, y: -1, lineID: -1 };
      if (element.classList.contains("line"))
        return { x: 0, y: this.model.getLineFromID(+element.dataset.id), lineID: +element.dataset.id };
      const line2 = element.closest(".line");
      if (line2)
        return { x: 0, y: this.model.getLineFromID(+line2.dataset.id), lineID: +line2.dataset.id };
      return { x: -1, y: -1, lineID: -1 };
    }
    getWordFromPosition(x2, y2) {
      const elements = this._document.elementsFromPoint(x2, y2);
      let element;
      for (let e = 0, el = elements.length; e < el; e++) {
        if (this._view === elements[e]) return "";
        if (this._view.contains(elements[e])) {
          element = elements[e];
          break;
        }
      }
      if (element && element.textContent) {
        const text = element.textContent;
        let start = text.lastIndexOf(" ", x2) + 1;
        let end = text.indexOf(" ", x2);
        if (end === -1) {
          end = text.length;
        }
        const word = text.substring(start, end);
        return word;
      }
      return "";
    }
  };
  var DisplayModel = class extends EventEmitter {
    constructor(options) {
      super();
      this._lineID = 0;
      this.lines = [];
      this._lineIDs = [];
      this._expire = {};
      this._expire2 = [];
      this._parser = new Parser(options);
      this._parser.on("debug", (msg) => {
        this.emit("debug", msg);
      });
      this._parser.on("bell", () => {
        this.emit("bell");
      });
      this._parser.on("add-line", (data) => {
        this.addParserLine(data, true);
      });
      this._parser.on("expire-links", (args) => {
        let lines;
        let line2;
        let expire;
        if (!args || args.length === 0) {
          for (line2 in this._expire2) {
            if (!this._expire2.hasOwnProperty(line2))
              continue;
            this._expireLineLinkFormat(this._expire2[line2], +line2);
          }
          for (expire in this._expire) {
            if (!this._expire.hasOwnProperty(expire))
              continue;
            lines = this._expire[expire];
            for (line2 in lines) {
              if (!lines.hasOwnProperty(line2))
                continue;
              this._expireLineLinkFormat(lines[line2], +line2);
            }
          }
          this._expire2 = [];
          this._expire = {};
          this.emit("expire-links", args);
        } else if (this._expire[args]) {
          lines = this._expire[args];
          for (line2 in lines) {
            if (!lines.hasOwnProperty(line2))
              continue;
            this._expireLineLinkFormat(lines[line2], +line2);
          }
          delete this._expire[args];
          this.emit("expire-links", args);
        }
      });
      this._parser.on("parse-done", () => {
        this.emit("parse-done");
      });
      this._parser.on("set-title", (title, type) => {
        this.emit("set-title", title, type);
      });
      this._parser.on("music", (data) => {
        this.emit("music", data);
      });
      this._parser.on("sound", (data) => {
        this.emit("sound", data);
      });
      this._parser.on("MXP-tag-reply", (tag, args) => {
        this.emit("MXP-tag-reply", tag, args);
      });
    }
    get enableDebug() {
      return this._parser.enableDebug;
    }
    set enableDebug(value) {
      this._parser.enableDebug = value;
    }
    get tabWidth() {
      return this._parser.tabWidth;
    }
    set tabWidth(value) {
      this._parser.tabWidth = value;
    }
    get textLength() {
      return this._parser.textLength;
    }
    get EndOfLine() {
      return this._parser.EndOfLine;
    }
    get parseQueueLength() {
      return this._parser.parseQueueLength;
    }
    get parseQueueEndOfLine() {
      return this._parser.parseQueueEndOfLine;
    }
    set enableFlashing(value) {
      this._parser.enableFlashing = value;
    }
    get enableFlashing() {
      return this._parser.enableFlashing;
    }
    set enableMXP(value) {
      this._parser.enableMXP = value;
    }
    get enableMXP() {
      return this._parser.enableMXP;
    }
    set showInvalidMXPTags(value) {
      this._parser.showInvalidMXPTags = value;
    }
    get showInvalidMXPTags() {
      return this._parser.showInvalidMXPTags;
    }
    set enableBell(value) {
      this._parser.enableBell = value;
    }
    get enableBell() {
      return this._parser.enableBell;
    }
    set enableURLDetection(value) {
      this._parser.enableURLDetection = value;
    }
    get enableURLDetection() {
      return this._parser.enableURLDetection;
    }
    set enableMSP(value) {
      this._parser.enableMSP = value;
    }
    get enableMSP() {
      return this._parser.enableMSP;
    }
    set displayControlCodes(value) {
      this._parser.displayControlCodes = value;
    }
    get displayControlCodes() {
      return this._parser.displayControlCodes;
    }
    set emulateTerminal(value) {
      this._parser.emulateTerminal = value;
    }
    get emulateTerminal() {
      return this._parser.emulateTerminal;
    }
    set emulateControlCodes(value) {
      this._parser.emulateControlCodes = value;
    }
    get emulateControlCodes() {
      return this._parser.emulateControlCodes;
    }
    set MXPStyleVersion(value) {
      this._parser.StyleVersion = value;
    }
    get MXPStyleVersion() {
      return this._parser.StyleVersion;
    }
    addParserLine(data, noUpdate) {
      data.timestamp = Date.now();
      this.emit("add-line", data);
      if (data == null || typeof data === "undefined" || data.line == null || typeof data.line === "undefined")
        return;
      this.emit("add-line-done", data);
      if (data.gagged)
        return;
      const line2 = {
        text: data.line === "\n" || data.line.length === 0 ? "" : data.line,
        raw: data.raw,
        formats: data.formats,
        id: this._lineID,
        timestamp: data.timestamp
      };
      this.lines.push(line2);
      this._lineIDs.push(this._lineID);
      this._lineID++;
      this._buildLineExpires(this.lines.length - 1);
      this.emit("line-added", data, noUpdate);
    }
    _expireLineLinkFormat(formats, idx) {
      let f;
      let fs;
      let fl;
      let fsl;
      let type;
      let eType;
      let format;
      let n = 0;
      for (fs = 0, fsl = formats.length; fs < fsl; fs++) {
        fl = this.lines[idx].formats.length;
        f = formats[fs];
        format = this.lines[idx].formats[f];
        type = format.formatType;
        if (format.formatType === 3 /* MXPLink */)
          eType = 4 /* MXPLinkEnd */;
        else
          eType = 8 /* MXPSendEnd */;
        format.formatType = 9 /* MXPExpired */;
        f++;
        for (; f < fl; f++) {
          if (this.lines[idx].formats[f] === eType) {
            if (n === 0) {
              this.lines[idx].formats[f].formatType = 10 /* MXPSkip */;
              break;
            } else
              n--;
          } else if (this.lines[idx].formats[f] === type)
            n++;
        }
      }
      this.emit("expire-link-line", idx);
    }
    clear() {
      this._parser.Clear();
      this.lines = [];
      this._expire = {};
      this._expire2 = [];
      this._lineIDs = [];
      this._lineID = 0;
    }
    IncreaseColor(color, percent) {
      return this._parser.IncreaseColor(color, percent);
    }
    GetColor(color) {
      return this._parser.GetColor(color);
    }
    append(txt, remote, force, prependSplit) {
      this._parser.parse(txt, remote || false, force || false, prependSplit || false);
    }
    CurrentAnsiCode() {
      return this._parser.CurrentAnsiCode();
    }
    updateWindow(width, height) {
      this._parser.updateWindow(width, height);
    }
    SetColor(code, color) {
      this._parser.SetColor(code, color);
    }
    ClearMXP() {
      this._parser.ClearMXP();
    }
    ResetMXPLine() {
      this._parser.ResetMXPLine();
    }
    get busy() {
      return this._parser.busy;
    }
    removeLine(line2) {
      this.lines.splice(line2, 1);
      this._lineIDs.splice(line2, 1);
      this._expire2.splice(line2, 1);
    }
    removeLines(line2, amt) {
      this.lines.splice(line2, amt);
      this._lineIDs.splice(line2, amt);
      this._expire2.splice(line2, amt);
      for (let ol in this._expire) {
        if (!this._expire.hasOwnProperty(ol) || this._expire[ol].length === 0 || line2 >= this._expire[ol].length)
          continue;
        this._expire[ol].splice(line2, amt);
      }
    }
    getLineID(line2) {
      if (line2 < 0 || line2 >= this._lineIDs.length) return -1;
      return this._lineIDs[line2];
    }
    get getNextLineID() {
      return this._lineID;
    }
    getLineFromID(id) {
      return this._lineIDs.indexOf(id);
    }
    _buildLineExpires(idx) {
      if (idx === void 0)
        idx = this.lines.length - 1;
      const formats = this.lines[idx].formats;
      for (const ol in this._expire) {
        if (!this._expire.hasOwnProperty(ol))
          continue;
        if (this._expire[ol][idx])
          delete this._expire[ol][idx];
      }
      delete this._expire2[idx];
      let f = formats.length;
      let format;
      while (f--) {
        format = formats[f];
        if (format.formatType === 7 /* MXPSend */ || format.formatType === 3 /* MXPLink */) {
          if (format.expire && format.expire.length > 0) {
            if (!this._expire[format.expire])
              this._expire[format.expire] = [];
            if (!this._expire[format.expire][idx])
              this._expire[format.expire][idx] = [];
            this._expire[format.expire][idx].push(f);
          } else {
            if (!this._expire2[idx])
              this._expire2[idx] = [];
            this._expire2[idx].push(f);
          }
        }
      }
    }
    //color like javascript.substr using 0 index and length
    colorSubStrByLine(idx, fore, back, start, len, style) {
      return this.colorSubStringByLine(idx, fore, back, start, start + len, style);
    }
    //color like javascript.substring using 0 index for start and end
    colorSubStringByLine(idx, fore, back, start, end, style) {
      if (idx < 0 || idx >= this.lines.length) return false;
      const lineLength = this.lines[idx].text.length;
      if (start >= lineLength) return false;
      if (!start || start < 0) start = 0;
      if (!end || end > lineLength)
        end = lineLength;
      if (start === end)
        return false;
      const formats = this.lines[idx].formats;
      let len = formats.length;
      let found = false;
      if (start === 0 && end >= lineLength) {
        for (let f = 0; f < len; f++) {
          const format = formats[f];
          if (format.formatType !== 0 /* Normal */)
            continue;
          found = true;
          if (format.bStyle) {
            format.bStyle = 0;
            format.fStyle = 0;
            format.fCls = 0;
          }
          format.color = fore || format.color;
          format.background = back || format.background;
          format.style |= style || 0 /* None */;
        }
        if (!found) {
          formats.unshift({
            formatType: 0 /* Normal */,
            offset: 0,
            color: fore || 0,
            background: back || 0,
            size: 0,
            font: 0,
            style: style || 0 /* None */,
            unicode: false
          });
        }
      } else {
        let nFormat;
        let formatEnd;
        for (let f = 0; f < len; f++) {
          const format = formats[f];
          if (format.formatType !== 0 /* Normal */)
            continue;
          if (f < len - 1) {
            let nF = f + 1;
            nFormat = formats[nF];
            if (format.offset === nFormat.offset && nFormat.formatType === format.formatType)
              continue;
            while (format.offset === nFormat.offset && nFormat.formatType === format.formatType && nF < len - 1)
              nFormat = formats[++nF];
            if (nF === len && format.offset === nFormat.offset)
              formatEnd = lineLength;
            else
              formatEnd = nFormat.offset;
          } else
            formatEnd = lineLength;
          if (start < format.offset) continue;
          if (start >= formatEnd) continue;
          found = true;
          if (format.bStyle) {
            format.bStyle = 0;
            format.fStyle = 0;
            format.fCls = 0;
          }
          if (end < formatEnd) {
            format.width = 0;
            formats.splice(f + 1, 0, {
              formatType: format.formatType,
              offset: end,
              color: format.color,
              background: format.background,
              size: format.size,
              font: format.font,
              style: format.style,
              unicode: format.unicode
            });
            len++;
          }
          if (start != format.offset) {
            format.width = 0;
            formats.splice(f + 1, 0, {
              formatType: format.formatType,
              offset: start,
              color: fore || format.color,
              background: back || format.background,
              size: format.size,
              font: format.font,
              style: format.style | (style || 0 /* None */),
              unicode: format.unicode
            });
            len++;
          } else {
            format.color = fore || format.color;
            format.background = back || format.background;
            format.style |= style || 0 /* None */;
          }
          if (end > formatEnd)
            start = formatEnd;
        }
        this.lines[idx].formats = this._pruneFormats(formats, this.textLength);
      }
      return true;
    }
    removeStyleSubStrByLine(idx, style, start, len) {
      return this.removeStyleSubStringByLine(idx, style, start, start + len);
    }
    //color like javascript.substring using 0 index for start and end
    removeStyleSubStringByLine(idx, style, start, end) {
      if (idx < 0 || idx >= this.lines.length) return false;
      const lineLength = this.lines[idx].text.length;
      if (start >= lineLength) return false;
      if (!start || start < 0) start = 0;
      if (!end || end > lineLength)
        end = lineLength;
      const formats = this.lines[idx].formats;
      let len = formats.length;
      let found = false;
      if (start === 0 && end >= lineLength) {
        for (let f = 0; f < len; f++) {
          const format = formats[f];
          if (format.formatType !== 0 /* Normal */)
            continue;
          found = true;
          if (format.bStyle) {
            format.bStyle = 0;
            format.fStyle = 0;
            format.fCls = 0;
          }
          format.style &= ~(style || 0 /* None */);
        }
        if (!found) {
          formats.unshift({
            formatType: 0 /* Normal */,
            offset: 0,
            color: 0,
            background: 0,
            size: 0,
            font: 0,
            style: 0 /* None */,
            unicode: false
          });
        }
      } else {
        let nFormat;
        let formatEnd;
        for (let f = 0; f < len; f++) {
          const format = formats[f];
          if (format.formatType !== 0 /* Normal */)
            continue;
          if (f < len - 1) {
            let nF = f + 1;
            nFormat = formats[nF];
            if (format.offset === nFormat.offset && nFormat.formatType === format.formatType)
              continue;
            while (format.offset === nFormat.offset && nFormat.formatType === format.formatType && nF < len - 1)
              nFormat = formats[++nF];
            if (nF === len && format.offset === nFormat.offset)
              formatEnd = lineLength;
            else
              formatEnd = nFormat.offset;
          } else
            formatEnd = lineLength;
          if (start < format.offset) continue;
          if (start >= formatEnd) continue;
          found = true;
          if (format.bStyle) {
            format.bStyle = 0;
            format.fStyle = 0;
            format.fCls = 0;
          }
          if (end < formatEnd) {
            format.width = 0;
            formats.splice(f + 1, 0, {
              formatType: format.formatType,
              offset: end,
              color: format.color,
              background: format.background,
              size: format.size,
              font: format.font,
              style: format.style,
              unicode: format.unicode
            });
            len++;
          }
          if (start != format.offset) {
            format.width = 0;
            formats.splice(f + 1, 0, {
              formatType: format.formatType,
              offset: start,
              color: format.color,
              background: format.background,
              size: format.size,
              font: format.font,
              style: format.style & ~(style || 0 /* None */),
              unicode: format.unicode
            });
            len++;
          } else {
            format.style &= ~(style || 0 /* None */);
          }
          if (end > formatEnd)
            start = formatEnd;
        }
        this.lines[idx].formats = this._pruneFormats(formats, this.textLength);
      }
      return true;
    }
    highlightSubStrByLine(idx, start, len) {
      return this.highlightStyleSubStringByLine(idx, start, start + len);
    }
    //color like javascript.substring using 0 index for start and end
    highlightStyleSubStringByLine(idx, start, end, color) {
      if (idx < 0 || idx >= this.lines.length) return false;
      const lineLength = this.lines[idx].text.length;
      if (start >= lineLength) return false;
      if (!start || start < 0) start = 0;
      if (!end || end > lineLength)
        end = lineLength;
      const formats = this.lines[idx].formats;
      let len = formats.length;
      let found = false;
      if (start === 0 && end >= lineLength) {
        for (let f = 0; f < len; f++) {
          const format = formats[f];
          if (format.formatType !== 0 /* Normal */)
            continue;
          found = true;
          if (format.bStyle) {
            format.bStyle = 0;
            format.fStyle = 0;
            format.fCls = 0;
          }
          if (color || (format.style & 1 /* Bold */) === 1 /* Bold */) {
            if (typeof format.color === "number")
              format.color = this._parser.IncreaseColor(this._parser.GetColor(format.color), 0.25);
            else
              format.color = this._parser.IncreaseColor(format.color, 0.25);
          } else
            format.style |= 1 /* Bold */;
        }
        if (!found) {
          formats.unshift({
            formatType: 0 /* Normal */,
            offset: 0,
            color: color ? 370 : 0,
            background: 0,
            size: 0,
            font: 0,
            style: color ? 0 /* None */ : 1 /* Bold */,
            unicode: false
          });
        }
      } else {
        let nFormat;
        let formatEnd;
        for (let f = 0; f < len; f++) {
          const format = formats[f];
          if (format.formatType !== 0 /* Normal */)
            continue;
          if (f < len - 1) {
            let nF = f + 1;
            nFormat = formats[nF];
            if (format.offset === nFormat.offset && nFormat.formatType === format.formatType)
              continue;
            while (format.offset === nFormat.offset && nFormat.formatType === format.formatType && nF < len - 1)
              nFormat = formats[++nF];
            if (nF === len && format.offset === nFormat.offset)
              formatEnd = lineLength;
            else
              formatEnd = nFormat.offset;
          } else
            formatEnd = lineLength;
          if (start < format.offset) continue;
          if (start >= formatEnd) continue;
          found = true;
          if (format.bStyle) {
            format.bStyle = 0;
            format.fStyle = 0;
            format.fCls = 0;
          }
          if (end < formatEnd) {
            format.width = 0;
            formats.splice(f + 1, 0, {
              formatType: format.formatType,
              offset: end,
              color: format.color,
              background: format.background,
              size: format.size,
              font: format.font,
              style: format.style,
              unicode: format.unicode
            });
            len++;
          }
          if (start != format.offset) {
            format.width = 0;
            nFormat = {
              formatType: format.formatType,
              offset: start,
              color: format.color,
              background: format.background,
              size: format.size,
              font: format.font,
              style: format.style,
              unicode: format.unicode
            };
            if (color || (format.style & 1 /* Bold */) === 1 /* Bold */) {
              if (typeof format.color === "number")
                nFormat.color = this._parser.IncreaseColor(this._parser.GetColor(format.color), 0.25);
              else
                nFormat.color = this._parser.IncreaseColor(format.color, 0.25);
            } else
              nFormat.style |= 1 /* Bold */;
            formats.splice(f + 1, 0, nFormat);
            len++;
          } else if (color || (format.style & 1 /* Bold */) === 1 /* Bold */) {
            if (typeof format.color === "number")
              format.color = this._parser.IncreaseColor(this._parser.GetColor(format.color), 0.25);
            else
              format.color = this._parser.IncreaseColor(format.color, 0.25);
          } else
            format.style |= 1 /* Bold */;
          if (end > formatEnd)
            start = formatEnd;
        }
        this.lines[idx].formats = this._pruneFormats(formats, this.textLength);
      }
      return true;
    }
    _pruneFormats(formats, textLen) {
      if (!formats || formats.length < 2) return formats;
      const l2 = formats.length;
      const nF = [];
      for (let f = 0; f < l2; f++) {
        const format = formats[f];
        let end;
        if (f < l2 - 1) {
          const nFormat = formats[f + 1];
          if (format.offset === nFormat.offset && nFormat.formatType === format.formatType)
            continue;
          end = nFormat.offset;
          if (format.formatType === 1 /* Link */ && end - format.offset === 0 && nFormat.formatType === 2 /* LinkEnd */)
            continue;
          if (format.formatType === 7 /* MXPSend */ && end - format.offset === 0 && nFormat.formatType === 8 /* MXPSendEnd */)
            continue;
          if (format.formatType === 3 /* MXPLink */ && end - format.offset === 0 && nFormat.formatType === 4 /* MXPLinkEnd */)
            continue;
          if (format.formatType === nFormat.formatType && format.color === nFormat.color && format.background === nFormat.background && format.size === nFormat.size && format.font === nFormat.font && format.style === nFormat.style && format.unicode === nFormat.unicode) {
            nFormat.offset = format.offset;
            nFormat.width = 0;
            continue;
          }
        } else if (format.offset === textLen && textLen !== 0 && (format.formatType === 0 /* Normal */ && !format.hr || format.formatType === 1 /* Link */ || format.formatType === 7 /* MXPSend */ || format.formatType === 3 /* MXPLink */))
          continue;
        nF.push(format);
      }
      return nF;
    }
    get text() {
      return this.lines.map((line2) => line2.text).join("\n");
    }
    get raw() {
      return this.lines.map((line2) => line2.raw).join("");
    }
    getText(line2, start, end) {
      if (line2 < 0 || line2 >= this.lines.length) return "";
      if (start < 0) start = 0;
      if (typeof end === "undefined" || end > this.lines[line2].text.length)
        return this.lines[line2].text.substring(start);
      return this.lines[line2].text.substring(start, end);
    }
  };

  // package.json
  var version = "1.0.0-alpha";

  // src/plugins/msp.ts
  var buzz = __toESM(require_buzz());

  // src/plugin.ts
  var Plugin = class extends EventEmitter {
    #client;
    get client() {
      return this.#client;
    }
    set client(value) {
      if (value === this.#client) return;
      this.remove();
      this.#client = value;
      this.initialize();
    }
    constructor(client2) {
      super();
      this.#client = client2;
    }
  };

  // src/plugins/msp.ts
  var SoundState = class extends EventEmitter {
    constructor() {
      super(...arguments);
      this._file = "";
      this._repeats = 1;
      this._volume = 100;
      this._priority = 50;
      this._retries = 0;
      this.current = 0;
      this.sound = null;
      this.playing = false;
      this.url = "";
      this.continue = true;
      this.maxErrorRetries = 0;
    }
    set file(file) {
      if (!this.continue)
        this.close();
      this._file = file;
    }
    get file() {
      return this._file;
    }
    set repeats(repeats) {
      if (repeats >= -1)
        this._repeats = repeats;
      else
        this._repeats = 1;
      this.current = 0;
    }
    get repeats() {
      return this._repeats;
    }
    set volume(volume) {
      if (volume >= 0 && volume <= 100)
        this._volume = volume;
      else
        this._volume = 1;
    }
    get volume() {
      return this._volume;
    }
    set priority(priority) {
      if (priority >= 0 && priority <= 100)
        this._priority = priority;
      else
        this._priority = 50;
    }
    get priority() {
      return this._priority;
    }
    play() {
      this.playing = true;
      if (this._repeats > 0 && this.current < this._repeats) {
        this.current++;
        this.close();
        this.open().then(() => {
          this._retries = 0;
          this.sound.setVolume(this._volume).play();
          if (this.current < this._repeats) {
            this.sound.bind("ended abort", (e) => {
              this.play();
            });
          } else
            this.sound.bind("ended abort", (e) => {
              this.playing = false;
              this.emit("ended");
            });
          if (this.sound.isEnded())
            this.playing = false;
        }).catch((err) => {
          if (this._retries < this.maxErrorRetries) {
            this.current--;
            this.play();
            this._retries++;
          } else
            this._retries = 0;
        });
      } else if (this._repeats === -1) {
        this.close();
        this.open().then(() => {
          this._retries = 0;
          this.sound.setVolume(this._volume).loop().play();
          if (this.sound.isEnded())
            this.playing = false;
        }).catch((err) => {
          if (this._retries < this.maxErrorRetries) {
            this.play();
            this._retries++;
          } else
            this._retries = 0;
        });
      } else
        this.playing = false;
    }
    async open() {
      this.close();
      return new Promise((resolve, reject) => {
        this.sound = new buzz.sound()(this.url + this._file);
        this.sound.bind("loadeddata", (e) => {
          this.emit("playing", { file: this._file, sound: this.sound, state: this, duration: buzz.toTimer(this.sound.getDuration()) });
          resolve(1);
        });
        this.sound.bind("error", (e) => {
          if (e && e.currentTarget && e.currentTarget.error) {
            switch (e.currentTarget.error.code) {
              case 1:
                this.emit("error", new Error(`MSP - Aborted: ${this.url}${this._file}`));
                break;
              case 2:
                this.emit("error", new Error(`MSP - Network error: ${this.url}${this._file}`));
                break;
              case 3:
                this.emit("error", new Error(`MSP - Could not decode: ${this.url}${this._file}`));
                break;
              case 4:
                this.emit("error", new Error(`MSP - Source not supported: ${this.url}${this._file}`));
                break;
            }
          } else if (e && e.currentTarget && e.currentTarget.networkState === 3)
            this.emit("error", new Error(`MSP - Source not found or unable to play: ${this.url}${this._file}`));
          else
            this.emit("error", new Error("MSP - Unknown error"));
          reject();
        });
        this.emit("opened");
      });
    }
    close() {
      if (this.sound) {
        this.stop();
        delete this.sound;
        this.sound = null;
      } else if (this.playing)
        this.playing = false;
      this.emit("closed");
    }
    stop() {
      if (this.sound)
        this.sound.stop();
      this.playing = false;
      this.emit("stopped");
    }
  };
  var MSP = class extends Plugin {
    constructor(options) {
      super(options instanceof Client ? options : options?.client);
      this._enabled = true;
      this._enableSound = true;
      this._maxErrorRetries = 1;
      this.server = false;
      this.enableDebug = false;
      this.defaultSoundURL = "";
      this.defaultMusicURL = "";
      this.forcedDefaultMusicURL = "http://" + window.location.hostname + "/sounds/";
      this.forcedDefaultSoundURL = "http://" + window.location.hostname + "/sounds/";
      this.defaultSoundExt = ".m4a";
      this.defaultMusicExt = ".m4a";
      this.MusicState = new SoundState();
      this.SoundState = new SoundState();
      this.parseMode = 0 /* default */;
      if (options && !(options instanceof Client)) {
        if ("forcedDefaultMusicURL" in options)
          this.forcedDefaultMusicURL = options.forcedDefaultMusicURL;
        if ("forcedDefaultSoundURL" in options)
          this.forcedDefaultSoundURL = options.forcedDefaultSoundURL;
      }
      this.MusicState.on("playing", (data) => {
        data.type = 1;
        this.emit("playing", data);
      });
      this.SoundState.on("playing", (data) => {
        data.type = 0;
        this.emit("playing", data);
      });
      this.MusicState.on("error", (err) => {
        this.emit("error", err);
      });
      this.SoundState.on("error", (err) => {
        this.emit("error", err);
      });
      this.MusicState.maxErrorRetries = this._maxErrorRetries;
      this.SoundState.maxErrorRetries = this._maxErrorRetries;
    }
    remove() {
      if (!this.client) return;
      this.client.removeListenersFromCaller(this);
      let idx = this.client.telnet.GMCPSupports.indexOf("Client.Media 1");
      this.client.telnet.GMCPSupports.splice(idx, 1);
    }
    initialize() {
      if (!this.client) return;
      this.client.telnet.GMCPSupports.push("Client.Media 1");
      this.client.on("connecting", () => this.reset(), this);
      this.client.on("close", () => this.reset(), this);
      this.client.on("received-option", this.processOption, this);
      this.client.on("received-GMCP", this.processGMCP, this);
      this.client.on("music", this.music, this);
      this.client.on("sound", this.sound, this);
      this.client.on("options-loaded", this.loadOptions, this);
      this.client.on("option-loaded", this.setOption, this);
      this.client.on("function", this._processFunction, this);
      this.on("playing", (data) => {
        if (!this.client) return;
        this.debug("MSP " + (data.type ? "Music" : "Sound") + " Playing " + data.file + " for " + data.duration);
        this.debug(data);
        if (!this.client.getOption("notifyMSPPlay")) return;
        this.client.echo((data.type ? "Music" : "Sound") + " Playing " + data.file + " for " + data.duration, -7 /* InfoText */, -8 /* InfoBackground */, true, true);
      });
      this.on("debug", (e) => this.client.debug(e), this);
      this.on("error", (e) => this.client.error(e), this);
      this.loadOptions();
    }
    get menu() {
      return [];
    }
    get settings() {
      return [];
    }
    loadOptions() {
      this.enableDebug = this.client.getOption("enableDebug");
      this.enabled = this.client.getOption("enableMSP");
      this.enableSound = this.client.getOption("enableSound");
      this.maxErrorRetries = this.client.getOption("mspMaxRetriesOnError");
    }
    setOption(option, value) {
      switch (option) {
        case "enableMSP":
          this.enabled = this.client.getOption("enableMSP");
          break;
        case "mspMaxRetriesOnError":
          this.maxErrorRetries = this.client.getOption("mspMaxRetriesOnError");
          break;
        case "enableSound":
        case "enableDebug":
          this[option] = value;
          break;
      }
    }
    /**
     * enable or disable MSP
     *
     * @type {boolean}
     * @memberof MSP
     */
    get enabled() {
      return this._enabled;
    }
    set enabled(value) {
      if (value === this._enabled) return;
      this._enabled = value;
      this.MusicState?.close();
      this.SoundState?.close();
    }
    /**
     * the number of retries to try before stopping when an error happens MSP
     *
     * @type {boolean}
     * @memberof MSP
     */
    get maxErrorRetries() {
      return this._maxErrorRetries;
    }
    set maxErrorRetries(value) {
      if (value === this._maxErrorRetries) return;
      this._maxErrorRetries = value;
      if (this.MusicState)
        this.MusicState.maxErrorRetries = value;
      if (this.SoundState)
        this.SoundState.maxErrorRetries = value;
    }
    /**
     * enable or disable enableSound, allow processing of msp
     *
     * @type {boolean}
     * @memberof MSP
     */
    get enableSound() {
      return this._enableSound;
    }
    set enableSound(value) {
      if (value === this._enableSound) return;
      this._enableSound = value;
      this.MusicState?.close();
      this.SoundState?.close();
    }
    /**
     * getArguments - process a line of text and extract any arguments and return
     * them as an object for consuming and handle it due to being a web browser can't
     * save sounds, so they either need a url or be on the local http server using
     * the default url set
     *
     * @param {String} text the line of text extract arguments from
     * @param {Number} type the type of arguments to process, 0 SOUND, 1 MUSIC
     * @returns {Object} return a MUSIC or SOUND argument object
     */
    getArguments(text, type) {
      const e = { off: false, file: "", url: "", volume: 100, repeat: 1, priority: 50, type: "", continue: true };
      const args = [];
      let state = 0;
      let str = [];
      let x2 = 0;
      let xl = text.length;
      let c;
      let arg;
      let tmp;
      for (; x2 < xl; x2++) {
        c = text.charAt(x2);
        switch (state) {
          case 1:
            if (c === "'") {
              state = 0;
              str.push(c);
            } else
              str.push(c);
            break;
          case 2:
            if (c === "'") {
              state = 0;
              str.push(c);
            } else
              str.push(c);
            break;
          default:
            if (c === " ") {
              args.push(str.join(""));
              str = [];
            } else if (c === "'") {
              state = 1;
              str.push(c);
            } else if (c === "'") {
              state = 2;
              str.push(c);
            } else
              str.push(c);
            break;
        }
      }
      if (str.length > 0) {
        args.push(str.join(""));
        str = [];
      }
      x2 = 0;
      xl = args.length;
      this.debug("MSP arguments found: " + args);
      for (x2 = 0; x2 < xl; x2++) {
        arg = args[x2].split("=");
        if (arg.length > 1) {
          switch (arg[0].toUpperCase()) {
            case "FNAME":
              e.file = stripQuotes(arg[1]);
              if (e.file.toLowerCase() === "off") {
                e.off = true;
                e.file = "";
              }
              break;
            case "V":
              tmp = parseInt(arg[1], 10);
              if (isNaN(tmp))
                tmp = 100;
              e.volume = tmp;
              break;
            case "L":
              tmp = parseInt(arg[1], 10);
              if (isNaN(tmp))
                tmp = 1;
              e.repeat = tmp;
              break;
            //Sound only
            case "P":
              tmp = parseInt(arg[1], 10);
              if (isNaN(tmp))
                tmp = 1;
              e.priority = tmp;
              break;
            //Music only
            case "C":
              e.continue = arg[1] !== "0";
              break;
            case "T":
              if (arg[1].length > 0)
                e.type = arg[1];
              break;
            case "U":
              e.url = stripQuotes(arg[1]);
              if (!e.url.endsWith("/") && e.url.length > 0)
                e.url += "/";
              break;
          }
        } else if (x2 === 0) {
          e.file = stripQuotes(args[x2]);
          if (e.file.toLowerCase() === "off") {
            e.off = true;
            e.file = "";
          }
        } else if (x2 === 1) {
          tmp = parseInt(args[x2], 10);
          if (isNaN(tmp))
            tmp = 100;
          e.volume = tmp;
        } else if (x2 === 2) {
          tmp = parseInt(args[x2], 10);
          if (isNaN(tmp))
            tmp = 1;
          e.repeat = tmp;
        } else if (x2 === 3 && type === 1)
          e.continue = args[x2] !== "0";
        else if (x2 === 3) {
          tmp = parseInt(args[x2], 10);
          if (isNaN(tmp))
            tmp = 1;
          e.priority = tmp;
        } else if (x2 === 4) {
          if (args[x2].length > 0)
            e.type = args[x2];
        } else if (x2 === 5) {
          e.url = stripQuotes(args[x2]);
          if (!e.url.endsWith("/") && e.url.length > 0)
            e.url += "/";
        }
      }
      this.debug(e);
      return e;
    }
    reset() {
      this.server = false;
    }
    /**
     * music - process music object and player/stop based on object options
     *
     * @param {Object} data Music argument object, contains all settings
     */
    music(data) {
      if (!this.enabled && !this.enableSound) return false;
      if (!data.file || data.file.length === 0) {
        if (data.off && data.url && data.url.length > 0)
          this.defaultMusicURL = data.url;
        else if (data.off)
          this.MusicState.stop();
        return;
      } else if (data.off) {
        this.MusicState.stop();
        return;
      }
      this.MusicState.volume = data.volume;
      this.MusicState.repeats = data.repeat;
      this.MusicState.continue = data.continue;
      const old = this.MusicState.file;
      if (data.file.lastIndexOf(".") === -1)
        this.MusicState.file = data.file + this.defaultMusicExt;
      else
        this.MusicState.file = data.file;
      if (data.url && data.url.length > 0)
        this.MusicState.url = data.url;
      else if (this.forcedDefaultMusicURL && this.forcedDefaultMusicURL.length > 0)
        this.MusicState.url = this.forcedDefaultMusicURL;
      else if (this.defaultMusicURL && this.defaultMusicURL.length > 0)
        this.MusicState.url = this.defaultMusicURL;
      else
        this.MusicState.url = "";
      if (this.MusicState.url.length > 0 && !this.MusicState.url.endsWith("/"))
        this.MusicState.url += "/";
      if (data.type && data.type.length > 0) {
        this.MusicState.url += data.type;
        if (this.MusicState.url.length > 0 && !this.MusicState.url.endsWith("/"))
          this.MusicState.url += "/";
      }
      if (old !== this.MusicState.file || !data.continue || !this.MusicState.playing) {
        if (this.enableSound)
          this.MusicState.play();
        else
          this.emit("playing", { type: 1, file: this.MusicState.file, sound: this.MusicState.sound, state: this.MusicState, duration: "--:--" });
      }
    }
    /**
     * sound - process music object and player/stop based on object options
     *
     * @param {Object} data Sound argument object, contains all settings
     * @todo make it play/stop sound
     */
    sound(data) {
      if (!this.enabled && !this.enableSound) return false;
      if (!data.file || data.file.length === 0) {
        if (data.off && data.url && data.url.length > 0)
          this.defaultSoundURL = data.url;
        else if (data.off)
          this.SoundState.stop();
        return;
      } else if (data.off) {
        this.SoundState.stop();
        return;
      }
      if (this.SoundState.playing && data.priority < this.SoundState.priority)
        return false;
      this.SoundState.volume = data.volume;
      this.SoundState.repeats = data.repeat;
      this.SoundState.priority = data.priority;
      if (data.file.lastIndexOf(".") === -1)
        this.SoundState.file = data.file + this.defaultSoundExt;
      else
        this.SoundState.file = data.file;
      if (data.url && data.url.length > 0)
        this.SoundState.url = data.url;
      else if (this.forcedDefaultSoundURL && this.forcedDefaultSoundURL.length > 0)
        this.SoundState.url = this.forcedDefaultSoundURL;
      else if (this.defaultSoundURL && this.defaultSoundURL.length > 0)
        this.SoundState.url = this.defaultSoundURL;
      else
        this.SoundState.url = "";
      if (this.SoundState.url.length > 0 && !this.SoundState.url.endsWith("/"))
        this.SoundState.url += "/";
      if (data.type && data.type.length > 0) {
        this.SoundState.url += data.type;
        if (this.SoundState.url.length > 0 && !this.SoundState.url.endsWith("/"))
          this.SoundState.url += "/";
      }
      if (this.enableSound)
        this.SoundState.play();
      else
        this.emit("playing", { type: 0, file: this.SoundState.file, sound: this.SoundState.sound, state: this.SoundState, duration: "--:--" });
    }
    /**
     * processOption - process telnet options, if its MSP handle it and correctly reply yes we support MSP or no don't
     *
     * @param {Object} data Telnet#replyToOption event object
     */
    processOption(data) {
      if (data.option === 90) {
        this.debug("<MSP>");
        if (data.verb === 253) {
          this.server = true;
          if (this.enabled) {
            this.debug("REPLY: <IAC><WILL><MSP>");
            data.telnet.sendData([255, 251, 90], true);
          } else {
            this.debug("REPLY: <IAC><DONT><MSP>");
            data.telnet.sendData([255, 254, 90], true);
          }
        } else if (data.verb === 254) {
          this.server = false;
          this.debug("REPLY: <IAC><WONT><MSP>");
          data.telnet.sendData([255, 252, 90], true);
        } else if (data.verb === 251) {
          this.server = true;
          if (this.enabled) {
            this.debug("REPLY: <IAC><DO><MSP>");
            data.telnet.sendData([255, 253, 90], true);
          } else {
            this.debug("REPLY: <IAC><DONT><MSP>");
            data.telnet.sendData([255, 254, 90], true);
          }
        } else if (data.verb === 252) {
          this.server = false;
          this.debug("REPLY: <IAC><DONT><MSP>");
          data.telnet.sendData([255, 254, 90], true);
        }
        data.handled = true;
      }
    }
    /**
     * processGMCP - process incoming GMCP for Client.Media events
     * @param {string} mod Client#received-GMCP module
     * @param {Object} data Client#received-GMCP data object
     */
    async processGMCP(mod, data) {
      switch (mod) {
        case "Client.Media.Default":
          if (data.type === "sound" || !data.type)
            this.sound({ off: true, url: data.url });
          else if (data.type === "music")
            this.music({ off: true, url: data.url });
          break;
        //as we don't support loading and caching of media ignore this
        case "Client.Media.Load":
          break;
        case "Client.Media.Play":
          const sound2 = { off: false, file: data.name, url: "", volume: 50, repeat: 1, priority: 50, type: "", continue: true };
          if (data.hasOwnProperty("url"))
            sound2.url = data.url;
          if (data.hasOwnProperty("tag"))
            sound2.type = data.tag;
          if (data.hasOwnProperty("volume"))
            sound2.volume = data.volume;
          if (data.hasOwnProperty("loops"))
            sound2.repeat = data.loops;
          if (data.hasOwnProperty("priority"))
            sound2.priority = data.priority;
          if (data.type === "sound" || !data.type)
            this.sound(sound2);
          else if (data.type === "music") {
            if (data.hasOwnProperty("continue") && (data.continue === "false" || !data.continue))
              sound2.continue = false;
            this.music(sound2);
          }
          break;
        case "Client.Media.Stop":
          if (data.type === "sound" || !data.type)
            this.sound({ off: true });
          else if (data.type === "music")
            this.music({ off: true });
          break;
      }
    }
    /**
     * debug - emit debug event if enabledDebug on
     * @param {string | object} e The debug message or an object of data 
     */
    debug(e) {
      if (!this.enableDebug) return;
      this.emit("debug", e);
    }
    /**
     * Process function event to execute custom text functions
     * @param data {FunctionEvent} The data about the function to execute
     */
    _processFunction(data) {
      let args;
      let tmp;
      let i2;
      if (!data) return;
      switch (data.name.toLowerCase()) {
        case "soundinfo":
          if (this.SoundState.playing)
            this.client.echo("Playing Sound - " + this.SoundState.file + " - " + buzz.toTimer(this.SoundState.sound.getTime()) + "/" + buzz.toTimer(this.SoundState.sound.getDuration()), -7, -8, true, true);
          else
            this.client.echo("No sound currently playing.", -7, -8, true, true);
          data.handled = true;
          break;
        case "musicinfo":
          if (this.MusicState.playing)
            this.client.echo("Playing Music - " + this.MusicState.file + " -  " + buzz.toTimer(this.MusicState.sound.getTime()) + "/" + buzz.toTimer(this.MusicState.sound.getDuration()), -7, -8, true, true);
          else
            this.client.echo("No music currently playing.", -7, -8, true, true);
          data.handled = true;
          break;
        case "playmusic":
        case "playm":
          args = this.client.input.parseOutgoing(data.args.join(" "), false);
          tmp = { off: false, file: "", url: "", volume: 100, repeat: 1, priority: 50, type: "", continue: true };
          i2 = args.lastIndexOf("/");
          if (i2 === -1)
            tmp.file = args;
          else {
            tmp.file = args.substring(i2 + 1);
            tmp.url = args.substring(0, i2 + 1);
          }
          this.music(tmp);
          data.handled = true;
          break;
        case "playsound":
        case "plays":
          args = this.client.input.parseOutgoing(data.args.join(" "), false);
          tmp = { off: false, file: "", url: "", volume: 100, repeat: 1, priority: 50, type: "", continue: true };
          i2 = args.lastIndexOf("/");
          if (i2 === -1)
            tmp.file = args;
          else {
            tmp.file = args.substring(i2 + 1);
            tmp.url = args.substring(0, i2 + 1);
          }
          this.sound(tmp);
          data.handled = true;
          break;
        case "stopmusic":
        case "stopm":
          this.MusicState.close();
          data.handled = true;
          break;
        case "stopsound":
        case "stops":
          this.SoundState.close();
          data.handled = true;
          break;
        case "stopallsound":
        case "stopa":
          this.MusicState.close();
          this.SoundState.close();
          data.handled = true;
          break;
      }
    }
  };

  // src/plugins/test.ts
  var Test = class extends Plugin {
    constructor(client2) {
      super(client2);
      /**
       * Contains a list of functions
       * @type {object}
       * @memberof Tests
       */
      this.functions = {};
      this._event = (data) => this._processFunction(data);
      this.functions["testfile"] = (data) => {
        if (data && data.args && data.args.length)
          throw new Error("Invalid syntax use " + this.client.getOption("commandChar") + "testfile");
        openFileDialog().then((files) => {
          console.time("testfile readFile");
          readFile(files[0]).then((contents) => {
            console.timeEnd("testfile readFile");
            if (data && data.raw && (this.client.getOption("echo") & 4) === 4)
              this.client.echo(data.raw, -3, -4, true, true);
            let n = this.client.getOption("enableCommands");
            this.client.setOption("enableCommands", true);
            let i2 = (/* @__PURE__ */ new Date()).getTime();
            console.time("testfile parse");
            this.client.sendCommand(contents, null, this.client.getOption("allowCommentsFromCommand"));
            console.timeEnd("testfile parse");
            let p = (/* @__PURE__ */ new Date()).getTime();
            this.client.setOption("enableCommands", n);
            this.client.print(`Time: ${p - i2}
`, true);
          }).catch(this.client.error);
        }).catch(() => {
        });
      };
      this.functions["testfiler"] = (data) => {
        if (data && data.args && data.args.length)
          throw new Error("Invalid syntax use " + this.client.getOption("commandChar") + "testfile");
        openFileDialog().then((files) => {
          console.time("testfile readFile");
          readFile(files[0]).then((contents) => {
            console.timeEnd("testfile readFile");
            if (data && data.raw && (this.client.getOption("echo") & 4) === 4)
              this.client.echo(data.raw, -3, -4, true, true);
            let n = this.client.getOption("enableCommands");
            this.client.setOption("enableCommands", true);
            let i2 = (/* @__PURE__ */ new Date()).getTime();
            console.time("testfiler parse");
            this.client.telnet.receivedData(StringToUint8Array(contents), true, true);
            console.timeEnd("testfiler parse");
            let p = (/* @__PURE__ */ new Date()).getTime();
            this.client.setOption("enableCommands", n);
            this.client.print(`Time: ${p - i2}
`, true);
          }).catch(this.client.error);
        }).catch(() => {
        });
      };
      this.functions["testspeedfile"] = (data) => {
        if (data && data.args && data.args.length)
          throw new Error("Invalid syntax use " + this.client.getOption("commandChar") + "testspeedfile");
        openFileDialog().then((files) => {
          console.time("testspeedfile readFile");
          readFile(files[0]).then((contents) => {
            console.timeEnd("testspeedfile readFile");
            if (data && data.raw && (this.client.getOption("echo") & 4) === 4)
              this.client.echo(data.raw, -3, -4, true, true);
            let avg = 0;
            let max2 = 0;
            let min = 0;
            let items = [];
            let p;
            console.time(`testspeedfile`);
            for (let i2 = 0; i2 < 10; i2++) {
              const start = (/* @__PURE__ */ new Date()).getTime();
              console.time(`testspeedfile parse ${i2}`);
              this.client.sendCommand(contents, null, this.client.getOption("allowCommentsFromCommand"));
              console.timeEnd(`testspeedfile parse ${i2}`);
              const end = (/* @__PURE__ */ new Date()).getTime();
              p = end - start;
              avg += p;
              if (p > max2) max2 = p;
              if (!min || p < min) min = p;
              items.push(`${i2} - ${p}`);
            }
            console.timeEnd(`testspeedfile`);
            items.push(`Total - ${avg}`);
            items.push(`Average - ${avg / 10}`);
            items.push(`Min - ${min}`);
            items.push(`Max - ${max2}`);
            this.client.print(items.join("\n") + "\n", true);
          }).catch(this.client.error);
        }).catch(() => {
        });
      };
      this.functions["testspeedfiler"] = (data) => {
        if (data && data.args && data.args.length)
          throw new Error("Invalid syntax use " + this.client.getOption("commandChar") + "testspeedfiler");
        openFileDialog().then((files) => {
          console.time("testspeedfile readFile");
          readFile(files[0]).then((contents) => {
            console.timeEnd("testspeedfile readFile");
            if (data && data.raw && (this.client.getOption("echo") & 4) === 4)
              this.client.echo(data.raw, -3, -4, true, true);
            let avg = 0;
            let max2 = 0;
            let min = 0;
            let items = [];
            let p;
            console.time(`testspeedfile`);
            for (let i2 = 0; i2 < 10; i2++) {
              const start = (/* @__PURE__ */ new Date()).getTime();
              console.time(`testspeedfile parse ${i2}`);
              this.client.telnet.receivedData(StringToUint8Array(contents), true, true);
              console.timeEnd(`testspeedfile parse ${i2}`);
              const end = (/* @__PURE__ */ new Date()).getTime();
              p = end - start;
              avg += p;
              if (p > max2) max2 = p;
              if (!min || p < min) min = p;
              items.push(`${i2} - ${p}`);
            }
            console.timeEnd(`testspeedfile`);
            items.push(`Total - ${avg}`);
            items.push(`Average - ${avg / 10}`);
            items.push(`Min - ${min}`);
            items.push(`Max - ${max2}`);
            this.client.print(items.join("\n") + "\n", true);
          }).catch(this.client.error);
        }).catch(() => {
        });
      };
      this.functions["testlist"] = () => {
        let sample = "Test commands:\n";
        let t;
        for (t in this.functions) {
          if (!this.functions.hasOwnProperty(t)) continue;
          sample += `	${this.client.getOption("commandChar") + t}
`;
        }
        this.client.print(sample, true);
      };
      this.functions["testcolors"] = () => {
        let r;
        let sample = "Colors and Styles\n-------------------------------------------------------------------------------------------\n";
        for (r = 30; r < 38; r++) {
          sample += "\x1B[" + r + ";0m" + r + "\x1B[0m ";
          sample += "\x1B[" + r + ";1mBold\x1B[0m ";
          sample += "\x1B[" + r + ";2mFaint\x1B[0m ";
          sample += "\x1B[" + r + ";3mItalic\x1B[0m ";
          sample += "\x1B[" + r + ";4mUnderline\x1B[0m ";
          sample += "\x1B[" + r + ";5mFlash\x1B[0m ";
          sample += "\x1B[" + r + ";7mInverse\x1B[0m ";
          sample += "\x1B[" + r + ";8mConceal\x1B[0m ";
          sample += "\x1B[" + r + ";9mStrikeout\x1B[0m ";
          sample += "\x1B[" + r + ";21mDoubleUnderline\x1B[0m ";
          sample += "\x1B[" + r + ";53mOverline\x1B[0m ";
          sample += "\x1B[" + r + ";1;2;3;4;5;9;21;53mAll\x1B[0m";
          sample += "\x1B[0m\n";
        }
        for (r = 40; r < 48; r++) {
          sample += "\x1B[" + r + ";0m" + r + "\x1B[0m ";
          sample += "\x1B[" + r + ";1mBold\x1B[0m ";
          sample += "\x1B[" + r + ";2mFaint\x1B[0m ";
          sample += "\x1B[" + r + ";3mItalic\x1B[0m ";
          sample += "\x1B[" + r + ";4mUnderline\x1B[0m ";
          sample += "\x1B[" + r + ";5mFlash\x1B[0m ";
          sample += "\x1B[" + r + ";7mInverse\x1B[0m ";
          sample += "\x1B[" + r + ";8mConceal\x1B[0m ";
          sample += "\x1B[" + r + ";9mStrikeout\x1B[0m ";
          sample += "\x1B[" + r + ";21mDoubleUnderline\x1B[0m ";
          sample += "\x1B[" + r + ";53mOverline\x1B[0m ";
          sample += "\x1B[" + r + ";1;2;3;4;5;9;21;53mAll\x1B[0m";
          sample += "\x1B[0m\n";
        }
        sample += "-------------------------------------------------------------------------------------------\n";
        this.client.print(sample, true);
      };
      this.functions["testcolorsdetails"] = () => {
        let sample = "";
        if (this.client.telnet.prompt)
          sample = "\n";
        sample += "Table for 16-color terminal escape sequences.\n";
        sample += "\n";
        sample += "Background        | Foreground colors\n";
        sample += "------------------------------------------------------------------------------------\n";
        for (let bg = 40; bg <= 47; bg++) {
          let a;
          for (a in Ansi) {
            if (typeof Ansi[a] !== "number") continue;
            if (a === "Rapid") continue;
            if (a === "None")
              sample += "\x1B[0m " + AnsiColorCode[bg - 10].toString().padEnd(16) + " | ";
            else
              sample += "\x1B[0m " + a.padEnd(16) + " | ";
            for (let fg = 30; fg <= 37; fg++) {
              if (a === "None")
                sample += "\x1B[" + bg + "m\x1B[" + fg + "m " + ("[" + fg + "m").padEnd(7);
              else
                sample += "\x1B[" + bg + "m\x1B[" + Ansi[a] + ";" + fg + "m " + ("[" + Ansi[a] + ";" + fg + "m").padEnd(7);
            }
            sample += "\x1B[0m\n";
          }
          sample += "------------------------------------------------------------------------------------\n";
        }
        this.client.print(sample, true);
      };
      this.functions["testxterm"] = (title) => {
        let r;
        let g;
        let b;
        let c;
        let sample = "";
        if (typeof title !== "undefined" && title.length > 0) {
          sample += "Set Title: ";
          sample += title;
          sample += "\x1B]0;";
          sample += title;
          sample += "\x07\n";
        }
        sample += "System colors:\n";
        for (c = 0; c < 8; c++)
          sample += "\x1B[48;5;" + c + "m  ";
        sample += "\x1B[0m\n";
        for (c = 8; c < 16; c++)
          sample += "\x1B[48;5;" + c + "m  ";
        sample += "\x1B[0m\n\n";
        sample += "Color cube, 6x6x6:\n";
        for (g = 0; g < 6; g++) {
          for (r = 0; r < 6; r++) {
            for (b = 0; b < 6; b++) {
              c = 16 + r * 36 + g * 6 + b;
              sample += "\x1B[48;5;" + c + "m  ";
            }
            sample += "\x1B[0m ";
          }
          sample += "\n";
        }
        sample += "Grayscale ramp:\n";
        for (c = 232; c < 256; c++)
          sample += "\x1B[48;5;" + c + "m  ";
        sample += "\x1B[0m\n";
        this.client.print(sample, true);
      };
      this.functions["testmxp"] = () => {
        let sample = "Text Formatting\n";
        sample += "	\x1B[6z";
        sample += "<!--Test-->&lt;!--Test--&gt;\n";
        sample += "	<!--Test>-->&lt;!--Test&gt;--&gt;\n";
        sample += "	<STRONG>STRONG</STRONG>\n";
        sample += "	<BOLD>BOLD</BOLD>\n";
        sample += "	<B>B</B>\n";
        sample += "	<I>I</I>\n";
        sample += "	<ITALIC>ITALIC</ITALIC>\n";
        sample += "	<EM>EM</EM>\n";
        sample += "	<U>U</U>\n";
        sample += "	<UNDERLINE>UNDERLINE</UNDERLINE>\n";
        sample += "	<S>S</S>\n";
        sample += "	<STRIKEOUT>STRIKEOUT</STRIKEOUT>\n";
        sample += "	<H>H</H>\n";
        sample += "	<HIGH>HIGH</HIGH>\n";
        sample += "	<C RED>C RED</C>\n";
        sample += "	<COLOR #F00>COLOR #F00</COLOR>\n";
        sample += "	<C Maroon>C Maroon</C>\n";
        sample += "	<COLOR #800000>COLOR #800000</COLOR>\n";
        sample += "	<H><C Maroon>H C Maroon</C></H>\n";
        sample += "	<H><COLOR #800000>H COLOR #800000</COLOR></H>\n";
        sample += "	Run <send PROMPT>#testmxpcolors</send> for a detailed list.\n";
        sample += '	<FONT "Times New Roman">FONT "Times New Roman"</FONT>\n';
        sample += '	<FONT "Webdings">FONT "Webdings"</FONT>\n';
        sample += "	<FONT COLOR=Red,Blink>FONT COLOR=Red,Blink</FONT>\n";
        sample += '	<FONT "Times New Roman" 24 RED GREEN>FONT "Times New Roman" 24 RED GREEN</FONT>\n';
        sample += "Line Spacing\n";
        sample += "	NOBR<NOBR>\n";
        sample += " Continued<NOBR>\n";
        sample += " More\n";
        sample += "	<P>P\n";
        sample += "	1\n";
        sample += "	2\n";
        sample += "	3\n";
        sample += "	4</P>\n";
        sample += "	BR Line<BR>Break\n";
        sample += "	SBR Soft<SBR>Break\n";
        sample += "Links\n";
        sample += '	<A "http://shadowmud.com">Click here for ShadowMUD</A> \n';
        sample += "	<send>test command</send>\n";
        sample += '	<send href="command2">test command2</send>\n';
        sample += '	<send "command1|command2|command3" hint="click to see menu|Item 1|Item 2|Item 3">this is a menu link</SEND>\n';
        sample += '	<SEND "sample" PROMPT EXPIRE=prompt>Prompt sample</SEND>\n';
        sample += '	<send PROMPT href="#testmxpexpire">&lt;EXPIRE&gt; - #testmxpexpire</send> \n';
        sample += "Horizontal Rule\n";
        sample += "<hr>\n";
        sample += "<hr>Text After\n";
        sample += "Text Before<hr>\n";
        sample += "<c red blue><hr></c>\n";
        sample += "Text Before<hr>Text After\n";
        sample += "Custom Element\n";
        sample += `	<!ELEMENT help '<send href="help &text;">'>&lt;!ELEMENT help '&lt;send href="help &amp;text;"&gt;'&gt;
`;
        sample += "	&lt;help&gt;test&lt;/help&gt; = <help>test</help>\n";
        sample += "	<!ELEMENT redbu '<c red><b><u>'>&lt;!ELEMENT redbu '&lt;c red&gt;&lt;b&gt;&lt;u&gt;'&gt;\n";
        sample += "	&lt;redbu&gt;test&lt;/redbu&gt; = <redbu>test</redbu>\n";
        sample += "Entities\n";
        sample += "	&#243;&brvbar;&copy;&plusmn;&sup3;&para;&frac34;&infin;&Dagger;&dagger;&spades;&clubs;&hearts;&diams;\n";
        sample += "Custom Entity\n";
        sample += '	<!ENTITY version "' + this.client.version + '">&lt;!ENTITY version "' + this.client.version + '"&gt;\n';
        sample += "	&amp;version; = &version;\n";
        sample += "	&lt;V Hp&gt;<V Hp>100</V>&lt;/V&gt; &amp;Hp; = &Hp; &amp;hp; = &hp;\n";
        sample += "	&lt;VAR Sp&gt;<VAR Sp>200</VAR>&lt;/VAR&gt; &amp;Sp; = &Sp; &amp;sp; = &sp;\n";
        sample += "Image\n";
        sample += 'default      <image connected.png URL="./images/" w=48 h=48>\n';
        sample += 'align left <image connected.png URL="./images/" align=left w=48 h=48> align left\n';
        sample += 'align right  <image connected.png URL="./images/" align=right w=48 h=48> align right\n';
        sample += 'align top    <image connected.png URL="./images/" align=top w=48 h=48> align top \n';
        sample += 'align middle <image connected.png URL="./images/" align=middle w=48 h=48> align middle\n';
        sample += 'align bottom <image connected.png URL="./images/" align=bottom w=48 h=48> align bottom\n';
        sample += 'map          <send showmap><image connected.png URL="./images/" ismap w=48 h=48></send>\n';
        sample += "<STAT Hp version Test>";
        sample += "<GAUGE Hp version Test>";
        sample += "\x1B[0z";
        this.client.print(sample, true);
      };
      this.functions["testmxp2"] = () => {
        let sample = "\x1B[6z";
        sample += "<!-- Elements to support the Auto mapper -->";
        sample += `<!ELEMENT RName '<FONT COLOR=Red><B>' FLAG="RoomName">`;
        sample += "<!ELEMENT RDesc FLAG='RoomDesc'>";
        sample += "<!ELEMENT RExits '<FONT COLOR=Blue>' FLAG='RoomExit'>";
        sample += "<!-- The next element is used to define a room exit link that sends ";
        sample += "the exit direction to the MUD if the user clicks on it -->";
        sample += "<!ELEMENT Ex '<SEND>'>";
        sample += "<!ELEMENT Chat '<FONT COLOR=Gray>' OPEN>";
        sample += "<!ELEMENT Gossip '<FONT COLOR=Cyan>' OPEN>";
        sample += "<!-- in addition to standard HTML Color specifications, you can use ";
        sample += "color attribute names such as blink -->";
        sample += "<!ELEMENT ImmChan '<FONT COLOR=Red,Blink>'>";
        sample += "<!ELEMENT Auction '<FONT COLOR=Purple>' OPEN>";
        sample += "<!ELEMENT Group '<FONT COLOR=Blue>' OPEN>";
        sample += "<!-- the next elements deal with the MUD prompt -->";
        sample += '<!ELEMENT Prompt FLAG="Prompt">';
        sample += '<!ELEMENT Hp FLAG="Set hp">';
        sample += '<!ELEMENT MaxHp FLAG="Set maxhp">';
        sample += '<!ELEMENT Mana FLAG="Set mana">';
        sample += '<!ELEMENT MaxMana FLAG="Set maxmana">';
        sample += "<!-- now the MUD text -->";
        sample += "<RName>The Main Temple</RName>\n";
        sample += "<RDesc>This is the main hall of the MUD where everyone starts.\n";
        sample += "Marble arches lead south into the town, and there is a <i>lovely</i>\n";
        sample += '<send "drink &text;">fountain</send> in the center of the temple,</RDesc>\n';
        sample += "<RExits>Exits: <Ex>N</Ex>, <Ex>S</Ex>, <Ex>E</Ex>, <Ex>W</Ex></RExits>\n\n";
        sample += "<Prompt>[<Hp>100</Hp>/<MaxHp>120</MaxHp>hp <Mana>50</Mana>/<MaxMana>55</MaxMana>mana]</Prompt>\n<hr>";
        sample += "<!ELEMENT boldtext '<COLOR &col;><B>' ATT='col=red'>";
        sample += "<boldtext>This is bold red</boldtext>\n";
        sample += "<boldtext col=blue>This is bold blue text</boldtext>\n";
        sample += "<boldtext blue>This is also bold blue text</boldtext>\n";
        sample += "\x1B[0z";
        this.client.print(sample, true);
      };
      this.functions["testmxpexpire"] = () => {
        this.client.print('	\x1B[6z<SEND "sample" PROMPT EXPIRE=prompt>Expire sample</SEND> <SEND "sample" PROMPT EXPIRE=prompt2>Expire sample2</SEND><EXPIRE prompt> <SEND "sample" PROMPT EXPIRE=prompt>Expire sample3</SEND>\x1B[0z\n', true);
        this.client.print('	\x1B[6z\x1B[36m<SEND "sample" PROMPT EXPIRE=prompt>Expire sample</SEND> <SEND "sample" PROMPT EXPIRE=prompt2>Expire sample2</SEND><EXPIRE prompt> <SEND "sample" PROMPT EXPIRE=prompt>Expire sample3</SEND>\x1B[0z\x1B[0m\n', true);
        this.client.print('	\x1B[6z\x1B[46;30m<SEND "sample" PROMPT EXPIRE=prompt>Expire sample</SEND> <SEND "sample" PROMPT EXPIRE=prompt2>Expire sample2</SEND><EXPIRE prompt> <SEND "sample" PROMPT EXPIRE=prompt>Expire sample3</SEND>\x1B[0z\x1B[0m\n', true);
        this.client.print('	\x1B[6z<SEND "sample" PROMPT EXPIRE=prompt>Expire \x1B[36msample\x1B[0m</SEND> <SEND "sample" PROMPT EXPIRE=prompt2>Expire \x1B[36msample2\x1B[0m</SEND><EXPIRE prompt> <SEND "sample" PROMPT EXPIRE=prompt>Expire \x1B[36msample3\x1B[0m</SEND>\x1B[0z\n', true);
      };
      this.functions["testmxpcolors"] = () => {
        const colors = [
          "IndianRed",
          "LightCoral",
          "Salmon",
          "DarkSalmon",
          "LightSalmon",
          "Crimson",
          "Red",
          "FireBrick",
          "DarkRed",
          "Pink",
          "LightPink",
          "HotPink",
          "DeepPink",
          "MediumVioletRed",
          "PaleVioletRed",
          "LightSalmon",
          "Coral",
          "Tomato",
          "OrangeRed",
          "DarkOrange",
          "Orange",
          "Gold",
          "Yellow",
          "LightYellow",
          "LemonChiffon",
          "LightGoldenrodYellow",
          "PapayaWhip",
          "Moccasin",
          "PeachPuff",
          "PaleGoldenrod",
          "Khaki",
          "DarkKhaki",
          "Lavender",
          "Thistle",
          "Plum",
          "Violet",
          "Orchid",
          "Fuchsia",
          "Magenta",
          "MediumOrchid",
          "MediumPurple",
          "BlueViolet",
          "DarkViolet",
          "DarkOrchid",
          "DarkMagenta",
          "Purple",
          "Indigo",
          "SlateBlue",
          "DarkSlateBlue",
          "MediumSlateBlue",
          "GreenYellow",
          "Chartreuse",
          "LawnGreen",
          "Lime",
          "LimeGreen",
          "PaleGreen",
          "LightGreen",
          "MediumSpringGreen",
          "SpringGreen",
          "MediumSeaGreen",
          "SeaGreen",
          "ForestGreen",
          "Green",
          "DarkGreen",
          "YellowGreen",
          "OliveDrab",
          "Olive",
          "DarkOliveGreen",
          "MediumAquamarine",
          "DarkSeaGreen",
          "LightSeaGreen",
          "DarkCyan",
          "Teal",
          "Aqua",
          "Cyan",
          "LightCyan",
          "PaleTurquoise",
          "Aquamarine",
          "Turquoise",
          "MediumTurquoise",
          "DarkTurquoise",
          "CadetBlue",
          "SteelBlue",
          "LightSteelBlue",
          "PowderBlue",
          "LightBlue",
          "SkyBlue",
          "LightSkyBlue",
          "DeepSkyBlue",
          "DodgerBlue",
          "CornflowerBlue",
          "MediumSlateBlue",
          "RoyalBlue",
          "Blue",
          "MediumBlue",
          "DarkBlue",
          "Navy",
          "MidnightBlue",
          "Cornsilk",
          "BlanchedAlmond",
          "Bisque",
          "NavajoWhite",
          "Wheat",
          "BurlyWood",
          "Tan",
          "RosyBrown",
          "SandyBrown",
          "Goldenrod",
          "DarkGoldenrod",
          "Peru",
          "Chocolate",
          "SaddleBrown",
          "Sienna",
          "Brown",
          "Maroon",
          "White",
          "Snow",
          "Honeydew",
          "MintCream",
          "Azure",
          "AliceBlue",
          "GhostWhite",
          "WhiteSmoke",
          "Seashell",
          "Beige",
          "OldLace",
          "FloralWhite",
          "Ivory",
          "AntiqueWhite",
          "Linen",
          "LavenderBlush",
          "MistyRose",
          "Gainsboro",
          "LightGrey",
          "Silver",
          "DarkGray",
          "Gray",
          "DimGray",
          "LightSlateGray",
          "SlateGray",
          "DarkSlateGray",
          "Black"
        ];
        let sample = "\x1B[6z";
        const cl = colors.length - 1;
        for (let c = 0; c < cl; c++) {
          sample += "" + colors[c] + ": ";
          sample += Array(22 - colors[c].length).join(" ");
          sample += "<C " + colors[c] + ">Fore</C> ";
          sample += "<C black " + colors[c] + ">Back</C> ";
          sample += "<h><C " + colors[c] + ">High</C></h> ";
          sample += "<b><C " + colors[c] + ">Bold</C></b> ";
          sample += "<C " + colors[c] + ">\x1B[1mAnsiBold\x1B[0m ";
          sample += "\x1B[2mFaint\x1B[0m ";
          sample += "\x1B[3mItalic\x1B[0m ";
          sample += "\x1B[4mUnderline\x1B[0m ";
          sample += "\x1B[5mFlash\x1B[0m ";
          sample += "\x1B[7mInverse\x1B[0m ";
          sample += "\x1B[8mConceal\x1B[0m ";
          sample += "\x1B[9mStrikeout\x1B[0m ";
          sample += "\x1B[21mDoubleUnderline\x1B[0m ";
          sample += "\x1B[53mOverline\x1B[0m";
          sample += "</C>\n";
        }
        sample += "Black: ";
        sample += Array(17).join(" ");
        sample += "<C Black silver>Fore</C> ";
        sample += "<C silver Black>Back</C> ";
        sample += "<h><C Black silver>High</C></h> ";
        sample += "<b><C Black silver>Bold</C></b> ";
        sample += "<C Black silver>\x1B[1mAnsiBold\x1B[0m ";
        sample += "\x1B[2mFaint\x1B[0m ";
        sample += "\x1B[3mItalic\x1B[0m ";
        sample += "\x1B[4mUnderline\x1B[0m ";
        sample += "\x1B[5mFlash\x1B[0m ";
        sample += "\x1B[7mInverse\x1B[0m ";
        sample += "\x1B[8mConceal\x1B[0m ";
        sample += "\x1B[9mStrikeout\x1B[0m ";
        sample += "\x1B[21mDoubleUnderline\x1B[0m ";
        sample += "\x1B[53mOverline\x1B[0m";
        sample += "</C>\n";
        sample += "\x1B[0z";
        this.client.print(sample, true);
      };
      this.functions["testmxpelements"] = () => {
        let sample = "\x1B[6z";
        sample += "Custom Element\n";
        sample += `	<!ELEMENT help '<send href="help &text;">'>&lt;!ELEMENT help '&lt;send href="help &amp;text;"&gt;'&gt;
`;
        sample += "	&lt;help&gt;test&lt;/help&gt; = <help>test</help>\n";
        sample += "	<!ELEMENT redbu '<c red><b><u>'>&lt;!ELEMENT redbu '&lt;c red&gt;&lt;b&gt;&lt;u&gt;'&gt;\n";
        sample += "	&lt;redbu&gt;test&lt;/redbu&gt; = <redbu>test</redbu>\n";
        sample += "\x1B[0z";
        this.client.print(sample, true);
      };
      this.functions["testmxplines"] = () => {
        let sample = "\x1B[6z";
        sample += "<!ELEMENT Auction '<FONT COLOR=red>' TAG=20 OPEN>";
        sample += "\x1B[20zA nice shiny sword is being auctioned.\n";
        sample += "\x1B[6z<Auction>Also, a gold ring is being auctioned.</Auction>";
        sample += "<!ELEMENT Auction TAG=20>\n";
        sample += "<!TAG 20 Fore=red>\n";
        sample += "\x1B[20zA nice shiny sword is being auctioned.\n";
        sample += "\x1B[6z<Auction>Also, a gold ring is being auctioned.</Auction>\n";
        sample += "\x1B[6z<!TAG 20 Fore=blue>\n";
        sample += "\x1B[20zA nice shiny sword is being auctioned.\n";
        sample += "\x1B[6z<Auction>Also, a gold ring is being auctioned.</Auction>\n";
        sample += "\x1B[0z";
        this.client.print(sample, true);
      };
      this.functions["testmapper"] = () => {
        this.client.emit("received-GMCP", "Room.Info", {
          details: [],
          doors: {},
          prevroom: { num: 0, dir: "", area: "" },
          area: "Doc Build Samples Area",
          exits: {
            south: { num: 87723359, dir: "south", area: "Doc Build Samples Area", isdoor: 0 },
            east: { num: -329701270, dir: "east", area: "Doc Build Samples Area", isdoor: 0 }
          },
          name: "Sample room 1",
          num: 1968208336,
          indoors: 0
        });
        this.client.emit("received-GMCP", "Room.Info", {
          details: [],
          doors: {},
          prevroom: { num: 1968208336, dir: "east", area: "Doc Build Samples Area" },
          area: "Doc Build Samples Area",
          environment: "wood",
          exits: {
            south: { num: 1916648905, dir: "south", area: "Doc Build Samples Area", isdoor: 0 },
            east: { num: -1688332036, dir: "east", area: "Doc Build Samples Area", isdoor: 0 },
            west: { num: 1968208336, dir: "west", area: "Doc Build Samples Area", isdoor: 0 }
          },
          name: "Sample room 2",
          num: -329701270,
          indoors: 0
        });
        this.client.emit("received-GMCP", "Room.Info", {
          details: [],
          doors: {},
          prevroom: { num: -329701270, dir: "east", area: "Doc Build Samples Area" },
          area: "Doc Build Samples Area",
          environment: "jungle",
          exits: {
            south: { num: -348853133, dir: "south", area: "Doc Build Samples Area", isdoor: 0 },
            west: { num: -329701270, dir: "west", area: "Doc Build Samples Area", isdoor: 0 }
          },
          name: "Sample room 3",
          num: -1688332036,
          indoors: 0
        });
        this.client.emit("received-GMCP", "Room.Info", {
          details: [],
          doors: {},
          prevroom: { num: -1688332036, dir: "south", area: "Doc Build Samples Area" },
          area: "Doc Build Samples Area",
          environment: "grass",
          exits: {
            north: { num: -1688332036, dir: "north", area: "Doc Build Samples Area", isdoor: 0 },
            south: { num: 2072768994, dir: "south", area: "Doc Build Samples Area", isdoor: 0 },
            west: { num: 1916648905, dir: "west", area: "Doc Build Samples Area", isdoor: 0 }
          },
          name: "Sample room 6",
          num: -348853133,
          indoors: 0
        });
        this.client.emit("received-GMCP", "Room.Info", {
          details: [],
          doors: {},
          prevroom: { num: -348853133, dir: "west", area: "Doc Build Samples Area" },
          area: "Doc Build Samples Area",
          environment: "desert",
          exits: {
            north: { num: -329701270, dir: "north", area: "Doc Build Samples Area", isdoor: 0 },
            south: { num: 210551156, dir: "south", area: "Doc Build Samples Area", isdoor: 0 },
            east: { num: -348853133, dir: "east", area: "Doc Build Samples Area", isdoor: 0 },
            west: { num: 87723359, dir: "west", area: "Doc Build Samples Area", isdoor: 0 }
          },
          name: "Sample room 5",
          num: 1916648905,
          indoors: 1
        });
        this.client.emit("received-GMCP", "Room.Info", {
          details: [],
          doors: {},
          prevroom: { num: 1916648905, dir: "west", area: "Doc Build Samples Area" },
          area: "Doc Build Samples Area",
          environment: "tundra",
          exits: {
            north: { num: 1968208336, dir: "north", area: "Doc Build Samples Area", isdoor: 0 },
            south: { num: -1674322715, dir: "south", area: "Doc Build Samples Area", isdoor: 0 },
            east: { num: 87723359, dir: "east", area: "Doc Build Samples Area", isdoor: 0 }
          },
          name: "Sample room 4",
          num: 87723359,
          indoors: 0
        });
        this.client.emit("received-GMCP", "Room.Info", {
          details: [],
          doors: {},
          prevroom: { num: 87723359, dir: "south", area: "Doc Build Samples Area" },
          area: "Doc Build Samples Area",
          environment: "water",
          exits: {
            north: { num: 87723359, dir: "north", area: "Doc Build Samples Area", isdoor: 0 },
            east: { num: 210551156, dir: "east", area: "Doc Build Samples Area", isdoor: 0 }
          },
          name: "Sample room 7",
          num: -1674322715,
          indoors: 0
        });
        this.client.emit("received-GMCP", "Room.Info", {
          details: [],
          doors: {},
          prevroom: { num: -1674322715, dir: "east", area: "Doc Build Samples Area" },
          area: "Doc Build Samples Area",
          environment: "jungle",
          exits: {
            north: { num: 1916648905, dir: "north", area: "Doc Build Samples Area", isdoor: 0 },
            east: { num: 2072768994, dir: "east", area: "Doc Build Samples Area", isdoor: 0 },
            west: { num: -1674322715, dir: "west", area: "Doc Build Samples Area", isdoor: 0 }
          },
          name: "Sample room 8",
          num: 210551156,
          indoors: 0
        });
        this.client.emit("received-GMCP", "Room.Info", {
          details: [],
          doors: {},
          prevroom: { num: 210551156, dir: "east", area: "Doc Build Samples Area" },
          area: "Doc Build Samples Area",
          exits: {
            north: { num: -348853133, dir: "north", area: "Doc Build Samples Area", isdoor: 0 },
            west: { num: 210551156, dir: "west", area: "Doc Build Samples Area", isdoor: 0 }
          },
          name: "Sample room 9",
          num: 2072768994,
          indoors: 0
        });
      };
      this.functions["teststatus"] = (data) => {
        this.client.emit("received-GMCP", "Char.Base", {
          name: "Tester",
          class: "fighter",
          subclass: "None",
          race: "human",
          level: 1,
          gender: "male"
        });
        this.client.emit("received-GMCP", "Char.Vitals", {
          hp: 75,
          hpmax: 100,
          sp: 50,
          spmax: 100,
          mp: 25,
          mpmax: 100
        });
        this.client.emit("received-GMCP", "Char.Experience", {
          current: 50,
          need: 100,
          needPercent: 50,
          earned: 200,
          banked: 300
        });
        this.client.emit("received-GMCP", "oMUD.limb", {
          head: 10,
          torso: 20,
          "left arm": 30,
          "right arm": 40,
          "left hand": 50,
          "right hand": 60,
          "left leg": 70,
          "right leg": 80,
          "right foot": 90,
          "left foot": 100,
          "left wing": 90,
          "right wing": 80,
          tail: 70
        });
        this.client.emit("received-GMCP", "oMUD.ac", {
          head: 0,
          torso: 1,
          "left arm": 2,
          "right arm": 3,
          "left hand": 3.5,
          "right hand": 4,
          "left leg": 4.5,
          "right leg": 5,
          "right foot": 5.5,
          "left foot": 6,
          "left wing": 6.5,
          "right wing": 5,
          tail: 4,
          overall: 4
        });
        this.client.emit("received-GMCP", "oMUD.weapons", {
          "right hand": { "name": "knife", "type": "knife", "subtype": "dagger", "material": "iron", "quality": "pooor", "dominant": 1 },
          "left hand": { "name": "club", "type": "blunt", "subtype": "club", "material": "wood", "quality": "ordinary", "dominant": 0 }
        });
        if (data && data.args && data.args.length && data.args[0] === "night")
          this.client.emit("received-GMCP", "oMUD.Environment", { tod: "night", moons: ["waning", "full", "waxing"] });
        else
          this.client.emit("received-GMCP", "oMUD.Environment", { "tod": "day" });
        this.client.emit("received-GMCP", "oMUD.skill", { skill: "knife", percent: 60 });
        this.client.emit("received-GMCP", "oMUD.skill", { skill: "knife", amount: 100, bonus: 5, category: "weapon" });
        this.client.emit("received-GMCP", "oMUD.skill", { skill: "small sword", percent: 100 });
        let found = false;
        this.client.emit("received-GMCP", "oMUD.skill", { skill: "small sword", amount: 1150, bonus: 0, category: "weapon" });
        if (data && data.args && data.args.length) {
          data.args.forEach((arg) => {
            if (arg.startsWith("party:")) {
              found = true;
              let s = parseInt(arg.split(":")[1], 10);
              for (let m = 0; m < s; m++)
                this.client.emit("received-GMCP", "oMUD.party", { "action": "update", "name": "Party " + (m + 1), "hp": 50, race: "human", "id": m });
            }
          });
        }
        if (!found) {
          this.client.emit("received-GMCP", "oMUD.party", { "action": "update", "name": "Elf", "hp": 50, race: "elf", "id": 1 });
          this.client.emit("received-GMCP", "oMUD.party", { "action": "update", "name": "Dwarf", "hp": 100, race: "dwarf", "id": 2 });
        }
        found = false;
        if (data && data.args && data.args.length) {
          data.args.forEach((arg) => {
            if (arg.startsWith("monster:")) {
              found = true;
              let s = parseInt(arg.split(":")[1], 10);
              for (let m = 0; m < s; m++)
                this.client.emit("received-GMCP", "oMUD.combat", { "action": "update", "name": "Monster " + (m + 1), "hp": 50, race: "orc", "id": m, order: 0 });
            }
          });
        }
        if (!found) {
          this.client.emit("received-GMCP", "oMUD.combat", { "action": "update", "name": "Monster", "hp": 50, race: "orc", "id": 3, order: 0 });
          this.client.emit("received-GMCP", "oMUD.combat", { "action": "update", "name": "Monster 2", "hp": 100, race: "dragon", "id": 4, order: 1 });
          this.client.emit("received-GMCP", "oMUD.combat", { "action": "update", "name": "Monster with extra super long name to test", "hp": 100, race: "dragon", "id": 5, order: 2 });
        }
      };
      this.functions["testfansi"] = () => {
        let sample = "";
        let i2;
        sample = String.fromCharCode(1);
        for (i2 = 3; i2 <= 6; i2++)
          sample += String.fromCharCode(i2);
        for (i2 = 14; i2 <= 26; i2++)
          sample += String.fromCharCode(i2);
        for (i2 = 28; i2 <= 31; i2++)
          sample += String.fromCharCode(i2);
        for (i2 = 127; i2 <= 254; i2++)
          sample += String.fromCharCode(i2);
        sample += "\n";
        const dcc = this.client.display.displayControlCodes;
        this.client.display.displayControlCodes = true;
        if (!this.client.display.emulateTerminal) {
          this.client.print(sample, true);
          this.client.display.emulateTerminal = true;
          this.client.print(sample, true);
          this.client.display.emulateTerminal = false;
        } else {
          this.client.display.emulateTerminal = false;
          this.client.print(sample, true);
          this.client.display.emulateTerminal = true;
          this.client.print(sample, true);
        }
        this.client.display.displayControlCodes = dcc;
      };
      this.functions["testcontrolchars"] = () => {
        let i2;
        let sample = "1:  " + String.fromCharCode(1) + ",";
        for (i2 = 3; i2 <= 9; i2++)
          sample += `${i2}: ${String.fromCharCode(i2)},`;
        for (i2 = 11; i2 <= 27; i2++)
          sample += `${i2}: ${String.fromCharCode(i2)},`;
        for (i2 = 28; i2 <= 31; i2++)
          sample += `${i2}: ${String.fromCharCode(i2)},`;
        for (i2 = 127; i2 <= 254; i2++)
          sample += `${i2}: ${String.fromCharCode(i2)},`;
        sample += "\n";
        const dcc = this.client.display.displayControlCodes;
        this.client.display.displayControlCodes = true;
        this.client.print(sample, true);
        this.client.display.displayControlCodes = dcc;
      };
      this.functions["testurldetect"] = () => {
        let sample = "\x1B[0mhttp://www.google.com\n";
        sample += "	http://www.google.com\x1B[44m\n";
        sample += "http://www.google.com\n";
        sample += "	try this http://www.google.com\n";
        sample += "http://www.google.com try this\n";
        sample += "	try this http://www.google.com try this\n";
        sample += "\x1B[36mhttp://www.google.com\n";
        sample += "	\x1B[0mhttp://www.google.com\n";
        sample += "http://www.google.com\x1B[44m\n";
        sample += "	http://www.google.com\n";
        sample += "try this http://www.google.com\n";
        sample += "	http://www.google.com try this\n";
        sample += "try this http://www.google.com try this\n";
        sample += "	\x1B[36mhttp://www.google.com\n";
        sample += "	https://localhost telnet://localhost\n";
        sample += "	news://test.edu/default.asp?t=1#1111 torrent://localhost/\n";
        sample += "	ftp://localhost gopher://localhost im://talk\n";
        sample += "	mailto:address@localhost irc://<host>[:<port>]/[<channel>[?<password>]]\n";
        sample += "awww... www.google.com awww.com\n";
        sample += "www.google.com www.google.com\x1B[0m";
        this.client.print(sample, true);
      };
      this.functions["testxtermrgb"] = () => {
        let sample = "";
        let r;
        let g;
        let b;
        let i2 = 0;
        for (r = 0; r < 256; r += 16) {
          for (g = 0; g < 256; g += 16) {
            for (b = 0; b < 256; b += 16) {
              sample += "\x1B[48;2;" + r + ";" + g + ";" + b + "m  ";
              if (i2 % 63 === 0)
                sample += "\n";
              i2++;
            }
          }
        }
        sample += "\x1B[0m";
        this.client.print(sample, true);
      };
      this.functions["testsize"] = () => {
        const ws = this.client.display.WindowSize;
        let sample = ws.width + "x" + ws.height + " ";
        ws.width -= sample.length;
        for (let w = 0; w < ws.width; w++)
          sample += "w";
        for (let h = 1; h < ws.height; h++)
          sample += "\n" + h;
        this.client.print(sample, true);
      };
      this.functions["testspeed"] = () => {
        const sample = [];
        const commands = this.client.getOption("commandChar") + ["testmxpcolors", "testmxp", "testcolors", "testcolorsdetails", "testxterm", "testxtermrgb"].join("\n" + this.client.getOption("commandChar"));
        const e = this.client.getOption("enableCommands");
        this.client.setOption("enableCommands", true);
        let avg = 0;
        let max2 = 0;
        let min = 0;
        let t;
        for (let i2 = 0; i2 < 10; i2++) {
          const start = (/* @__PURE__ */ new Date()).getTime();
          this.client.sendCommand(commands);
          const end = (/* @__PURE__ */ new Date()).getTime();
          t = end - start;
          avg += t;
          if (t > max2) max2 = t;
          if (!min || t < min) min = t;
          sample.push(`${i2} - ${t}`);
        }
        sample.push(`Total - ${avg}`);
        sample.push(`Average - ${avg / 10}`);
        sample.push(`Min - ${min}`);
        sample.push(`Max - ${max2}`);
        this.client.print(sample.join("\n") + "\n", true);
        this.client.setOption("enableCommands", e);
      };
      this.functions["testperiod"] = () => {
        if (window["periodID"]) {
          clearInterval(window["periodID"]);
          delete window["period"];
          delete window["periodID"];
          return;
        }
        window["period"] = 0;
        window["periodID"] = setInterval(() => {
          if (window["period"] % 3 === 1)
            this.client.sendCommand("#testcolors");
          else if (window["period"] % 3 === 2)
            this.client.sendCommand("#testxterm");
          else
            this.client.sendCommand("#testlist");
          window["period"]++;
        }, 2e3);
      };
      this.functions["testutf8"] = () => {
        const sample = `Armenian
\u0531 \u0532 \u0533 \u0534 \u0535 \u0536 \u0537 \u0538 \u0539 \u053A \u053B \u053C \u053D \u053E \u053F \u0540 \u0541 \u0542 \u0543 \u0544 \u0545 \u0546 \u0547 \u0548 \u0549 \u054A \u054B \u054C \u054D \u054E \u054F \u0550 \u0551 \u0552 \u0553 \u0554 \u0555 \u0556 \u0559 \u055A \u055B \u055C \u055D \u055E \u055F \u0561 \u0562 \u0563 \u0564 \u0565 \u0566 \u0567 \u0568 \u0569 \u056A \u056B \u056C \u056D \u056E \u056F \u0570 \u0571 \u0572 \u0573 \u0574 \u0575 \u0576 \u0577 \u0578 \u0579 \u057A \u057B \u057C \u057D \u057E \u057F \u0580 \u0581 \u0582 \u0583 \u0584 \u0585 \u0586 \u0587 \u0589
Hebrew
\u0591 \u0592 \u0593 \u0594 \u0595 \u0596 \u0597 \u0598 \u0599 \u059A \u059B \u059C \u059D \u059E \u059F \u05A0 \u05A1 \u05A3 \u05A4 \u05A5 \u05A6 \u05A7 \u05A8 \u05A9 \u05AA \u05AB \u05AC \u05AD \u05AE \u05AF \u05B0 \u05B1 \u05B2 \u05B3 \u05B4 \u05B5 \u05B6 \u05B7 \u05B8 \u05B9 \u05BB \u05BC \u05BD \u05BE \u05BF \u05C0 \u05C1 \u05C2 \u05C3 \u05C4 \u05D0 \u05D1 \u05D2 \u05D3 \u05D4 \u05D5 \u05D6 \u05D7 \u05D8 \u05D9 \u05DA \u05DB \u05DC \u05DD \u05DE \u05DF \u05E0 \u05E1 \u05E2 \u05E3 \u05E4 \u05E5 \u05E6 \u05E7 \u05E8 \u05E9 \u05EA \u05F0 \u05F1 \u05F2 \u05F3 \u05F4
Arabic
\u060C \u061B \u061F \u0621 \u0622 \u0623 \u0624 \u0625 \u0626 \u0627 \u0628 \u0629 \u062A \u062B \u062C \u062D \u062E \u062F \u0630 \u0631 \u0632 \u0633 \u0634 \u0635 \u0636 \u0637 \u0638 \u0639 \u063A \u0640 \u0641 \u0642 \u0643 \u0644 \u0645 \u0646 \u0647 \u0648 \u0649 \u064A \u064B \u064C \u064D \u064E \u064F \u0650 \u0651 \u0652 \u0660 \u0661 \u0662 \u0663 \u0664 \u0665 \u0666 \u0667 \u0668 \u0669 \u066A \u066B \u066C \u066D \u0670 \u0671 \u0672 \u0673 \u0674 \u0675 \u0676 \u0677 \u0678 \u0679 \u067A \u067B \u067C \u067D \u067E \u067F \u0680 \u0681 \u0682 \u0683 \u0684 \u0685 \u0686 \u0687 \u0688 \u0689 \u068A \u068B \u068C \u068D \u068E \u068F \u0690 \u0691 \u0692 \u0693 \u0694 \u0695 \u0696 \u0697 \u0698 \u0699 \u069A \u069B \u069C \u069D \u069E \u069F \u06A0 \u06A1 \u06A2 \u06A3 \u06A4 \u06A5 \u06A6 \u06A7 \u06A8 \u06A9 \u06AA \u06AB \u06AC \u06AD \u06AE \u06AF \u06B0 \u06B1 ...
Devanagari
\u0901 \u0902 \u0903 \u0905 \u0906 \u0907 \u0908 \u0909 \u090A \u090B \u090C \u090D \u090E \u090F \u0910 \u0911 \u0912 \u0913 \u0914 \u0915 \u0916 \u0917 \u0918 \u0919 \u091A \u091B \u091C \u091D \u091E \u091F \u0920 \u0921 \u0922 \u0923 \u0924 \u0925 \u0926 \u0927 \u0928 \u0929 \u092A \u092B \u092C \u092D \u092E \u092F \u0930 \u0931 \u0932 \u0933 \u0934 \u0935 \u0936 \u0937 \u0938 \u0939 \u093C \u093D \u093E \u093F \u0940 \u0941 \u0942 \u0943 \u0944 \u0945 \u0946 \u0947 \u0948 \u0949 \u094A \u094B \u094C \u094D \u0950 \u0951 \u0952 \u0953 \u0954 \u0958 \u0959 \u095A \u095B \u095C \u095D \u095E \u095F \u0960 \u0961 \u0962 \u0963 \u0964 \u0965 \u0966 \u0967 \u0968 \u0969 \u096A \u096B \u096C \u096D \u096E \u096F \u0970
Armenian
\u0531 \u0532 \u0533 \u0534 \u0535 \u0536 \u0537 \u0538 \u0539 \u053A \u053B \u053C \u053D \u053E \u053F \x1B[33m\u0540 \u0541 \u0542 \u0543 \u0544 \u0545 \u0546 \u0547 \u0548 \u0549 \u054A \u054B \u054C \u054D \u054E \u054F \u0550 \u0551 \u0552 \x1B[34m\u0553 \u0554 \u0555 \u0556 \u0559 \u055A \u055B \u055C \u055D \u055E \u055F \u0561 \u0562 \u0563 \u0564 \u0565 \u0566 \u0567 \u0568 \u0569 \u056A \u056B \u056C \u056D \u056E \u056F \u0570\x1B[35m \u0571 \u0572 \u0573 \u0574 \u0575 \u0576 \u0577 \u0578 \u0579 \u057A \u057B \u057C \u057D \u057E \u057F \u0580 \u0581 \u0582 \u0583 \u0584 \u0585 \u0586 \u0587 \u0589\x1B[0m
Hebrew
\u0591 \u0592 \u0593 \u0594 \u0595 \u0596 \u0597 \u0598 \u0599 \u059A \u059B \u059C \u059D \u059E\x1B[33m \u059F \u05A0 \u05A1 \u05A3 \u05A4 \u05A5 \u05A6 \u05A7 \u05A8 \u05A9 \u05AA \u05AB \u05AC \u05AD \u05AE \u05AF \u05B0 \u05B1 \u05B2 \u05B3 \u05B4 \u05B5 \u05B6 \u05B7 \u05B8 \u05B9 \u05BB \u05BC \u05BD \u05BE \u05BF \u05C0 \u05C1 \u05C2 \u05C3 \u05C4 \u05D0 \u05D1 \u05D2 \u05D3 \u05D4 \u05D5 \u05D6 \u05D7 \u05D8 \u05D9 \u05DA \u05DB \u05DC\x1B[34m \u05DD \u05DE \u05DF \u05E0 \u05E1 \u05E2 \u05E3 \u05E4 \u05E5 \u05E6 \u05E7 \u05E8 \u05E9 \u05EA \u05F0 \u05F1 \u05F2 \u05F3 \u05F4\x1B[0m
\u0591 \u0592 \u0593 \u0594 \u0595 \u0596 \u0597 \u0598 \u0599 \u059A \u059B \u059C \u059D \u059E\x1B[33m \u059F \u05A0 \u05A1 \u05A3 \u05A4 \u05A5 \u05A6 \u05A7 \u05A8 \u05A9 \u05AA \u05AB \u05AC \u05AD \u05AE \u05AF \u05B0 \u05B1 \u05B2 \u05B3 \u05B4 \u05B5 \u05B6 \u05B7 \u05B8 \u05B9 \u05BB \u05BC \u05BD \u05BE \u05BF \u05C0 \u05C1 \u05C2 \u05C3 \u05C4 \u05D0 \u05D1 \u05D2 \u05D3 \u05D4 \u05D5 \u05D6 \u05D7 \u05D8 \u05D9 \u05DA \u05DB \u05DCa\x1B[34m \u05DD \u05DE \u05DF \u05E0 \u05E1 \u05E2 \u05E3 \u05E4 \u05E5 \u05E6 \u05E7 \u05E8 \u05E9 \u05EA \u05F0 \u05F1 \u05F2 \u05F3 \u05F4\x1B[0m
Arabic
\u060C \u061B \u061F \u0621 \u0622 \u0623 \u0624 \u0625 \u0626 \u0627 \u0628 \u0629 \u062A \u062B \u062C \u062D \u062E \u062F \u0630 \u0631 \u0632 \u0633 \u0634 \u0635 \u0636 \u0637 \u0638 \u0639\x1B[34m \u063A \u0640 \u0641 \u0642 \u0643 \u0644 \u0645 \u0646 \u0647 \u0648 \u0649 \u064A \u064B \u064C \u064D \u064E \u064F \u0650 \u0651 \u0652 \u0660 \u0661 \u0662 \u0663 \u0664 \u0665 \u0666 \u0667 \u0668 \u0669 \u066A \u066B \u066C \u066D \u0670 \u0671 \u0672 \u0673 \u0674 \u0675 \u0676 \u0677 \u0678 \u0679 \u067A \u067B \u067C \u067D \u067E \u067F \u0680 \u0681 \u0682 \u0683 \u0684 \u0685 \u0686 \u0687 \u0688 \u0689 \u068A \u068B \u068C \u068D \u068E \u068F \u0690 \u0691 \u0692 \u0693 \u0694 \u0695 \u0696 \u0697 \u0698 \u0699 \u069A \u069B \u069C \u069D \u069E \u069F \u06A0 \u06A1 \u06A2 \u06A3 \u06A4 \u06A5 \u06A6 \x1B[33m\u06A7 \u06A8 \u06A9 \u06AA \u06AB \u06AC \u06AD \u06AE \u06AF \u06B0 \u06B1 ...\x1B[0m
Devanagari
\u0901 \u0902 \u0903 \u0905 \u0906 \u0907 \u0908 \u0909 \u090A \u090B \u090C \u090D \u090E \u090F \u0910 \u0911 \u0912 \u0913 \u0914 \u0915 \u0916 \u0917 \u0918 \u0919 \u091A \u091B \u091C \u091D \u091E \u091F \u0920 \u0921 \u0922 \u0923 \u0924 \u0925 \u0926 \u0927 \u0928 \u0929 \u092A \x1B[33m\u092B \u092C \u092D \u092E \u092F \u0930 \u0931 \u0932 \u0933 \u0934 \u0935 \u0936 \u0937 \u0938 \u0939 \u093C \u093D \u093E \u093F \u0940 \u0941 \u0942 \u0943 \u0944 \u0945 \u0946 \u0947 \u0948 \u0949 \u094A \u094B \u094C \u094D \u0950 \u0951 \u0952 \u0953 \u0954 \u0958 \u0959 \u095A \u095B\x1B[34m \u095C \u095D \u095E \u095F \u0960 \u0961 \u0962 \u0963 \u0964 \u0965 \u0966 \u0967 \u0968 \u0969 \u096A \u096B \u096C \u096D \u096E \u096F \u0970\x1B[0m`;
        this.client.print(sample, true);
      };
      this.functions["testunicodeemoji"] = () => {
        let sample = "";
        var emojiRange = [
          [128513, 128591],
          //Emoticons ( 1F601 - 1F64F ) 
          [9986, 10160],
          //Dingbats ( 2702 - 27B0 ) 
          [128640, 128704],
          //Transport and map symbols ( 1F680 - 1F6C0 ) 
          //[0x24C2, 0x1F251], //Enclosed characters ( 24C2 - 1F251 ) 
          [128512, 128566],
          //Additional emoticons ( 1F600 - 1F636 )
          [128641, 128709],
          //Additional transport and map symbols ( 1F681 - 1F6C5 ) 
          [127757, 128359]
          //Other additional symbols ( 1F30D - 1F567 ) 
        ];
        var n = 0;
        for (var i2 = 0; i2 < emojiRange.length; i2++) {
          var range = emojiRange[i2];
          for (var x2 = range[0]; x2 < range[1]; x2++) {
            sample += String.fromCodePoint(x2);
            n++;
            if (n == 36) {
              sample += "\n";
              n = 0;
            }
          }
          sample += "\x1B[4z<hr>";
          n = 0;
        }
        let sample2 = `\x1B[4z<hr>\xA9\xAE\u203C\u2049#\u20E38\u20E39\u20E37\u20E30\u20E36\u20E35\u20E34\u20E33\u20E32\u20E31\u20E3\u2122\u2139\u2194\u2195\u2196\u2197\u2198\u2199\u21A9\u21AA\u231A\u231B\u23E9\u23EA\u23EB\u23EC\u23F0\u23F3\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FD\u25FE\u2600\u2601\u260E\u2611\u2614\u2615
\u261D\u263A\u2648\u2649\u264A\u264B\u264C\u264D\u264E\u264F\u2650\u2651\u2652\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2693\u26A0\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5
\u26FA\u26FD\u2934\u2935\u2B05\u2B06\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299\u{1F004}\u{1F0CF}\u{1F300}\u{1F301}\u{1F302}\u{1F303}\u{1F304}\u{1F305}\u{1F306}\u{1F307}\u{1F308}\u{1F309}\u{1F30A}\u{1F30B}\u{1F30C}\u{1F30F}\u{1F311}\u{1F313}\u{1F314}\u{1F315}
\u{1F319}\u{1F31B}\u{1F31F}\u{1F320}\u{1F330}\u{1F331}\u{1F334}\u{1F335}\u{1F337}\u{1F338}\u{1F339}\u{1F33A}\u{1F33B}\u{1F33C}\u{1F33D}\u{1F33E}\u{1F33F}\u{1F340}\u{1F341}\u{1F342}\u{1F343}\u{1F344}\u{1F345}\u{1F346}\u{1F347}\u{1F348}\u{1F349}\u{1F34A}\u{1F34C}\u{1F34D}\u{1F34E}\u{1F34F}\u{1F351}
\u{1F352}\u{1F353}\u{1F354}\u{1F355}\u{1F356}\u{1F357}\u{1F358}\u{1F359}\u{1F35A}\u{1F35B}\u{1F35C}\u{1F35D}\u{1F35E}\u{1F35F}\u{1F360}\u{1F361}\u{1F362}\u{1F363}\u{1F364}\u{1F365}\u{1F366}\u{1F367}\u{1F368}\u{1F369}\u{1F36A}\u{1F36B}\u{1F36C}\u{1F36D}\u{1F36E}\u{1F36F}\u{1F370}\u{1F371}\u{1F372}
\u{1F373}\u{1F374}\u{1F375}\u{1F376}\u{1F377}\u{1F378}\u{1F379}\u{1F37A}\u{1F37B}\u{1F380}\u{1F381}\u{1F382}\u{1F383}\u{1F384}\u{1F385}\u{1F386}\u{1F387}\u{1F388}\u{1F389}\u{1F38A}\u{1F38B}\u{1F38C}\u{1F38D}\u{1F38E}\u{1F38F}\u{1F390}\u{1F391}\u{1F392}\u{1F393}\u{1F3A0}\u{1F3A1}\u{1F3A2}\u{1F3A3}\u{1F3A4}
\u{1F3A5}\u{1F3A6}\u{1F3A7}\u{1F3A8}\u{1F3A9}\u{1F3AA}\u{1F3AB}\u{1F3AC}\u{1F3AD}\u{1F3AE}\u{1F3AF}\u{1F3B0}\u{1F3B1}\u{1F3B2}\u{1F3B3}\u{1F3B4}\u{1F3B5}\u{1F3B6}\u{1F3B7}\u{1F3B8}\u{1F3B9}\u{1F3BA}\u{1F3BB}\u{1F3BC}\u{1F3BD}\u{1F3BE}\u{1F3BF}\u{1F3C0}\u{1F3C1}\u{1F3C2}\u{1F3C3}\u{1F3C4}
\u{1F3C6}\u{1F3C8}\u{1F3CA}\u{1F3E0}\u{1F3E1}\u{1F3E2}\u{1F3E3}\u{1F3E5}\u{1F3E6}\u{1F3E7}\u{1F3E8}\u{1F3E9}\u{1F3EA}\u{1F3EB}\u{1F3EC}\u{1F3ED}\u{1F3EE}\u{1F3EF}\u{1F3F0}\u{1F40C}\u{1F40D}\u{1F40E}\u{1F411}\u{1F412}\u{1F414}\u{1F417}\u{1F418}\u{1F419}\u{1F41A}\u{1F41B}\u{1F41C}\u{1F41D}
\u{1F41E}\u{1F41F}\u{1F420}\u{1F421}\u{1F422}\u{1F423}\u{1F424}\u{1F425}\u{1F426}\u{1F427}\u{1F428}\u{1F429}\u{1F42B}\u{1F42C}\u{1F42D}\u{1F42E}\u{1F42F}\u{1F430}\u{1F431}\u{1F432}\u{1F433}\u{1F434}\u{1F435}\u{1F436}\u{1F437}\u{1F438}\u{1F439}\u{1F43A}\u{1F43B}\u{1F43C}\u{1F43D}\u{1F43E}
\u{1F440}\u{1F442}\u{1F443}\u{1F444}\u{1F445}\u{1F446}\u{1F447}\u{1F448}\u{1F449}\u{1F44A}\u{1F44B}\u{1F44C}\u{1F44D}\u{1F44E}\u{1F44F}\u{1F450}\u{1F451}\u{1F452}\u{1F453}\u{1F454}\u{1F455}\u{1F456}\u{1F457}\u{1F458}\u{1F459}\u{1F45A}\u{1F45B}\u{1F45C}\u{1F45D}\u{1F45E}\u{1F45F}\u{1F460}\u{1F461}\u{1F462}
\u{1F463}\u{1F464}\u{1F466}\u{1F467}\u{1F468}\u{1F469}\u{1F46A}\u{1F46B}\u{1F46E}\u{1F46F}\u{1F470}\u{1F471}\u{1F472}\u{1F473}\u{1F474}\u{1F475}\u{1F476}\u{1F477}\u{1F478}\u{1F479}\u{1F47A}\u{1F47B}\u{1F47C}\u{1F47D}\u{1F47E}\u{1F47F}\u{1F480}\u{1F481}\u{1F482}\u{1F483}\u{1F484}\u{1F485}\u{1F486}
\u{1F487}\u{1F488}\u{1F489}\u{1F48A}\u{1F48B}\u{1F48C}\u{1F48D}\u{1F48E}\u{1F48F}\u{1F490}\u{1F491}\u{1F492}\u{1F493}\u{1F494}\u{1F495}\u{1F496}\u{1F497}\u{1F498}\u{1F499}\u{1F49A}\u{1F49B}\u{1F49C}\u{1F49D}\u{1F49E}\u{1F49F}\u{1F4A0}\u{1F4A1}\u{1F4A2}\u{1F4A3}\u{1F4A4}\u{1F4A5}\u{1F4A6}\u{1F4A7}
\u{1F4A8}\u{1F4A9}\u{1F4AA}\u{1F4AB}\u{1F4AC}\u{1F4AE}\u{1F4AF}\u{1F4B0}\u{1F4B1}\u{1F4B2}\u{1F4B3}\u{1F4B4}\u{1F4B5}\u{1F4B8}\u{1F4B9}\u{1F4BA}\u{1F4BB}\u{1F4BC}\u{1F4BD}\u{1F4BE}\u{1F4BF}\u{1F4C0}\u{1F4C1}\u{1F4C2}\u{1F4C3}\u{1F4C4}\u{1F4C5}\u{1F4C6}\u{1F4C7}\u{1F4C8}\u{1F4C9}\u{1F4CA}\u{1F4CB}
\u{1F4CC}\u{1F4CD}\u{1F4CE}\u{1F4CF}\u{1F4D0}\u{1F4D1}\u{1F4D2}\u{1F4D3}\u{1F4D4}\u{1F4D5}\u{1F4D6}\u{1F4D7}\u{1F4D8}\u{1F4D9}\u{1F4DA}\u{1F4DB}\u{1F4DC}\u{1F4DD}\u{1F4DE}\u{1F4DF}\u{1F4E0}\u{1F4E1}\u{1F4E2}\u{1F4E3}\u{1F4E4}\u{1F4E5}\u{1F4E6}\u{1F4E7}\u{1F4E8}\u{1F4E9}\u{1F4EA}\u{1F4EB}\u{1F4EE}\u{1F4F0}
\u{1F4F1}\u{1F4F2}\u{1F4F3}\u{1F4F4}\u{1F4F6}\u{1F4F7}\u{1F4F9}\u{1F4FA}\u{1F4FB}\u{1F4FC}\u{1F503}\u{1F50A}\u{1F50B}\u{1F50C}\u{1F50D}\u{1F50E}\u{1F50F}\u{1F510}\u{1F511}\u{1F512}\u{1F513}\u{1F514}\u{1F516}\u{1F517}\u{1F518}\u{1F519}\u{1F51A}\u{1F51B}\u{1F51C}\u{1F51D}\u{1F51E}\u{1F51F}\u{1F520}
\u{1F521}\u{1F522}\u{1F523}\u{1F524}\u{1F525}\u{1F526}\u{1F527}\u{1F528}\u{1F529}\u{1F52A}\u{1F52B}\u{1F52E}\u{1F52F}\u{1F530}\u{1F531}\u{1F532}\u{1F533}\u{1F534}\u{1F535}\u{1F536}\u{1F537}\u{1F538}\u{1F539}\u{1F53A}\u{1F53B}\u{1F53C}\u{1F53D}\u{1F550}\u{1F551}\u{1F552}\u{1F553}\u{1F554}\u{1F555}
\u{1F556}\u{1F557}\u{1F558}\u{1F559}\u{1F55A}\u{1F55B}\u{1F5FB}\u{1F5FC}\u{1F5FD}\u{1F5FE}\u{1F5FF}`;
        this.client.print(sample, true);
        this.client.print(sample2, true);
      };
      this.functions["testlines"] = () => {
        const maxLines = this.client.display.maxLines;
        let sample = "";
        const id = this.client.display.model.getNextLineID;
        for (let h = 0; h < maxLines; h++)
          sample += `Line: ${h}, LineID: ${id + h}
`;
        this.client.print(sample, true);
      };
      this.functions["testscreen"] = () => {
        let sample = "Window innerWidth: " + window.innerWidth;
        sample += "\nWindow innerHeight: " + window.innerHeight;
        sample += "\nDocument clientWidth: " + document.body.clientWidth;
        sample += "\nDocument clientHeight: " + document.body.clientHeight;
        sample += "\nDisplay clientWidth: " + this.client.display.container.clientWidth;
        sample += "\nDisplay clientHeight: " + this.client.display.container.clientHeight;
        sample += "\nScreen orientation: " + screen?.orientation?.type;
        this.client.print(sample, true);
      };
    }
    remove() {
      if (!this.client) return;
      this.client.off("function", this._event);
    }
    initialize() {
      if (!this.client) return;
      this.client.on("function", this._event);
    }
    get menu() {
      return [];
    }
    get settings() {
      return [];
    }
    /**
     * Process function event to execute custom text functions
     * @param data {FunctionEvent} The data about the function to execute
     */
    _processFunction(data) {
      let name2;
      if (!data) return;
      name2 = data.name.toLowerCase();
      if (name2.endsWith("()"))
        name2 = name2.substring(0, name2.length - 2);
      if (this.functions[name2]) {
        console.time(name2);
        this.functions[name2].apply(this, [data || {}]);
        console.timeEnd(name2);
        data.handled = true;
      }
    }
  };

  // src/interface/mapdisplay.ts
  var PF = __toESM(require_pathfinding3D());

  // src/map.ts
  var RoomExits = {
    out: 4096,
    enter: 2048,
    unknown: 1024,
    up: 512,
    down: 256,
    north: 128,
    northeast: 64,
    east: 32,
    southeast: 16,
    south: 8,
    southwest: 4,
    west: 2,
    northwest: 1,
    none: 0
  };
  var Room = class _Room {
    constructor(data) {
      this.num = null;
      this.x = 0;
      this.y = 0;
      this.z = 0;
      this.area = "";
      this.zone = 0;
      this.details = 0 /* None */;
      this.exits = {};
      if (data) {
        for (let prop in data) {
          if (!data.hasOwnProperty(prop)) continue;
          this[prop] = data[prop];
        }
      }
    }
    get exitsID() {
      return Object.keys(this.exits).map((exit) => RoomExits[exit]).reduce((a, c) => a | c, 0);
    }
    clone() {
      return new _Room(copy(this));
    }
  };
  var Map = class _Map extends EventEmitter {
    constructor() {
      super();
      this.changed = false;
      this._rooms = {};
      this._areas = [];
      this._zone = 0;
      this._keys = [];
      this._keysZones = [];
      this._current = new Room();
    }
    get current() {
      return this._current;
    }
    set current(value) {
      this._current = value;
      this.emit("current-changed", value);
    }
    get Rooms() {
      return this._rooms;
    }
    set Rooms(value) {
      if (Array.isArray(value)) {
        const or = value;
        const rooms = {};
        for (var r = 0, rl = or.length; r < rl; r++)
          rooms[or[r].num] = or[r];
        this._rooms = rooms;
      } else
        this._rooms = value || {};
      this._buildKeys();
      this._keys.forEach((key) => {
        this._rooms[key] = this._normalizeRoom(this._rooms[key]);
        if (this._rooms[key].zone > this._zone)
          this._zone = this._rooms[key].zone;
        if (this._areas.indexOf(this._rooms[key].area) === -1)
          this._areas.push(this._rooms[key].area);
      });
      this._areas.sort();
    }
    get Areas() {
      if (!this._areas) this._buildAreas();
      return this._areas;
    }
    get zone() {
      return this._zone;
    }
    set zone(value) {
      this._zone = value || 0;
    }
    get count() {
      return this._keys.length;
    }
    static load() {
      return new Promise((resolve, reject) => {
        localforage.getItem("nMapperData").then((value) => {
          const map = new _Map();
          if (value && value.Rooms)
            map.Rooms = value.Rooms;
          resolve(map);
        }).catch(reject);
      });
    }
    save() {
      this.changed = false;
      return localforage.setItem("nMapperData", { Rooms: this._rooms, Areas: this.Areas, Keys: this._keys });
    }
    getRoom(filter) {
      const keys = this._keys;
      const filterKeys = Object.keys(filter);
      const fl = filterKeys.length;
      roomLoop:
        for (let k = 0, kl = keys.length; k < kl; k++) {
          let room = this._rooms[keys[k]];
          for (let f = 0; f < fl; f++) {
            if (room[filterKeys[f]] !== filter[filterKeys[f]])
              continue roomLoop;
          }
          return room;
        }
      return null;
    }
    getRooms(filter) {
      const keys = this._keys;
      const filterKeys = Object.keys(filter);
      const fl = filterKeys.length;
      const rooms = [];
      roomLoop:
        for (let k = 0, kl = keys.length; k < kl; k++) {
          let room = this._rooms[keys[k]];
          for (let f = 0; f < fl; f++) {
            if (room[filterKeys[f]] !== filter[filterKeys[f]])
              continue roomLoop;
          }
          rooms.push(room);
        }
      return rooms;
    }
    roomExists(filter) {
      const keys = this._keysZones;
      const filterKeys = Object.keys(filter);
      const fl = filterKeys.length;
      if (keys.findIndex((key) => {
        let room = this._rooms[key];
        for (let f = 0; f < fl; f++) {
          if (room[filterKeys[f]] !== filter[filterKeys[f]])
            return false;
        }
        return true;
      }) !== -1)
        return true;
      return false;
    }
    removeRoom(room) {
      if (typeof room === "string")
        room = this._rooms[room];
      if (!room) return;
      if (this.Rooms[room.num]) {
        let idx = this._keys.indexOf(room.num);
        if (idx !== -1)
          this._keys.splice(idx, 1);
        idx = this._keysZones.indexOf(room.num);
        if (idx !== -1)
          this._keysZones.splice(idx, 1);
        delete this._rooms[room.num];
        this.changed = true;
        this.emit("rooms-removed", [room]);
        if (!this.getRoom({ area: room.area })) {
          let idx2 = this._areas.indexOf(room.area);
          this._areas.splice(idx2, 1);
          this.emit("areas-removed", [room.area]);
        }
      }
    }
    removeRooms(filter) {
      const keys = this._keys;
      const filterKeys = Object.keys(filter);
      const fl = filterKeys.length;
      const rooms = [];
      let idx;
      let areas = {};
      roomLoop:
        for (let k = keys.length - 1; k >= 0; k--) {
          let room = this._rooms[keys[k]];
          for (let f = 0; f < fl; f++) {
            if (room[filterKeys[f]] !== filter[filterKeys[f]])
              continue roomLoop;
          }
          rooms.push(room);
          idx = this._keys.indexOf(room.num);
          if (idx !== -1)
            this._keys.splice(idx, 1);
          idx = this._keysZones.indexOf(room.num);
          if (idx !== -1)
            this._keysZones.splice(idx, 1);
          areas[room.area] = true;
          delete this._rooms[room.num];
        }
      if (rooms.length) {
        this.changed = true;
        this.emit("rooms-removed", rooms);
        for (let area in areas) {
          if (!this.getRoom({ area })) {
            let idx2 = this._areas.indexOf(area);
            this._areas.splice(idx2, 1);
          }
        }
        this.emit("areas-removed", Object.keys(areas));
      }
    }
    removeAllRooms() {
      const rooms = this._keys.map((key) => this._rooms[key]);
      const areas = this._areas;
      this._rooms = {};
      this._keys = [];
      this._keysZones = [];
      this._areas = [];
      this._zone = 0;
      this.current = new Room();
      this.changed = true;
      this.emit("rooms-removed", rooms);
      this.emit("areas-removed", areas);
    }
    setRoom(room) {
      if (!room) return;
      this.changed = true;
      room = this._normalizeRoom(room);
      this.emit("before-room-changed", this._rooms[room.num]);
      this._rooms[room.num] = room;
      if (room.zone > this._zone)
        this._zone = room.zone;
      this._buildKeys();
      this.addArea(room.area);
      this.emit("room-changed", this._rooms[room.num]);
      return this._rooms[room.num];
    }
    addArea(area) {
      if (!area) return 0;
      if (this._areas.indexOf(area) !== -1) return;
      this._areas.push(area);
      this._areas.sort();
      this.emit("areas-added", [area]);
    }
    getFreeZone(zone) {
      if (!zone) zone = 0;
      if (zone > this.zone)
        return zone;
      return ++this.zone;
    }
    _normalizeRoom(r) {
      const id = "" + (r.num || r.ID);
      const room = {
        area: r.Area || r.area || "",
        details: r.Details || r.details || 0 /* None */,
        name: r.Name || r.name || "",
        env: r.Env || r.env || r.environment || "",
        x: +r.X || +r.x || 0,
        y: +r.Y || +r.y || 0,
        z: +r.Z || +r.z || 0,
        zone: +r.Zone || +r.zone || 0,
        indoors: +r.Indoors || +r.indoors || 0,
        background: r.Background || r.background || "",
        notes: r.Notes || r.notes || "",
        num: id ? "" + id : null,
        exits: r.exits || {}
      };
      if (room.exits) {
        let exit;
        let dest;
        for (exit in room.exits) {
          if (!room.exits.hasOwnProperty(exit)) continue;
          dest = room.exits[exit].DestID || room.exits[exit].num || null;
          room.exits[exit] = {
            num: dest ? "" + dest : null,
            isdoor: +room.exits[exit].IsDoor || +room.exits[exit].isdoor || null,
            isclosed: +room.exits[exit].IsClosed || +room.exits[exit].isclosed || null
          };
        }
      }
      return new Room(room);
    }
    _buildKeys() {
      this._keys = Object.keys(this._rooms).sort((a, b) => {
        const aRoom = this._rooms[a];
        const bRoom = this._rooms[b];
        if (aRoom.x > bRoom.x) return 1;
        if (aRoom.x < bRoom.x) return -1;
        if (aRoom.y > bRoom.y) return 1;
        if (aRoom.y < bRoom.y) return -1;
        if (aRoom.z > bRoom.z) return 1;
        if (aRoom.z < bRoom.z) return -1;
        if (aRoom.zone > bRoom.zone) return 1;
        if (aRoom.zone < bRoom.zone) return -1;
        return a.localeCompare(b);
      });
      this._keysZones = this._keys.slice().sort((a, b) => {
        const aRoom = this._rooms[a];
        const bRoom = this._rooms[b];
        if (aRoom.zone > bRoom.zone) return 1;
        if (aRoom.zone < bRoom.zone) return -1;
        return a.localeCompare(b);
      });
    }
    _buildAreas() {
      this._areas = [];
      this._keys.forEach((key) => {
        if (this._areas.indexOf(this._rooms[key].area) === -1)
          this._areas.push(this._rooms[key].area);
      });
      this._areas.sort();
    }
    cancelImport() {
      this._cancel = true;
    }
    async import(data, type) {
      if (!data || data === null || typeof data == "undefined") {
        return;
      }
      this._cancel = false;
      if (!Array.isArray(data))
        data = Object.values(data);
      if (type === 1 /* Replace */)
        this.removeAllRooms();
      this.emit("import-progress", 0);
      const rl = data.length;
      let room;
      const areas = {};
      this._areas.forEach((area) => areas[area] = true);
      const rooms = [];
      for (let r = 0; r < rl; r++) {
        if (this._cancel)
          break;
        this.emit("import-progress", Math.floor(r / rl * 100));
        if (data[r] === null) continue;
        room = this._normalizeRoom(data[r]);
        this._rooms[room.num] = room;
        if (room.zone > this._zone)
          this._zone = room.zone;
        areas[room.area] = true;
        rooms.push(room);
      }
      this.emit("rooms-changed", rooms);
      this._areas = Object.keys(areas);
      this._areas.sort();
      this.emit("areas-added", Object.keys(areas));
      this._buildKeys();
      this.changed = true;
      if (this._cancel)
        this.emit("import-canceled");
      else
        this.emit("import-complete");
    }
  };

  // src/interface/mapdisplay.ts
  var MapDisplay = class extends EventEmitter {
    constructor(container, options) {
      super();
      this._MouseDrag = { x: 0, y: 0, button: 0, state: false };
      this._drag = false;
      this._vscroll = 0;
      this._hscroll = 0;
      this._markers = {};
      this._updating = 0 /* none */;
      this._rTimeout = 0;
      this._focused = false;
      this._showLegend = false;
      this._splitArea = false;
      this._fillWalls = false;
      this._enabled = true;
      this._follow = true;
      this.commandDelay = 500;
      this.commandDelayCount = 5;
      this._scale = 1;
      this._mapperNavDown = false;
      this._pointerCache = [];
      this._pointerDistance = -1;
      this._showNav = true;
      if (!container)
        throw new Error("Container must be a selector, element, jquery object or Map options");
      if (typeof container === "object" && "container" in container) {
        options = Object.assign(options || {}, container);
        container = options.container;
        delete options.container;
      } else if (!options)
        options = {};
      if (typeof container === "string") {
        this._container = document.querySelector(container);
        if (!this._container)
          throw new Error("Invalid selector for display.");
      } else if (container instanceof $)
        this._container = container[0];
      else if (container instanceof HTMLElement)
        this._container = container;
      else if (container.ownerDocument.defaultView && container instanceof container.ownerDocument.defaultView.HTMLElement)
        this._container = container;
      else
        throw new Error("Container must be a selector, element or jquery object");
      this._document = this._container.ownerDocument;
      this._window = this._document.defaultView;
      this._resizeObserver = new ResizeObserver((entries, observer) => {
        if (entries.length === 0) return;
        if (!entries[0].contentRect || entries[0].contentRect.width === 0 || entries[0].contentRect.height === 0)
          return;
        if (!this._resizeObserverCache || this._resizeObserverCache.height !== entries[0].contentRect.height || this._resizeObserverCache.width !== entries[0].contentRect.width) {
          this._resizeObserverCache = { width: entries[0].contentRect.width, height: entries[0].contentRect.height };
          this._resizeCanvas();
        }
      });
      this._resizeObserver.observe(this._container);
      this._observer = new MutationObserver((mutationsList) => {
        let mutation;
        for (mutation of mutationsList) {
          if (mutation.type === "attributes" && mutation.attributeName === "style") {
            this._resizeCanvas();
          }
        }
      });
      this._observer.observe(this._container, { attributes: true, attributeOldValue: true, attributeFilter: ["style"] });
      this._canvas = this._document.createElement("canvas");
      this._canvas.id = this._container.id + "-canvas";
      this._canvas.classList.add("map-canvas");
      this._canvas.style.touchAction = "none";
      this._canvas.tabIndex = 1;
      this._resizeCanvas();
      this._container.appendChild(this._canvas);
      this._container.insertAdjacentHTML("afterbegin", `<div class="MapperNavButton" title="Scroll northwest" style="top:4px;left:4px;background-position: 0px 0px;" data-x="-1" data-y="-1"></div><div class="MapperNavButton" title="Scroll north" style="top:4px;left:50%;background-position: -22px 0px;margin-left:-11px;" data-x="0" data-y="-1"></div><div class="MapperNavButton" title="Scroll northeast" style="top:4px;left:100%;background-position: -44px 0px;margin-left:-26px;" data-x="1" data-y="-1"></div><div class="MapperNavButton" title="Scroll west" style="top:50%;left:4px;background-position: 0px -22px;margin-top:-11px;" data-x="-1" data-y="0"></div><div class="MapperNavButton" title="Scroll east" style="top:50%;left:100%;background-position: -44px -22px;margin-top:-11px;margin-left:-26px;" data-x="1" data-y="0"></div><div class="MapperNavButton" title="Scroll southwest" style="bottom:4px;left:4px;background-position: 0px -44px;" data-x="-1" data-y="1"></div><div class="MapperNavButton" title="Scroll south" style="bottom:4px;left:50%;background-position: -22px -44px;margin-left:-11px;" data-x="0" data-y="1"></div><div class="MapperNavButton" title="Scroll southeast" style="bottom:4px;left:100%;background-position: -44px -44px;margin-left:-26px;" data-x="1" data-y="1"></div>`);
      this._container.querySelectorAll(".MapperNavButton").forEach((e) => {
        e.addEventListener("wheel", (e2) => {
          this._mapperNavDown = true;
          const target = e2.currentTarget || e2.target;
          if (e2.deltaY >= 0)
            this._mapperNavClick(-parseInt(target.dataset.x, 10), -parseInt(target.dataset.y, 10));
          else
            this._mapperNavClick(parseInt(target.dataset.x, 10), parseInt(target.dataset.y, 10));
          this._mapperNavDown = false;
        }, { passive: true });
        e.addEventListener("mouseleave", () => this._mapperNavDown = false);
        e.addEventListener("mouseup", () => this._mapperNavDown = false);
        e.addEventListener("mousedown", (e2) => {
          this._mapperNavDown = true;
          const target = e2.currentTarget || e2.target;
          this._mapperNavClick(parseInt(target.dataset.x, 10), parseInt(target.dataset.y, 10));
        });
      });
      this._context = this._canvas.getContext("2d");
      this._context.mozImageSmoothingEnabled = false;
      this._context.webkitImageSmoothingEnabled = false;
      this._context.imageSmoothingEnabled = false;
      this._canvas.addEventListener("pointerdown", (e) => {
        this._pointerCache.push(e);
      });
      this._canvas.addEventListener("pointermove", (e) => {
        const index = this._pointerCache.findIndex(
          (cached) => cached.pointerId === e.pointerId
        );
        this._pointerCache[index] = e;
        if (this._pointerCache.length === 2) {
          const curDiff = Math.abs(this._pointerCache[0].clientX - this._pointerCache[1].clientX);
          if (this._pointerDistance > 0) {
            if (curDiff > this._pointerDistance) {
              if (this.scale < 300)
                this.scale += 1;
            }
            if (curDiff < this._pointerDistance) {
              if (this.scale > 25)
                this.scale -= 1;
            }
          }
          this._pointerDistance = curDiff;
        }
      });
      const pointerUp = (e) => {
        const index = this._pointerCache.findIndex(
          (cachedEv) => cachedEv.pointerId === e.pointerId
        );
        this._pointerCache.splice(index, 1);
        if (this._pointerCache.length < 2) {
          this._pointerDistance = -1;
        }
      };
      this._canvas.addEventListener("pointerup", pointerUp);
      this._canvas.addEventListener("pointercancel", pointerUp);
      this._canvas.addEventListener("pointerout", pointerUp);
      this._canvas.addEventListener("pointerleave", pointerUp);
      this._canvas.addEventListener("touchstart", (e) => {
        this._Mouse = this.getMapMousePos(e);
        this._MouseDown = this.getMapMousePos(e);
        this._MouseDrag.state = true;
        this._drag = e.touches.length === 1;
      }, { passive: true });
      this._canvas.addEventListener("touchmove", (e) => {
        this._MousePrev = this._Mouse;
        this._Mouse = this.getMapMousePos(event);
        if (this._drag) {
          this._MouseDrag.x += this._MousePrev.x - this._Mouse.x;
          this._MouseDrag.y += this._MousePrev.y - this._Mouse.y;
          const x2 = Math.floor(this._MouseDrag.x / 32 / this._scale);
          const y2 = Math.floor(this._MouseDrag.y / 32 / this._scale);
          if (x2 > 0 || x2 < 0 || y2 < 0 || y2 > 0) {
            this._MouseDrag.x -= x2 * 32 * this._scale;
            this._MouseDrag.y -= y2 * 32 * this._scale;
            this.scrollBy(x2, y2);
          }
          this._canvas.style.cursor = "move";
        }
        e.preventDefault();
      }, { passive: true });
      this._canvas.addEventListener("touchend", (e) => {
        this._Mouse = this.getMapMousePos(e);
        if (!this._MouseDown)
          this._MouseDown = this.getMapMousePos(e);
        if (this._Mouse.button === 0 && Math.floor(this._Mouse.x / 32 / this._scale) === Math.floor(this._MouseDown.x / 32 / this._scale) && Math.floor(this._Mouse.y / 32 / this._scale) === Math.floor(this._MouseDown.y / 32 / this._scale)) {
          const x2 = this._Mouse.x;
          const y2 = this._Mouse.y;
          const room = this.findActiveRoomByCoords(x2, y2);
          if (!this.selected || room && room.num !== this.selected.num)
            this.selected = room;
        }
        this._MouseDrag.state = false;
        this._drag = false;
        this._canvas.style.cursor = "default;";
      }, { passive: true });
      this._canvas.addEventListener("mousemove", (event2) => {
        this._MousePrev = this._Mouse;
        this._Mouse = this.getMapMousePos(event2);
        if (this._drag) {
          this._MouseDrag.x += this._MousePrev.x - this._Mouse.x;
          this._MouseDrag.y += this._MousePrev.y - this._Mouse.y;
          const x2 = Math.floor(this._MouseDrag.x / 32 / this._scale);
          const y2 = Math.floor(this._MouseDrag.y / 32 / this._scale);
          if (x2 > 0 || x2 < 0 || y2 < 0 || y2 > 0) {
            this._MouseDrag.x -= x2 * 32 * this._scale;
            this._MouseDrag.y -= y2 * 32 * this._scale;
            this.scrollBy(x2, y2);
          }
          this._canvas.style.cursor = "move";
        }
        event2.preventDefault();
      });
      this._canvas.addEventListener("mousedown", (event2) => {
        this._Mouse = this.getMapMousePos(event2);
        this._MouseDown = this.getMapMousePos(event2);
        this._MouseDrag.state = true;
        this._drag = this._MouseDown.button === 0;
      });
      this._canvas.addEventListener("mouseup", (event2) => {
        this._Mouse = this.getMapMousePos(event2);
        if (!this._MouseDown)
          this._MouseDown = this.getMapMousePos(event2);
        if (this._Mouse.button === 0 && Math.floor(this._Mouse.x / 32 / this._scale) === Math.floor(this._MouseDown.x / 32 / this._scale) && Math.floor(this._Mouse.y / 32 / this._scale) === Math.floor(this._MouseDown.y / 32 / this._scale)) {
          const x2 = this._Mouse.x;
          const y2 = this._Mouse.y;
          const room = this.findActiveRoomByCoords(x2, y2);
          if (!this.selected || room && room.num !== this.selected.num)
            this.selected = room;
        }
        this._MouseDrag.state = false;
        this._drag = false;
        this._canvas.style.cursor = "default;";
      });
      this._canvas.addEventListener("wheel", (e) => {
        if (e.deltaY >= 0)
          this.scale -= 5;
        else
          this.scale += 5;
      }, { passive: true });
      this._canvas.addEventListener("mouseenter", (event2) => {
        this._Mouse = this.getMapMousePos(event2);
      });
      this._canvas.addEventListener("mouseleave", (event2) => {
        this._Mouse = this.getMapMousePos(event2);
        if (this._drag) {
          this._doUpdate(1 /* draw */);
          this._drag = false;
          $(this._canvas).css("cursor", "default");
        }
      });
      this._canvas.addEventListener("contextmenu", (event2) => {
        event2.preventDefault();
        const m = this.getMapMousePos(event2);
        this.emit("context-menu", this.findActiveRoomByCoords(m.x, m.y).clone());
        return false;
      });
      this._canvas.addEventListener("click", (event2) => {
        event2.preventDefault();
        this._MouseDrag.state = false;
        this._drag = false;
        $(this._canvas).css("cursor", "default");
      });
      this._canvas.addEventListener("dblclick", (event2) => {
        event2.preventDefault();
        this._Mouse = this.getMapMousePos(event2);
        this._MouseDown = this.getMapMousePos(event2);
        this._MouseDrag.state = true;
        this._drag = true;
        $(this._canvas).css("cursor", "move");
      });
      this._canvas.onselectstart = () => {
        return false;
      };
      this._canvas.addEventListener("focus", (e) => {
        this._setFocus(true);
      });
      this._canvas.addEventListener("blur", (e) => {
        this._setFocus(false);
      });
      this._canvas.addEventListener("keydown", (e) => {
        if (!this._focused) return;
        switch (e.which) {
          case 27:
            e.preventDefault();
            this._MouseDrag.state = false;
            this._drag = false;
            $(this._canvas).css("cursor", "default");
            break;
          case 38:
            e.preventDefault();
            this.scrollBy(0, -1);
            break;
          case 40:
            e.preventDefault();
            this.scrollBy(0, 1);
            break;
          case 37:
            e.preventDefault();
            this.scrollBy(-1, 0);
            break;
          case 39:
            e.preventDefault();
            this.scrollBy(1, 0);
            break;
          case 110:
          case 46:
            e.preventDefault();
            this.emit("delete-selected");
            break;
          case 97:
            e.preventDefault();
            this.scrollBy(-1, 1);
            break;
          case 98:
            e.preventDefault();
            this.scrollBy(0, 1);
            break;
          case 99:
            e.preventDefault();
            this.scrollBy(1, 1);
            break;
          case 100:
            e.preventDefault();
            this.scrollBy(-1, 0);
            break;
          case 101:
            e.preventDefault();
            this.focusCurrentRoom();
            break;
          case 102:
            e.preventDefault();
            this.scrollBy(1, 0);
            break;
          case 103:
            e.preventDefault();
            this.scrollBy(-1, -1);
            break;
          case 104:
            e.preventDefault();
            this.scrollBy(0, -1);
            break;
          case 105:
            e.preventDefault();
            this.scrollBy(1, -1);
            break;
          case 107:
            e.preventDefault();
            this.setLevel(this.active.z + 1);
            break;
          case 109:
            e.preventDefault();
            this.setLevel(this.active.z - 1);
            break;
          case 111:
            e.preventDefault();
            this.setZone(this.active.zone - 1);
            break;
          case 106:
            e.preventDefault();
            this.setZone(this.active.zone + 1);
            break;
        }
      });
      this._map = options.map;
      this.reset();
      this.refresh();
    }
    get showNavigation() {
      return this._showNav;
    }
    set showNavigation(value) {
      if (value === this._showNav) return;
      this._showNav = value;
      this._container.querySelectorAll(".MapperNavButton").forEach((e) => {
        e.style.display = this._showNav ? "" : "none";
      });
      this._canvas.style.top = this._showNav ? "" : "0";
      this._canvas.style.left = this._showNav ? "" : "0";
      this._canvas.style.right = this._showNav ? "" : "0";
      this._canvas.style.bottom = this._showNav ? "" : "0";
      this._resizeCanvas();
    }
    get selected() {
      return this._selected;
    }
    set selected(value) {
      this.emit("room-before-selected", this._selected ? this._selected.clone() : null);
      this._selected = value.clone();
      this.emit("room-selected", value.clone());
      this._doUpdate(1 /* draw */);
    }
    get container() {
      return this._container;
    }
    set scale(value) {
      if (value < 25)
        value = 25;
      if (value > 300)
        value = 300;
      if (this._scale !== value) {
        this._scale = value / 100;
        this.emit("setting-changed", "scale", value);
        this._drawCache = 0;
        this._doUpdate(1 /* draw */);
      }
    }
    get scale() {
      return Math.round(this._scale * 100);
    }
    set enabled(value) {
      if (this._enabled !== value) {
        this._enabled = value;
        this.emit("setting-changed", "enabled", value);
      }
    }
    get enabled() {
      return this._enabled;
    }
    set follow(value) {
      if (this._follow !== value) {
        this._follow = value;
        this.emit("setting-changed", "follow", value);
      }
    }
    get follow() {
      return this._follow;
    }
    set showLegend(value) {
      if (this._showLegend !== value) {
        this._showLegend = value;
        this._drawCache = 0;
        this._doUpdate(1 /* draw */);
        this.emit("setting-changed", "legend", value);
      }
    }
    get showLegend() {
      return this._showLegend;
    }
    set splitArea(value) {
      if (this._splitArea !== value) {
        this._splitArea = value;
        this._drawCache = 0;
        this._doUpdate(1 /* draw */);
        this.emit("setting-changed", "split", value);
      }
    }
    get splitArea() {
      return this._splitArea;
    }
    set fillWalls(value) {
      if (this._fillWalls !== value) {
        this._fillWalls = value;
        this._drawCache = 0;
        this._doUpdate(1 /* draw */);
        this.emit("setting-changed", "fill", value);
      }
    }
    get fillWalls() {
      return this._fillWalls;
    }
    getMapMousePos(evt) {
      const rect = this._canvas.getBoundingClientRect();
      if (evt.touches && evt.touches.length)
        return {
          x: evt.touches[0].clientX - rect.left,
          y: evt.touches[0].clientY - rect.top,
          button: 0,
          state: false
        };
      return {
        x: evt.clientX - rect.left,
        y: evt.clientY - rect.top,
        button: evt.button,
        state: false
      };
    }
    scrollBy(x2, y2) {
      this._vscroll += x2;
      this._hscroll += y2;
      this._doUpdate(1 /* draw */);
      this.emit("setting-changed", "vscroll", this._vscroll);
      this.emit("setting-changed", "hscroll", this._hscroll);
    }
    scrollTo(x2, y2) {
      this._vscroll = x2;
      this._hscroll = y2;
      this._doUpdate(1 /* draw */);
      this.emit("setting-changed", "vscroll", this._vscroll);
      this.emit("setting-changed", "hscroll", this._hscroll);
    }
    findActiveRoomByCoords(rx, ry) {
      let x2 = this._vscroll - this._canvas.width / 32 / 2 / this._scale;
      let y2 = this._hscroll - this._canvas.height / 32 / 2 / this._scale;
      let ox = 15.5 * this._scale;
      let oy = 15.5 * this._scale;
      if (this._canvas.width % 2 !== 0)
        ox = 15 * this._scale;
      if (this._canvas.height % 2 !== 0)
        oy = 15 * this._scale;
      x2 += (rx - ox) / 32 / this._scale;
      y2 += (ry - oy) / 32 / this._scale;
      x2 = Math.floor(x2);
      y2 = Math.floor(y2);
      if (this._splitArea)
        return this.map.getRoom({ x: x2, y: y2, z: this.active.z, zone: this.active.zone, area: this.active.area }) || new Room();
      return this.map.getRoom({ x: x2, y: y2, z: this.active.z, zone: this.active.zone }) || new Room();
    }
    draw(canvas, context, ex2) {
      return new Promise((resolve, reject) => {
        if (!canvas)
          canvas = this._canvas;
        if (!context)
          context = this._context;
        if (!ex2) ex2 = false;
        if (!canvas || !context || !this._map) {
          reject();
          return;
        }
        const x2 = this._vscroll - canvas.width / 32 / 2 / this._scale;
        const y2 = this._hscroll - canvas.height / 32 / 2 / this._scale;
        const z2 = this.active.z || 0;
        const area = this.active.area || "";
        const zone = this.active.zone || 0;
        let ox = 15.5 * this._scale;
        let oy = 15.5 * this._scale;
        if (canvas.width % 2 !== 0)
          ox = 15 * this._scale;
        if (canvas.height % 2 !== 0)
          oy = 15 * this._scale;
        context.font = "8pt Arial";
        const s = (/* @__PURE__ */ new Date()).getTime();
        const $w = canvas.width / 32 / this._scale + 1;
        const $h = canvas.height / 32 / this._scale + 1;
        const $x = x2 - 1;
        const $y = y2 - 1;
        const rooms = Object.values(this._map.Rooms).filter((room) => {
          if (room.zone !== zone || room.z !== z2) return false;
          if (this._splitArea && room.area !== area) return false;
          if (0 <= room.x - $x && room.x - $x <= $w && (0 <= room.y - $y && room.y - $y <= $h) || 0 <= room.x - $x && room.x - $x <= $w && (0 <= room.y - $y + 1 && room.y - $y + 1 <= $h) || 0 <= room.x - $x + 1 && room.x - $x + 1 <= $w && (0 <= room.y - $y + 1 && room.y - $y + 1 <= $h) || 0 <= room.x - $x + 1 && room.x - $x + 1 <= $w && (0 <= room.y - $y && room.y - $y <= $h))
            return true;
          return false;
        });
        this.emit("debug", "Mapper: Draw - room query time: " + ((/* @__PURE__ */ new Date()).getTime() - s));
        const d2 = (/* @__PURE__ */ new Date()).getTime();
        if (ex2) {
          context.fillStyle = "#eae4d6";
          context.fillRect(0, 0, canvas.width, canvas.height);
        } else
          context.clearRect(0, 0, canvas.width, canvas.height);
        this.emit("debug", "Mapper: Draw - room calculations time: " + ((/* @__PURE__ */ new Date()).getTime() - s));
        for (let r = 0, rl = rooms.length; r < rl; r++) {
          const room = rooms[r];
          this.DrawRoom(context, (room.x - x2) * 32 * this._scale + ox, (room.y - y2) * 32 * this._scale + oy, room, ex2, this._scale);
        }
        this.emit("debug", "Mapper: Draw - display time: " + ((/* @__PURE__ */ new Date()).getTime() - d2));
        this.emit("debug", "Mapper: Draw - final time: " + ((/* @__PURE__ */ new Date()).getTime() - s));
        this.DrawLegend(context, 1, -4, 0);
        resolve(true);
      });
    }
    reset(type) {
      if (this._map && (!type || type === 1)) {
        this._map.current = new Room();
        this.emit("current-changed", this._map.current);
      }
      if (!type) {
        this.active = new Room();
        this.selected = new Room();
      }
    }
    refresh() {
      this._drawCache = 0;
      this._doUpdate(1 /* draw */);
      this.emit("refresh");
    }
    focusCurrentRoom() {
      if (this._map.current.num) {
        this.active = this._map.current;
        this.emit("active-room-changed", this.active.clone());
      }
      this.focusActiveRoom();
    }
    focusActiveRoom() {
      this.scrollTo(this.active.x + 1, this.active.y + 1);
    }
    set active(value) {
      this._active = value && value.clone ? value.clone() : value;
      this.emit("active-room-changed", this._active);
    }
    get active() {
      return this._active;
    }
    get current() {
      return this._map.current;
    }
    set current(value) {
      this.emit("path-cleared");
      if (!value || !value.num) value = this.selected;
      this._map.current = value.clone();
      this._markers = {};
      this._markedRooms = 0;
      this._doUpdate(1 /* draw */);
    }
    setArea(area) {
      this.active.area = area;
      if (this._map.current.num !== null && this._map.current.area === this.active.area) {
        this.active = this._map.current;
        this.focusActiveRoom();
        this.emit("setting-changed", "active", this.active);
      } else {
        const room = this._map.getRoom({ area });
        if (room) {
          this.active = room;
          this.focusActiveRoom();
          this.emit("setting-changed", "active", this.active);
        }
      }
    }
    setLevel(level) {
      if (level !== this.active.z) {
        this.active.z = level;
        this._doUpdate(1 /* draw */);
        this.emit("setting-changed", "active", this.active);
      }
    }
    setZone(zone) {
      if (zone !== this.active.zone) {
        this.active.zone = zone;
        this._doUpdate(1 /* draw */);
        this.emit("setting-changed", "active", this.active);
      }
    }
    removeRoom(room) {
      if (this._map.roomExists({ num: room.num })) {
        this._map.removeRoom(room);
        this.emit("remove-done", room);
        if (room.num === this._map.current.num) {
          this._map.current = new Room();
          this.emit("current-changed", this._map.current);
          this.clearPath();
        } else if (this._markers[room.num])
          this.clearPath();
        if (room.num === this.active.num)
          this.active = new Room();
        if (room.num === this.selected.num)
          this.selected = new Room();
        this.refresh();
      }
    }
    clearSelectedRoom() {
      const es = { preventDefault: false };
      this.emit("clear-selected", es);
      if (es.preventDefault) return;
      this.removeRoom(this.selected);
    }
    clearCurrentRoom() {
      const es = { preventDefault: false };
      this.emit("clear-current", es);
      if (es.preventDefault) return;
      this.removeRoom(this._map.current);
    }
    clearArea() {
      const es = { preventDefault: false };
      this.emit("clear-area", es);
      if (es.preventDefault) return;
      this._map.removeRooms({ area: this.active.area });
      this.emit("clear-area-done", this.active.area);
      this.reset();
      this.refresh();
    }
    clearAll() {
      const es = { preventDefault: false };
      this.emit("clear-all", es);
      if (es.preventDefault) return;
      this._map.removeAllRooms();
      this.emit("clear-done");
      this.reset();
      this.refresh();
      this.focusActiveRoom();
    }
    set map(map) {
      this._map = map;
      map.on("current-changed", (room) => {
        this.clearPath();
        this.emit("current-changed", this._map.current);
        if (this.selected && this.selected.num === room.num)
          this.emit("room-selected", room.clone());
        if (this.follow)
          this.focusCurrentRoom();
        else
          this.active = room;
        this.refresh();
      });
      map.on("before-room-changed", (room) => {
        if (room)
          delete this._drawCache[(room.background ? room.background : room.env) + "," + room.indoors + "," + room.exitsID + "," + room.details];
      });
      map.on("room-changed", (room) => {
        if (this.selected && this.selected.num === room.num)
          this.selected = room;
        if (this.follow)
          this.focusCurrentRoom();
        else
          this.active = this.current;
        this.refresh();
      });
      map.on("rooms-changed", (rooms) => {
        if (this.selected && this.selected.num) {
          const idx = rooms.findIndex((room) => room.num === this.selected.num);
          if (idx !== -1)
            this.selected = rooms[idx];
        }
        if (this.follow)
          this.focusCurrentRoom();
        else
          this.active = this.current;
        this.refresh();
      });
      this.refresh();
    }
    get map() {
      return this._map;
    }
    set rooms(rooms) {
      this._map.Rooms = rooms;
    }
    get rooms() {
      return this._map.Rooms;
    }
    roomExists(x2, y2, z2, zone, area) {
      if (area)
        return this._map.roomExists({ x: x2, y: y2, z: z2, zone: zone || 0, area });
      return this._map.roomExists({ x: x2, y: y2, z: z2, zone: zone || 0 });
    }
    setRoom(room) {
      this._map.setRoom(room);
    }
    DrawLegend(ctx, x2, y2, nc) {
      if (!this._showLegend) return;
      ctx.strokeStyle = "black";
      if (!nc) {
        ctx.fillStyle = "#eae4d6";
        ctx.fillRect(x2 + 30, y2 + 35, 130, 175);
      }
      ctx.fillStyle = "black";
      ctx.strokeRect(x2 + 30, y2 + 35, 130, 175);
      ctx.font = "italic bold 8pt Georgia";
      ctx.fillText("Dock", x2 + 50, y2 + 50);
      ctx.fillStyle = "chocolate";
      ctx.beginPath();
      ctx.arc(x2 + 40, y2 + 45, 2, 0, Math.PI * 2);
      ctx.fill();
      ctx.closePath();
      ctx.fillStyle = "black";
      ctx.fillText("Pier", x2 + 50, y2 + 65);
      ctx.fillStyle = "gray";
      ctx.beginPath();
      ctx.arc(x2 + 40, y2 + 60, 2, 0, Math.PI * 2);
      ctx.fill();
      ctx.closePath();
      ctx.fillStyle = "black";
      ctx.fillText("Water Source", x2 + 50, y2 + 80);
      ctx.fillStyle = "aqua";
      ctx.beginPath();
      ctx.arc(x2 + 40, y2 + 75, 2, 0, Math.PI * 2);
      ctx.fill();
      ctx.closePath();
      ctx.fillStyle = "black";
      ctx.fillText("Bank", x2 + 50, y2 + 95);
      ctx.font = "8pt Arial";
      ctx.fillStyle = "goldenrod";
      ctx.beginPath();
      ctx.fillText("$", x2 + 38, y2 + 95);
      ctx.closePath();
      ctx.font = "italic bold 8pt Georgia";
      ctx.fillStyle = "black";
      ctx.fillText("Shop", x2 + 50, y2 + 110);
      ctx.font = "8pt Arial";
      ctx.fillStyle = "purple";
      ctx.beginPath();
      ctx.fillText("\u23CF", x2 + 38, y2 + 110);
      ctx.closePath();
      ctx.font = "italic bold 8pt Georgia";
      ctx.fillStyle = "black";
      ctx.fillText("Hospital", x2 + 50, y2 + 125);
      ctx.font = "8pt Arial";
      ctx.fillStyle = "blue";
      ctx.beginPath();
      ctx.fillText("\u2665", x2 + 38, y2 + 125);
      ctx.closePath();
      ctx.font = "italic bold 8pt Georgia";
      ctx.fillStyle = "black";
      ctx.fillText("Bar & Restaurant", x2 + 50, y2 + 140);
      ctx.font = "8pt Arial";
      ctx.fillStyle = "green";
      ctx.beginPath();
      ctx.fillText("\u2617", x2 + 38, y2 + 140);
      ctx.closePath();
      ctx.font = "italic bold 8pt Georgia";
      ctx.fillStyle = "black";
      ctx.fillText("Bar", x2 + 50, y2 + 155);
      ctx.font = "8pt Arial";
      ctx.fillStyle = "green";
      ctx.beginPath();
      ctx.fillText("\u266A", x2 + 38, y2 + 155);
      ctx.closePath();
      ctx.font = "italic bold 8pt Georgia";
      ctx.fillStyle = "black";
      ctx.fillText("Restaurant", x2 + 50, y2 + 170);
      ctx.font = "8pt Arial";
      ctx.fillStyle = "green";
      ctx.beginPath();
      ctx.fillText("\u2616", x2 + 38, y2 + 170);
      ctx.closePath();
      ctx.font = "italic bold 8pt Georgia";
      ctx.fillStyle = "black";
      ctx.fillText("Train", x2 + 50, y2 + 185);
      ctx.font = "8pt Arial";
      ctx.fillStyle = "red";
      ctx.beginPath();
      ctx.fillText("\u260D", x2 + 38, y2 + 185);
      ctx.closePath();
      ctx.font = "italic bold 8pt Georgia";
      ctx.fillStyle = "black";
      ctx.fillText("Stable", x2 + 50, y2 + 200);
      ctx.font = "8pt Arial";
      ctx.fillStyle = "rgb(153, 102, 0)";
      ctx.beginPath();
      ctx.fillText("\u2658", x2 + 38, y2 + 200);
      ctx.closePath();
    }
    _translate(ctx, amt, scale) {
      if (scale === 2) return;
      const o = amt - amt * scale;
      ctx.translate(amt * scale + o, amt * scale + o);
    }
    DrawRoom(ctx, x2, y2, room, ex2, scale) {
      if (!this._drawCache)
        this._drawCache = {};
      if (!scale) scale = this._scale;
      const key = (room.background ? room.background : room.env) + "," + room.indoors + "," + room.exitsID + "," + room.details;
      if (!this._drawCache[key]) {
        this._drawCache[key] = this._document.createElement("canvas");
        this._drawCache[key].classList.add("map-canvas");
        this._drawCache[key].height = 32 * scale;
        this._drawCache[key].width = 32 * scale;
        const tx = this._drawCache[key].getContext("2d");
        this._translate(tx, 0.5, scale);
        tx.beginPath();
        let f = false;
        if (room.background) {
          tx.fillStyle = room.background;
          f = true;
        } else if (room.env) {
          switch (room.env) {
            case "wood":
              tx.fillStyle = "#966F33";
              f = true;
              break;
            case "jungle":
              tx.fillStyle = "#347C2C";
              f = true;
              break;
            case "forest":
              tx.fillStyle = "#4E9258";
              f = true;
              break;
            case "grass":
            case "grassland":
            case "plains":
            case "prairie":
            case "savannah":
              tx.fillStyle = "#4AA02C";
              f = true;
              break;
            case "desert":
            case "dirt":
            case "dirtroad":
            case "beach":
            case "sand":
            case "sanddesert":
              tx.fillStyle = "#C2B280";
              f = true;
              break;
            case "snow":
              tx.fillStyle = "#F0F8FF";
              f = true;
              break;
            case "tundra":
            case "icesheet":
              tx.fillStyle = "#368BC1";
              f = true;
              break;
            case "underwater":
            case "water":
            case "lake":
            case "river":
              tx.fillStyle = "#EBF4FA";
              f = true;
              break;
            case "ocean":
              tx.fillStyle = "#C2DFFF";
              f = true;
              break;
            case "bog":
            case "city":
            case "cliff":
            case "highmountain":
            case "hills":
            case "mountain":
            case "swamp":
              f = false;
              break;
            case "farmland":
              f = true;
              tx.fillStyle = "#A9DFBF";
              break;
            case "rockdesert":
              tx.fillStyle = "#6E2C00";
              f = true;
              break;
            case "pavedroad":
              tx.fillStyle = "#D0D3D4";
              f = true;
              break;
            case "cobble":
            case "rocky":
            case "stone":
              tx.fillStyle = "#D5DBDB";
              f = true;
              break;
            default:
              f = false;
              break;
          }
        } else
          f = false;
        tx.strokeStyle = "black";
        tx.lineWidth = 0.6 * scale;
        if (!room.indoors) {
          tx.arc(16 * scale, 16 * scale, 8 * scale, 0, Math.PI * 2, false);
          if (f) tx.fill();
          tx.stroke();
        } else {
          if (f) tx.fillRect(8 * scale, 8 * scale, 16 * scale, 16 * scale);
          tx.strokeRect(8 * scale, 8 * scale, 16 * scale, 16 * scale);
        }
        tx.closePath();
        tx.beginPath();
        tx.fillStyle = "#cccccc";
        if (room.exits.north) {
          tx.moveTo(16 * scale, 0 * scale);
          tx.lineTo(16 * scale, 8 * scale);
        } else if (this._fillWalls)
          tx.fillRect(9 * scale, 0 * scale, 14 * scale, 4 * scale);
        if (room.exits.northwest) {
          if (!room.Indoors) {
            tx.moveTo(0 * scale, 0 * scale);
            tx.lineTo(10 * scale, 10 * scale);
          } else {
            tx.moveTo(0 * scale, 0 * scale);
            tx.lineTo(8 * scale, 8 * scale);
          }
        } else if (this._fillWalls) {
          tx.fillRect(2 * scale, 0 * scale, 2 * scale, 2 * scale);
          tx.fillRect(0 * scale, 2 * scale, 4 * scale, 2 * scale);
          if (!room.exits.north)
            tx.fillRect(4 * scale, 0 * scale, 5 * scale, 4 * scale);
          if (!room.exits.west)
            tx.fillRect(0 * scale, 4 * scale, 4 * scale, 5 * scale);
        }
        if (room.exits.northeast) {
          if (!room.Indoors) {
            tx.moveTo(32 * scale, 0 * scale);
            tx.lineTo(22 * scale, 10 * scale);
          } else {
            tx.moveTo(32 * scale, 0 * scale);
            tx.lineTo(24 * scale, 8 * scale);
          }
        } else if (this._fillWalls) {
          tx.fillRect(28 * scale, 0 * scale, 2 * scale, 2 * scale);
          tx.fillRect(28 * scale, 2 * scale, 4 * scale, 2 * scale);
          tx.clearRect(30 * scale, 0 * scale, 2 * scale, 2 * scale);
          if (!room.exits.north)
            tx.fillRect(23 * scale, 0 * scale, 5 * scale, 4 * scale);
          if (!room.exits.east)
            tx.fillRect(28 * scale, 4 * scale, 4 * scale, 5 * scale);
        }
        if (room.exits.east) {
          tx.moveTo(24 * scale, 16 * scale);
          tx.lineTo(32 * scale, 16 * scale);
        } else if (this._fillWalls)
          tx.fillRect(28 * scale, 9 * scale, 4 * scale, 14 * scale);
        if (room.exits.west) {
          tx.moveTo(0 * scale, 16 * scale);
          tx.lineTo(8 * scale, 16 * scale);
        } else if (this._fillWalls)
          tx.fillRect(0 * scale, 9 * scale, 4 * scale, 14 * scale);
        if (room.exits.south) {
          tx.moveTo(16 * scale, 24 * scale);
          tx.lineTo(16 * scale, 32 * scale);
        } else if (this._fillWalls)
          tx.fillRect(9 * scale, 28 * scale, 14 * scale, 4 * scale);
        if (room.exits.southeast) {
          if (!room.Indoors) {
            tx.moveTo(32 * scale, 32 * scale);
            tx.lineTo(22 * scale, 22 * scale);
          } else {
            tx.moveTo(32 * scale, 32 * scale);
            tx.lineTo(24 * scale, 24 * scale);
          }
        } else if (this._fillWalls) {
          tx.fillRect(28 * scale, 28 * scale, 4 * scale, 2 * scale);
          tx.fillRect(28 * scale, 30 * scale, 2 * scale, 2 * scale);
          if (!room.exits.south)
            tx.fillRect(23 * scale, 28 * scale, 5 * scale, 4 * scale);
          if (!room.exits.east)
            tx.fillRect(28 * scale, 23 * scale, 4 * scale, 5 * scale);
        }
        if (room.exits.southwest) {
          if (!room.Indoors) {
            tx.moveTo(0 * scale, 32 * scale);
            tx.lineTo(10 * scale, 22 * scale);
          } else {
            tx.moveTo(0 * scale, 32 * scale);
            tx.lineTo(8 * scale, 24 * scale);
          }
        } else if (this._fillWalls) {
          tx.fillRect(0 * scale, 28 * scale, 4 * scale, 2 * scale);
          tx.fillRect(2 * scale, 30 * scale, 2 * scale, 2 * scale);
          if (!room.exits.south)
            tx.fillRect(4 * scale, 28 * scale, 5 * scale, 4 * scale);
          if (!room.exits.west)
            tx.fillRect(0 * scale, 23 * scale, 4 * scale, 5 * scale);
        }
        tx.closePath();
        tx.stroke();
        tx.fillStyle = "black";
        tx.strokeStyle = "black";
        if (room.exits.up) {
          tx.beginPath();
          tx.moveTo(1 * scale, 11 * scale);
          tx.lineTo(7 * scale, 11 * scale);
          tx.lineTo(4 * scale, 8 * scale);
          tx.closePath();
          tx.fill();
        }
        if (room.exits.down) {
          tx.beginPath();
          tx.moveTo(1 * scale, 21 * scale);
          tx.lineTo(7 * scale, 21 * scale);
          tx.lineTo(4 * scale, 24 * scale);
          tx.closePath();
          tx.fill();
        }
        if (room.exits.out) {
          tx.beginPath();
          tx.moveTo(26 * scale, 8 * scale);
          tx.lineTo(29 * scale, 11 * scale);
          tx.lineTo(26 * scale, 14 * scale);
          tx.closePath();
          tx.fill();
        }
        if (room.exits.enter) {
          tx.beginPath();
          tx.moveTo(29 * scale, 19 * scale);
          tx.lineTo(26 * scale, 22 * scale);
          tx.lineTo(29 * scale, 25 * scale);
          tx.closePath();
          tx.fill();
        }
        if ((room.details & 1 /* Dock */) === 1 /* Dock */) {
          tx.fillStyle = "chocolate";
          tx.beginPath();
          tx.arc(20 * scale, 5 * scale, 2 * scale, 0, Math.PI * 2);
          tx.fill();
          tx.closePath();
        } else if ((room.details & 2 /* Pier */) === 2 /* Pier */) {
          tx.fillStyle = "gray";
          tx.beginPath();
          tx.arc(12 * scale, 5 * scale, 2 * scale, 0, Math.PI * 2);
          tx.fill();
          tx.closePath();
        }
        if ((room.details & 128 /* WaterSource */) === 128 /* WaterSource */) {
          tx.fillStyle = "aqua";
          tx.beginPath();
          tx.arc(12 * scale, 5 * scale, 2 * scale, 0, Math.PI * 2);
          tx.fill();
          tx.closePath();
        }
        tx.scale(scale, scale);
        if ((room.details & 4 /* Bank */) === 4 /* Bank */) {
          tx.fillStyle = "goldenrod";
          tx.beginPath();
          tx.fillText("$", 9, 17);
          tx.closePath();
        }
        if ((room.details & 8 /* Shop */) === 8 /* Shop */) {
          tx.fillStyle = "purple";
          tx.beginPath();
          tx.fillText("\u23CF", 15, 17);
          tx.closePath();
        }
        if ((room.details & 16 /* Hospital */) === 16 /* Hospital */) {
          tx.fillStyle = "blue";
          tx.beginPath();
          tx.fillText("\u2665", 15, 17);
          tx.closePath();
        }
        if ((room.details & 256 /* Trainer */) === 256 /* Trainer */) {
          tx.fillStyle = "red";
          tx.beginPath();
          tx.fillText("\u260D", 15, 17);
          tx.closePath();
        }
        if ((room.details & 512 /* Stable */) === 512 /* Stable */) {
          tx.fillStyle = "rgb(153, 102, 0)";
          tx.beginPath();
          tx.fillText("\u2658", 7, 17);
          tx.closePath();
        }
        if ((room.details & 64 /* Restaurant */) === 64 /* Restaurant */ && (room.details & 32 /* Bar */) === 32 /* Bar */) {
          tx.fillStyle = "green";
          tx.beginPath();
          tx.fillText("\u2617", 15, 17);
          tx.closePath();
        } else if ((room.details & 32 /* Bar */) === 32 /* Bar */) {
          tx.fillStyle = "green";
          tx.beginPath();
          tx.fillText("\u266A", 15, 17);
          tx.closePath();
        } else if ((room.details & 64 /* Restaurant */) === 64 /* Restaurant */) {
          tx.fillStyle = "green";
          tx.beginPath();
          tx.fillText("\u2616", 15, 17);
          tx.closePath();
        }
        tx.setTransform(1, 0, 0, 1, 0, 0);
        this._translate(tx, -0.5, scale);
      }
      ctx.drawImage(this._drawCache[key], x2 | 0, y2 | 0);
      this.DrawDoor(ctx, x2 + 12 * scale, y2 - 2 * scale, 8 * scale, 3 * scale, room.exits.north);
      this.DrawDoor(ctx, x2 + 31 * scale, y2 + 12 * scale, 3 * scale, 8 * scale, room.exits.east);
      this.DrawDoor(ctx, x2 - 1 * scale, y2 + 12 * scale, 3 * scale, 8 * scale, room.exits.west);
      this.DrawDoor(ctx, x2 + 12 * scale, y2 + 30 * scale, 8 * scale, 3 * scale, room.exits.south);
      this.DrawDDoor(ctx, x2, y2, 5 * scale, 5 * scale, room.exits.northwest);
      this.DrawDDoor(ctx, x2 + 32 * scale, y2, -5 * scale, 5 * scale, room.exits.northeast);
      this.DrawDDoor(ctx, x2 + 32 * scale, y2 + 32 * scale, -5 * scale, -5 * scale, room.exits.southeast);
      this.DrawDDoor(ctx, x2, y2 + 32 * scale, 5 * scale, -5 * scale, room.exits.southwest);
      if (!ex2 && this.selected.num === room.num) {
        if (this._focused) {
          ctx.fillStyle = "rgba(135, 206, 250, 0.5)";
          ctx.strokeStyle = "LightSkyBlue";
        } else {
          ctx.fillStyle = "rgba(142, 142, 142, 0.5)";
          ctx.strokeStyle = "rgba(142, 142, 142, 0.5)";
        }
        ctx.fillRoundedRect(x2, y2, 32 * scale, 32 * scale, 8 * scale);
        ctx.strokeRoundedRect(x2, y2, 32 * scale, 32 * scale, 8 * scale);
      }
      if (this._markers[room.num] === 2)
        this.drawMarker(ctx, x2, y2, "green", scale);
      else if (this._markers[room.num] === 3)
        this.drawMarker(ctx, x2, y2, "blue", scale);
      else if (this._markers[room.num])
        this.drawMarker(ctx, x2, y2, "yellow", scale);
      if (!ex2 && room.num === this._map.current.num)
        this.drawMarker(ctx, x2, y2, "red", scale);
    }
    drawMarker(ctx, x2, y2, color, scale) {
      if (!color) color = "yellow";
      ctx.beginPath();
      ctx.fillStyle = color;
      ctx.strokeStyle = "black";
      ctx.arc(x2 + 16 * scale, y2 + 16 * scale, 4 * scale, 0, Math.PI * 2);
      ctx.fill();
      ctx.closePath();
    }
    DrawDoor(ctx, x2, y2, w, h, exit) {
      if (!exit || !exit.isdoor) return;
      ctx.beginPath();
      ctx.clearRect(x2, y2, w, h);
      ctx.fillStyle = "black";
      ctx.strokeStyle = "black";
      if (exit.isclosed)
        ctx.fillRect(x2, y2, w, h);
      else
        ctx.strokeRect(x2, y2, w, h);
      ctx.closePath();
    }
    DrawDDoor(ctx, x2, y2, w, h, exit) {
      if (!exit || !exit.isdoor) return;
      ctx.beginPath();
      ctx.fillStyle = "black";
      ctx.strokeStyle = "black";
      ctx.moveTo(x2, y2);
      ctx.lineTo(x2 + w, y2);
      ctx.lineTo(x2, y2 + h);
      ctx.lineTo(x2, y2);
      if (exit.isclosed)
        ctx.fill();
      else
        ctx.stroke();
      ctx.closePath();
    }
    PointInRect(x2, y2, x1, x22, y1, y22) {
      if (x1 <= x2 && x2 <= x22 && (y1 <= y2 && y2 <= y22))
        return true;
      return false;
    }
    getRoom(id) {
      return this._map.Rooms[id];
    }
    getRooms(filter) {
      if (!filter)
        return Object.values(this._map.Rooms);
      return this._map.getRooms(filter);
    }
    showPath(destRoom) {
      if (!destRoom || !destRoom.num)
        destRoom = this.selected;
      if (this._map.current.num == null || destRoom.num == null)
        return;
      if (this._splitArea && this._map.current.area !== destRoom.area)
        return;
      if (this._map.current.zone !== destRoom.zone)
        return;
      let rooms;
      if (this._splitArea)
        rooms = this.getRooms({ area: this._map.current.area, zone: this._map.current.zone });
      else
        rooms = this.getRooms({ zone: this._map.current.zone });
      let room;
      let id;
      const roomsC = [];
      let ox = null;
      let oy = 0;
      let oz = 0;
      let w = 0;
      let h = 0;
      let d2 = 0;
      let r;
      let rl;
      let x2;
      let y2;
      let z2;
      let cx;
      let cy;
      let cz;
      for (id in rooms) {
        if (!rooms.hasOwnProperty(id)) continue;
        room = rooms[id];
        if (ox == null) {
          ox = room.x;
          w = room.x + 1;
          oy = room.y;
          h = room.y + 1;
          oz = room.z;
          d2 = room.z + 1;
          continue;
        }
        if (room.x < ox) ox = room.x;
        else if (room.x > w) w = room.x;
        if (room.y < oy) oy = room.y;
        else if (room.y > h) h = room.y;
        if (room.z < oz) oz = room.z;
        else if (room.z > d2) d2 = room.z;
      }
      for (id in rooms) {
        if (!rooms.hasOwnProperty(id)) continue;
        room = rooms[id];
        if (room == null) continue;
        if (!roomsC[room.y - oy]) roomsC[room.y - oy] = [];
        if (!roomsC[room.y - oy][room.x - ox]) roomsC[room.y - oy][room.x - ox] = [];
        roomsC[room.y - oy][room.x - ox][room.z - oz] = room;
      }
      w = Math.sqrt(Math.pow(w - ox, 2)) + 1;
      h = Math.sqrt(Math.pow(oy - h, 2)) + 1;
      d2 = Math.sqrt(Math.pow(oz - d2, 2)) + 1;
      const matrix = [];
      for (y2 = 0; y2 < h; y2++) {
        matrix[y2] = [];
        for (x2 = 0; x2 < w; x2++) {
          matrix[y2][x2] = [];
          for (z2 = 0; z2 < d2; z2++)
            matrix[y2][x2][z2] = 0;
        }
      }
      for (id in rooms) {
        if (!rooms.hasOwnProperty(id)) continue;
        room = rooms[id];
        x2 = room.x - ox;
        y2 = room.y - oy;
        z2 = room.z - oz;
        if (room.exits.northwest)
          matrix[y2][x2][z2] |= 1;
        if (room.exits.north)
          matrix[y2][x2][z2] |= 128;
        if (room.exits.northeast)
          matrix[y2][x2][z2] |= 64;
        if (room.exits.west)
          matrix[y2][x2][z2] |= 2;
        if (room.exits.east)
          matrix[y2][x2][z2] |= 32;
        if (room.exits.southwest)
          matrix[y2][x2][z2] |= 4;
        if (room.exits.south)
          matrix[y2][x2][z2] |= 8;
        if (room.exits.southeast)
          matrix[y2][x2][z2] |= 16;
        if (room.exits.up)
          matrix[y2][x2][z2] |= 512;
        if (room.exits.down)
          matrix[y2][x2][z2] |= 256;
      }
      const grid = new PF.Grid(w, h, d2, matrix);
      const finder = new PF.AStarFinder({ allowDiagonal: true, dontCrossCorners: false });
      x2 = this._map.current.x - ox;
      y2 = this._map.current.y - oy;
      z2 = this._map.current.z - oz;
      cx = destRoom.x - ox;
      cy = destRoom.y - oy;
      cz = destRoom.z - oz;
      const fPath = finder.findPath(x2, y2, z2, cx, cy, cz, grid);
      rl = fPath.length;
      this._markers = {};
      this._markedRooms = [this._map.current, destRoom];
      for (r = 0; r < rl; r++) {
        x2 = Math.floor(fPath[r][0]);
        y2 = Math.floor(fPath[r][1]);
        z2 = Math.floor(fPath[r][2]);
        if (roomsC[y2] && roomsC[y2][x2] && roomsC[y2][x2][z2]) {
          if (roomsC[y2][x2][z2].num === this._map.current.num)
            this._markers[roomsC[y2][x2][z2].num] = 2;
          else if (roomsC[y2][x2][z2].num === destRoom.num)
            this._markers[roomsC[y2][x2][z2].num] = 3;
          else
            this._markers[roomsC[y2][x2][z2].num] = 1;
        }
      }
      this.emit("path-shown");
      this._doUpdate(1 /* draw */);
    }
    clearPath() {
      this.emit("path-cleared");
      this._markers = {};
      this._markedRooms = 0;
      this._doUpdate(1 /* draw */);
    }
    get hasMarked() {
      return this._markedRooms && this._markedRooms.length !== 0;
    }
    get markedStart() {
      if (!this._markedRooms) return 0;
      return this._markedRooms[0];
    }
    get markedEnd() {
      if (!this._markedRooms) return 0;
      return this._markedRooms[1];
    }
    getMarkedPath() {
      return new Promise((resolve, reject) => {
        if (!this._markedRooms)
          this.getPath().then(resolve).catch(reject);
        else
          this.getPath(this._markedRooms[1], this._markedRooms[0]).then(resolve).catch(reject);
      });
    }
    getPath(destRoom, startRoom) {
      return new Promise((resolve, reject) => {
        if (!destRoom || !destRoom.num)
          destRoom = this.selected;
        if (!startRoom || !startRoom.num)
          startRoom = this._map.current;
        if (startRoom.num == null || destRoom.num == null) {
          reject("Invalid start or end room.");
          return;
        }
        if (this._splitArea && startRoom.area !== destRoom.area) {
          reject("Start and end rooms must be in same the area.");
          return;
        }
        if (startRoom.zone !== destRoom.zone) {
          reject("Start and end rooms must be in the same zone.");
          return;
        }
        let rooms;
        if (this._splitArea)
          rooms = this.getRooms({ area: startRoom.area, zone: startRoom.zone });
        else
          rooms = this.getRooms({ zone: startRoom.zone });
        let room;
        let id;
        let ox = null;
        let oy = 0;
        let oz = 0;
        let w = 0;
        let h = 0;
        let d2 = 0;
        let r;
        let rl;
        let x2;
        let y2;
        let z2;
        let cx;
        let cy;
        let cz;
        let x22;
        let y22;
        let z22;
        for (id in rooms) {
          if (!rooms.hasOwnProperty(id)) continue;
          room = rooms[id];
          if (ox == null) {
            ox = room.x;
            w = room.x + 1;
            oy = room.y;
            h = room.y + 1;
            oz = room.z;
            d2 = room.z + 1;
            continue;
          }
          if (room.x < ox) ox = room.x;
          else if (room.x > w) w = room.x;
          if (room.y < oy) oy = room.y;
          else if (room.y > h) h = room.y;
          if (room.z < oz) oz = room.z;
          else if (room.z > d2) d2 = room.z;
        }
        w = Math.sqrt(Math.pow(w - ox, 2)) + 1;
        h = Math.sqrt(Math.pow(oy - h, 2)) + 1;
        d2 = Math.sqrt(Math.pow(oz - d2, 2)) + 1;
        const matrix = [];
        for (y2 = 0; y2 < h; y2++) {
          matrix[y2] = [];
          for (x2 = 0; x2 < w; x2++) {
            matrix[y2][x2] = [];
            for (z2 = 0; z2 < d2; z2++)
              matrix[y2][x2][z2] = 0;
          }
        }
        for (id in rooms) {
          if (!rooms.hasOwnProperty(id)) continue;
          room = rooms[id];
          x2 = room.x - ox;
          y2 = room.y - oy;
          z2 = room.z - oz;
          if (room.exits.northwest)
            matrix[y2][x2][z2] |= 1;
          if (room.exits.north)
            matrix[y2][x2][z2] |= 128;
          if (room.exits.northeast)
            matrix[y2][x2][z2] |= 64;
          if (room.exits.west)
            matrix[y2][x2][z2] |= 2;
          if (room.exits.east)
            matrix[y2][x2][z2] |= 32;
          if (room.exits.southwest)
            matrix[y2][x2][z2] |= 4;
          if (room.exits.south)
            matrix[y2][x2][z2] |= 8;
          if (room.exits.southeast)
            matrix[y2][x2][z2] |= 16;
          if (room.exits.up)
            matrix[y2][x2][z2] |= 512;
          if (room.exits.down)
            matrix[y2][x2][z2] |= 256;
        }
        const grid = new PF.Grid(w, h, d2, matrix);
        const finder = new PF.AStarFinder({ allowDiagonal: true, dontCrossCorners: false });
        x2 = startRoom.x - ox;
        y2 = startRoom.y - oy;
        z2 = startRoom.z - oz;
        cx = destRoom.x - ox;
        cy = destRoom.y - oy;
        cz = destRoom.z - oz;
        const fPath = finder.findPath(x2, y2, z2, cx, cy, cz, grid);
        rl = fPath.length;
        const walk = [];
        for (r = 0; r < rl - 1; r++) {
          x2 = Math.floor(fPath[r][0]);
          y2 = Math.floor(fPath[r][1]);
          z2 = Math.floor(fPath[r][2]);
          x22 = Math.floor(fPath[r + 1][0]);
          y22 = Math.floor(fPath[r + 1][1]);
          z22 = Math.floor(fPath[r + 1][2]);
          if (z2 - 1 === z22)
            walk.push("down");
          else if (z2 + 1 === z22)
            walk.push("up");
          else if (x2 - 1 === x22 && y2 - 1 === y22)
            walk.push("northwest");
          else if (x2 === x22 && y2 - 1 === y22)
            walk.push("north");
          else if (x2 + 1 === x22 && y2 - 1 === y22)
            walk.push("northeast");
          else if (x2 - 1 === x22 && y2 + 1 === y22)
            walk.push("southwest");
          else if (x2 === x22 && y2 + 1 === y22)
            walk.push("south");
          else if (x2 + 1 === x22 && y2 + 1 === y22)
            walk.push("southeast");
          else if (x2 - 1 === x22 && y2 === y22)
            walk.push("west");
          else
            walk.push("east");
        }
        resolve(walk);
      });
    }
    walkPath(destRoom, startRoom) {
      this.getPath(destRoom, startRoom).then((walk) => {
        this.SendCommands(walk);
      }).catch(() => {
      });
    }
    walkMarkedPath() {
      const destRoom = this._markedRooms ? this._markedRooms[1] : 0;
      const startRoom = this._markedRooms ? this._markedRooms[0] : 0;
      return new Promise((resolve, reject) => {
        this.getPath(destRoom, startRoom).then((walk) => {
          this.SendCommands(walk);
        }).catch(() => {
        });
      });
    }
    SendCommands(cmds) {
      let tmp;
      let cnt = this.commandDelayCount;
      if (cnt < 0) cnt = 1;
      if (cmds.length > cnt) {
        tmp = cmds.slice(cnt);
        cmds = cmds.slice(0, cnt);
        setTimeout(() => {
          this.SendCommands(tmp);
        }, this.commandDelay);
      }
      this.emit("send-commands", cmds.join("\n") + "\n");
    }
    _doUpdate(type) {
      if (!type) return;
      this._updating |= type;
      if (this._updating === 0 /* none */ || this._rTimeout)
        return;
      this._rTimeout = this._window.requestAnimationFrame(() => {
        if ((this._updating & 1 /* draw */) === 1 /* draw */) {
          this.draw().catch(() => {
          });
          this._updating &= ~1 /* draw */;
        }
        this._rTimeout = 0;
        this._doUpdate(this._updating);
      });
    }
    _setFocus(value) {
      if (this._focused === value) return;
      this._focused = value;
      this._doUpdate(1 /* draw */);
    }
    updateOptions(options) {
      if (!options) return;
      for (let option in options) {
        if (!Object.prototype.hasOwnProperty.call(options, option))
          continue;
        if (option in this)
          this[option] = options[option];
      }
    }
    _resizeCanvas() {
      if (!this._context || this.container.clientHeight === 0 || this.container.clientWidth === 0) return;
      const tempCanvas = this._document.createElement("canvas");
      tempCanvas.width = this._canvas.width;
      tempCanvas.height = this._canvas.height;
      const tempContext = tempCanvas.getContext("2d");
      tempContext.drawImage(this._canvas, 0, 0);
      if (this._showNav) {
        this._canvas.width = this.container.clientWidth - 60;
        this._canvas.height = this.container.clientHeight - 60;
      } else {
        const computedStyle = this._window.getComputedStyle(this._canvas);
        const borderLeftWidth = parseFloat(computedStyle.borderLeftWidth);
        const borderRightWidth = parseFloat(computedStyle.borderRightWidth);
        const borderTopWidth = parseFloat(computedStyle.borderTopWidth);
        const borderBottomWidth = parseFloat(computedStyle.borderBottomWidth);
        this._canvas.width = this.container.clientWidth - borderLeftWidth - borderRightWidth;
        this._canvas.height = this.container.clientHeight - borderTopWidth - borderBottomWidth;
      }
      this._context.drawImage(tempCanvas, 0, 0);
      this._doUpdate(1 /* draw */);
    }
    _mapperNavClick(x2, y2) {
      if (!this._mapperNavDown) return;
      this.scrollBy(x2, y2);
      setTimeout(() => {
        this._mapperNavClick(x2, y2);
      }, 100);
    }
    copyPath(separator) {
      separator = separator || client.getOption("commandStackingChar") || ";";
      this.getPath().then((walk) => {
        copyText(walk.join(separator || "\n"));
        this.emit("debug", "Directions: " + walk);
      }).catch((err) => this.emit("error", err));
    }
    copyMarkedPath(separator) {
      separator = separator || client.getOption("commandStackingChar") || ";";
      this.getMarkedPath().then((walk) => {
        copyText(walk.join(separator || "\n"));
        this.emit("debug", "Directions: " + walk);
      }).catch((err) => this.emit("error", err));
    }
    copySpeedpath() {
      this.getPath().then((walk) => {
        let cnt = 0;
        let cmd = "";
        let cmds = [client.getOption("speedpathsChar") || "!"];
        const wl = walk.length;
        for (let w = 0; w < wl; w++) {
          if (cmd.length && cmd !== walk[w]) {
            cmds.push(cnt);
            cmds.push(cmd);
            cnt = 0;
          }
          cnt++;
          cmd = walk[w];
        }
        cmds.push(cnt);
        cmds.push(cmd);
        copyText(cmds.join(""));
        this.emit("debug", "Speedpath: " + cmds);
      }).catch((err) => this.emit("error", err));
    }
    copyMarkedSpeedpath() {
      this.getMarkedPath().then((walk) => {
        let cnt = 0;
        let cmd = "";
        let cmds = [client.getOption("speedpathsChar") || "!"];
        const wl = walk.length;
        for (let w = 0; w < wl; w++) {
          if (cmd.length && cmd !== walk[w]) {
            cmds.push(cnt);
            cmds.push(cmd);
            cnt = 0;
          }
          cnt++;
          cmd = walk[w];
        }
        cmds.push(cnt);
        cmds.push(cmd);
        copyText(cmds.join(""));
        this.emit("debug", "Speedpath: " + cmds);
      }).catch((err) => this.emit("error", err));
    }
    exportImage(scaled) {
      const rooms = this.getRooms({ area: this.active.area, z: this.active.z, zone: this.active.zone });
      let x2 = null, y2 = 0, w = 0, h = 0, r;
      const rl = rooms.length;
      let room, cx, cy;
      const t = this.active.area === null || !this._splitArea ? "" : this.active.area;
      const scale = scaled ? this._scale : 1;
      for (r = 0; r < rl; r++) {
        room = rooms[r];
        if (room === null) continue;
        if (x2 === null) {
          x2 = room.x;
          w = room.x + 1;
          y2 = room.y;
          h = room.y + 1;
          continue;
        }
        if (room.x < x2) x2 = room.x;
        else if (room.x > w) w = room.x;
        if (room.y < y2) y2 = room.y;
        else if (room.y > h) h = room.y;
      }
      this._context.font = "italic bold 16pt Georgia";
      var fx = this._context.measureText(t).width;
      var rectWidth = Math.ceil(Math.sqrt(Math.pow(w - x2, 2)) * 32 * scale + 60 + 32);
      var rectHeight = Math.ceil(Math.sqrt(Math.pow(y2 - h, 2)) * 32 * scale + 60 + 32);
      if (rectWidth < fx) rectWidth = fx + 60;
      if (this._showLegend) {
        rectWidth += 155;
        if (rectHeight < 200) rectHeight = 200;
      }
      const tempCanvas = this._document.createElement("canvas");
      tempCanvas.id = "mapper-export";
      tempCanvas.style.height = rectHeight + "px";
      tempCanvas.style.width = rectWidth + "px";
      tempCanvas.width = rectWidth;
      tempCanvas.height = rectHeight;
      var ctx;
      if (tempCanvas && tempCanvas.getContext)
        ctx = tempCanvas.getContext("2d");
      else {
        this.emit("error", "Mapper image export: Error generating map!");
        return;
      }
      ctx.strokeStyle = "black";
      ctx.fillStyle = "#eae4d6";
      ctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
      ctx.font = "8pt Arial";
      for (r = 0; r < rl; r++) {
        room = rooms[r];
        if (room === null) continue;
        cx = (room.x - x2) * 32 * scale + 30.5;
        cy = (room.y - y2) * 32 * scale + 30.5;
        this.DrawRoom(ctx, cx, cy, room, true, scale);
      }
      ctx.save();
      ctx.strokeStyle = "black";
      ctx.fillStyle = "black";
      ctx.font = "italic bold 16pt Georgia";
      fx = rectWidth / 2 - fx / 2;
      ctx.fillText(t, fx, 20);
      ctx.translate(rectWidth - 25, rectHeight - 25);
      ctx.font = "italic bold 12pt Georgia";
      ctx.fillText("N", 3, -5);
      ctx.beginPath();
      ctx.moveTo(10, 0);
      ctx.lineTo(5, 15);
      ctx.lineTo(10, 20);
      ctx.lineTo(15, 15);
      ctx.lineTo(10, 0);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.restore();
      this.DrawLegend(ctx, rectWidth - 185, -10, 1);
      tempCanvas.toBlob((blob) => {
        var reader = new FileReader();
        reader.addEventListener("loadend", (evt) => {
          fileSaveAs.show(evt.target.result, this._splitArea && t.length ? "OoMUD." + t + ".png" : "OoMUD.png", "image/png");
        });
        reader.readAsArrayBuffer(blob);
      });
    }
    exportCurrentImage() {
      var tempCanvas = this._document.createElement("canvas");
      var context = tempCanvas.getContext("2d");
      tempCanvas.width = this._canvas.width;
      tempCanvas.height = this._canvas.height;
      this.draw(tempCanvas, context, true).then(() => {
        tempCanvas.toBlob((blob) => {
          var reader = new FileReader();
          reader.addEventListener("loadend", (evt) => {
            fileSaveAs.show(evt.target.result, "OoMUD.current.png", "image/png");
          });
          reader.readAsArrayBuffer(blob);
        });
      });
    }
    exportArea() {
      fileSaveAs.show(JSON.stringify(this.getRooms({ area: this.active.area })), this._splitArea ? "OoMUD." + this.active.area + ".map.txt" : "OoMUD.map.txt", "text/plain");
    }
    exportAll() {
      fileSaveAs.show(JSON.stringify(this.map.Rooms), "OoMUD.map.txt", "text/plain");
    }
  };

  // src/interface/dialog.ts
  var DialogButtons = /* @__PURE__ */ ((DialogButtons2) => {
    DialogButtons2[DialogButtons2["None"] = 0] = "None";
    DialogButtons2[DialogButtons2["Ok"] = 1] = "Ok";
    DialogButtons2[DialogButtons2["Cancel"] = 2] = "Cancel";
    DialogButtons2[DialogButtons2["Yes"] = 4] = "Yes";
    DialogButtons2[DialogButtons2["No"] = 8] = "No";
    DialogButtons2[DialogButtons2["YesNo"] = 12] = "YesNo";
    DialogButtons2[DialogButtons2["Standard"] = 3] = "Standard";
    return DialogButtons2;
  })(DialogButtons || {});
  var Dialog = class extends EventEmitter {
    constructor(options) {
      super();
      this._state = { x: 0, y: 0, height: 0, width: 0, zIndex: 100, maximized: false, show: 0 };
      this._resize = { x: 0, y: 0, height: 0, width: 0, type: 0 /* None */, minHeight: 150, minWidth: 300, borderHeight: 1, borderWidth: 1 };
      this._dragPosition = { x: 0, y: 0 };
      this._windowResize = () => {
        debounce(() => {
          if (this.keepCentered || this._state.show === 2 && !this.moveable)
            this.center();
          else
            this.makeVisible();
          if (this._footer.style.display !== "none")
            this._body.style.bottom = this._footer.clientHeight + 1 + "px";
          this.emit("resizing");
        }, 250, this._id + "dialogResize");
      };
      this._resizeDoDrag = (e) => {
        let t;
        if ((this._resize.type & 1 /* Right */) === 1 /* Right */) {
          t = this._resize.width + e.clientX - this._resize.x;
          if (t > window.innerWidth) t = window.innerWidth;
          this._dialog.style.width = t + "px";
        }
        if ((this._resize.type & 2 /* Bottom */) === 2 /* Bottom */) {
          t = this._resize.height + e.clientY - this._resize.y;
          if (t > window.innerWidth - 16) t = window.innerHeight - 16;
          this._dialog.style.height = t + "px";
        }
        if ((this._resize.type & 8 /* Top */) === 8 /* Top */) {
          t = this._resize.height - e.clientY + this._resize.y - this._resize.borderHeight;
          if (t + this._resize.borderHeight > window.innerHeight) t = window.innerHeight;
          if (t + this._resize.borderHeight <= this._resize.minHeight) {
            this._dialog.style.height = this._resize.minHeight + "px";
            return;
          }
          this._dialog.style.height = t + "px";
          t = e.clientY;
          if (t > window.innerHeight) t = window.innerHeight;
          this._dialog.style.top = t + "px";
        }
        if ((this._resize.type & 4 /* Left */) === 4 /* Left */) {
          t = this._resize.width - e.clientX + this._resize.x - this._resize.borderWidth;
          if (t + this._resize.borderWidth > window.innerWidth) t = window.innerWidth;
          if (t + this._resize.borderWidth <= this._resize.minWidth) {
            this._dialog.style.width = this._resize.minWidth + "px";
            return;
          }
          this._dialog.style.width = t + "px";
          t = e.clientX;
          if (t > window.innerWidth) t = window.innerWidth;
          this._dialog.style.left = t + "px";
        }
        if (this._footer.style.display !== "none")
          this._body.style.bottom = this._footer.clientHeight + 1 + "px";
        this.emit("resizing");
      };
      this._resizeTouchDrag = (e) => {
        if (!e.touches.length) return;
        let t;
        if ((this._resize.type & 1 /* Right */) === 1 /* Right */) {
          t = this._resize.width + e.touches[0].clientX - this._resize.x;
          if (t > window.innerWidth) t = window.innerWidth;
          this._dialog.style.width = t + "px";
        }
        if ((this._resize.type & 2 /* Bottom */) === 2 /* Bottom */) {
          t = this._resize.height + e.touches[0].clientY - this._resize.y;
          if (t > window.innerWidth) t = window.innerHeight;
          this._dialog.style.height = t + "px";
        }
        if ((this._resize.type & 8 /* Top */) === 8 /* Top */) {
          t = this._resize.height - e.touches[0].clientY + this._resize.y - this._resize.borderHeight;
          if (t + this._resize.borderHeight > window.innerHeight) t = window.innerHeight;
          if (t + this._resize.borderHeight <= this._resize.minHeight) {
            this._dialog.style.height = this._resize.minHeight + "px";
            return;
          }
          this._dialog.style.height = t + "px";
          t = e.touches[0].clientY;
          if (t > window.innerHeight) t = window.innerHeight;
          this._dialog.style.top = t + "px";
        }
        if ((this._resize.type & 4 /* Left */) === 4 /* Left */) {
          t = this._resize.width - e.touches[0].clientX + this._resize.x - this._resize.borderWidth;
          if (t + this._resize.borderWidth > window.innerWidth) t = window.innerWidth;
          if (t + this._resize.borderWidth <= this._resize.minWidth) {
            this._dialog.style.width = this._resize.minWidth + "px";
            return;
          }
          this._dialog.style.width = t + "px";
          t = e.touches[0].clientX;
          if (t > window.innerWidth) t = window.innerWidth;
          this._dialog.style.left = t + "px";
        }
        if (this._footer.style.display !== "none")
          this._body.style.bottom = this._footer.clientHeight + 1 + "px";
        this.emit("resizing");
      };
      this._resizeStopDrag = (e) => {
        this._document.documentElement.removeEventListener("mousemove", this._resizeDoDrag);
        this._document.documentElement.removeEventListener("mouseup", this._resizeStopDrag);
        this._document.documentElement.removeEventListener("touchmove", this._resizeTouchDrag);
        this._document.documentElement.removeEventListener("touchend", this._resizeStopDrag);
        const styles = this._window.getComputedStyle(this._dialog);
        this._state.x = parseInt(styles.left, 10);
        ;
        this._state.width = parseInt(styles.width, 10);
        this._state.y = parseInt(styles.top, 10);
        ;
        this._state.height = parseInt(styles.height, 10);
        this._body.style.pointerEvents = "";
        this.emit("resized", this._state);
      };
      this._dragMouseDown = (e) => {
        if (this.maximized) return;
        this._dragPosition.x = e.clientX;
        this._dragPosition.y = e.clientY;
        this._document.documentElement.addEventListener("mouseup", this._dragMouseUp);
        this._document.documentElement.addEventListener("mousemove", this._dragMouseMove);
        this._header.style.cursor = "move";
      };
      this._dragTouchStart = (e) => {
        if (this.maximized) return;
        this._dragPosition.x = e.clientX;
        this._dragPosition.y = e.clientY;
        this._document.documentElement.addEventListener("touchend", this._dragMouseUp);
        this._document.documentElement.addEventListener("touchmove", this._dragTouchMove);
        this._header.style.cursor = "move";
      };
      this._dragMouseMove = (e) => {
        let x2 = this._dragPosition.x - e.clientX;
        let y2 = this._dragPosition.y - e.clientY;
        this._dragPosition.x = e.clientX;
        this._dragPosition.y = e.clientY;
        this._state.x = this._dialog.offsetLeft - x2;
        this._state.y = this._dialog.offsetTop - y2;
        if (this._state.x > window.innerWidth - 16)
          this._state.x = window.innerWidth - 16;
        if (this._state.y > window.innerHeight - 16)
          this._state.y = window.innerHeight - 16;
        let size = this._size;
        if (this._state.x < 16 - size.width)
          this._state.x = 16 - size.width;
        if (this._state.y < 16 - size.height)
          this._state.y = 16 - size.height;
        this._dialog.style.left = this._state.x + "px";
        this._dialog.style.top = this._state.y + "px";
      };
      this._dragTouchMove = (e) => {
        if (!e.touches.length) return;
        let x2 = this._dragPosition.x - e.touches[0].clientX;
        let y2 = this._dragPosition.y - e.touches[0].clientY;
        this._dragPosition.x = e.touches[0].clientX;
        this._dragPosition.y = e.touches[0].clientY;
        this._state.x = this._dialog.offsetLeft - x2;
        this._state.y = this._dialog.offsetTop - y2;
        if (this._state.x > window.innerWidth - 16)
          this._state.x = window.innerWidth - 16;
        if (this._state.y > window.innerHeight - 16)
          this._state.y = window.innerHeight - 16;
        let size = this._size;
        if (this._state.x < 16 - size.width)
          this._state.x = 16 - size.width;
        if (this._state.y < 16 - size.height)
          this._state.y = 16 - size.height;
        this._dialog.style.left = this._state.x + "px";
        this._dialog.style.top = this._state.y + "px";
      };
      this._dragMouseUp = () => {
        this._document.documentElement.removeEventListener("mouseup", this._dragMouseUp);
        this._document.documentElement.removeEventListener("mousemove", this._dragMouseMove);
        this._document.documentElement.removeEventListener("touchend", this._dragMouseUp);
        this._document.documentElement.removeEventListener("touchmove", this._dragTouchMove);
        this._header.style.cursor = "";
        const styles = this._window.getComputedStyle(this._dialog);
        this._state.x = parseInt(styles.left, 10);
        ;
        this._state.width = parseInt(styles.width, 10);
        this._state.y = parseInt(styles.top, 10);
        ;
        this._state.height = parseInt(styles.height, 10);
        this.emit("moved", this._state);
      };
      this.keepCentered = false;
      this.moveable = true;
      this.resizable = true;
      this._maximizable = true;
      this._closable = true;
      this._window = window;
      this._document = options ? options.document || document : document;
      this._window = this._document.defaultView;
      if (options && "type" in options && options.type == 1) {
        this._dialog = this._document.createElement("div");
        this._dialog.open = false;
      } else
        this._dialog = this._document.createElement("dialog");
      if (typeof this._dialog.showModal !== "function") {
        this._dialog.showModal = () => {
          if (this._dialog.open) return;
          this._dialog.style.display = "block";
          this._dialog.style.visibility = "visible";
          this._dialog.open = true;
          this._state.show = 2;
          this._dialog.dataset.show = "" + this._state.show;
          if (!this._dialog._keydown) {
            this._dialog._keydown = (e) => {
              if (e.key === "Escape" && e.srcElement.tagName !== "TEXTAREA" && e.srcElement.tagName !== "INPUT" && e.srcElement.tagName !== "SELECT") {
                this._dialog.returnValue = "canceled";
                this.close();
              }
            };
          }
          if (!this._dialog.backdrop_) {
            this._dialog.backdrop_ = this._document.createElement("div");
            this._dialog.backdrop_.className = "backdrop";
            this._dialog.backdrop_MouseEvent = function(e) {
              if (!this.hasAttribute("tabindex")) {
                var fake = this._document.createElement("div");
                this.insertBefore(fake, this.firstChild);
                fake.tabIndex = -1;
                fake.focus();
                this.removeChild(fake);
              } else
                this.focus();
              var redirectedEvent = this._document.createEvent("MouseEvents");
              redirectedEvent.initMouseEvent(
                e.type,
                e.bubbles,
                e.cancelable,
                window,
                e.detail,
                e.screenX,
                e.screenY,
                e.clientX,
                e.clientY,
                e.ctrlKey,
                e.altKey,
                e.shiftKey,
                e.metaKey,
                e.button,
                e.relatedTarget
              );
              this.dispatchEvent(redirectedEvent);
              e.stopPropagation();
            };
            this._dialog.backdrop_.addEventListener("mouseup", this._dialog.backdrop_MouseEvent.bind(this._dialog));
            this._dialog.backdrop_.addEventListener("mousedown", this._dialog.backdrop_MouseEvent.bind(this._dialog));
            this._dialog.backdrop_.addEventListener("click", this._dialog.backdrop_MouseEvent.bind(this._dialog));
          }
          this._dialog.parentNode.insertBefore(this._dialog.backdrop_, this._dialog.nextSibling);
          this._document.addEventListener("keydown", this._dialog._keydown);
        };
      }
      if (typeof this._dialog.show !== "function") {
        this._dialog.show = () => {
          if (this._dialog.open) return;
          this._dialog.style.display = "block";
          this._dialog.style.visibility = "visible";
          this._dialog.open = true;
          this._state.show = 1;
          this._dialog.dataset.show = "" + this._state.show;
        };
      }
      if (typeof this._dialog.close !== "function") {
        this._dialog.close = () => {
          this._dialog.style.display = "";
          this._dialog.style.visibility = "";
          this._dialog.open = false;
          this._state.show = 0;
          this._dialog.dataset.show = "" + this._state.show;
          this._window.removeEventListener("resize", this._windowResize);
          this.emit("closed");
        };
      }
      this._dialog.dialog = this;
      if (options && "id" in options && options.id && options.id.length)
        this._id = options.id;
      else if (!this._id || !this._id.length)
        this._id = "dialog" + (/* @__PURE__ */ new Date()).getTime();
      this._dialog.id = this._id;
      this._dialog.style.zIndex = "100";
      this._dialog.style.margin = "0";
      this._dialog.classList.add("dialog");
      if (!options || !options.noAdaptive)
        this._dialog.classList.add("adaptive");
      if (options && "moveable" in options)
        this.moveable = options.moveable;
      if (options && "resizable" in options)
        this.resizable = options.resizable;
      if (options && "maximizable" in options)
        this._maximizable = options.maximizable;
      if (typeof options?.height === "number")
        this._dialog.style.height = options.height + "px";
      else if (options?.height && options?.height.length > 0)
        this._dialog.style.height = options.height;
      else
        this._dialog.style.height = "480px";
      if (typeof options?.minHeight === "number")
        this._dialog.style.minHeight = options.minHeight + "px";
      else if (options?.minHeight && options?.minHeight.length > 0)
        this._dialog.style.minHeight = options.minHeight;
      else
        this._dialog.style.minHeight = "150px";
      if (typeof options?.minWidth === "number")
        this._dialog.style.minWidth = options.minWidth + "px";
      else if (options?.minWidth && options?.minWidth.length > 0)
        this._dialog.style.minWidth = options.minWidth;
      else
        this._dialog.style.minWidth = "300px";
      if (typeof options?.width === "number")
        this._dialog.style.width = options.width + "px";
      else if (options?.width && options?.width.length > 0)
        this._dialog.style.width = options.width;
      else
        this._dialog.style.width = "640px";
      if (typeof options?.y === "number")
        this._dialog.style.top = options.y + "px";
      else if (options?.y && options?.y.length > 0)
        this._dialog.style.top = options.y;
      else
        this._dialog.style.top = "0";
      if (typeof options?.x === "number")
        this._dialog.style.left = options.x + "px";
      else if (options?.x && options?.x.length > 0)
        this._dialog.style.left = options.x;
      else
        this._dialog.style.left = "0";
      let footer = "";
      if (options && (options.buttons & 2 /* Cancel */) === 2 /* Cancel */)
        footer += `<button id="${this._id}-cancel" type="button" class="btn-sm float-end btn btn-light" title="Cancel dialog">Cancel</button>`;
      if (options && (options.buttons & 1 /* Ok */) === 1 /* Ok */)
        footer += `<button id="${this._id}-ok" type="button" class="btn-sm float-end btn btn-primary" title="Confirm dialog">Ok</button>`;
      if (options && (options.buttons & 8 /* No */) === 8 /* No */)
        footer += `<button id="${this._id}-no" type="button" class="btn-sm float-end btn btn-light" title="No">No</button>`;
      if (options && (options.buttons & 4 /* Yes */) === 4 /* Yes */)
        footer += `<button id="${this._id}-yes" type="button" class="btn-sm float-end btn btn-primary" title="Yes">Yes</button>`;
      this._dialog.innerHTML = `<div class="dialog-header"><button id="${this._id}-header-close" style="padding: 4px;" type="button" class="btn btn-close float-end btn-danger" data-dismiss="modal" title="Close window"></button><button type="button" class="btn btn-light float-end maximize" id="${this._id}-max" title="Maximize window" style="padding: 0 4px;margin-top: -1px;"><i class="bi-arrows-fullscreen"></i></button><div>${options?.title || ""}</div></div><div class="dialog-body"></div><div class="dialog-footer">${footer}</div>`;
      this._dialog.querySelector(`#${this._id}-header-close`).addEventListener("click", () => {
        this.close();
      });
      this._dialog.querySelector(`#${this._id}-max`).addEventListener("click", () => {
        if (!this.maximized)
          this.maximize();
        else
          this.restore();
      });
      this._dialog.addEventListener("close", (e) => {
        if (e.target !== this._dialog) return;
        const ec = { preventDefault: false };
        this.emit("closing", ec);
        if (ec.preventDefault) {
          e.preventDefault();
          return;
        }
        this._document.body.removeChild(this._dialog);
        this._state.show = 0;
        this._dialog.dataset.show = "" + this._state.show;
        if (this._dialog.backdrop_)
          this._dialog.parentNode.removeChild(this._dialog.backdrop_);
        if (this._dialog._keydown)
          this._window.document.removeEventListener("keydown", this._dialog._keydown);
        this._window.removeEventListener("resize", this._windowResize);
        this.emit("closed", this._dialog.returnValue);
      });
      this._dialog.addEventListener("cancel", (e) => {
        if (e.target !== this._dialog) return;
        const ec = { preventDefault: false };
        this.emit("canceling", ec);
        if (ec.preventDefault) {
          e.preventDefault();
          return;
        }
        if (this._document.activeElement && (this._document.activeElement.tagName === "TEXTAREA" || this._document.activeElement.tagName === "iNPUT" || this._document.activeElement.tagName === "SELECT")) {
          e.preventDefault();
          return;
        }
        this._dialog.open = false;
        this._document.body.removeChild(this._dialog);
        this._state.show = 0;
        this._dialog.dataset.show = "" + this._state.show;
        if (this._dialog.backdrop_)
          this._dialog.parentNode.removeChild(this._dialog.backdrop_);
        if (this._dialog._keydown)
          this._window.document.removeEventListener("keydown", this._dialog._keydown);
        this._window.removeEventListener("resize", this._windowResize);
        if (this._dialog.returnValue !== "ok")
          this.emit("canceled");
      });
      this._document.body.appendChild(this._dialog);
      if (this._maximizable)
        this._dialog.querySelector(`#${this._id}-max`).style.display = "";
      else
        this._dialog.querySelector(`#${this._id}-max`).style.display = "none";
      if (options && "closeable" in options)
        this.closeable = options.closeable;
      if (options && (options.buttons & 2 /* Cancel */) === 2 /* Cancel */)
        this._dialog.querySelector(`#${this._id}-cancel`).addEventListener("click", () => {
          const e = { preventDefault: false, button: 2 /* Cancel */ };
          this.emit("button-click", e);
          if (e.preventDefault) return;
          this._dialog.returnValue = "cancel";
          this.close();
        });
      if (options && (options.buttons & 8 /* No */) === 8 /* No */)
        this._dialog.querySelector(`#${this._id}-no`).addEventListener("click", () => {
          const e = { preventDefault: false, button: 8 /* No */ };
          this.emit("button-click", e);
          if (e.preventDefault) return;
          this._dialog.returnValue = "no";
          this.close();
        });
      if (options && (options.buttons & 1 /* Ok */) === 1 /* Ok */)
        this._dialog.querySelector(`#${this._id}-ok`).addEventListener("click", () => {
          const e = { preventDefault: false, button: 1 /* Ok */ };
          this.emit("button-click", e);
          if (e.preventDefault) return;
          this._dialog.returnValue = "ok";
          this._dialog.close();
        });
      if (options && (options.buttons & 4 /* Yes */) === 4 /* Yes */)
        this._dialog.querySelector(`#${this._id}-yes`).addEventListener("click", () => {
          const e = { preventDefault: false, button: 4 /* Yes */ };
          this.emit("button-click", e);
          if (e.preventDefault) return;
          this._dialog.returnValue = "yes";
          this._dialog.close();
        });
      this._body = this._dialog.querySelector('[class="dialog-body"]');
      this._title = this._dialog.querySelector('[class="dialog-header"] div');
      this._footer = this._dialog.querySelector('[class="dialog-footer"]');
      this._header = this._dialog.querySelector('[class="dialog-header"]');
      if (this.resizable) {
        this._dialog.classList.add("resizable");
        var right = this._document.createElement("div");
        right.className = "resizer-right";
        this._dialog.appendChild(right);
        right.addEventListener("mousedown", (e) => {
          this._initResize(e, 1 /* Right */);
        }, false);
        right.addEventListener("touchstart", (e) => {
          this._initResizeTouch(e, 1 /* Right */);
        }, { passive: true });
        var bottom = this._document.createElement("div");
        bottom.className = "resizer-bottom";
        this._dialog.appendChild(bottom);
        bottom.addEventListener("mousedown", (e) => {
          this._initResize(e, 2 /* Bottom */);
        }, false);
        bottom.addEventListener("touchstart", (e) => {
          this._initResizeTouch(e, 2 /* Bottom */);
        }, { passive: true });
        var corner = this._document.createElement("div");
        corner.className = "resizer-se";
        this._dialog.appendChild(corner);
        corner.addEventListener("mousedown", (e) => {
          this._initResize(e, 1 /* Right */ | 2 /* Bottom */);
        }, false);
        corner.addEventListener("touchstart", (e) => {
          this._initResizeTouch(e, 1 /* Right */ | 2 /* Bottom */);
        }, { passive: true });
        corner = this._document.createElement("div");
        corner.className = "resizer-ne";
        this._dialog.appendChild(corner);
        corner.addEventListener("mousedown", (e) => {
          this._initResize(e, 1 /* Right */ | 8 /* Top */);
        }, false);
        corner.addEventListener("touchstart", (e) => {
          this._initResizeTouch(e, 1 /* Right */ | 8 /* Top */);
        }, { passive: true });
        corner = this._document.createElement("div");
        corner.className = "resizer-nw";
        this._dialog.appendChild(corner);
        corner.addEventListener("mousedown", (e) => {
          this._initResize(e, 4 /* Left */ | 8 /* Top */);
        }, false);
        corner.addEventListener("touchstart", (e) => {
          this._initResizeTouch(e, 4 /* Left */ | 8 /* Top */);
        }, { passive: true });
        corner = this._document.createElement("div");
        corner.className = "resizer-sw";
        this._dialog.appendChild(corner);
        corner.addEventListener("mousedown", (e) => {
          this._initResize(e, 4 /* Left */ | 2 /* Bottom */);
        }, false);
        corner.addEventListener("touchstart", (e) => {
          this._initResizeTouch(e, 4 /* Left */ | 2 /* Bottom */);
        }, { passive: true });
        var left = this._document.createElement("div");
        left.className = "resizer-left";
        this._dialog.appendChild(left);
        left.addEventListener("mousedown", (e) => {
          this._initResize(e, 4 /* Left */);
        }, false);
        left.addEventListener("touchstart", (e) => {
          this._initResizeTouch(e, 4 /* Left */);
        }, { passive: true });
        var top = this._document.createElement("div");
        top.className = "resizer-top";
        this._dialog.appendChild(top);
        top.addEventListener("mousedown", (e) => {
          this._initResize(e, 8 /* Top */);
        }, false);
        top.addEventListener("touchstart", (e) => {
          this._initResizeTouch(e, 8 /* Top */);
        }, { passive: true });
      }
      if (this.moveable) {
        this._dialog.addEventListener("mousedown", () => {
          this.focus();
        });
        this._header.addEventListener("mousedown", this._dragMouseDown);
        this._header.addEventListener("touchstart", this._dragTouchStart, { passive: true });
      }
      const styles = this._window.getComputedStyle(this._dialog);
      this._state.x = this._resize.x = parseInt(styles.left, 10);
      ;
      this._state.width = this._resize.width = parseInt(styles.width, 10);
      this._state.y = this._resize.y = parseInt(styles.top, 10);
      ;
      this._state.height = this._resize.height = parseInt(styles.height, 10);
      if (options && "noFooter" in options && options.noFooter)
        this.hideFooter();
      if (options && "maximized" in options && options.maximized)
        this.maximize();
      if (options && "showModal" in options && options.showModal)
        this.showModal();
      else if (options && "show" in options && options.show) {
        if (options.show === 2)
          this.showModal();
        else
          this.show();
      }
      if (options && "keepCentered" in options && options.keepCentered)
        this.keepCentered = options.keepCentered;
      if (this.keepCentered || options && "center" in options && options.center)
        this.center();
      if (options && "position" in options && options.position > 0)
        this.position(options.position);
      this._windowResize();
      this._resizeObserver = new ResizeObserver((entries, observer) => {
        if (entries.length === 0) return;
        if (!entries[0].contentRect || entries[0].contentRect.width === 0 || entries[0].contentRect.height === 0)
          return;
        if (!this._resizeObserverCache || this._resizeObserverCache.height !== entries[0].contentRect.height) {
          this._resizeObserverCache = { width: entries[0].contentRect.width, height: entries[0].contentRect.height };
          if (this._footer.style.display !== "none")
            this._body.style.bottom = this._footer.clientHeight + 1 + "px";
        }
      });
      this._resizeObserver.observe(this._footer);
      this._observer = new MutationObserver((mutationsList) => {
        let mutation;
        for (mutation of mutationsList) {
          if (mutation.type === "attributes" && mutation.attributeName === "style") {
            if (this._footer.style.display !== "none")
              this._body.style.bottom = this._footer.clientHeight + 1 + "px";
          }
        }
      });
      this._observer.observe(this._footer, { attributes: true, attributeOldValue: true, attributeFilter: ["style"] });
    }
    get maximizable() {
      return this._maximizable;
    }
    set maximizable(value) {
      if (value === this._maximizable) return;
      this._maximizable = value;
      if (this.maximizable)
        this._dialog.querySelector(`#${this._id}-max`).style.display = "";
      else
        this._dialog.querySelector(`#${this._id}-max`).style.display = "none";
    }
    get closeable() {
      return this._closable;
    }
    set closeable(value) {
      if (value === this._closable) return;
      this._closable = value;
      if (this._closable)
        this._dialog.querySelector(`#${this._id}-header-close`).style.display = "";
      else
        this._dialog.querySelector(`#${this._id}-header-close`).style.display = "none";
    }
    set maximized(value) {
      if (this._state.maximized === value) return;
      this._state.maximized = value;
    }
    get maximized() {
      return this._state.maximized;
    }
    _initResize(e, type) {
      if (this.maximized) return;
      const styles = this._window.getComputedStyle(this._dialog);
      this._resize.x = e.clientX;
      this._resize.width = parseInt(styles.width, 10);
      this._resize.y = e.clientY;
      this._resize.height = parseInt(styles.height, 10);
      this._resize.type = type;
      this._resize.minHeight = parseInt(styles.minHeight, 10);
      this._resize.minWidth = parseInt(styles.minWidth, 10);
      this._resize.borderHeight = e.offsetY + parseInt(styles.borderTopWidth);
      this._resize.borderWidth = e.offsetX + parseInt(styles.borderLeftWidth);
      this._body.style.pointerEvents = "none";
      this._document.documentElement.addEventListener("mousemove", this._resizeDoDrag, false);
      this._document.documentElement.addEventListener("mouseup", this._resizeStopDrag, false);
    }
    _initResizeTouch(e, type) {
      if (!e.touches.length || this.maximized) return;
      const styles = this._window.getComputedStyle(this._dialog);
      this._resize.x = e.touches[0].clientX;
      this._resize.width = parseInt(styles.width, 10);
      this._resize.y = e.touches[0].clientY;
      this._resize.height = parseInt(styles.height, 10);
      this._resize.type = type;
      this._resize.minHeight = parseInt(styles.minHeight, 10);
      this._resize.minWidth = parseInt(styles.minWidth, 10);
      var rect = e.target.getBoundingClientRect();
      var x2 = e.targetTouches[0].clientX - rect.x;
      var y2 = e.targetTouches[0].clientY - rect.y;
      this._resize.borderHeight = y2 + parseInt(styles.borderTopWidth);
      this._resize.borderWidth = x2 + parseInt(styles.borderLeftWidth);
      this._body.style.pointerEvents = "none";
      this._document.documentElement.addEventListener("touchmove", this._resizeTouchDrag, false);
      this._document.documentElement.addEventListener("touchend", this._resizeStopDrag, false);
    }
    get id() {
      return this._id;
    }
    set id(value) {
      if (this._id === value) return;
      this._id = value;
      if (this._dialog) {
        this._dialog.id = this._id;
        let el = this._dialog.querySelector(`#${this._id}-cancel`);
        if (el) el.id = this._id + "-cancel";
        el = this._dialog.querySelector(`#${this._id}-ok`);
        if (el) el.id = this._id + "-ok";
        el = this._dialog.querySelector(`#${this._id}-max`);
        if (el) el.id = this._id + "-max";
        el = this._dialog.querySelector(`#${this._id}-header-close`);
        if (el) el.id = this._id + "-header-close";
      }
    }
    get title() {
      return this._title.innerHTML;
    }
    set title(value) {
      this._title.innerHTML = value;
    }
    showModal() {
      if (!this._dialog.parentElement)
        this._document.body.appendChild(this._dialog);
      this.makeVisible(true);
      this._dialog.returnValue = "";
      if (this._dialog.open) {
        this.focus();
        return;
      }
      this._dialog.showModal();
      this._state.show = 2;
      this._dialog.dataset.show = "" + this._state.show;
      this._window.addEventListener("resize", this._windowResize);
      this.emit("shown", true);
      this.focus();
    }
    show() {
      if (!this._dialog.parentElement)
        this._document.body.appendChild(this._dialog);
      this.makeVisible(true);
      this._dialog.returnValue = "";
      if (this._dialog.open) {
        this.focus();
        return;
      }
      this._dialog.show();
      this._state.show = 1;
      this._dialog.dataset.show = "" + this._state.show;
      this._window.addEventListener("resize", this._windowResize);
      this.emit("shown", false);
      this.focus();
    }
    get opened() {
      return this._dialog.open;
    }
    close(returnValue) {
      if (!this._dialog.open) return;
      if (this._dialog.backdrop_)
        this._dialog.parentNode.removeChild(this._dialog.backdrop_);
      if (this._dialog._keydown)
        this._document.removeEventListener("keydown", this._dialog._keydown);
      if (returnValue)
        this._dialog.returnValue = returnValue;
      this._dialog.close();
    }
    get header() {
      return this._header;
    }
    get body() {
      return this._body;
    }
    get footer() {
      return this._footer;
    }
    get dialog() {
      return this._dialog;
    }
    get left() {
      return this._dialog.style.left;
    }
    set left(value) {
      this._dialog.style.left = value;
    }
    get top() {
      return this._dialog.style.top;
    }
    set top(value) {
      this._dialog.style.top = value;
    }
    get width() {
      return this._dialog.style.width;
    }
    set width(value) {
      this._dialog.style.width = value;
    }
    get height() {
      return this._dialog.style.height;
    }
    set height(value) {
      this._dialog.style.top = value;
    }
    get windowState() {
      return this._state;
    }
    /*
        private _width() {
            let w = this.dialog.offsetWidth || this._dialog.clientWidth;
            if (!w) {
                const styles = this._window.getComputedStyle(this._dialog);
                w = w || parseInt(styles.width, 10);
            }
            return w;
        }
    
        private _height() {
            let h = this.dialog.offsetHeight || this._dialog.clientHeight;
            if (!h) {
                const styles = this._window.getComputedStyle(this._dialog);
                h = h || parseInt(styles.height, 10);
            }
            return h;
        }
        */
    get _size() {
      let w = this.dialog.offsetWidth || this._dialog.clientWidth;
      let h = this.dialog.offsetHeight || this._dialog.clientHeight;
      if (!w || !h) {
        const styles = this._window.getComputedStyle(this._dialog);
        w = w || parseInt(styles.width, 10);
        h = h || parseInt(styles.height, 10);
      }
      return { width: w, height: h };
    }
    center() {
      this.position(48 /* Center */);
    }
    position(position) {
      if (position < 1) return;
      let size = this._size;
      if ((position & 4 /* Top */) === 4 /* Top */)
        this._state.y = 0;
      else if ((position & 8 /* Bottom */) === 8 /* Bottom */)
        this._state.y = this._window.innerHeight - size.height;
      else if ((position & 16 /* CenterVertical */) === 16 /* CenterVertical */)
        this._state.y = this._window.innerHeight / 2 - size.height / 2;
      if ((position & 1 /* Left */) === 1 /* Left */)
        this._state.x = 0;
      else if ((position & 2 /* Right */) === 2 /* Right */)
        this._state.x = this._window.innerWidth - size.width;
      else if ((position & 32 /* CenterHorizontal */) === 32 /* CenterHorizontal */)
        this._state.x = this._window.innerWidth / 2 - size.width / 2;
      this._dialog.style.left = this._state.x + "px";
      this._dialog.style.top = this._state.y + "px";
      this._state.width = size.width;
      this._state.height = size.height;
      this.emit("moved", this._state);
    }
    maximize() {
      if (this.maximized) return;
      this.maximized = true;
      this._dialog.classList.add("maximized");
      this._dialog.querySelector(`#${this._id}-max`).firstElementChild.classList.remove("bi-arrows-fullscreen");
      this._dialog.querySelector(`#${this._id}-max`).firstElementChild.classList.add("bi-arrows-angle-contract");
      this.emit("maximized");
    }
    restore() {
      if (!this.maximized) return;
      this.maximized = false;
      this._dialog.classList.remove("maximized");
      this._dialog.querySelector(`#${this._id}-max`).firstElementChild.classList.add("bi-arrows-fullscreen");
      this._dialog.querySelector(`#${this._id}-max`).firstElementChild.classList.remove("bi-arrows-angle-contract");
      this.emit("restored");
    }
    _getMaxZIndex(forceReset) {
      const dialogs = this._document.getElementsByTagName("dialog");
      let d2 = 0;
      const dl = dialogs.length;
      let i2 = parseInt(this._dialog.style.zIndex, 10);
      ;
      const order = [];
      for (; d2 < dl; d2++) {
        if (!dialogs[d2].style.zIndex || !dialogs[d2].style.zIndex.length) continue;
        let z2 = parseInt(dialogs[d2].style.zIndex, 10);
        if (z2 > i2)
          i2 = z2;
        order.push({ z: z2, idx: d2, show: parseInt(dialogs[d2].dataset.show || "", 10) || 0 });
      }
      this._state.zIndex = i2;
      if (forceReset || this._state.zIndex > 1e3) {
        this._state.zIndex = 100;
        d2 = 0;
        order.sort((a, b) => a.show > b.show ? 1 : a.z < b.z ? -1 : a.z > b.z ? 1 : 0);
        for (; d2 < dl; d2++) {
          if (dialogs[order[d2]].backdrop_)
            dialogs[order[d2]].backdrop_.style.zIndex = "" + this._state.zIndex++;
          dialogs[order[d2].idx].style.zIndex = "" + this._state.zIndex++;
        }
      }
    }
    showFooter() {
      this._footer.style.display = "";
      this._body.style.bottom = this._footer.clientHeight + 1 + "px";
    }
    hideFooter() {
      this._footer.style.display = "none";
      this._body.style.bottom = "0";
    }
    focus() {
      this._dialog.focus();
      this._getMaxZIndex();
      this._dialog.style.zIndex = "" + ++this._state.zIndex;
      this.emit("focus");
    }
    makeVisible(full, silent) {
      var rect = this._dialog.getBoundingClientRect();
      if (full) {
        if (rect.right > this._window.innerWidth) {
          this._state.x = this._window.innerWidth - this._state.width - 16;
          if (rect.left < 0) this._state.x = 0;
          this._dialog.style.left = this._state.x + "px";
        }
        if (rect.bottom > this._window.innerHeight) {
          this._state.y = this._window.innerHeight - this._state.height - 16;
          if (rect.top < 0) this._state.y = 0;
          this._dialog.style.top = this._state.y + "px";
        }
      } else {
        if (rect.left > this._window.innerWidth - 16) {
          this._state.x = this._window.innerWidth - 16;
          this._dialog.style.left = this._state.x + "px";
        }
        if (rect.top > this._window.innerHeight - 16) {
          this._state.y = this._window.innerHeight - 16;
          this._dialog.style.top = this._state.y + "px";
        }
      }
      if (!silent)
        this.emit("moved", this._state);
    }
    resetState(options) {
      if (typeof options?.height === "number")
        this._dialog.style.height = options.height + "px";
      else if (options?.height && options?.height.length > 0)
        this._dialog.style.height = options.height;
      else
        this._dialog.style.height = "480px";
      if (typeof options?.minHeight === "number")
        this._dialog.style.minHeight = options.minHeight + "px";
      else if (options?.minHeight && options?.minHeight.length > 0)
        this._dialog.style.minHeight = options.minHeight;
      else
        this._dialog.style.minHeight = "150px";
      if (typeof options?.minWidth === "number")
        this._dialog.style.minWidth = options.minWidth + "px";
      else if (options?.minWidth && options?.minWidth.length > 0)
        this._dialog.style.minWidth = options.minWidth;
      else
        this._dialog.style.minWidth = "300px";
      if (typeof options?.width === "number")
        this._dialog.style.width = options.width + "px";
      else if (options?.width && options?.width.length > 0)
        this._dialog.style.width = options.width;
      else
        this._dialog.style.width = "640px";
      if (typeof options?.y === "number")
        this._dialog.style.top = options.y + "px";
      else if (options?.y && options?.y.length > 0)
        this._dialog.style.top = options.y;
      else
        this._dialog.style.top = "0";
      if (typeof options?.x === "number")
        this._dialog.style.left = options.x + "px";
      else if (options?.x && options?.x.length > 0)
        this._dialog.style.left = options.x;
      else
        this._dialog.style.left = "0";
      const styles = this._window.getComputedStyle(this._dialog);
      this._state.x = this._resize.x = parseInt(styles.left, 10);
      ;
      this._state.width = this._resize.width = parseInt(styles.width, 10);
      this._state.y = this._resize.y = parseInt(styles.top, 10);
      ;
      this._state.height = this._resize.height = parseInt(styles.height, 10);
      if (options && "maximized" in options && options.maximized)
        this.maximize();
      else
        this.restore();
      if (this.keepCentered || options && "center" in options && options.center)
        this.center();
      if (options && "position" in options && options.position > 0)
        this.position(options.position);
      this._windowResize();
    }
    setBody(contents, args) {
      this._body.innerHTML = contents;
      args = args || {};
      const scripts = this._body.querySelectorAll("script");
      for (let s = 0, sl = scripts.length; s < sl; s++) {
        let script = new Function("body", "dialog", ...Object.keys(args), scripts[s].textContent);
        script.apply(client, [this._body, this, ...Object.values(args), this]);
      }
    }
  };
  var AlertDialog = class extends Dialog {
    constructor(title, message, icon, win) {
      super(typeof title === "string" ? { title: getIcon(icon || 4 /* exclamation */) + title, width: 300, height: 150, keepCentered: true, center: true, resizable: false, moveable: false, maximizable: false, buttons: 1 /* Ok */, document: win ? win.document : document } : title);
      this.body.classList.add("d-flex", "justify-content-center", "align-content-center", "align-items-center");
      if (message)
        this.body.innerHTML = `<div class="text-center" style="width: 64px;height:64px;font-size: 40px;">${getIcon(icon || 4 /* exclamation */)}</div><div class="ms-3 align-self-center flex-fill">${message}</div></div>`;
    }
  };
  var ConfirmDialog = class extends Dialog {
    constructor(title, message, icon, buttons, win) {
      super(typeof title === "string" ? { title: getIcon(icon || 1 /* question */) + title, width: 300, height: 150, keepCentered: true, center: true, resizable: false, moveable: false, maximizable: false, buttons: buttons === void 0 ? 12 /* YesNo */ : buttons, document: win ? win.document : document } : title);
      this.body.classList.add("d-flex", "justify-content-center", "align-content-center", "align-items-center");
      if (message)
        this.body.innerHTML = `<div class="text-center" style="width: 64px;height:64px;font-size: 40px;">${getIcon(icon || 1 /* question */)}</div><div class="ms-3 align-self-center flex-fill">${message}</div></div>`;
    }
  };
  var ProgressDialog = class extends Dialog {
    constructor(title, message, icon, win) {
      super(typeof title === "string" ? { title: getIcon(icon || 1 /* question */) + title, width: 300, height: 150, keepCentered: true, center: true, resizable: false, moveable: false, maximizable: false, buttons: 2 /* Cancel */, closeable: false, document: win ? win.document : document } : title);
      this.body.classList.add("text-center", "justify-content-center", "align-content-center", "align-items-center");
      this.body.innerHTML = `<div class="align-self-center flex-fill" id="progress-message" style="padding:0 5px">${message || ""}</div></div><div class="progress" role="progressbar" aria-label="${title}" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" style="margin: 5px;"><div class="progress-bar" style="width: 0%"></div></div>`;
      this._progress = this.body.querySelector(".progress-bar");
    }
    set label(value) {
      this._progress.innerHTML = value;
    }
    get label() {
      return this._progress.innerHTML;
    }
    set progress(value) {
      if (value < 0) value = 0;
      if (value > 100) value = 100;
      this._progress.style.width = value + "%";
    }
    get progress() {
      return parseInt(this._progress.style.width, 10);
    }
    get message() {
      return this.body.querySelector("#progress-message").textContent;
    }
    set message(value) {
      this.body.querySelector("#progress-message").textContent = value;
    }
  };
  function getIcon(icon) {
    if (typeof icon === "string")
      return icon + " ";
    switch (icon) {
      case 3 /* error */:
        return '<i class="fa-regular fa-circle-xmark"></i> ';
      case 4 /* exclamation */:
        return '<i class="fa-solid fa-circle-exclamation"></i> ';
      case 1 /* question */:
        return '<i class="fa-regular fa-circle-question"></i> ';
    }
    return '<i class="fa-solid fa-circle-info"></i> ';
  }
  window.confirm_box = (title, message, icon, buttons, win) => {
    return new Promise((resolve, reject) => {
      const confirm = new ConfirmDialog(title, message, icon, buttons, win);
      confirm.showModal();
      confirm.on("button-click", (e) => resolve(e));
      confirm.on("canceled", () => reject(null));
      confirm.on("closed", (reason) => reason === "Yes" ? 0 : reject(null));
    });
  };
  window.alert_box = (title, message, icon, win) => {
    new AlertDialog(title, message, icon, win).showModal();
  };
  window.progress_box = (title, message, icon, win) => {
    return new ProgressDialog(title, message, icon, win);
  };
  window.Dialog = Dialog;

  // src/interface/menu.ts
  function closeMenu() {
    const instance = bootstrap.Offcanvas.getInstance(document.getElementById("clientMenu"));
    if (!instance) return;
    instance.hide();
  }
  function showMenu() {
    bootstrap.Offcanvas.getOrCreateInstance(document.getElementById("clientMenu")).show();
  }
  function initMenu() {
    document.getElementById("btn-menu").addEventListener("click", showMenu);
    client.on("connected", () => {
      let el = document.getElementById("menu-connect");
      let text = document.querySelector("#menu-connect a span");
      let icon = document.querySelector("#menu-connect svg") || document.querySelector("#menu-connect i");
      el.title = "Disconnect";
      el.classList.add("active");
      text.textContent = "Disconnect";
      icon.classList.add("fa-plug-circle-xmark");
      icon.classList.remove("fa-plug");
    });
    client.on("closed", () => {
      let el = document.getElementById("menu-connect");
      let text = document.querySelector("#menu-connect a span");
      let icon = document.querySelector("#menu-connect svg") || document.querySelector("#menu-connect i");
      el.title = "Connect";
      el.classList.remove("active");
      text.textContent = "Connect";
      icon.classList.remove("fa-plug-circle-xmark");
      icon.classList.add("fa-plug");
    });
    client.on("scroll-lock", updateScrollLock);
    document.querySelector("#menu-connect a").addEventListener("click", (e) => {
      if (client.connected)
        client.close();
      else {
        client.connect();
        closeMenu();
      }
    });
    document.querySelector("#menu-clear a").addEventListener("click", (e) => {
      client.clear();
      closeMenu();
    });
    document.querySelector("#menu-lock a").addEventListener("click", (e) => {
      client.toggleScrollLock();
      closeMenu();
    });
    document.querySelector("#menu-editor a").addEventListener("click", (e) => {
      closeMenu();
      document.getElementById("btn-adv-editor").click();
    });
    document.querySelector("#menu-about a").addEventListener("click", (e) => {
      showDialog("about");
      closeMenu();
    });
    document.querySelector("#menu-settings a").addEventListener("click", (e) => {
      showDialog("settings");
      closeMenu();
    });
    document.querySelector("#menu-profiles a").addEventListener("click", (e) => {
      showDialog("profiles");
      closeMenu();
    });
    document.querySelector("#menu-fullscreen a").addEventListener("click", (e) => {
      var doc = window.document;
      var docEl = doc.documentElement;
      var requestFullScreen = docEl.requestFullscreen || docEl.mozRequestFullScreen || docEl.webkitRequestFullScreen || docEl.msRequestFullscreen;
      var cancelFullScreen = doc.exitFullscreen || doc.mozCancelFullScreen || doc.webkitExitFullscreen || doc.msExitFullscreen;
      let el = document.getElementById("menu-fullscreen");
      let icon = document.querySelector("#menu-fullscreen svg") || document.querySelector("#menu-fullscreen i");
      let text = document.querySelector("#menu-fullscreen a span");
      if (!doc.fullscreenElement && !doc.mozFullScreenElement && !doc.webkitFullscreenElement && !doc.msFullscreenElement) {
        el.title = "Exit fullscreen";
        text.textContent = "Exit fullscreen";
        requestFullScreen.call(docEl);
        icon.classList.add("fa-minimize");
        icon.classList.remove("fa-maximize");
      } else {
        el.title = "Enter fullscreen";
        text.textContent = "Enter fullscreen";
        cancelFullScreen.call(doc);
        icon.classList.add("fa-maximize");
        icon.classList.remove("fa-minimize");
      }
      closeMenu();
    });
    document.querySelector("#menu-buttons a").addEventListener("click", (e) => {
      toggleButtons();
      let button2 = document.querySelector("#menu-buttons");
      if (client.getOption("showButtons")) {
        button2.title = "Hide buttons";
        button2.classList.add("active");
        document.querySelector("#menu-buttons a span").textContent = "Hide buttons";
      } else {
        button2.title = "Show buttons";
        button2.classList.remove("active");
        document.querySelector("#menu-buttons a span").textContent = "Show buttons";
      }
      closeMenu();
    });
    updateScrollLock();
    let pl = client.plugins.length;
    let s;
    let sl;
    const list = document.querySelector("#clientMenu ul");
    for (let p = 0; p < pl; p++) {
      if (!client.plugins[p].menu) continue;
      if (client.plugins[p].menu.length) {
        sl = client.plugins[p].menu.length;
        for (s = 0; s < sl; s++) {
          let item = client.plugins[p].menu[s];
          let code;
          let id = "menu-" + (item.id || item.name || s).trim().toLowerCase().replace(/ /g, "-");
          if (item.name === "-")
            code = `<li id="${id}"><hr class="dropdown-divider"></li>`;
          else if (typeof item.action === "string")
            code = `<li id="${id}" class="nav-item${item.active ? " active" : ""}" title="${item.name || ""}"><a class="nav-link" href="#${item.action}">${item.icon || ""}<span>${item.name || ""}</span></a></li>`;
          else
            code = `<li id="${id}" class="nav-item${item.active ? " active" : ""}" title="${item.name || ""}"><a class="nav-link" href="javascript:void(0)">${item.icon || ""}<span>${item.name || ""}</span></a></li>`;
          if (item.exists && list.querySelector(item.exists)) continue;
          if ("position" in item) {
            if (typeof item.position === "string") {
              if (list.querySelector(item.position))
                list.querySelector(item.position).insertAdjacentHTML("afterend", code);
            } else if (item.position >= 0 && item.position < list.children.length)
              list.children[item.position].insertAdjacentHTML("afterend", code);
            else if (item.position < 0) {
              let pos = list.children.length - item.position;
              if (pos >= 0 && pos < list.children.length)
                list.children[pos].insertAdjacentHTML("afterend", code);
            } else
              list.insertAdjacentHTML("beforeend", code);
          } else
            list.insertAdjacentHTML("beforeend", code);
          if (item.name === "-") continue;
          if (typeof item.action === "function")
            document.querySelector(`#${id} a`).addEventListener("click", (e) => {
              const ie = { client, preventDefault: false };
              item.action(ie);
              if (ie.preventDefault) return;
              closeMenu();
            });
        }
      }
    }
    let button = document.querySelector("#menu-buttons");
    if (client.getOption("showButtons")) {
      button.title = "Hide buttons";
      button.classList.add("active");
      document.querySelector("#menu-buttons a span").textContent = "Hide buttons";
    } else {
      button.title = "Show buttons";
      button.classList.remove("active");
      document.querySelector("#menu-buttons a span").textContent = "Show buttons";
    }
  }
  function updateScrollLock() {
    let el = document.getElementById("menu-lock");
    let text = document.querySelector("#menu-lock a span");
    let icon = document.querySelector("#menu-lock svg") || document.querySelector("#menu-lock i");
    if (client.scrollLock) {
      el.title = "Unlock display";
      el.classList.add("active");
      text.textContent = "Unlock display";
      icon.classList.add("fa-unlock");
      icon.classList.remove("fa-lock");
    } else {
      el.title = "Lock display";
      el.classList.remove("active");
      text.textContent = "Lock display";
      icon.classList.remove("fa-unlock");
      icon.classList.add("fa-lock");
    }
  }

  // src/interface/adv.editor.ts
  var AdvEditor = class extends EventEmitter {
    constructor(element, enabledAdvanced) {
      super();
      this._simple = true;
      this._init = false;
      //private _colorCodes;
      this._colorNames = {
        "No color": "Default",
        "BLACK": "Black",
        "RED": "Maroon",
        "GREEN": "Green",
        "ORANGE": "Olive",
        "BLUE": "Navy",
        "MAGENTA": "Purple",
        "WHITE": "Silver",
        "CYAN": "Teal",
        "BOLD BLACK": "Grey",
        "BOLD RED": "Red",
        "BOLD GREEN": "Lime",
        "YELLOW": "Yellow",
        "BOLD YELLOW": "Yellow",
        "BOLD BLUE": "Blue",
        "BOLD MAGENTA": "Fuchsia",
        "BOLD CYAN": "Aqua",
        "BOLD": "White",
        "BOLD WHITE": "White",
        "RGB000": "Black",
        "RGB001": "Navy Blue",
        "RGB002": "Dark Blue",
        "RGB003": "Blue",
        "RGB004": "Blue",
        "RGB005": "Blue",
        "RGB010": "Dark Green",
        "RGB011": "Deep Sky Blue",
        "RGB012": "Deep Sky Blue",
        "RGB013": "Deep Sky Blue",
        "RGB014": "Cobalt/Dodger Blue",
        "RGB015": "Dodger Blue",
        "RGB020": "Green",
        "RGB021": "Spring Green",
        "RGB022": "Turquoise",
        "RGB023": "Deep Sky Blue",
        "RGB024": "Deep Sky Blue",
        "RGB025": "Dodger Blue",
        "RGB030": "Green",
        "RGB031": "Spring Green",
        "RGB032": "Dark Cyan",
        "RGB033": "Light Sea Green",
        "RGB034": "Deep Sky Blue",
        "RGB035": "Deep Sky Blue",
        "RGB040": "Green",
        "RGB041": "Spring Green",
        "RGB042": "Spring Green",
        "RGB043": "Cyan",
        "RGB044": "Dark Turquoise",
        "RGB045": "Turquoise",
        "RGB050": "Green",
        "RGB051": "Spring Green",
        "RGB052": "Spring Green",
        "RGB053": "Medium Spring Green",
        "RGB054": "Cyan",
        "RGB055": "Cyan",
        "RGB100": "Dark Red",
        "RGB101": "Deep Pink",
        "RGB102": "Purple",
        "RGB103": "Purple",
        "RGB104": "Purple",
        "RGB105": "Blue Violet",
        "RGB110": "Orange",
        "RGB111": "Dark Grey",
        "RGB112": "Medium Purple",
        "RGB113": "Slate Blue",
        "RGB114": "Slate Blue",
        "RGB115": "Royal Blue",
        "RGB120": "Chartreuse",
        "RGB121": "Dark Sea Green",
        "RGB122": "Pale Turquoise",
        "RGB123": "Steel Blue",
        "RGB124": "Steel Blue",
        "RGB125": "Cornflower Blue",
        "RGB130": "Chartreuse",
        "RGB131": "Dark Sea Green",
        "RGB132": "Cadet Blue",
        "RGB133": "Cadet Blue",
        "RGB134": "Sky Blue",
        "RGB135": "Steel Blue",
        "RGB140": "Chartreuse",
        "RGB141": "Pale Green",
        "RGB142": "Sea Green",
        "RGB143": "Aquamarine",
        "RGB144": "Medium Turquoise",
        "RGB145": "Steel Blue",
        "RGB150": "Chartreuse",
        "RGB151": "Sea Green",
        "RGB152": "Sea Green",
        "RGB153": "Sea Green",
        "RGB154": "Aquamarine",
        "RGB155": "Dark Slate Gray",
        "RGB200": "Dark Red",
        "RGB201": "Deep Pink",
        "RGB202": "Dark Magenta",
        "RGB203": "Dark Magenta",
        "RGB204": "Dark Violet",
        "RGB205": "Purple",
        "RGB210": "Orange",
        "RGB211": "Light Pink",
        "RGB212": "Plum",
        "RGB213": "Medium Purple",
        "RGB214": "Medium Purple",
        "RGB215": "Slate Blue",
        "RGB220": "Yellow",
        "RGB221": "Wheat",
        "RGB222": "Grey",
        "RGB223": "Light Slate Grey",
        "RGB224": "Medium Purple",
        "RGB225": "Light Slate Blue",
        "RGB230": "Yellow",
        "RGB231": "Dark Olive Green",
        "RGB232": "Dark Sea Green",
        "RGB233": "Light Sky Blue",
        "RGB234": "Light Sky Blue",
        "RGB235": "Sky Blue",
        "RGB240": "Chartreuse",
        "RGB241": "Dark Olive Green",
        "RGB242": "Pale Green",
        "RGB243": "Dark Sea Green",
        "RGB244": "Dark Slate Gray",
        "RGB245": "Sky Blue",
        "RGB250": "Chartreuse",
        "RGB251": "Light Green",
        "RGB252": "Light Green",
        "RGB253": "Pale Green",
        "RGB254": "Aquamarine",
        "RGB255": "Dark Slate Gray",
        "RGB300": "Red",
        "RGB301": "Deep Pink",
        "RGB302": "Medium Violet Red",
        "RGB303": "Magenta",
        "RGB304": "Dark Violet",
        "RGB305": "Purple",
        "RGB310": "Dark Orange",
        "RGB311": "Indian Red",
        "RGB312": "Hot Pink",
        "RGB313": "Medium Orchid",
        "RGB314": "Medium Orchid",
        "RGB315": "Medium Purple",
        "RGB320": "Dark Goldenrod",
        "RGB321": "Light Salmon",
        "RGB322": "Rosy Brown",
        "RGB323": "Grey",
        "RGB324": "Medium Purple",
        "RGB325": "Medium Purple",
        "RGB330": "Gold",
        "RGB331": "Dark Khaki",
        "RGB332": "Navajo White",
        "RGB333": "Grey",
        "RGB334": "Light Steel Blue",
        "RGB335": "Light Steel Blue",
        "RGB340": "Yellow",
        "RGB341": "Dark Olive Green",
        "RGB342": "Dark Sea Green",
        "RGB343": "Dark Sea Green",
        "RGB344": "Light Cyan",
        "RGB345": "Light Sky Blue",
        "RGB350": "Green Yellow",
        "RGB351": "Dark Olive Green",
        "RGB352": "Pale Green",
        "RGB353": "Dark Sea Green",
        "RGB354": "Dark Sea Green",
        "RGB355": "Pale Turquoise",
        "RGB400": "Crimson/Red",
        "RGB401": "Deep Pink",
        "RGB402": "Deep Pink",
        "RGB403": "Magenta",
        "RGB404": "Magenta",
        "RGB405": "Magenta",
        "RGB410": "Dark Orange",
        "RGB411": "Indian Red",
        "RGB412": "Hot Pink",
        "RGB413": "Hot Pink",
        "RGB414": "Orchid",
        "RGB415": "Medium Orchid",
        "RGB420": "Orange",
        "RGB421": "Light Salmon/Bronze",
        "RGB422": "Light Pink",
        "RGB423": "Pink",
        "RGB424": "Plum",
        "RGB425": "Violet",
        "RGB430": "Gold",
        "RGB431": "Light Goldenrod",
        "RGB432": "Tan",
        "RGB433": "Misty Rose",
        "RGB434": "Thistle",
        "RGB435": "Plum",
        "RGB440": "Yellow",
        "RGB441": "Khaki",
        "RGB442": "Light Goldenrod",
        "RGB443": "Light Yellow",
        "RGB444": "Grey",
        "RGB445": "Light Steel Blue",
        "RGB450": "Yellow",
        "RGB451": "Dark Olive Green",
        "RGB452": "Dark Olive Green",
        "RGB453": "Dark Sea Green",
        "RGB454": "Honeydew",
        "RGB455": "Light Cyan",
        "RGB500": "Red",
        "RGB501": "Deep Pink",
        "RGB502": "Deep Pink",
        "RGB503": "Deep Pink",
        "RGB504": "Magenta",
        "RGB505": "Magenta",
        "RGB510": "Orangered",
        "RGB511": "Indian Red",
        "RGB512": "Indian Red",
        "RGB513": "Hot Pink",
        "RGB514": "Hot Pink",
        "RGB515": "Medium Orchid",
        "RGB520": "Dark Orange",
        "RGB521": "Salmon",
        "RGB522": "Light Coral",
        "RGB523": "Pale Violet Red",
        "RGB524": "Orchid",
        "RGB525": "Orchid",
        "RGB530": "Orange",
        "RGB531": "Sandy Brown",
        "RGB532": "Light Salmon",
        "RGB533": "Light Pink",
        "RGB534": "Pink",
        "RGB535": "Plum",
        "RGB540": "Gold",
        "RGB541": "Light Goldenrod",
        "RGB542": "Light Goldenrod",
        "RGB543": "Navajo White",
        "RGB544": "Misty Rose",
        "RGB545": "Thistle",
        "RGB550": "Yellow",
        "RGB551": "Light Goldenrod",
        "RGB552": "Khaki",
        "RGB553": "Wheat",
        "RGB554": "Corn Silk",
        "RGB555": "White",
        "mono00": "Grey 3",
        "mono01": "Grey 7",
        "mono02": "Grey 11",
        "mono03": "Grey 15",
        "mono04": "Grey 19",
        "mono05": "Grey 23",
        "mono06": "Grey 27",
        "mono07": "Grey 30",
        "mono08": "Grey 35",
        "mono09": "Grey 39",
        "mono10": "Grey 32",
        "mono11": "Grey 46",
        "mono12": "Grey 50",
        "mono13": "Grey 54",
        "mono14": "Grey 58",
        "mono15": "Grey 62",
        "mono16": "Grey 66",
        "mono17": "Grey 70",
        "mono18": "Grey 74",
        "mono19": "Grey 78",
        "mono20": "Grey 82",
        "mono21": "Grey 85",
        "mono22": "Grey 89",
        "mono23": "Grey 93"
      };
      //{ color: 'red', hex: '#EA4235', rgb: { r: 234, g: 66, b: 53 } },
      this._colorList = [];
      if (!element)
        throw new Error("AdvEditor must be a selector, element or jquery object");
      if (typeof element === "string") {
        this._element = document.querySelector(element);
        if (!this._element)
          throw new Error("Invalid selector for AdvEditor.");
      } else if (element instanceof $)
        this._element = element[0];
      else if (element instanceof HTMLElement)
        this._element = element;
      else
        throw new Error("AdvEditor must be a selector, element or jquery object");
      this.simple = !enabledAdvanced;
    }
    get id() {
      if (this._element) return this._element.id;
      return "";
    }
    get element() {
      return this._element;
    }
    get simple() {
      return this._simple;
    }
    set simple(value) {
      if (value === this._simple) return;
      this._simple = value;
      if (!this.tinymceExist) return;
      if (value)
        this.remove();
      else
        this.initialize();
    }
    clear() {
      if (!this.isSimple)
        tinymce.activeEditor.setContent("");
      else
        this._element.value = "";
    }
    get value() {
      if (!this.isSimple)
        return this.getFormattedText().replace(/(?:\r)/g, "");
      return this._element.value;
    }
    set value(value) {
      if (this.isSimple)
        this._element.value = value;
      else
        tinymce.activeEditor.setContent(value);
    }
    insert(value) {
      if (!this.isSimple) {
        value = htmlEncode(value);
        value = value.replace(/ /g, "&nbsp;");
        value = value.replace(/\t/g, "&nbsp;&nbsp;&nbsp;");
        value = value.replace(/(?:\r\n|\r|\n)/g, "<br/>");
        var content = this.getText();
        if (content === "\n") {
          tinymce.activeEditor.undoManager.transact(() => {
            tinymce.activeEditor.setContent(value);
          });
        } else {
          if (!content.endsWith("\n"))
            value = "<br>" + value;
          tinymce.activeEditor.undoManager.transact(() => {
            tinymce.activeEditor.dom.add(tinymce.activeEditor.getBody(), "span", {}, value);
          });
        }
      } else
        insertValue(this._element, value);
      {
      }
    }
    get tinymceExist() {
      return typeof tinymce !== "undefined";
    }
    get isSimple() {
      return this._simple || !this.tinymceExist;
    }
    _loadColors() {
      var _dColors = getColors();
      var c, color, r, g, b, idx, _bold = [], bl;
      this._ColorTable = [];
      this._colors = {};
      var clientColors = client.getOption("colors") || [];
      color = new RGBColor(clientColors[0] || _dColors[0]).toHex().substr(1).toUpperCase();
      this._colors[color] = "BLACK";
      this._ColorTable.push(color, "BLACK");
      color = new RGBColor(clientColors[1] || _dColors[1]).toHex().substr(1).toUpperCase();
      this._colors[color] = "RED";
      this._ColorTable.push(color, "RED");
      color = new RGBColor(clientColors[2] || _dColors[2]).toHex().substr(1).toUpperCase();
      this._colors[color] = "GREEN";
      this._ColorTable.push(color, "GREEN");
      color = new RGBColor(clientColors[3] || _dColors[3]).toHex().substr(1).toUpperCase();
      this._colors[color] = "ORANGE";
      this._ColorTable.push(color, "ORANGE");
      color = new RGBColor(clientColors[4] || _dColors[4]).toHex().substr(1).toUpperCase();
      this._colors[color] = "BLUE";
      this._ColorTable.push(color, "BLUE");
      color = new RGBColor(clientColors[5] || _dColors[5]).toHex().substr(1).toUpperCase();
      this._colors[color] = "MAGENTA";
      this._ColorTable.push(color, "MAGENTA");
      color = new RGBColor(clientColors[6] || _dColors[6]).toHex().substr(1).toUpperCase();
      this._colors[color] = "CYAN";
      this._ColorTable.push(color, "CYAN");
      color = new RGBColor(clientColors[7] || _dColors[7]).toHex().substr(1).toUpperCase();
      this._colors[color] = "WHITE";
      this._ColorTable.push(color, "WHITE");
      color = new RGBColor(clientColors[8] || _dColors[8]).toHex().substr(1).toUpperCase();
      this._colors[color] = "mono11";
      this._ColorTable.push(color, "BOLD BLACK");
      _bold.push(color);
      color = new RGBColor(clientColors[9] || _dColors[9]).toHex().substr(1).toUpperCase();
      this._colors[color] = "BOLD%^%^RED";
      this._ColorTable.push(color, "BOLD RED");
      _bold.push(color);
      color = new RGBColor(clientColors[10] || _dColors[10]).toHex().substr(1).toUpperCase();
      this._colors[color] = "BOLD%^%^GREEN";
      this._ColorTable.push(color, "BOLD GREEN");
      _bold.push(color);
      color = new RGBColor(clientColors[11] || _dColors[11]).toHex().substr(1).toUpperCase();
      this._colors[color] = "BOLD%^%^YELLOW";
      this._ColorTable.push(color, "BOLD YELLOW");
      _bold.push(color);
      color = new RGBColor(clientColors[11] || _dColors[11]).toHex().substr(1).toUpperCase();
      this._colors[color] = "YELLOW";
      this._ColorTable.push(color, "YELLOW");
      _bold.push(color);
      color = new RGBColor(clientColors[12] || _dColors[12]).toHex().substr(1).toUpperCase();
      this._colors[color] = "BOLD%^%^BLUE";
      this._ColorTable.push(color, "BOLD BLUE");
      _bold.push(color);
      color = new RGBColor(clientColors[13] || _dColors[13]).toHex().substr(1).toUpperCase();
      this._colors[color] = "BOLD%^%^MAGENTA";
      this._ColorTable.push(color, "BOLD MAGENTA");
      _bold.push(color);
      color = new RGBColor(clientColors[14] || _dColors[14]).toHex().substr(1).toUpperCase();
      this._colors[color] = "BOLD%^%^CYAN";
      this._ColorTable.push(color, "BOLD CYAN");
      _bold.push(color);
      color = new RGBColor(clientColors[15] || _dColors[15]).toHex().substr(1).toUpperCase();
      this._colors[color] = "BOLD%^%^WHITE";
      this._ColorTable.push(color, "BOLD WHITE");
      for (r = 0; r < 6; r++) {
        for (g = 0; g < 6; g++) {
          for (b = 0; b < 6; b++) {
            idx = `RGB${r}${g}${b}`;
            color = "";
            c = 0;
            c = r * 40 + 55;
            if (c < 16)
              color += "0";
            color += c.toString(16);
            c = 0;
            c = g * 40 + 55;
            if (c < 16)
              color += "0";
            color += c.toString(16);
            c = 0;
            c = b * 40 + 55;
            if (c < 16)
              color += "0";
            color += c.toString(16);
            color = color.toUpperCase();
            if (!this._colors[color])
              this._colors[color] = idx;
            this._colorList.push({ color: idx, hex: "#" + color, rgb: { r: r * 40 + 55, g: g * 40 + 55, b: b * 40 + 55 } });
          }
        }
      }
      for (r = 232; r <= 255; r++) {
        g = (r - 232) * 10 + 8;
        if (g < 16)
          g = "0" + g.toString(16).toUpperCase();
        else
          g = g.toString(16).toUpperCase();
        g = g + g + g;
        if (r < 242) {
          if (!this._colors[g])
            this._colors[g] = "mono0" + (r - 232);
        } else {
          if (!this._colors[g])
            this._colors[g] = "mono" + (r - 232);
        }
      }
      for (b = 0, bl = _bold.length; b < bl; b++) {
        this._colors["B" + _bold[b]] = this._colors[this._nearestHex("#" + _bold[b]).substr(1)].toUpperCase();
      }
      this._colors["BFFFFFF"] = "RGB555";
      tinymce.activeEditor.options.set("color_map", this._ColorTable);
    }
    _initPlugins() {
      if (false) return;
      const _editor = this;
      tinymce.PluginManager.add("pinkfishtextcolor", function(editor2, url) {
        const fallbackColor = "#000000";
        const _colors = ["000000", "BLACK", "800000", "RED", "008000", "GREEN", "808000", "ORANGE", "0000EE", "BLUE", "800080", "MAGENTA", "008080", "CYAN", "BBBBBB", "WHITE", "808080", "BOLD BLACK", "FF0000", "BOLD RED", "00FF00", "BOLD GREEN", "FFFF00", "YELLOW", "5C5CFF", "BOLD BLUE", "FF00FF", "BOLD MAGENTA", "00FFFF", "BOLD CYAN", "FFFFFF", "BOLD WHITE"];
        let _lastButton;
        const Cell = (initial) => {
          let value = initial;
          const get = () => {
            return value;
          };
          const set = (v) => {
            value = v;
          };
          return {
            get,
            set
          };
        };
        let _forecolor = Cell(fallbackColor);
        let _backcolor = Cell(fallbackColor);
        const getCurrentColor = (editor3, format) => {
          let color;
          editor3.dom.getParents(editor3.selection.getStart(), (elm) => {
            let value;
            if (value = elm.style[format === "forecolor" ? "color" : "background-color"]) {
              color = color ? color : value;
            }
          });
          return color;
        };
        const applyFormat = (editor3, format, value) => {
          editor3.undoManager.transact(() => {
            editor3.focus();
            editor3.formatter.apply(format, { value });
            editor3.nodeChanged();
          });
        };
        const removeFormat = (editor3, format) => {
          editor3.undoManager.transact(() => {
            editor3.focus();
            editor3.formatter.remove(format, { value: null }, null, true);
            editor3.nodeChanged();
          });
        };
        const registerCommands = (editor3) => {
          editor3.addCommand("mceApplyPinkfishcolor", (format, value) => {
            applyFormat(editor3, format, value);
          });
          editor3.addCommand("mceRemovePinkfishcolor", (format) => {
            removeFormat(editor3, format);
          });
          editor3.addCommand("mceSetPinkfishcolor", (name2, color) => {
            if (_lastButton) {
              setIconColor(_lastButton, name2 === "forecolor" ? "pinkfishforecolor" : name2, color);
              (name2 === "forecolor" ? _forecolor : _backcolor).set(color);
            }
          });
        };
        const getAdditionalColors = (hasCustom) => {
          const type = "choiceitem";
          const remove = {
            type,
            text: "Remove color",
            icon: "color-swatch-remove-color",
            value: "remove"
          };
          const custom = {
            type,
            text: "Custom color",
            icon: "color-picker",
            value: "custom"
          };
          return hasCustom ? [
            remove,
            custom
          ] : [remove];
        };
        const applyColor = (editor3, format, value, onChoice) => {
          if (value === "custom") {
            _editor._openColorDialog(format, "");
          } else if (value === "remove") {
            onChoice("");
            editor3.execCommand("mceRemovePinkfishcolor", format);
          } else {
            onChoice(value);
            editor3.execCommand("mceApplyPinkfishcolor", format, value);
          }
        };
        const mapColors = (colorMap) => {
          const colors = [];
          for (let i2 = 0; i2 < colorMap.length; i2 += 2) {
            colors.push({
              text: colorMap[i2 + 1],
              value: "#" + colorMap[i2],
              type: "choiceitem"
            });
          }
          return colors;
        };
        const getColors2 = (colors, hasCustom) => mapColors(_colors).concat(getAdditionalColors(hasCustom));
        const getFetch = (colors, hasCustom) => (callback) => {
          callback(getColors2(colors, hasCustom));
        };
        const setIconColor = (splitButtonApi, name2, newColor) => {
          const id = name2 === "pinkfishforecolor" ? "tox-icon-text-color__color" : "tox-icon-highlight-bg-color__color";
          splitButtonApi.setIconFill(id, newColor);
        };
        const registerTextColorButton = (editor3, name2, format, tooltip, lastColor) => {
          editor3.ui.registry.addSplitButton(name2, {
            tooltip,
            presets: "color",
            icon: name2 === "pinkfishforecolor" ? "text-color" : "highlight-bg-color",
            select: (value) => {
              const optCurrentRgb = new RGBColor(getCurrentColor(editor3, format) || "").toHex();
              return optCurrentRgb.toLowerCase() === value.toLowerCase();
            },
            columns: 5,
            fetch: getFetch(_colors, true),
            onAction: (_splitButtonApi) => {
              _lastButton = _splitButtonApi;
              applyColor(editor3, format, lastColor.get(), () => {
              });
            },
            onItemAction: (_splitButtonApi, value) => {
              _lastButton = _splitButtonApi;
              applyColor(editor3, format, value, (newColor) => {
                lastColor.set(newColor);
                editor3.fire("TextColorChange", {
                  name: name2,
                  color: newColor
                });
              });
            },
            onSetup: (splitButtonApi) => {
              setIconColor(splitButtonApi, name2, lastColor.get());
              const handler = (e) => {
                if (e.name === name2) {
                  setIconColor(splitButtonApi, e.name, e.color);
                }
              };
              editor3.on("TextColorChange", handler);
              return () => {
                editor3.off("TextColorChange", handler);
              };
            }
          });
        };
        const registerTextColorMenuItem = (editor3, name2, format, text) => {
          editor3.ui.registry.addNestedMenuItem(name2, {
            text,
            icon: name2 === "pinkfishforecolor" ? "text-color" : "highlight-bg-color",
            getSubmenuItems: () => [
              {
                type: "fancymenuitem",
                fancytype: "colorswatch",
                onAction: (data) => {
                  applyColor(editor3, format, data.value, () => {
                  });
                }
              }
            ]
          });
        };
        registerCommands(editor2);
        registerTextColorButton(editor2, "pinkfishforecolor", "forecolor", "Text color", _forecolor);
        registerTextColorButton(editor2, "pinkfishbackcolor", "hilitecolor", "Background color", _backcolor);
        registerTextColorMenuItem(editor2, "pinkfishforecolor", "forecolor", "Text color");
        registerTextColorMenuItem(editor2, "pinkfishbackcolor", "hilitecolor", "Background color");
      });
      tinymce.PluginManager.add("pinkfish", function(editor2) {
        editor2.addCommand("mceApplyFormat", (format, value) => {
          editor2.undoManager.transact(() => {
            editor2.focus();
            _editor._clearReverse($(".reverse", $(editor2.getDoc()).contents()));
            if (value)
              editor2.formatter.apply(format, { value });
            else
              editor2.formatter.apply(format);
            _editor._addReverse($(".reverse", $(editor2.getDoc()).contents()));
            editor2.nodeChanged();
          });
        });
        editor2.addCommand("mceRemoveFormat", (format) => {
          editor2.undoManager.transact(() => {
            editor2.focus();
            _editor._clearReverse($(".reverse", $(editor2.getDoc()).contents()));
            editor2.formatter.remove(format, { value: null }, null, true);
            _editor._addReverse($(".reverse", $(editor2.getDoc()).contents()));
            editor2.nodeChanged();
          });
        });
        function buttonPostRender(buttonApi, format) {
          editor2.on("init", () => {
            editor2.formatter.formatChanged(format, function(state) {
              buttonApi.setActive(state);
            });
          });
        }
        function toggleFormat(format) {
          if (!format || typeof format !== "string") format = this.settings.format;
          tinymce.activeEditor.undoManager.transact(() => {
            $("#tinymce", tinymce.activeEditor.getDoc()).removeClass("animate");
            this.clearReverse($(".reverse", $(editor2.getDoc()).contents()));
            editor2.execCommand("mceToggleFormat", false, format);
            this.addReverse($(".reverse", $(editor2.getDoc()).contents()));
            $("#tinymce", tinymce.activeEditor.getDoc()).addClass("animate");
          });
        }
        editor2.ui.registry.addIcon("overline", '<i class="mce-i-overline"></i>');
        editor2.ui.registry.addIcon("dblunderline", '<i class="mce-i-dblunderline"></i>');
        editor2.ui.registry.addIcon("flash", '<i class="mce-i-flash"></i>');
        editor2.ui.registry.addIcon("reverse", '<i class="mce-i-reverse"></i>');
        editor2.ui.registry.addIcon("pasteformatted", '<i class="mce-i-pasteformatted"></i>');
        editor2.ui.registry.addIcon("copyformatted", '<i class="mce-i-copyformatted"></i>');
        editor2.ui.registry.addSplitButton("send", {
          icon: "send",
          tooltip: "Send to mud",
          onAction: () => {
            client.sendCommand(_editor.getFormattedText().replace(/(?:\r)/g, ""));
            if (client.getOption("editorClearOnSend"))
              tinymce.activeEditor.setContent("");
            if (client.getOption("editorCloseOnSend"))
              _editor.emit("close");
          },
          onItemAction: (api, value) => {
            switch (value) {
              case "formatted":
                client.sendCommand(_editor.getFormattedText().replace(/(?:\r)/g, ""));
                if (client.getOption("editorClearOnSend"))
                  tinymce.activeEditor.setContent("");
                if (client.getOption("editorCloseOnSend"))
                  _editor.emit("close");
                break;
              case "text":
                client.sendCommand(_editor.getText().replace(/(?:\r)/g, ""));
                if (client.getOption("editorClearOnSend"))
                  tinymce.activeEditor.setContent("");
                if (client.getOption("editorCloseOnSend"))
                  _editor.emit("close");
                break;
              case "formattednoecho":
                client.sendBackground(_editor.getFormattedText().replace(/(?:\r)/g, ""), true);
                if (client.getOption("editorClearOnSend"))
                  tinymce.activeEditor.setContent("");
                if (client.getOption("editorCloseOnSend"))
                  _editor.emit("close");
                break;
              case "textnoecho":
                client.sendBackground(_editor.getText().replace(/(?:\r)/g, ""), true);
                if (client.getOption("editorClearOnSend"))
                  tinymce.activeEditor.setContent("");
                if (client.getOption("editorCloseOnSend"))
                  _editor.emit("close");
                break;
              case "formattedverbatim":
                client.send(_editor.getFormattedText().replace(/(?:\r)/g, ""));
                if (client.getOption("editorClearOnSend"))
                  tinymce.activeEditor.setContent("");
                if (client.getOption("editorCloseOnSend"))
                  _editor.emit("close");
                break;
              case "textverbatim":
                client.send(_editor.getText().replace(/(?:\r)/g, ""));
                if (client.getOption("editorClearOnSend"))
                  tinymce.activeEditor.setContent("");
                if (client.getOption("editorCloseOnSend"))
                  _editor.emit("close");
                break;
              case "rawformatted":
                client.sendRaw(_editor.getFormattedText().replace(/(?:\r)/g, ""));
                if (client.getOption("editorClearOnSend"))
                  tinymce.activeEditor.setContent("");
                if (client.getOption("editorCloseOnSend"))
                  _editor.emit("close");
                break;
              case "rawtext":
                client.sendRaw(_editor.getText().replace(/(?:\r)/g, ""));
                if (client.getOption("editorClearOnSend"))
                  tinymce.activeEditor.setContent("");
                if (client.getOption("editorCloseOnSend"))
                  _editor.emit("close");
                break;
            }
          },
          fetch: (callback) => {
            callback([
              {
                text: "Formatted as commands",
                value: "formatted",
                type: "choiceitem"
              },
              {
                text: "Text as commands",
                value: "text",
                type: "choiceitem"
              },
              {
                text: "Formatted as commands (No echo)",
                value: "formattednoecho",
                type: "choiceitem"
              },
              {
                text: "Text as commands (No echo)",
                value: "textnoecho",
                type: "choiceitem"
              },
              {
                text: "Formatted verbatim (No echo)",
                value: "formattedverbatim",
                type: "choiceitem"
              },
              {
                text: "Text verbatim (No echo)",
                value: "textverbatim",
                type: "choiceitem"
              },
              {
                text: "Raw formatted (No echo)",
                value: "rawformatted",
                type: "choiceitem"
              },
              {
                text: "Raw text (No echo)",
                value: "rawtext",
                type: "choiceitem"
              }
            ]);
          }
        });
        editor2.ui.registry.addButton("append", {
          icon: "browse",
          tooltip: "Append file...",
          onAction: () => _editor._appendFile()
        });
        editor2.ui.registry.addButton("clear", {
          icon: "remove",
          tooltip: "Clear",
          onAction: () => _editor.clear()
        });
        editor2.ui.registry.addButton("pasteformatted", {
          icon: "pasteformatted",
          tooltip: "Paste formatted",
          onAction: (buttonApi) => {
            pasteText().then((text) => {
              _editor._insertFormatted(text || "");
            }).catch((err) => {
              if (client.enableDebug)
                client.debug(err);
              if (err.message && err.message === "Permission not granted!")
                alert("Paste permission not granted.");
              else
                alert("Paste not supported.");
            });
          }
        });
        editor2.ui.registry.addButton("pasteastext", {
          icon: "paste-text",
          tooltip: "Paste as text",
          onAction: (buttonApi) => {
            pasteText().then((text) => {
              tinymce.activeEditor.execCommand("mceInsertContent", false, (text || "").replace(/(\r\n|\r|\n)/g, "<br/>").replaceAll("  ", "&nbsp;&nbsp;"));
            }).catch((err) => {
              if (client.enableDebug)
                client.debug(err);
              if (err.message && err.message === "Permission not granted!")
                alert("Paste permission not granted.");
              else
                alert("Paste not supported.");
            });
          }
        });
        editor2.ui.registry.addButton("copyformatted", {
          icon: "copyformatted",
          tooltip: "Copy formatted",
          onAction: (buttonApi) => copyText(_editor.getFormattedSelection().replace(/(?:\r)/g, ""))
        });
        editor2.ui.registry.addToggleButton("overline", {
          icon: "overline",
          tooltip: "Overline",
          format: "overline",
          onAction: (buttonApi) => toggleFormat("overline"),
          onSetup: (buttonApi) => buttonPostRender(buttonApi, "overline")
        });
        editor2.ui.registry.addToggleButton("dblunderline", {
          icon: "dblunderline",
          tooltip: "Double Underline",
          format: "dblunderline",
          onAction: (buttonApi) => toggleFormat("dblunderline"),
          onSetup: (buttonApi) => buttonPostRender(buttonApi, "dblunderline")
        });
        editor2.ui.registry.addToggleButton("flash", {
          tooltip: "Flash",
          format: "flash",
          icon: "flash",
          onAction: (buttonApi) => toggleFormat("flash"),
          onSetup: (buttonApi) => buttonPostRender(buttonApi, "flash")
        });
        editor2.ui.registry.addToggleButton("reverse", {
          icon: "reverse",
          tooltip: "Reverse",
          format: "reverse",
          onAction: (buttonApi) => toggleFormat("reverse"),
          onSetup: (buttonApi) => buttonPostRender(buttonApi, "reverse")
        });
        editor2.ui.registry.addMenuItem("style", {
          text: "Style",
          menu: [
            {
              image: "overline",
              text: "Overline",
              format: "overline",
              onclick: toggleFormat,
              onpostrender: buttonPostRender
            },
            {
              image: "dblunderline",
              text: "Double Underline",
              format: "dblunderline",
              onclick: toggleFormat,
              onpostrender: buttonPostRender
            },
            {
              text: "Flash",
              format: "flash",
              image: "flash",
              onclick: toggleFormat,
              onpostrender: buttonPostRender
            },
            {
              image: "reverse",
              text: "Reverse",
              format: "reverse",
              onclick: toggleFormat,
              onpostrender: buttonPostRender
            }
          ]
        });
        editor2.ui.registry.addMenuItem("overline", {
          image: "overline",
          text: "Overline",
          format: "overline",
          onclick: toggleFormat,
          onpostrender: buttonPostRender
        });
        editor2.ui.registry.addMenuItem("dblunderline", {
          image: "dblunderline",
          text: "Double Underline",
          format: "dblunderline",
          onclick: toggleFormat,
          onpostrender: buttonPostRender
        });
        editor2.ui.registry.addMenuItem("flash", {
          text: "Flash",
          format: "flash",
          image: "flash",
          onclick: toggleFormat,
          onpostrender: buttonPostRender
        });
        editor2.ui.registry.addMenuItem("reverse", {
          image: "reverse",
          text: "Reverse",
          format: "reverse",
          onclick: toggleFormat,
          onpostrender: buttonPostRender
        });
        editor2.on("Change", () => {
          _editor._addReverse($(".reverse", $(editor2.getDoc()).contents()));
        });
        editor2.addShortcut("ctrl+s", "Strikethrough", () => {
          toggleFormat("strikethrough");
        });
        editor2.addShortcut("ctrl+o", "Overline", () => {
          toggleFormat("overline");
        });
        editor2.addShortcut("ctrl+d", "Double Underline", () => {
          toggleFormat("dblunderline");
        });
        editor2.addShortcut("ctrl+f", "Flash", () => {
          toggleFormat("flash");
        });
        editor2.addShortcut("ctrl+r", "Reverse", () => {
          toggleFormat("reverse");
        });
      });
    }
    _clearReverse(els, c) {
      els.each(
        function() {
          if (!$(this).data("reverse"))
            return;
          if (c && $(this).hasClass("reverse"))
            return;
          var back, fore;
          if (c) {
            back = $(this).css("color");
            fore = $(this).css("background-color");
          } else {
            fore = $(this).parent().css("color");
            back = $(this).parent().css("background-color");
          }
          if (back === "black")
            back = "";
          if (fore === "rgba(0, 0, 0, 0)")
            fore = "black";
          $(this).css("color", fore);
          $(this).css("background-color", back);
          if ($(this).children().length)
            this.clearReverse($(this).children(), true);
        }
      );
    }
    _addReverse(els, c) {
      els.each(
        function() {
          if (c && $(this).hasClass("reverse"))
            return;
          var back, fore;
          if (c) {
            back = $(this).css("color");
            fore = $(this).css("background-color");
          } else {
            back = $(this).parent().css("color");
            fore = $(this).parent().css("background-color");
          }
          if (back === "rgba(0, 0, 0, 0)")
            back = "black";
          if (fore === "rgba(0, 0, 0, 0)")
            fore = "black";
          if ($(this).children().length) {
            this.clearReverse($(this).children(), true);
            this.addReverse($(this).children(), true);
          }
          $(this).css("color", fore);
          $(this).css("background-color", back);
          $(this).data("reverse", true);
        }
      );
    }
    _colorCell(color, idx) {
      var cell = '<td class="mce-grid-cell' + (color === "transparent" ? " mce-colorbtn-trans" : "") + '">';
      cell += '<div id="' + idx + '"';
      cell += ' data-mce-color="' + color + '"';
      cell += ' role="option"';
      cell += ' tabIndex="-1"';
      cell += ' style="background-color: ' + (color === "transparent" ? color : "#" + color) + '"';
      if (this._colorNames[idx])
        cell += ' title="' + idx + ", " + this._colorNames[idx] + '">';
      else
        cell += ' title="' + idx + '">';
      if (color === "transparent") cell += "&#215;";
      cell += "</div>";
      cell += "</td>";
      return cell;
    }
    _openColorDialog(type, color) {
      if (!this._colorDialog) {
        this._colorDialog = new Dialog({ noFooter: true, title: '<i class="fas fa-palette"></i> Pick color', center: true, resizable: false, moveable: false, maximizable: false, width: 380, height: 340 });
        this._colorDialog.body.style.alignItems = "center";
        this._colorDialog.body.style.display = "flex";
        let c;
        let cl;
        let r;
        let g;
        let b;
        let idx;
        var html = '<table style="margin : auto !important;" class="mce-grid mce-grid-border mce-colorbutton-grid" role="list" cellspacing="0"><tbody><tr>';
        for (c = 0, cl = this._ColorTable.length; c < cl; c += 2) {
          html += this._colorCell(this._ColorTable[c], this._ColorTable[c + 1]);
          if (c / 2 % 6 === 5)
            html += '<td class="mce-grid-cell"></td>';
        }
        html += '<td class="mce-grid-cell"></td>';
        html += this._colorCell("transparent", "No color");
        html += "</tr><tr><td></td></tr>";
        var html2 = "";
        for (r = 0; r < 6; r++) {
          if (g < 3)
            html += "<tr>";
          else
            html2 += "<tr>";
          for (g = 0; g < 6; g++) {
            for (b = 0; b < 6; b++) {
              idx = `RGB${r}${g}${b}`;
              color = "";
              c = 0;
              c = r * 40 + 55;
              if (c < 16)
                color += "0";
              color += c.toString(16);
              c = 0;
              c = g * 40 + 55;
              if (c < 16)
                color += "0";
              color += c.toString(16);
              c = 0;
              c = b * 40 + 55;
              if (c < 16)
                color += "0";
              color += c.toString(16);
              color = color.toUpperCase();
              if (g < 3)
                html += this._colorCell(color, idx);
              else
                html2 += this._colorCell(color, idx);
            }
            if (g === 2)
              html += "</tr>";
            else if (g < 3)
              html += '<td class="mce-grid-cell"></td>';
            else if (g < 5)
              html2 += '<td class="mce-grid-cell"></td>';
          }
          if (g < 3)
            html += "</tr>";
          else
            html2 += "</tr>";
        }
        html += html2;
        html += "<tr><td></td></tr><tr>";
        for (r = 232; r <= 255; r++) {
          g = (r - 232) * 10 + 8;
          if (g < 16)
            g = "0" + g.toString(16).toUpperCase();
          else
            g = g.toString(16).toUpperCase();
          g = g + g + g;
          html += this._colorCell(g, color);
          if (r === 237 || r === 249)
            html += '<td class="mce-grid-cell"></td>';
          if (r === 243)
            html += "</tr><tr>";
        }
        html += "</tr></tbody></table>";
        html += `<style>.mce-colorbtn-trans div {line-height: 14px;overflow: hidden;}.mce-grid td.mce-grid-cell div{border:1px solid #c5c5c5;width:15px;height:15px;margin:0;cursor:pointer}.mce-grid td.mce-grid-cell div:focus{border-color:#91bbe9}.mce-grid td.mce-grid-cell div[disabled]{cursor:not-allowed}.mce-grid{border-spacing:2px;border-collapse:separate}.mce-grid a{display:block;border:1px solid transparent}.mce-grid a:hover,.mce-grid a:focus{border-color:#91bbe9}.mce-grid-border{margin:0 4px 0 4px}.mce-grid-border a{border-color:#c5c5c5;width:13px;height:13px}.mce-grid-border a:hover,.mce-grid-border a.mce-active{border-color:#91bbe9;background:#bdd6f2}</style>`;
        this._colorDialog.body.innerHTML = html;
        let cells = this._colorDialog.body.querySelectorAll("div");
        for (c = 0, cl = cells.length; c < cl; c++)
          cells[c].addEventListener("click", (e) => {
            color = e.currentTarget.dataset.mceColor;
            if (color === "transparent")
              tinymce.activeEditor.execCommand("mceRemoveFormat", this._colorDialog.dialog.dataset.type);
            else
              tinymce.activeEditor.execCommand("mceApplyFormat", this._colorDialog.dialog.dataset.type, "#" + color);
            tinymce.activeEditor.execCommand("mceSetTextcolor", this._colorDialog.dialog.dataset.type, "#" + color);
            this._colorDialog.close();
          });
      }
      this._colorDialog.dialog.dataset.type = type;
      this._colorDialog.showModal();
    }
    _appendFile() {
      openFileDialog("Append file(s)", true).then((files) => {
        for (var f = 0, fl = files.length; f < fl; f++)
          readFile(files[f]).then((contents) => {
            this.insert(contents);
          }).catch(client.error);
      }).catch(() => {
      });
    }
    _insertFormatted(text) {
      if (this.isSimple)
        insertValue(this._element, text);
      else
        tinymce.activeEditor.execCommand("insertHTML", false, pinkfishToHTML(text).replace(/(\r\n|\r|\n)/g, "<br/>"));
    }
    setFormatted(text) {
      if (this.isSimple)
        this._element.value = text;
      else {
        tinymce.activeEditor.getBody().innerHTML = pinkfishToHTML(text).replace(/(\r\n|\r|\n)/g, "<br/>");
      }
    }
    _buildHTMLStack(els) {
      var tag, $el, t, tl;
      var stack = [];
      var tags;
      for (var e = 0, el = els.length; e < el; e++) {
        $el = $(els[e]);
        tag = $el.prop("tagName");
        if (tag === "EM" || tag === "I")
          tag = "ITALIC";
        else if (tag === "STRONG" || tag === "B")
          tag = "BOLD";
        if (!tag)
          stack.push('"' + $el.text() + '"');
        else if (tag === "SPAN") {
          tags = [];
          if (els[e].className != "") {
            tag = els[e].className.toUpperCase().split(/\s+/g);
            tl = tag.length;
            for (t = 0; t < tl; t++) {
              if (tag[t] === "NOFLASH")
                tags.push("FLASH");
              else if (tag[t].length > 0)
                tags.push(tag[t]);
            }
          }
          if ($el.css("text-decoration") === "line-through")
            tags.push("STRIKEOUT");
          if ($el.css("text-decoration") === "underline")
            tags.push("UNDERLINE");
          if ($el.data("mce-style")) {
            tag = $el.data("mce-style").toUpperCase().split(";");
            tl = tag.length;
            for (t = 0; t < tl; t++) {
              if (tag[t].endsWith("INHERIT") || tag[t].endsWith("BLACK"))
                continue;
              tag[t] = tag[t].trim();
              tag[t] = tag[t].replace("BACKGROUND:", "BACKGROUND-COLOR:");
              if (tag[t].length > 0)
                tags.push(tag[t]);
            }
          } else if ($el.css("color") || $el.css("background-color") || $el.css("background")) {
            tag = [];
            if ($el.css("color"))
              tag.push("COLOR: " + new RGBColor($el.css("color")).toHex().toUpperCase());
            if ($el.css("background-color"))
              tag.push("BACKGROUND-COLOR: " + new RGBColor($el.css("background-color")).toHex().toUpperCase());
            if ($el.css("background"))
              tag.push("BACKGROUND-COLOR: " + new RGBColor($el.css("background")).toHex().toUpperCase());
            tl = tag.length;
            for (t = 0; t < tl; t++) {
              if (tag[t].length > 0)
                tags.push(tag[t].trim());
            }
          }
          tl = tags.length;
          for (t = 0; t < tl; t++) {
            if (!tags[t].length) continue;
            stack.push(tags[t].trim());
          }
          stack = stack.concat(this._buildHTMLStack($el.contents()));
          for (t = tl - 1; t >= 0; t--) {
            if (!tags[t].length) continue;
            stack.push("/" + tags[t].trim());
          }
        } else if (tag == "BR" && $el.data("mce-bogus"))
          stack.push("RESET");
        else {
          stack.push(tag);
          stack = stack.concat(this._buildHTMLStack($el.contents()));
          stack.push("/" + tag);
        }
      }
      return stack;
    }
    getFormattedSelection() {
      var nodes = tinymce.activeEditor.dom.getParents(tinymce.activeEditor.selection.getNode());
      var n = 0, nl = nodes.length;
      var start = "<html>";
      var end = "</html>";
      for (; n < nl; n++) {
        var tag = nodes[n].tagName;
        if (tag === "EM" || tag === "I" || tag === "STRONG" || tag === "B") {
          start += "<" + tag + ">";
          end = "</" + tag + ">" + end;
        } else if (tag === "SPAN") {
          start += "<" + tag;
          if (nodes[n].className != "")
            start += ' class="' + nodes[n].className + '"';
          var style = "";
          if (nodes[n].style.textDecoration != "")
            style += "text-decoration:" + nodes[n].style.textDecoration + ";";
          if (nodes[n].style.color != "")
            style += "color:" + nodes[n].style.color + ";";
          if (nodes[n].style.background != "")
            style += "background:" + nodes[n].style.background + ";";
          if (nodes[n].style.backgroundColor != "")
            style += "background-color:" + nodes[n].style.backgroundColor + ";";
          if (style.length > 0)
            start += ' style="' + style + '"';
          if (nodes[n].dataset && nodes[n].dataset.mceStyle)
            start += ' data-mce-style="' + nodes[n].dataset.mceStyle + '"';
          start += " >";
          end = "</" + tag + ">" + end;
        } else if (tag === "BODY") {
          start += "<" + tag + ">";
          end = "</" + tag + ">" + end;
          break;
        }
      }
      return this._formatHtml($(start + tinymce.activeEditor.selection.getContent({ format: "raw" }).replace(/<\/div><div>/g, "<br>") + end));
    }
    getFormattedText() {
      if (this.isSimple)
        return this._element.value;
      return this._formatHtml($("<html>" + this.getRaw() + "</html>"));
    }
    getText() {
      if (this.isSimple)
        return this._element.value;
      return tinymce.activeEditor.getContent({ format: "text" });
    }
    // eslint-disable-next-line no-unused-vars
    getHTML() {
      if (this.isSimple)
        return this._element.value;
      return tinymce.activeEditor.getContent({ format: "html" });
    }
    getRaw() {
      if (this.isSimple)
        return this._element.value;
      return tinymce.activeEditor.getContent({ format: "raw" });
    }
    _formatHtml(text) {
      var data = this._buildHTMLStack(text);
      var buffer = [];
      var codes = [];
      var color, d2, dl, rgb;
      if (client.getOption("enableDebug"))
        client.debug("Advanced Editor Get Raw HTML: " + this.getRaw());
      for (d2 = data.length - 1; d2 >= 0; d2--) {
        if (!data[d2].startsWith('"') && data[d2] != "BR" && data[d2] != "RESET")
          data.pop();
        else
          break;
      }
      if (data[0] === "DIV")
        data.shift();
      for (d2 = 0, dl = data.length; d2 < dl; d2++) {
        switch (data[d2]) {
          case "BOLD":
          case "ITALIC":
          case "UNDERLINE":
          case "STRIKEOUT":
          case "DBLUNDERLINE":
          case "OVERLINE":
          case "FLASH":
          case "REVERSE":
            codes.push("%^" + data[d2] + "%^");
            buffer.push("%^" + data[d2] + "%^");
            break;
          case "/DBLUNDERLINE":
          case "/OVERLINE":
          case "/FLASH":
          case "/REVERSE":
          case "/UNDERLINE":
          case "/BOLD":
          case "/ITALIC":
          case "/STRIKEOUT":
            codes.pop();
            this._cleanReset(buffer);
            buffer.push("%^RESET%^");
            if (codes.length > 0)
              buffer.push(codes.join(""));
            break;
          case "SPAN":
          case "/SPAN":
          case "/BR":
          case "/DIV":
            break;
          case "DIV":
          case "BR":
            if (codes.length > 0 && buffer.length > 0 && !buffer[buffer.length - 1].endsWith("%^RESET%^")) {
              this._cleanReset(buffer);
              buffer.push("%^RESET%^");
            }
            buffer.push("\n");
            if (codes.length > 0)
              buffer.push(codes.join(""));
            break;
          case "RESET":
            if (codes.length > 0 && buffer.length > 0 && !buffer[buffer.length - 1].endsWith("%^RESET%^")) {
              this._cleanReset(buffer);
              buffer.push("%^RESET%^");
            }
            if (codes.length > 0)
              buffer.push(codes.join(""));
            break;
          default:
            if (data[d2].startsWith("COLOR: #")) {
              color = data[d2].substr(8);
              if (!this._colors[color]) {
                rgb = new RGBColor(color);
                color = this._nearestHex(rgb.toHex()).substr(1);
              }
              color = this._colors[color];
              if (color === "BOLD BLACK" || color === "BOLD%^%^BLACK")
                color = "mono11";
              codes.push("%^" + color + "%^");
              buffer.push("%^" + color + "%^");
            } else if (data[d2].startsWith("COLOR: ")) {
              color = new RGBColor(data[d2].substr(7)).toHex().substr(1);
              if (!this._colors[color])
                color = this._nearestHex("#" + color).substr(1);
              color = this._colors[color];
              if (color === "BOLD BLACK" || color === "BOLD%^%^BLACK")
                color = "mono11";
              codes.push("%^" + color + "%^");
              buffer.push("%^" + color + "%^");
            } else if (data[d2].startsWith("/COLOR: ")) {
              codes.pop();
              this._cleanReset(buffer);
              buffer.push("%^RESET%^");
              if (codes.length > 0)
                buffer.push(codes.join(""));
            } else if (data[d2].startsWith("BACKGROUND-COLOR: #")) {
              color = data[d2].substr(19);
              if (!this._colors[color]) {
                rgb = new RGBColor(color);
                color = this._nearestHex(rgb.toHex()).substr(1);
              }
              if (this._colors["B" + color])
                color = this._colors["B" + color];
              else
                color = this._colors[color];
              color = "%^B_" + color + "%^";
              codes.push(color);
              buffer.push(color);
            } else if (data[d2].startsWith("BACKGROUND-COLOR: ")) {
              color = new RGBColor(data[d2].substr(18)).toHex().substr(1);
              if (!this._colors[color])
                color = this._nearestHex("#" + color).substr(1);
              if (this._colors["B" + color])
                color = this._colors["B" + color];
              else
                color = this._colors[color];
              color = "%^B_" + color + "%^";
              codes.push(color);
              buffer.push(color);
            } else if (data[d2].startsWith("/BACKGROUND-COLOR: ")) {
              codes.pop();
              this._cleanReset(buffer);
              buffer.push("%^RESET%^");
              if (codes.length > 0)
                buffer.push(codes.join(""));
            } else if (data[d2].startsWith('"'))
              buffer.push(data[d2].substring(1, data[d2].length - 1));
            break;
        }
      }
      return buffer.join("");
    }
    _cleanReset(buffer) {
      let b = buffer.length - 1;
      for (; b >= 0; b--) {
        if (buffer[b].startsWith("%^"))
          buffer.pop();
        else
          return buffer;
      }
      return buffer;
    }
    _nearestHex(hex) {
      var _editor = this;
      var hexToRgb = function(hex2) {
        var shortRegEx = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        hex2 = hex2.replace(shortRegEx, function(full, r, g, b) {
          return [r, r, g, g, b, b].join();
        });
        var longRegEx = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?/i;
        var rgbArray = longRegEx.exec(hex2);
        var rgbObj = rgbArray ? {
          r: parseInt(rgbArray[1], 16),
          g: parseInt(rgbArray[2], 16),
          b: parseInt(rgbArray[3], 16)
        } : null;
        return rgbObj;
      };
      var closestHexFromRgb = function(rgbObj) {
        if (!rgbObj) {
          throw new Error("The hex you provided is not formatted correctly. Please try in a format such as '#FFF' or '#DDFFDD'.");
        }
        var minDistance = Number.MAX_SAFE_INTEGER;
        var nearestHex = null;
        for (var i2 = 0; i2 < _editor._colorList.length; i2++) {
          var currentColor = _editor._colorList[i2];
          var distance = Math.sqrt(
            Math.pow(rgbObj.r - currentColor.rgb.r, 2) + Math.pow(rgbObj.g - currentColor.rgb.g, 2) + Math.pow(rgbObj.b - currentColor.rgb.b, 2)
          );
          if (distance < minDistance) {
            minDistance = distance;
            nearestHex = currentColor.hex;
          }
        }
        return nearestHex;
      };
      return closestHexFromRgb(hexToRgb(hex));
    }
    remove() {
      tinymce.remove(`#${this._element.id}`);
    }
    initialize() {
      if (this.isSimple) return;
      this._initPlugins();
      tinymce.init({
        license_key: "gpl",
        custom_colors: false,
        selector: `textarea#${this._element.id}`,
        height: 500,
        menubar: false,
        browser_spellcheck: true,
        //contextmenu: false,
        resize: true,
        statusbar: false,
        nowrap: true,
        force_br_newlines: true,
        forced_root_block: "div",
        plugins: "pinkfish insertdatetime pinkfishtextcolor nonbreaking",
        color_picker_callback: (editor2, color, format) => {
          this._openColorDialog(format, color || "");
        },
        color_picker_caption: "More&hellip;",
        textcolor_rows: "3",
        textcolor_cols: "8",
        toolbar: "send | append | undo redo | pinkfishforecolor pinkfishbackcolor | italic underline strikethrough overline dblunderline flash reverse | clear | copy copyformatted | insertdatetime",
        toolbar_mode: "sliding",
        content_css: "css/tinymce.content.min.css",
        formats: {
          bold: { inline: "strong", exact: true, links: true, remove_similar: true },
          italic: { inline: "em", exact: true, links: true, remove_similar: true },
          overline: { inline: "span", "classes": "overline", links: true, remove_similar: true },
          dblunderline: { inline: "span", "classes": "dblunderline", links: true, remove_similar: true },
          flash: { inline: "span", "classes": "flash", links: true, remove_similar: true },
          reverse: { inline: "span", "classes": "reverse", links: true, remove_similar: true },
          underline: { inline: "span", "classes": "underline", links: true, remove_similar: true },
          strikethrough: { inline: "span", "classes": "strikeout", links: true, remove_similar: true }
          //forecolor: { inline: 'span', styles: { textDecoration: 'inherit', border: 'inherit', color: '%value' }, exact: true, links: true, remove_similar: true },
          //hilitecolor: { inline: 'span', styles: { textDecoration: 'inherit', border: 'inherit', backgroundColor: '%value' }, exact: true, links: true, remove_similar: true }
          //forecolor: { block: 'span', attributes: { 'data-color': '%value' }, styles: { textDecoration: 'inherit', border: 'inherit', color: '%value' }, exact: true, links: true, remove_similar: true },
          //hilitecolor: { block: 'span', attributes: { 'data-backcolor': '%value' }, styles: { textDecoration: 'inherit', border: 'inherit', backgroundColor: '%value' }, exact: true, links: true, remove_similar: true }
        },
        init_instance_callback: (editor2) => {
          editor2.shortcuts.add("ctrl+shift+c", "Copy formatted", () => copyText(this.getFormattedSelection().replace(/(?:\r)/g, "")));
          editor2.on("PastePreProcess", (e) => {
            if (client.getOption("enableDebug"))
              client.debug("Advanced Before Editor PastePreProcess: " + e.content);
            this._clearReverse($(".reverse", $(editor2.getDoc()).contents()));
            e.content = e.content.replace(/<\/p>/g, "<br>");
            e.content = e.content.replace(/<\/h[1-6]>/g, "<br>");
            e.content = e.content.replace(/<\/li>/g, "<br>");
            e.content = e.content.replace(/ background: #000000;/g, "");
            e.content = e.content.replace(/background: #000000;/g, "");
            e.content = e.content.replace(/ background-color: #000000;/g, "");
            e.content = e.content.replace(/background-color: #000000;/g, "");
            e.content = e.content.replace(/ color: #BBBBBB;/g, "");
            e.content = e.content.replace(/color: #BBBBBB;/g, "");
            var regex = /<pre(.*?)>((.|\s)*)<\/pre>/mgi;
            var m;
            while ((m = regex.exec(e.content)) !== null) {
              if (m.index === regex.lastIndex) {
                regex.lastIndex++;
              }
              e.content = e.content.substring(0, m.index) + e.content.substring(m.index, regex.lastIndex).replace(/(\r\n|\r|\n)/g, "<br/>").replaceAll("  ", "&nbsp;&nbsp;") + e.content.substring(regex.lastIndex);
            }
            if (client.getOption("enableDebug"))
              client.debug("Advanced After Editor PastePreProcess: " + e.content);
          });
          editor2.on("PastePreProcess", () => {
            this._addReverse($(".reverse", $(editor2.getDoc()).contents()));
          });
          $(".mce-content-body", tinymce.activeEditor.getDoc()).css("font-size", client.getOption("cmdfontSize"));
          $(".mce-content-body", tinymce.activeEditor.getDoc()).css("font-family", client.getOption("cmdfont") + ", monospace");
          if (tinymce.activeEditor.formatter)
            tinymce.activeEditor.formatter.register("flash", { inline: "span", "classes": client.getOption("flashing") ? "flash" : "noflash", links: true, remove_similar: true });
          else
            tinymce.activeEditor.settings.formats["flash"] = { inline: "span", "classes": client.getOption("flashing") ? "flash" : "noflash", links: true, remove_similar: true };
          this._loadColors();
          this.setFormatted(this._element.value);
          editor2.on("click", (e) => {
            this.emit("click", e);
          });
          this.emit("editor-init");
          this._init = true;
        },
        paste_data_images: false,
        paste_webkit_styles: "color background background-color text-decoration",
        valid_elements: "strong/b,em/i,u,span[style|class],strike/s,br",
        valid_styles: {
          "*": "color,background,background-color,text-decoration,font-weight"
        },
        color_map: this._ColorTable
      });
    }
    focus() {
      if (this.isSimple)
        this._element.focus();
      else if (this._init && true && tinymce.activeEditor && tinymce.activeEditor.initialized)
        tinymce.activeEditor.focus();
    }
  };

  // src/interface/breadcrumb.ts
  function buildBreadcrumb(pages, small, sep, formatter) {
    let breadcrumb = "";
    let last = pages.length - 1;
    sep = sep || "-";
    formatter = formatter || ((item) => capitalize(item.match(/([A-Z]|^[a-z])[a-z]+/g).join(" ")));
    if (pages.length === 1)
      breadcrumb += '<li class="breadcrumb-icon"><i class="float-start fas fa-cogs" style="padding: 2px;margin-right: 2px;"></i></li>';
    else
      breadcrumb += '<li class="breadcrumb-icon"><a href="#' + pages.slice(0, 1).join("-") + '"><i class="float-start fas fa-cogs" style="padding: 2px;margin-right: 2px;"></i></a></li>';
    for (let p = 0, pl = pages.length; p < pl; p++) {
      let title = formatter(pages[p], p, last);
      if (p === last)
        breadcrumb += '<li class="breadcrumb-item active">' + title + "</li>";
      else
        breadcrumb += '<li class="breadcrumb-item" aria-current="page"><a href="#' + pages.slice(0, p + 1).join(sep) + '">' + title + "</a></li>";
    }
    if (small)
      `<ol class="breadcrumb${this._small ? " breadcrumb-sm" : ""}" style="overflow: hidden;white-space: nowrap;text-overflow: ellipsis;flex-wrap: nowrap;">${breadcrumb}</ol>`;
    return '<ol class="float-start breadcrumb">' + breadcrumb + "</ol>";
  }

  // src/html/settings.menu.htm
  var settings_menu_default = '<div class="contents list-group list-group-flush" style="top:0;position:absolute;left:0;bottom:49px;right:0"><a href="#settings-general" class="list-group-item list-group-item-action"><i class="fas fa-cogs"></i> General</a> <a href="#settings-display" class="list-group-item list-group-item-action"><i class="fas fa-display"></i> Display</a> <a href="#settings-colors" class="list-group-item list-group-item-action"><i class="fas fa-palette"></i> Colors</a> <a href="#settings-commandLine" class="list-group-item list-group-item-action"><i class="fas fa-terminal"></i> Command line</a> <a href="#settings-tabCompletion" class="list-group-item list-group-item-action"><i class="fa-solid fa-arrow-right-to-bracket"></i> Tab completion</a> <a href="#settings-telnet" class="list-group-item list-group-item-action"><i class="fas fa-network-wired"></i> Telnet</a> <a href="#settings-scripting" class="list-group-item list-group-item-action"><i class="fas fa-code"></i> Scripting</a> <a href="#settings-specialCharacters" class="list-group-item list-group-item-action"><i class="fa-regular fa-file-code"></i> Special characters</a> <a href="#settings-advanced" class="list-group-item list-group-item-action"><i class="fa-solid fa-sliders"></i> Advanced</a></div>';

  // src/interface/settingsdialog.ts
  var SettingsDialog = class _SettingsDialog extends Dialog {
    constructor() {
      super({ title: '<i class="fas fa-cogs"></i> Settings', keepCentered: true, resizable: false, moveable: false, center: true, maximizable: false });
      this.body.style.padding = "10px";
      this._buildMenu();
      let footer = "";
      footer += `<button id="${this.id}-cancel" type="button" class="btn-sm float-end btn btn-light" title="Cancel dialog"><i class="bi bi-x-lg"></i><span class="icon-only"> Cancel</span></button>`;
      footer += `<button id="${this.id}-save" type="button" class="btn-sm float-end btn btn-primary" title="Confirm dialog"><i class="bi bi-save"></i><span class="icon-only"> Save</span></button>`;
      footer += `<button id="${this.id}-reset" type="button" class="btn-sm float-start btn btn-warning" title="Reset settings"><i class="bi bi-arrow-clockwise"></i><span class="icon-only"> Reset</span></button>`;
      footer += `<button id="${this.id}-reset-all" type="button" class="btn-sm float-start btn btn-warning" title="Reset All settings"><i class="bi bi-arrow-repeat"></i><span class="icon-only"> Reset All</span></button>`;
      footer += '<div class="vr float-start" style="margin-right: 4px;height: 29px;"></div>';
      footer += `<button id="${this.id}-export" type="button" class="btn-sm float-start btn btn-light" title="Export settings"><i class="bi bi-box-arrow-up"></i><span class="icon-only"> Export</span></button>`;
      footer += `<button id="${this.id}-import" type="button" class="btn-sm float-start btn btn-light" title="Import settings"><i class="bi bi-box-arrow-in-down"></i><span class="icon-only"> Import</span></button>`;
      this.footer.innerHTML = footer;
      this.footer.querySelector(`#${this.id}-cancel`).addEventListener("click", () => {
        removeHash(this._page);
        this.close();
      });
      this.footer.querySelector(`#${this.id}-export`).addEventListener("click", () => {
        var data = clone(this.settings);
        data.version = 2;
        fileSaveAs.show(JSON.stringify(data), "oiMUD.settings.txt", "text/plain");
      });
      this.footer.querySelector(`#${this.id}-import`).addEventListener("click", () => {
        openFileDialog("Import settings").then((files) => {
          readFile(files[0]).then((contents) => {
            try {
              var data = JSON.parse(contents);
              var s, sl;
              if (data.version === 1) {
                for (s = 0, sl = SettingList.length; s < sl; s++) {
                  this.settings[SettingList[s][0]] = data[SettingList[s][0]];
                }
                this.emit("import-rooms", data.rooms);
              } else if (data.version === 2 && !data.profiles) {
                for (s = 0, sl = SettingList.length; s < sl; s++) {
                  this.settings[SettingList[s][0]] = data[SettingList[s][0]];
                }
              } else
                setTimeout(function() {
                  alert_box("Invalid file", "Unable to import file, not a valid settings file", 4 /* exclamation */);
                }, 50);
              this._loadPageSettings();
            } catch (err) {
              setTimeout(function() {
                alert_box("Error importing", "Error importing file.", 3 /* error */);
              }, 50);
              client.error(err);
            }
          }).catch(client.error);
        }).catch(() => {
        });
      });
      this.footer.querySelector(`#${this.id}-reset`).addEventListener("click", () => {
        if (this._page === "settings-colors") {
          confirm_box("Reset colors", "Reset colors?").then((e) => {
            if (e.button === 4 /* Yes */) {
              var c;
              var colors = this.settings.colors = [];
              for (c = 0; c < 16; c++)
                this.setColor("color" + c, colors[c] || this.getDefaultColor(c));
              for (c = 256; c < 280; c++)
                this.setColor("color" + c, colors[c] || this.getDefaultColor(c));
              this.body.querySelector(`#colorScheme`).value = 0;
            }
          });
        } else if (this._page && this._page !== "settings" && this._page.length) {
          const pages = this._page.split("-");
          let title = capitalize(pages[pages.length - 1].match(/([A-Z]|^[a-z])[a-z]+/g).join(" "));
          confirm_box(`Reset ${title} settings`, `Reset ${title} settings?`).then((e) => {
            if (e.button === 4 /* Yes */) {
              const forms = this.body.querySelectorAll("input,select,textarea");
              for (let f = 0, fl = forms.length; f < fl; f++) {
                let id = forms[f].name || forms[f].id;
                this.settings[id] = Settings.defaultValue(id);
                if (forms[f].type === "checkbox" || forms[f].type === "radio")
                  forms[f].checked = this.settings[id];
                else
                  forms[f].value = this.settings[id];
              }
            }
          });
        } else {
          confirm_box("Reset all settings", "Reset all settings?").then((e) => {
            if (e.button === 4 /* Yes */)
              this.settings.reset();
          });
        }
      });
      this.footer.querySelector(`#${this.id}-reset-all`).addEventListener("click", () => {
        confirm_box("Reset all settings", "Reset all settings?").then((e) => {
          if (e.button === 4 /* Yes */)
            this.settings.reset();
        });
      });
      this.footer.querySelector(`#${this.id}-save`).addEventListener("click", () => {
        removeHash(this._page);
        for (var s in this.settings) {
          if (!this.settings.hasOwnProperty(s)) continue;
          Settings.setValue(s, this.settings[s]);
        }
        client.clearCache();
        client.loadOptions();
        this.close();
      });
      this.settings = new Settings();
      this.on("closed", () => {
        removeHash(this._page);
      });
      this.on("canceled", () => {
        removeHash(this._page);
      });
    }
    setBody(contents, args) {
      super.setBody(this.dialog.dataset.path === "settings" ? settings_menu_default : contents, args);
      this._page = this.dialog.dataset.path;
      const pages = this._page.split("-");
      this.title = buildBreadcrumb(pages);
      if (this._menu) {
        let items = this._menu.querySelectorAll("a.active");
        items.forEach((item) => item.classList.remove("active"));
        items = this._menu.querySelector(`a[href="#${this._page}"]`);
        if (items)
          items.classList.add("active");
      }
      if (this._page === "settings") {
        if (this._menu)
          this._menu.style.display = "none";
        this.body.style.left = "";
        if (this.footer.querySelector(`#${this.id}-reset`))
          this.footer.querySelector(`#${this.id}-reset`).style.display = "none";
        _SettingsDialog.addPlugins(this.body.querySelector("div.contents"));
      } else {
        if (this._menu)
          this._menu.style.display = "";
        if (this.footer.querySelector(`#${this.id}-reset`))
          this.footer.querySelector(`#${this.id}-reset`).style.display = "";
        this.body.style.left = "200px";
      }
      this.body.scrollTop = 0;
      this._loadPageSettings();
    }
    _buildMenu() {
      this.dialog.insertAdjacentHTML("beforeend", settings_menu_default.replace(' style="top:0;position:absolute;left:0;bottom:49px;right:0"', ""));
      this._menu = this.dialog.querySelector(".contents");
      this._menu.classList.add("settings-menu");
      _SettingsDialog.addPlugins(this._menu);
      if (this._page === "settings")
        this._menu.style.display = "none";
      this.body.style.left = "200px";
    }
    _loadPageSettings() {
      const forms = this.body.querySelectorAll("input,select,textarea");
      let required;
      if (this._page === "settings-colors") {
        var c;
        var colors = this.settings.colors || [];
        for (c = 0; c < 16; c++)
          this.setColor("color" + c, colors[c] || this.getDefaultColor(c));
        for (c = 256; c < 280; c++)
          this.setColor("color" + c, colors[c] || this.getDefaultColor(c));
        for (let f = 0, fl = forms.length; f < fl; f++) {
          forms[f].addEventListener("change", (e) => {
            const target = e.currentTarget || e.target;
            let value = target.value;
            let id = parseInt(target.id.substring(5), 10);
            var colors2 = this.settings.colors || [];
            if (!colors2[id] || colors2[id].length === 0) {
              if (this.getDefaultColor(id) !== value)
                colors2[id] = value;
            } else if (this.getDefaultColor(id) !== value)
              delete colors2[id];
            else
              colors2[id] = value;
            this.settings.colors = colors2;
          });
          forms[f].addEventListener("input", (e) => {
            const target = e.currentTarget || e.target;
            let value = target.value;
            let id = parseInt(target.id.substring(5), 10);
            if (!this.settings.colors[id] || this.settings.colors[id].length === 0) {
              if (this.getDefaultColor(id) !== value)
                this.settings.colors[id] = value;
            } else if (this.getDefaultColor(id) !== value)
              delete this.settings.colors[id];
            else
              this.settings.colors[id] = value;
          });
        }
      } else {
        for (let f = 0, fl = forms.length; f < fl; f++) {
          if (forms[f].type === "radio") {
            forms[f].checked = "" + this.settings[forms[f].name] === forms[f].value;
            forms[f].addEventListener("change", (e) => {
              const target = e.currentTarget || e.target;
              if (target.checked)
                this.settings[target.name] = this.convertType(target.value, typeof this.settings[target.name]);
            });
          } else if (forms[f].type === "checkbox") {
            let name2;
            if (forms[f].dataset.enum === "true") {
              name2 = forms[f].name || forms[f].id.substring(0, forms[f].id.lastIndexOf("-"));
              const value = +forms[f].id.substring(forms[f].id.lastIndexOf("-") + 1);
              forms[f].checked = (this.settings[name2] & value) === value;
            } else {
              name2 = forms[f].name || forms[f].id;
              forms[f].checked = this.settings[name2];
            }
            forms[f].addEventListener("change", (e) => {
              const target = e.currentTarget || e.target;
              let name3;
              if (target.dataset.enum === "true") {
                name3 = target.name || target.id.substring(0, target.id.lastIndexOf("-"));
                const enums = this.body.querySelectorAll(`[name=${name3}]`);
                let value = 0;
                for (let e2 = 0, el = enums.length; e2 < el; e2++) {
                  if (enums[e2].checked)
                    value |= +enums[e2].value;
                }
                this.settings[name3] = value;
              } else {
                name3 = target.name || target.id;
                this.settings[name3] = target.checked || false;
              }
              let required2 = this.body.querySelectorAll(`[data-require="${name3}"]`);
              required2.forEach((r) => {
                r.disabled = !this.settings[name3];
              });
            });
            required = this.body.querySelectorAll(`[data-require="${name2}"]`);
            required.forEach((r) => {
              r.disabled = !this.settings[name2];
            });
          } else {
            if (forms[f].dataset.join && forms[f].dataset.join.length)
              forms[f].value = (this.settings[forms[f].id] || []).map((v) => v.trim()).join(forms[f].dataset.join);
            else
              forms[f].value = this.settings[forms[f].id];
            forms[f].addEventListener("change", (e) => {
              const target = e.currentTarget || e.target;
              if (forms[f].dataset.join && forms[f].dataset.join.length)
                this.setValue(target.name || target.id, target.value.split(forms[f].dataset.join).map((v) => v.trim()));
              else
                this.setValue(target.name || target.id, target.value);
            });
            forms[f].addEventListener("input", (e) => {
              const target = e.currentTarget || e.target;
              if (forms[f].dataset.join && forms[f].dataset.join.length)
                this.setValue(target.name || target.id, target.value.split(forms[f].dataset.join).map((v) => v.trim()));
              else
                this.setValue(target.name || target.id, target.value);
            });
          }
        }
      }
    }
    setColor(id, color) {
      if (!color || typeof color === "undefined" || color.length === 0)
        this.body.querySelector("#" + id).value = "";
      else
        this.body.querySelector("#" + id).value = this.colorHex(color);
    }
    colorHex(color) {
      if (!color) return false;
      color = new RGBColor(color);
      if (!color.ok)
        return "";
      return color.toHex();
    }
    getDefaultColor(code) {
      if (code === 0) return "rgb(0,0,0)";
      if (code === 1) return "rgb(128, 0, 0)";
      if (code === 2) return "rgb(0, 128, 0)";
      if (code === 3) return "rgb(128, 128, 0)";
      if (code === 4) return "rgb(0, 0, 128)";
      if (code === 5) return "rgb(128, 0, 128)";
      if (code === 6) return "rgb(0, 128, 128)";
      if (code === 7) return "rgb(192, 192, 192)";
      if (code === 8) return "rgb(128, 128, 128)";
      if (code === 9) return "rgb(255, 0, 0)";
      if (code === 10) return "rgb(0, 255, 0)";
      if (code === 11) return "rgb(255, 255, 0)";
      if (code === 12) return "rgb(0, 0, 255)";
      if (code === 13) return "rgb(255, 0, 255)";
      if (code === 14) return "rgb(0, 255, 255)";
      if (code === 15) return "rgb(255, 255, 255)";
      if (code === 256) return "rgb(0, 0, 0)";
      if (code === 257) return "rgb(118, 0, 0)";
      if (code === 258) return "rgb(0, 108, 0)";
      if (code === 259) return "rgb(145, 136, 0)";
      if (code === 260) return "rgb(0, 0, 108)";
      if (code === 261) return "rgb(108, 0, 108)";
      if (code === 262) return "rgb(0, 108, 108)";
      if (code === 263) return "rgb(160, 160, 160)";
      if (code === 264) return "rgb(0, 0, 0)";
      if (code === 265) return "rgb(128, 0, 0)";
      if (code === 266) return "rgb(0, 128, 0)";
      if (code === 267) return "rgb(128, 128, 0)";
      if (code === 268) return "rgb(0, 0, 128)";
      if (code === 269) return "rgb(128, 0, 128)";
      if (code === 270) return "rgb(0, 128, 128)";
      if (code === 271) return "rgb(192, 192, 192)";
      if (code === 272) return "rgb(0,0,0)";
      if (code === 273) return "rgb(0, 255, 255)";
      if (code === 274) return "rgb(0,0,0)";
      if (code === 275) return "rgb(255, 255, 0)";
      if (code === 276) return "rgb(0, 0, 0)";
      if (code === 277) return "rgb(192, 192, 192)";
      if (code === 278) return "rgb(128, 0, 0)";
      if (code === 279) return "rgb(192, 192, 192)";
      if (code === 280) return "rgb(255,255,255)";
      return "";
    }
    setValue(option, value) {
      if (value == "false") value = false;
      if (value == "true") value = true;
      if (value == "null") value = null;
      if (value == "undefined") value = void 0;
      if (typeof value == "string" && parseFloat(value).toString() == value)
        value = parseFloat(value);
      this.settings[option] = this.convertType(value, typeof this.settings[option]);
    }
    convertType(value, type) {
      if (typeof value === type)
        return value;
      switch (type) {
        case "number":
          if (typeof value == "string" && parseFloat(value).toString() == value)
            return parseFloat(value);
          return Number(value);
        case "boolean":
          return Boolean(value);
        case "string":
          return "" + value;
      }
      return value;
    }
    static addPlugins(menu) {
      let pl = client.plugins.length;
      let s;
      let sl;
      for (let p = 0; p < pl; p++) {
        if (!client.plugins[p].settings) continue;
        if (client.plugins[p].settings.length) {
          sl = client.plugins[p].settings.length;
          for (s = 0; s < sl; s++) {
            let item = client.plugins[p].settings[s];
            if (typeof item.action !== "string") continue;
            let code = `<a href="#${item.action}" class="list-group-item list-group-item-action">${item.icon || ""}${item.name || ""}</a>`;
            if ("position" in item) {
              if (typeof item.position === "string") {
                if (menu.querySelector(item.position)) {
                  menu.querySelector(item.position).insertAdjacentHTML("afterend", code);
                  continue;
                }
              } else if (item.position >= 0 && item.position < menu.children.length) {
                menu.children[item.position].insertAdjacentHTML("afterend", code);
                continue;
              }
            }
            menu.insertAdjacentHTML("beforeend", code);
          }
        }
      }
    }
  };

  // src/interface/splitter.ts
  var Splitter = class extends EventEmitter {
    constructor(options) {
      super();
      this.$panel1MinSize = 200;
      this.$panel2MinSize = 200;
      this.$splitterWidth = 4;
      this.$splitterDistance = 204;
      this.$dragging = false;
      this.$collapsed = 0;
      this.live = true;
      if (options && options.id)
        this.$id = options.id;
      if (options) {
        this.$panel1 = options.panel1;
        this.$panel2 = options.panel2;
      }
      if (options && options.container)
        this.parent = options.container.container ? options.container.container : options.container;
      else if (options && options.parent)
        this.parent = options.parent;
      else
        this.parent = document.body;
      if (options) {
        if ("anchor" in options)
          this.$anchor = options.anchor;
        else
          this.$anchor = 2 /* panel2 */;
        this.orientation = options.orientation || 0 /* horizontal */;
      } else {
        this.$anchor = 2 /* panel2 */;
        this.orientation = 0 /* horizontal */;
      }
    }
    hide() {
      this.$el.style.display = "none";
    }
    show() {
      this.$el.style.display = "";
    }
    get id() {
      return this.$id || this.parent.id;
    }
    set id(value) {
      if (value === this.$id) return;
      this.$id = value;
      this.$el.id = this.id + "-splitter";
      this.$panel1.id = this.id + "-splitter-panel1";
      this.$panel2.id = this.id + "-splitter-panel2";
      this.$dragBar.id = this.id + "-splitter-drag-bar";
      if (this.$ghostBar)
        this.$ghostBar.id = this.id + "-ghost-bar";
    }
    set parent(parent) {
      if (typeof parent === "string") {
        if (parent.startsWith("#"))
          this.$parent = document.getElementById(parent.substr(1));
        else
          this.$parent = document.getElementById(parent);
      } else if (parent instanceof $)
        this.$parent = parent[0];
      else if (parent instanceof HTMLElement)
        this.$parent = parent;
      if (!this.$parent)
        this.$parent = document.body;
      this._createControl();
    }
    get parent() {
      return this.$parent;
    }
    get panel1() {
      return this.$panel1;
    }
    get panel2() {
      return this.$panel2;
    }
    get anchor() {
      return this.$anchor;
    }
    set anchor(value) {
      if (this.$anchor === value) return;
      this.$anchor = 2;
      this._updatePanels();
    }
    set SplitterDistance(value) {
      if (this.$splitterDistance === value)
        return;
      this.$splitterDistance = value;
      this._updatePanels();
      this.emit("splitter-moved", value);
    }
    get SplitterDistance() {
      return this.$splitterDistance;
    }
    set Panel1MinSize(value) {
      if (this.$panel1MinSize === value)
        return;
      this.$panel1MinSize = value;
      if (this.$orientation === 0 /* horizontal */) {
        if (this.$panel1.clientWidth < value)
          this.$splitterDistance = this.parent.clientWidth - this.$panel1MinSize;
      } else if (this.$panel1.clientHeight < value)
        this.$splitterDistance = this.parent.clientHeight - this.$panel1MinSize;
      this._updatePanels();
    }
    get Panel1MinSize() {
      return this.$panel1MinSize;
    }
    set Panel2MinSize(value) {
      if (this.$panel2MinSize === value)
        return;
      this.$panel2MinSize = value;
      if (this.$orientation === 0 /* horizontal */) {
        if (this.$panel2.clientWidth < value)
          this.$splitterDistance = value;
      } else if (this.$panel2.clientHeight < value)
        this.$splitterDistance = value;
      this._updatePanels();
    }
    get Panel2MinSize() {
      return this.$panel2MinSize;
    }
    get orientation() {
      return this.$orientation;
    }
    set orientation(value) {
      if (value === this.$orientation) return;
      this.$orientation = value;
      this._updatePanels();
    }
    get panel1Collapsed() {
      return this.$collapsed === 1;
    }
    set panel1Collapsed(value) {
      if (value) {
        if (this.$collapsed === 1) return;
        this.$collapsed = 1;
        this.panel1.dataset.collapsed = "true";
        this.panel2.dataset.collapsed = "false";
        this.emit("collapsed", 1);
        this._updatePanels();
      } else if (this.$collapsed === 1) {
        this.$collapsed = 0;
        delete this.panel1.dataset.collapsed;
        delete this.panel2.dataset.collapsed;
        this.emit("collapsed", 0);
        this._updatePanels();
      }
    }
    get panel2Collapsed() {
      return this.$collapsed === 2;
    }
    set panel2Collapsed(value) {
      if (value) {
        if (this.$collapsed === 2) return;
        this.$collapsed = 2;
        this.panel1.dataset.collapsed = "false";
        this.panel2.dataset.collapsed = "true";
        this.emit("collapsed", 2);
        this._updatePanels();
      } else if (this.$collapsed === 2) {
        this.$collapsed = 0;
        delete this.panel1.dataset.collapsed;
        delete this.panel2.dataset.collapsed;
        this.emit("collapsed", 0);
        this._updatePanels();
      }
    }
    _updatePanels() {
      if (this.$orientation === 0 /* horizontal */) {
        this.$panel1.style.left = "0";
        this.$panel1.style.top = "0";
        this.$panel1.style.right = "0";
        this.$panel2.style.left = "0";
        this.$panel2.style.top = "";
        this.$panel2.style.right = "0";
        this.$panel2.style.bottom = "0";
        this.$dragBar.style.left = "0";
        this.$dragBar.style.right = "0";
        if (this.$anchor === 1 /* panel1 */) {
          this.$dragBar.style.bottom = "";
          this.$dragBar.style.top = this.$splitterDistance + "px";
        } else {
          this.$dragBar.style.top = "";
          this.$dragBar.style.bottom = this.$splitterDistance - this.$splitterWidth + "px";
        }
        this.$dragBar.style.height = this.$splitterWidth + "px";
        this.$dragBar.style.cursor = "ns-resize";
        if (this.$collapsed === 1) {
          this.$panel1.style.display = "none";
          this.$panel2.style.display = "";
          this.$panel2.style.top = "0";
          this.$panel2.style.height = "";
          this.$dragBar.style.display = "none";
        } else if (this.$collapsed === 2) {
          this.$panel1.style.display = "";
          this.$panel1.style.bottom = "0";
          this.$panel1.style.height = "";
          this.$panel2.style.display = "none";
          this.$dragBar.style.display = "none";
        } else if (this.$anchor === 1 /* panel1 */) {
          this.$panel1.style.display = "";
          this.$panel1.style.height = this.$splitterDistance - this.$splitterWidth + "px";
          this.$panel2.style.display = "";
          this.$panel2.style.top = this.$splitterDistance - this.$splitterWidth + "px";
          this.$panel2.style.height = "";
          this.$dragBar.style.display = "";
        } else {
          this.$panel1.style.display = "";
          this.$panel1.style.bottom = this.$splitterDistance + "px";
          this.$panel2.style.display = "";
          this.$panel2.style.height = this.$splitterDistance - this.$splitterWidth + "px";
          this.$dragBar.style.display = "";
        }
        this.$el.classList.remove("vertical");
        this.$el.classList.add("horizontal");
      } else {
        this.$panel1.style.left = "0";
        this.$panel1.style.top = "0";
        this.$panel1.style.bottom = "0";
        this.$panel1.classList.remove("horizontal");
        this.$panel1.classList.add("vertical");
        this.$panel2.style.left = "";
        this.$panel2.style.top = "0";
        this.$panel2.style.right = "0";
        this.$panel2.style.bottom = "0";
        if (this.$anchor === 1 /* panel1 */) {
          this.$dragBar.style.right = "";
          this.$dragBar.style.left = this.$splitterDistance - this.$splitterWidth + "px";
        } else {
          this.$dragBar.style.left = "";
          this.$dragBar.style.right = this.$splitterDistance - this.$splitterWidth + "px";
        }
        this.$dragBar.style.top = "0";
        this.$dragBar.style.bottom = "0";
        this.$dragBar.style.width = this.$splitterWidth + "px";
        this.$dragBar.style.cursor = "ew-resize";
        if (this.$collapsed === 1) {
          this.$panel1.style.display = "none";
          this.$panel2.style.display = "";
          this.$panel2.style.left = "0";
          this.$panel2.style.width = "";
          this.$dragBar.style.display = "none";
        } else if (this.$collapsed === 2) {
          this.$panel1.style.display = "";
          this.$panel1.style.right = "0";
          this.$panel1.style.width = "";
          this.$panel2.style.display = "none";
          this.$dragBar.style.display = "none";
        } else if (this.$anchor === 1 /* panel1 */) {
          this.$panel1.style.display = "";
          this.$panel1.style.width = this.$splitterDistance - this.$splitterWidth + "px";
          this.$panel2.style.display = "";
          this.$panel2.style.left = this.$splitterDistance - this.$splitterWidth + "px";
          this.$panel2.style.width = "";
          this.$dragBar.style.display = "";
        } else {
          this.$panel1.style.display = "";
          this.$panel1.style.right = this.$splitterDistance + "px";
          this.$panel2.style.display = "";
          this.$panel2.style.width = this.$splitterDistance - this.$splitterWidth + "px";
          this.$dragBar.style.display = "";
        }
        this.$el.classList.remove("horizontal");
        this.$el.classList.add("vertical");
      }
    }
    _createControl() {
      this.$el = document.createElement("div");
      this.$el.id = this.id + "-splitter";
      this.$el.classList.add("splitter");
      if (!this.$panel1) {
        this.$panel1 = document.createElement("div");
        this.$panel1.id = this.id + "-splitter-panel1";
      }
      this.$panel1.classList.add("splitter-panel", "splitter-panel-1");
      this.$el.appendChild(this.$panel1);
      if (!this.$panel2) {
        this.$panel2 = document.createElement("div");
        this.$panel2.id = this.id + "-splitter-panel2";
      }
      this.$panel2.classList.add("splitter-panel", "splitter-panel-2");
      this.$el.appendChild(this.$panel2);
      this.$dragBar = document.createElement("div");
      this.$dragBar.id = this.id + "-splitter-drag-bar";
      this.$dragBar.classList.add("spitter-drag-bar");
      this.$el.appendChild(this.$dragBar);
      this.$dragBar.tabIndex = 1;
      this.$dragBar.addEventListener("mousedown", (e) => {
        this.$dragBar.focus();
        e.preventDefault();
        this.$panel1.style.pointerEvents = "none";
        this.$panel2.style.pointerEvents = "none";
        this.$dragging = true;
        this.$ghostBar = document.createElement("div");
        this.$ghostBar.id = this.id + "-ghost-bar";
        this.$ghostBar.classList.add("splitter-ghost-bar");
        let bnd = this.$panel2.getBoundingClientRect();
        if (this.$anchor === 1 /* panel1 */)
          bnd = this.$panel1.getBoundingClientRect();
        if (this.$orientation === 0 /* horizontal */) {
          this.$ghostBar.style.left = "0";
          if (this.$anchor === 1 /* panel1 */)
            this.$ghostBar.style.top = bnd.bottom - this.$elBounds.top + "px";
          else
            this.$ghostBar.style.top = bnd.top - this.$elBounds.top - this.$splitterWidth + "px";
          this.$ghostBar.style.right = "0";
          this.$ghostBar.style.bottom = "";
          this.$ghostBar.style.width = "";
          this.$ghostBar.style.height = this.$splitterWidth + "px";
          this.$ghostBar.style.cursor = "ns-resize";
        } else {
          if (this.$anchor === 1 /* panel1 */)
            this.$ghostBar.style.left = bnd.right - this.$elBounds.left + "px";
          else
            this.$ghostBar.style.left = bnd.left - this.$elBounds.left - this.$splitterWidth + "px";
          this.$ghostBar.style.top = "0";
          this.$ghostBar.style.bottom = "0";
          this.$ghostBar.style.right = "";
          this.$ghostBar.style.height = "";
          this.$ghostBar.style.width = this.$splitterWidth + "px";
          this.$ghostBar.style.cursor = "ew-resize";
        }
        this.$ghostBar.move = (ge) => {
          let l2;
          if (this.$orientation === 0 /* horizontal */ && this.$anchor === 1 /* panel1 */) {
            l2 = ge.pageY - this.$elBounds.top;
            if (l2 < this.$panel1MinSize + this.$splitterWidth)
              this.$ghostBar.style.top = this.$panel1MinSize + "px";
            else if (l2 > this.parent.clientHeight - this.$panel2MinSize - this.$splitterWidth)
              this.$ghostBar.style.top = this.parent.clientHeight - this.$panel2MinSize - this.$splitterWidth + "px";
            else
              this.$ghostBar.style.top = l2 - 2 + "px";
            if (this.live) {
              if (l2 < this.$panel1MinSize + this.$splitterWidth)
                this.SplitterDistance = this.$panel1MinSize + this.$splitterWidth;
              else if (l2 > this.parent.clientHeight - this.$panel2MinSize - this.$splitterWidth)
                this.SplitterDistance = this.parent.clientHeight - this.$panel2MinSize;
              else
                this.SplitterDistance = l2 - 2 + this.$splitterWidth;
            }
          } else if (this.$orientation === 0 /* horizontal */) {
            l2 = ge.pageY - this.$elBounds.top;
            if (l2 < this.$panel1MinSize)
              this.$ghostBar.style.top = this.$panel1MinSize + "px";
            else if (l2 > this.parent.clientHeight - this.$panel2MinSize)
              this.$ghostBar.style.top = this.parent.clientHeight - this.$panel2MinSize + "px";
            else
              this.$ghostBar.style.top = l2 - 2 + "px";
            if (this.live) {
              if (l2 < this.$panel1MinSize)
                this.SplitterDistance = this.parent.clientHeight - this.$panel1MinSize;
              else if (l2 > this.parent.clientHeight - this.$panel2MinSize)
                this.SplitterDistance = this.$panel2MinSize;
              else
                this.SplitterDistance = this.parent.clientHeight - l2 + 2;
            }
          } else if (this.$orientation === 1 /* vertical */ && this.$anchor === 1 /* panel1 */) {
            l2 = ge.pageX - this.$elBounds.left;
            if (l2 < this.$panel1MinSize + this.$splitterWidth)
              this.$ghostBar.style.left = this.$panel1MinSize + "px";
            else if (l2 >= this.parent.clientWidth - this.$panel2MinSize - this.$splitterWidth)
              this.$ghostBar.style.left = this.parent.clientWidth - this.$panel2MinSize - this.$splitterWidth + "px";
            else
              this.$ghostBar.style.left = l2 - 2 + "px";
            if (this.live) {
              if (l2 < this.$panel1MinSize + this.$splitterWidth)
                this.SplitterDistance = this.$panel1MinSize + this.$splitterWidth;
              else if (l2 >= this.parent.clientWidth - this.$panel2MinSize - this.$splitterWidth)
                this.SplitterDistance = this.parent.clientWidth - this.$panel2MinSize;
              else
                this.SplitterDistance = l2 - 2 + this.$splitterWidth;
            }
          } else {
            l2 = ge.pageX - this.$elBounds.left;
            if (l2 < this.$panel1MinSize)
              this.$ghostBar.style.left = this.$panel1MinSize + "px";
            else if (l2 > this.parent.clientWidth - this.$panel2MinSize)
              this.$ghostBar.style.left = this.parent.clientWidth - this.$panel2MinSize + "px";
            else
              this.$ghostBar.style.left = l2 - 2 + "px";
            if (this.live) {
              if (l2 < this.$panel1MinSize)
                this.SplitterDistance = this.parent.clientWidth - this.$panel1MinSize;
              else if (l2 > this.parent.clientWidth - this.$panel2MinSize)
                this.SplitterDistance = this.$panel2MinSize;
              else
                this.SplitterDistance = this.parent.clientWidth - l2 + 2;
            }
          }
          this.emit("splitter-moving", l2);
        };
        this.$el.appendChild(this.$ghostBar);
        document.addEventListener("mousemove", this.$ghostBar.move);
      });
      this.$dragBar.addEventListener("dblclick", (e) => {
        this.emit("dblclick", e);
      });
      window.addEventListener("resize", () => {
        this.resize();
      });
      document.addEventListener("mouseup", (e) => {
        if (!this.$dragging) return;
        e.preventDefault();
        e.stopPropagation();
        e.cancelBubble = true;
        let l2;
        if (this.$orientation === 0 /* horizontal */) {
          l2 = e.pageY - this.$elBounds.top;
          if (this.$anchor === 1 /* panel1 */) {
            if (l2 < this.$panel1MinSize + this.$splitterWidth)
              this.SplitterDistance = this.$panel1MinSize + this.$splitterWidth;
            else if (l2 > this.parent.clientHeight - this.$panel2MinSize - this.$splitterWidth)
              this.SplitterDistance = this.parent.clientHeight - this.$panel2MinSize;
            else
              this.SplitterDistance = l2 - 2 + this.$splitterWidth;
          } else if (l2 < this.$panel1MinSize)
            this.SplitterDistance = this.parent.clientHeight - this.$panel1MinSize - 2;
          else if (l2 > this.parent.clientHeight - this.$panel2MinSize)
            this.SplitterDistance = this.$panel2MinSize;
          else
            this.SplitterDistance = this.parent.clientHeight - l2 + 2;
        } else {
          l2 = e.pageX - this.$elBounds.left;
          if (this.$anchor === 1 /* panel1 */) {
            if (l2 < this.$panel1MinSize + this.$splitterWidth)
              this.SplitterDistance = this.$panel1MinSize + this.$splitterWidth;
            else if (l2 > this.parent.clientWidth - this.$panel2MinSize - this.$splitterWidth)
              this.SplitterDistance = this.parent.clientWidth - this.$panel2MinSize;
            else
              this.SplitterDistance = l2 - 2 + this.$splitterWidth;
          } else if (l2 < this.$panel1MinSize)
            this.SplitterDistance = this.parent.clientWidth - this.$panel1MinSize - 2;
          else if (l2 > this.parent.clientWidth - this.$panel2MinSize)
            this.SplitterDistance = this.$panel2MinSize;
          else
            this.SplitterDistance = this.parent.clientWidth - l2 + 2;
        }
        this.$el.removeChild(this.$ghostBar);
        document.removeEventListener("mousemove", this.$ghostBar.move);
        this.$ghostBar = null;
        this.$dragging = false;
        this.$panel1.style.pointerEvents = "";
        this.$panel2.style.pointerEvents = "";
      });
      this.parent.appendChild(this.$el);
      setTimeout(() => {
        this.$elBounds = this.$el.getBoundingClientRect();
      }, 10);
      this.$resizeObserver = new ResizeObserver((entries, observer) => {
        if (entries.length === 0) return;
        if (!entries[0].contentRect || entries[0].contentRect.width === 0 || entries[0].contentRect.height === 0)
          return;
        if (!this.$resizeObserverCache || this.$resizeObserverCache.width !== entries[0].contentRect.width || this.$resizeObserverCache.height !== entries[0].contentRect.height) {
          this.$resizeObserverCache = { width: entries[0].contentRect.width, height: entries[0].contentRect.height };
          this.resize();
        }
      });
      this.$resizeObserver.observe(this.$el);
      this.$observer = new MutationObserver((mutationsList) => {
        let mutation;
        for (mutation of mutationsList) {
          if (mutation.type === "attributes" && mutation.attributeName === "style") {
            if (mutation.oldValue === "display: none;")
              this.resize();
          }
        }
      });
      this.$observer.observe(this.$el, { attributes: true, attributeOldValue: true, attributeFilter: ["style"] });
    }
    resize() {
      if (this.$orientation === 0 /* horizontal */ && this.$anchor === 1 /* panel1 */) {
        if (this.$panel2.clientHeight && this.$panel2.clientHeight < this.$panel2MinSize && this.$panel1.clientHeight > this.$panel1MinSize)
          this.SplitterDistance = this.parent.clientHeight - this.$panel2MinSize;
      } else if (this.$orientation === 0 /* horizontal */) {
        if (this.$panel1.clientHeight && this.$panel1.clientHeight < this.$panel1MinSize && this.$panel2.clientHeight > this.$panel2MinSize)
          this.SplitterDistance = this.$panel1MinSize;
      } else if (this.$orientation === 1 /* vertical */ && this.$anchor === 1 /* panel1 */) {
        if (this.$panel2.clientWidth && this.$panel2.clientWidth < this.$panel2MinSize && this.$panel1.clientWidth > this.$panel1MinSize)
          this.SplitterDistance = this.parent.clientWidth - this.$panel2MinSize;
      } else if (this.$panel1.clientWidth < this.$panel1MinSize && this.$panel2.clientWidth > this.$panel2MinSize)
        this.SplitterDistance = this.$panel1MinSize;
      this.$elBounds = this.$el.getBoundingClientRect();
    }
  };

  // src/interface/profilesdialog.ts
  var ProfilesDialog = class extends Dialog {
    constructor() {
      super(Object.assign({}, client.getOption("windows.profiles") || { center: true }, { title: 'i class="fas fa-users"></i> Profiles', minWidth: 410 }));
      this._profilesChanged = false;
      this._current = {
        profile: null,
        profileName: "",
        item: null,
        parent: null,
        itemIdx: -1,
        collection: "",
        itemSubIdx: -1
      };
      this._canClose = false;
      this._small = false;
      this.on("resized", (e) => {
        if (e.width < 430) {
          if (this._small) return;
          const item = this.header.querySelector(".breadcrumb");
          item.classList.add("breadcrumb-sm");
          this._small = true;
        } else if (this._small) {
          const item = this.header.querySelector(".breadcrumb");
          item.classList.remove("breadcrumb-sm");
          this._small = false;
        }
        client.setOption("windows.profiles", e);
      });
      client.on("profiles-loaded", () => {
        if (!this.profiles) {
          this.profiles = client.profiles.clone();
          this.profiles.SortByPriority();
          this._buildMenu();
        }
      });
      client.on("profiles-updated", () => {
      });
      client.on("options-loaded", () => {
        this.resetState(client.getOption("windows.profiles") || { center: true });
      });
      client.on("initialized", () => {
        if (!this.profiles) {
          this.profiles = client.profiles.clone();
          this.profiles.SortByPriority();
          this._buildMenu();
        }
      });
      this.body.style.padding = "10px";
      this._splitter = new Splitter({ id: "profile", parent: this.body, orientation: 1 /* vertical */, anchor: 1 /* panel1 */ });
      if (client.getOption("profiles.split") >= 200)
        this._splitter.SplitterDistance = client.getOption("profiles.split");
      this._splitter.on("splitter-moved", (distance) => {
        client.setOption("profiles.split", distance);
      });
      this._menu = this._splitter.panel1;
      this._menu.style.overflow = "hidden";
      this._menu.style.overflowY = "auto";
      this._contents = this._splitter.panel2;
      this._contents.style.overflow = "auto";
      this._contents.style.padding = "10px";
      this._contents.style.paddingLeft = "14px";
      if (client.profiles) {
        this.profiles = client.profiles.clone();
        this.profiles.SortByPriority();
        this._buildMenu();
      }
      let footer = "";
      footer += `<button id="${this.id}-back" type="button" class="btn-sm float-start btn btn-light" title="Go back"><i class="bi bi-arrow-left"></i><span class="icon-only"> Back</span></button>`;
      footer += `<button id="btn-profile-menu" class="btn-sm float-start btn btn-outline-secondary" type="button" aria-controls="profile-menu" title="Show menu" data-bs-toggle="dropdown" aria-expanded="false" style="margin-right: 4px;"><i class="fa-solid fa-bars"></i></button>`;
      footer += `<ul id="${this.id}-dropdown-menu" class="dropdown-menu" style="overflow: auto;">`;
      footer += `<li id="${this.id}-add-profile"><a class="dropdown-item">Add profile</a></li>`;
      footer += `<li id="${this.id}-add-empty-profile"><a class="dropdown-item">Add empty profile</a></li>`;
      footer += `<li id="${this.id}-add-sep"><hr class="dropdown-divider"></li>`;
      footer += `<li id="${this.id}-add-alias"><a class="dropdown-item">Add alias</a></li>`;
      footer += `<li id="${this.id}-add-macro"><a class="dropdown-item">Add macro</a></li>`;
      footer += `<li id="${this.id}-add-trigger"><a class="dropdown-item">Add trigger</a></li>`;
      footer += `<li id="${this.id}-add-button"><a class="dropdown-item">Add button</a></li>`;
      footer += `<li id="${this.id}-add-sep2"><hr class="dropdown-divider"></li>`;
      footer += `<li id="${this.id}-add-default-buttons"><a class="dropdown-item">Add default buttons</a></li>`;
      footer += `<li id="${this.id}-add-default-macros"><a class="dropdown-item">Add default macros</a></li>`;
      footer += '<li><hr class="dropdown-divider"></li>';
      footer += `<li id="${this.id}-export-current"><a class="dropdown-item">Export current profile</a></li>`;
      footer += `<li id="${this.id}-export"><a class="dropdown-item">Export profiles</a></li>`;
      footer += `<li id="${this.id}-import"><a class="dropdown-item">Import profiles</a></li>`;
      footer += '<li><hr class="dropdown-divider"></li>';
      footer += `<li id="${this.id}-refresh"><a class="dropdown-item">Refresh</a></li>`;
      footer += "</ul>";
      footer += '<span id="profile-page-buttons"></span>';
      footer += `<button id="${this.id}-cancel" type="button" class="btn-sm float-end btn btn-light" title="Close dialog"><i class="bi bi-x-lg"></i><span class="icon-only"> Cancel</span></button>`;
      footer += `<button id="${this.id}-save" type="button" class="btn-sm float-end btn btn-primary" title="Save changes" disabled><i class="bi bi-save"></i><span class="icon-only"> Save</span></button>`;
      footer += `<button id="${this.id}-apply" type="button" class="btn-sm float-end btn btn-secondary" title="Apply changes" disabled><i class="bi bi-check-lg"></i><span class="icon-only"> Apply</span></button>`;
      this.footer.innerHTML = footer;
      this.footer.classList.add("dropup");
      document.getElementById("btn-profile-menu").addEventListener("shown.bs.dropdown", () => {
        setTimeout(() => {
          let el = this.footer.querySelector("#" + this.id + "-dropdown-menu");
          let rect = el.getBoundingClientRect();
          if (rect.y < 10)
            el.style.height = rect.height + rect.y - 10 + "px";
          if (rect.bottom > document.body.clientHeight - 10)
            el.style.height = document.body.clientHeight - rect.y - 10 + "px";
        }, 0);
      });
      document.getElementById("btn-profile-menu").addEventListener("hidden.bs.dropdown", () => {
        let el = this.footer.querySelector("#" + this.id + "-dropdown-menu");
        el.style.height = "";
      });
      this.footer.querySelector(`#${this.id}-cancel`).addEventListener("click", () => {
        removeHash(this._page);
        this.close();
      });
      this.footer.querySelector(`#${this.id}-back`).addEventListener("click", () => {
        this._goBack();
      });
      this.on("closed", () => {
        client.setOption("windows.profiles", this.windowState);
        removeHash(this._page);
      });
      this.on("canceled", () => {
        client.setOption("windows.profiles", this.windowState);
        removeHash(this._page);
      });
      this.on("moved", (e) => {
        client.setOption("windows.profiles", e);
      });
      this.on("maximized", () => {
        client.setOption("windows.profiles", this.windowState);
      });
      this.on("restored", () => {
        client.setOption("windows.profiles", this.windowState);
      });
      this.on("shown", () => {
        client.setOption("windows.profiles", this.windowState);
      });
      this.footer.querySelector(`#${this.id}-add-profile a`).addEventListener("click", () => {
        this._createProfile(true);
      });
      this.footer.querySelector(`#${this.id}-add-empty-profile a`).addEventListener("click", () => {
        this._createProfile(false);
      });
      this.footer.querySelector(`#${this.id}-add-alias a`).addEventListener("click", () => {
        this._addItem("aliases");
      });
      this.footer.querySelector(`#${this.id}-add-macro a`).addEventListener("click", () => {
        this._addItem("macros");
      });
      this.footer.querySelector(`#${this.id}-add-trigger a`).addEventListener("click", () => {
        this._addItem("triggers");
      });
      this.footer.querySelector(`#${this.id}-add-button a`).addEventListener("click", () => {
        this._addItem("buttons");
      });
      this.footer.querySelector(`#${this.id}-add-default-buttons a`).addEventListener("click", () => {
        const items = Profile.DefaultButtons;
        let il = items.length;
        for (let i2 = 0; i2 < il; i2++)
          this._addItem("buttons", items[i2]);
      });
      this.footer.querySelector(`#${this.id}-add-default-macros a`).addEventListener("click", () => {
        const items = Profile.DefaultMacros;
        let il = items.length;
        for (let i2 = 0; i2 < il; i2++)
          this._addItem("macros", items[i2]);
      });
      this.footer.querySelector(`#${this.id}-export-current a`).addEventListener("click", () => {
        const data = {
          version: 2,
          profiles: {}
        };
        data.profiles[this._current.profileName] = this._current.profile.clone(2);
        fileSaveAs.show(JSON.stringify(data), `oiMUD.${this._current.profileName}.txt`, "text/plain");
      });
      this.footer.querySelector(`#${this.id}-export a`).addEventListener("click", () => {
        const data = {
          version: 2,
          profiles: this.profiles.clone(2)
        };
        fileSaveAs.show(JSON.stringify(data), "oiMUD.profiles.txt", "text/plain");
      });
      this.footer.querySelector(`#${this.id}-import a`).addEventListener("click", () => {
        openFileDialog("Import profile(s)").then((files) => {
          readFile(files[0]).then((contents) => {
            try {
              var data = JSON.parse(contents);
              if (data.version == 2) {
                if (data.profiles) {
                  var keys = Object.keys(data.profiles);
                  var n, i2, k = 0, kl = keys.length;
                  for (; k < kl; k++) {
                    n = keys[k];
                    i2 = 0;
                    while (this.profiles.contains(n)) {
                      if (i2 === 0)
                        n = keys[k] + " Copy";
                      else
                        n = keys[k] + " Copy (" + i2 + ")";
                      i2++;
                    }
                    data.profiles[keys[k]].name = n;
                    const p = Profile.load(data.profiles[keys[k]]);
                    this.profiles.add(p);
                  }
                  if (kl === 0) return;
                  this.changed = true;
                  this._buildMenu();
                  this._expandPath(this._page);
                }
              } else
                setTimeout(function() {
                  alert_box("Invalid file", "Unable to import file, not a valid profile file", 4 /* exclamation */);
                }, 50);
            } catch (err) {
              setTimeout(function() {
                alert_box("Error importing", "Error importing file.", 3 /* error */);
              }, 50);
              client.error(err);
            }
          }).catch(client.error);
        }).catch(() => {
        });
      });
      this.footer.querySelector(`#${this.id}-refresh a`).addEventListener("click", () => {
        this._buildMenu();
        this.setBody(this._page);
      });
      this.footer.querySelector(`#${this.id}-save`).addEventListener("click", () => {
        if (this._errorField) {
          this._errorField.focus();
          return;
        }
        this._save();
        this.close();
      });
      this.footer.querySelector(`#${this.id}-apply`).addEventListener("click", () => {
        if (this._errorField) {
          this._errorField.focus();
          return;
        }
        this._save();
      });
    }
    set errorField(value) {
      this._errorField = value;
    }
    get errorField() {
      return this._errorField;
    }
    get current() {
      return this._current;
    }
    set changed(value) {
      if (value === this._profilesChanged) return;
      this._profilesChanged = value;
      this.footer.querySelector(`#${this.id}-save`).disabled = !value;
      this.footer.querySelector(`#${this.id}-apply`).disabled = !value;
    }
    get changed() {
      return this._profilesChanged;
    }
    get contents() {
      return this._contents;
    }
    _getItem(collection, index, idPrefix, hrefPrefix, indent) {
      if (!collection || collection.length === 0) return "";
      let menu = "";
      indent = indent || 0;
      let padding = indent * 20 + 16;
      menu += `<li class="nav-item" title="${htmlEncode(GetDisplay(collection[index]))}" id="${idPrefix + "-" + (collection[index].useName ? this._sanitizeID(collection[index].name.toLowerCase()) : index)}">`;
      if (collection[index].items && collection[index].items.length) {
        menu += `<a style="padding-left: ${padding}px" class="nav-link text-dark" href="#${hrefPrefix}/${encodeURIComponent(collection[index].name.toLowerCase())}"><i class="align-middle float-start bi bi-chevron-right"></i> <input data-page="${hrefPrefix}/${encodeURIComponent(collection[index].name.toLowerCase())}" type="checkbox" class="form-check-input" id="enabled-${idPrefix}-${this._sanitizeID(collection[index].name.toLowerCase())}"${collection[index].enabled ? " checked" : ""}> ${htmlEncode(GetDisplay(collection[index]))}</a>`;
        menu += this._getItems(collection[index].items, idPrefix + "-" + this._sanitizeID(collection[index].name.toLowerCase()), hrefPrefix + "/" + encodeURIComponent(collection[index].name.toLowerCase()), indent + 1);
      } else if (collection[index].useName)
        menu += `<a style="padding-left: ${padding}px" class="nav-link text-dark " href="#${hrefPrefix}/${encodeURIComponent(collection[index].name.toLowerCase())}"><i class="align-middle float-start no-icon"></i> <input data-page="${hrefPrefix}/${encodeURIComponent(collection[index].name.toLowerCase())}" type="checkbox" class="form-check-input" id="enabled-${idPrefix}-${this._sanitizeID(collection[index].name.toLowerCase())}"${collection[index].enabled ? " checked" : ""}> ${htmlEncode(GetDisplay(collection[index]))}</a>`;
      else
        menu += `<a style="padding-left: ${padding}px" class="nav-link text-dark" href="#${hrefPrefix}/${index}"><i class="align-middle float-start no-icon"></i><input type="checkbox" class="form-check-input" data-page="${hrefPrefix}/${index}" id="enabled-${idPrefix}-${index}"${collection[index].enabled ? " checked" : ""}> ${htmlEncode(GetDisplay(collection[index]))}</a>`;
      menu += "</li>";
      return menu;
    }
    _getItems(collection, idPrefix, hrefPrefix, indent) {
      if (!collection || collection.length === 0) return "";
      let menu = "";
      for (let c = 0, cl = collection.length; c < cl; c++) {
        menu += this._getItem(collection, c, idPrefix, hrefPrefix, indent);
      }
      return '<ul class="dropdown-menu dropdown-inline">' + menu + "</ul>";
    }
    _buildMenu() {
      let nav = "";
      for (let k = 0, kl = this.profiles.keys.length; k < kl; k++) {
        nav += this._profile(this.profiles.keys[k]);
      }
      this._menu.innerHTML = '<ul class="nav" id="profile-menu">' + nav + "</ul>";
      let items = this._menu.querySelectorAll("a");
      for (let i2 = 0, il = items.length; i2 < il; i2++) {
        this._profileEvents(items[i2]);
      }
    }
    _profileEvents(item) {
      let items = item.querySelectorAll(".bi-chevron-right");
      let i2, il;
      for (i2 = 0, il = items.length; i2 < il; i2++)
        items[i2].addEventListener("click", (e) => {
          e.target.closest("li").querySelector(".dropdown-menu").classList.toggle("show");
          e.target.classList.toggle("bi-chevron-right");
          e.target.classList.toggle("bi-chevron-down");
          e.preventDefault();
        });
      items = item.querySelectorAll("input");
      for (i2 = 0, il = items.length; i2 < il; i2++)
        items[i2].addEventListener("change", (e) => {
          const data = e.target.dataset.page.split("/");
          const value = e.target.checked;
          switch (data.length) {
            case 2:
              if (!value && this.profiles.keys.filter((k) => this.profiles.enabled(k)).length === 1) {
                alert_box("Cannot disable", "One profile must always be enabled.");
                e.target.checked = true;
                return;
              }
              this._menu.querySelector(`#enabled-${this._sanitizeID(data[1])}`).checked = value;
              this._menu.querySelector(`#enabled-${this._sanitizeID(data[1])}-switch`).checked = value;
              if (this._page === e.target.dataset.page)
                this._contents.querySelector("#enabled").checked = value;
              this.profiles.items[data[1]].enabled = value;
              this.changed = true;
              break;
            case 3:
              this._menu.querySelector(`#enabled-${this._sanitizeID(data[1])}-${data[2]}`).checked = value;
              if (this._page === `profiles/${data[1]}`)
                this._contents.querySelector("#enable" + capitalize(data[2])).checked = value;
              this.profiles.items[data[1]]["enable" + capitalize(data[2])] = value;
              this.changed = true;
              break;
            case 4:
              this._menu.querySelector(`#enabled-${this._sanitizeID(data[1])}-${data[2]}-${data[3]}`).checked = value;
              if (this._page === e.target.dataset.page)
                this._contents.querySelector("#enabled").checked = value;
              else if (this._page === `profiles/${data[1]}/${data[2]}`)
                this._contents.querySelector("#check-" + data[3]).checked = value;
              this.profiles.items[data[1]][data[2]][+data[3]].enabled = value;
              this.changed = true;
              break;
          }
          e.stopPropagation();
          e.cancelBubble = true;
        });
      items = item.querySelectorAll(".list-badge-button");
      for (i2 = 0, il = items.length; i2 < il; i2++)
        items[i2].addEventListener("click", (e) => {
          this._deleteProfile(e.target.parentElement.dataset.profile);
          e.preventDefault();
        });
    }
    _profile(profile) {
      let nav = `<li class="nav-item" data-profile="${profile}" title="${capitalize(profile)}" id="${this._sanitizeID(profile)}">`;
      nav += `<a class="nav-link text-dark" href="#profiles/${encodeURIComponent(profile)}">`;
      if (profile !== "default")
        nav += `<span class="list-badge-button badge text-bg-danger" data-profile="${profile}"><i class="bi bi-trash"></i></span>`;
      nav += `<i class="align-middle float-start bi bi-chevron-right"></i> `;
      nav += this._item(capitalize(profile), "enabled-" + profile, this.profiles.items[profile].enabled);
      nav += `</a>`;
      nav += this._getItems([
        {
          name: "Aliases",
          items: this.profiles.items[profile].aliases,
          useName: true,
          enabled: this.profiles.items[profile].enableAliases
        },
        {
          name: "Macros",
          items: this.profiles.items[profile].macros,
          useName: true,
          enabled: this.profiles.items[profile].enableMacros
        },
        {
          name: "Triggers",
          items: this.profiles.items[profile].triggers,
          useName: true,
          enabled: this.profiles.items[profile].enableTriggers
        },
        {
          name: "Buttons",
          items: this.profiles.items[profile].buttons,
          useName: true,
          enabled: this.profiles.items[profile].enableButtons
        }
      ], this._sanitizeID(profile), "profiles/" + encodeURIComponent(profile), 1);
      nav += "</li>";
      return nav;
    }
    _item(title, id, enabled) {
      return `<span><input type="checkbox" data-page="profiles/${title.toLowerCase()}" class="form-check-input" id="${this._sanitizeID(id)}"${enabled ? " checked" : ""}> ${title}</span><div class="form-check form-switch"><input type="checkbox" class="form-check-input" id="${id}-switch"${enabled ? " checked" : ""}> ${title}</div>`;
    }
    setBody(contents, args) {
      if (!this.profiles) {
        setTimeout(() => {
          this.setBody(contents, args);
        }, 100);
        return;
      }
      if (this._errorField) {
        setTimeout(() => this._errorField.focus(), 100);
        window.location.hash = this._page;
        return;
      }
      this._page = this.dialog.dataset.path;
      if (this._page === "profiles")
        this.dialog.dataset.panel = "left";
      else
        this.dialog.dataset.panel = "right";
      const pages = this._page.split("/");
      let k, kl, p;
      this._expandPath(pages);
      this.footer.querySelector("#profile-page-buttons").innerHTML = "";
      this.footer.querySelector(`#${this.id}-export-current`).style.display = "";
      this._contents.scrollTop = 0;
      if (!this._setCurrent(pages)) {
        this.title = buildBreadcrumb(pages, true, "/");
        return;
      }
      if (pages.length === 4)
        this.title = buildBreadcrumb(pages, true, "/", (item, index, last) => index === last ? htmlEncode(GetDisplay(this._current.item)) : capitalize(item));
      else if (pages.length === 5)
        this.title = buildBreadcrumb(pages, true, "/", (item, index, last) => index === last ? htmlEncode(GetDisplay(this._current.parent)) : index === last - 1 ? htmlEncode(GetDisplay(this._current.item)) : capitalize(item));
      else
        this.title = buildBreadcrumb(pages, true, "/");
      if (pages.length < 2) {
        this.footer.querySelector(`#${this.id}-export-current`).style.display = "none";
        this.footer.querySelector(`#${this.id}-add-sep`).style.display = "none";
        this.footer.querySelector(`#${this.id}-add-alias`).style.display = "none";
        this.footer.querySelector(`#${this.id}-add-macro`).style.display = "none";
        this.footer.querySelector(`#${this.id}-add-trigger`).style.display = "none";
        this.footer.querySelector(`#${this.id}-add-button`).style.display = "none";
        this.footer.querySelector(`#${this.id}-add-sep2`).style.display = "none";
        this.footer.querySelector(`#${this.id}-add-default-buttons`).style.display = "none";
        this.footer.querySelector(`#${this.id}-add-default-macros`).style.display = "none";
        this._splitter.panel2Collapsed = true;
        this.footer.querySelector(`#${this.id}-back`).style.display = "none";
      } else {
        this.footer.querySelector(`#${this.id}-add-sep`).style.display = "";
        this.footer.querySelector(`#${this.id}-add-alias`).style.display = "";
        this.footer.querySelector(`#${this.id}-add-macro`).style.display = "";
        this.footer.querySelector(`#${this.id}-add-trigger`).style.display = "";
        this.footer.querySelector(`#${this.id}-add-button`).style.display = "";
        this.footer.querySelector(`#${this.id}-back`).style.display = "";
        this.footer.querySelector(`#${this.id}-add-sep2`).style.display = "";
        this.footer.querySelector(`#${this.id}-add-default-buttons`).style.display = "";
        this.footer.querySelector(`#${this.id}-add-default-macros`).style.display = "";
        this._splitter.panel2Collapsed = false;
      }
      if (pages.length === 2) {
        if (this._contentPage !== "properties") {
          this._loadPage("properties").then(
            (contents2) => {
              this._contentPage = "properties";
              this._setContents(contents2);
              const forms = this._contents.querySelectorAll("input");
              this._contents.querySelector("#name").disabled = this._current.profileName === "default";
              for (let f = 0, fl = forms.length; f < fl; f++)
                if (forms[f].type === "checkbox") {
                  forms[f].checked = this._current.profile[forms[f].id];
                  forms[f].addEventListener("change", (e) => {
                    const value = e.target.checked;
                    if (e.target.id === "enabled") {
                      if (!value && this.profiles.keys.filter((k2) => this.profiles.enabled(k2)).length === 1) {
                        alert_box("Cannot disable", "One profile must always be enabled.");
                        e.target.checked = true;
                        return;
                      }
                      this._menu.querySelector(`#enabled-${this._sanitizeID(this._current.profileName)}`).checked = value;
                      this._menu.querySelector(`#enabled-${this._sanitizeID(this._current.profileName)}-switch`).checked = value;
                      if (this._page === e.target.dataset.page)
                        this._contents.querySelector("#enabled").checked = value;
                      this.profiles.items[this._current.profileName].enabled = value;
                    } else {
                      this._current.profile[e.target.id] = value;
                      this._menu.querySelector(`#enabled-${this._sanitizeID(this._current.profileName)}-${e.target.id.substring(6).toLowerCase()}`).checked = value;
                      this.changed = true;
                    }
                    this.changed = true;
                  });
                } else {
                  forms[f].value = this._current.profile[forms[f].id];
                  forms[f].addEventListener("change", (e) => {
                    const target = e.currentTarget || e.target;
                    if (target.id === "name") {
                      debounce(() => {
                        let err = this._renameProfile(target.value);
                        if (err === true) {
                          forms[f].classList.remove("is-invalid");
                          this._errorField = null;
                        } else {
                          forms[f].classList.add("is-invalid");
                          this._errorField = forms[f];
                          this._contents.querySelector("#name-feedback").textContent = err;
                        }
                        this._sortProfiles();
                      }, 200, "renameProfile");
                    } else {
                      this._current.profile[target.id] = target.value;
                      debounce(() => this._sortProfiles(), 200, "sortProfiles");
                    }
                    this.changed = true;
                  });
                  forms[f].addEventListener("input", (e) => {
                    const target = e.currentTarget || e.target;
                    if (target.id === "name") {
                      debounce(() => {
                        let err = this._renameProfile(target.value);
                        if (err === true) {
                          forms[f].classList.remove("is-invalid");
                          this._errorField = null;
                        } else {
                          forms[f].classList.add("is-invalid");
                          this._errorField = forms[f];
                          this._contents.querySelector("#name-feedback").textContent = err;
                        }
                        this._sortProfiles();
                      }, 200, "renameProfile");
                    } else {
                      this._current.profile[target.id] = target.value;
                      debounce(() => this._sortProfiles(), 200, "sortProfiles");
                    }
                    this.changed = true;
                  });
                }
            }
          ).catch(() => {
          });
        } else {
          this._contents.querySelector("#name").disabled = this._current.profileName === "default";
          const forms = this._contents.querySelectorAll("input");
          for (let f = 0, fl = forms.length; f < fl; f++) {
            if (forms[f].type === "checkbox")
              forms[f].checked = this._current.profile[forms[f].id];
            else
              forms[f].value = this._current.profile[forms[f].id];
          }
        }
        if (this._current.profileName !== "default") {
          let b = `<button id="${this.id}-remove" type="button" class="btn-sm btn btn-danger" title="Remove profile"><i class="bi bi-trash"></i></button>`;
          this.footer.querySelector("#profile-page-buttons").innerHTML = b;
          this.footer.querySelector(`#${this.id}-remove`).addEventListener("click", (e) => {
            if (this._errorField)
              this._errorField = null;
            this._deleteProfile(this._current.profileName);
          });
        }
      } else if (pages.length === 3) {
        let pp = "";
        if (this._current.item.length === 0) {
          p = '<h1 id="empty" style="width: 100%;text-align:center">No ' + this._current.collection + ".</h1>";
          p += `<button id="${this.id}-add-contents" type="button" class="btn-sm float-start btn btn-outline-secondary" title="Add ${this._getItemType()}"><i class="bi bi-plus-lg"></i> Add ${this._getItemType()}</button>`;
        } else {
          p = "";
          for (k = 0, kl = this._current.item.length; k < kl; k++) {
            p += `<a data-profile ="${this._current.profileName}" id="item-${k}" data-index="${k}" href="#profiles/${encodeURIComponent(this._current.profileName)}/${this._current.collection}/${k}" class="list-group-item list-group-item-action">`;
            p += `<span data-index="${k}" class="list-badge-button badge text-bg-danger"><i class="bi bi-trash"></i></span>`;
            p += `<div class="form-check-inline form-switch" style="margin: 0;">`;
            p += `<input type="checkbox" class="form-check-input" id="check-${k}" data-profile="${this._current.profileName}" data-index="${k}" data-field="enabled" data-items="${this._current.collection}"${this._current.item[k].enabled ? ' checked="checked"' : ""}>`;
            p += `</div>${htmlEncode(GetDisplay(this._current.item[k]))}</a>`;
          }
          pp = `<button id="${this.id}-add-contents" type="button" class="btn-sm btn btn-outline-secondary" title="Add ${this._getItemType()}" style="margin-bottom: 5px;width:100%;"><i class="bi bi-plus-lg"></i> Add ${this._getItemType()}</button>`;
        }
        let b = `<button id="${this.id}-add" type="button" class="btn-sm float-start btn btn-outline-secondary" title="Add ${this._getItemType()}"><i class="bi bi-plus-lg"></i></button>`;
        this.footer.querySelector("#profile-page-buttons").innerHTML = b;
        this._setContents(pp + '<div class="list-group">' + p + "</div>");
        let items = this._contents.querySelectorAll(".list-badge-button");
        for (let i2 = 0, il = items.length; i2 < il; i2++)
          items[i2].addEventListener("click", (e) => {
            this._removeItem(+e.target.parentElement.dataset.index);
            e.stopPropagation();
            e.cancelBubble = true;
            e.preventDefault();
          });
        this._contentPage = null;
        this.footer.querySelector(`#${this.id}-add`).addEventListener("click", () => {
          this._addItem();
        });
        if (this._contents.querySelector(`#${this.id}-add-contents`))
          this._contents.querySelector(`#${this.id}-add-contents`).addEventListener("click", () => {
            this._addItem();
          });
        items = this._contents.querySelectorAll("input");
        for (let i2 = 0, il = items.length; i2 < il; i2++)
          items[i2].addEventListener("change", (e) => {
            const target = e.currentTarget || e.target;
            const value = target.checked;
            this._menu.querySelector(`#enabled-${this._sanitizeID(this._current.profileName)}-${this._current.collection}-${target.dataset.index}`).checked = value;
            this._current.profile[this._current.collection][+target.dataset.index].enabled = value;
            this.changed = true;
          });
      } else if (pages.length === 4) {
        let b = `<button id="${this.id}-remove" type="button" class="btn-sm btn btn-danger" title="Remove ${this._getItemType()}"><i class="bi bi-trash"></i></button>`;
        this.footer.querySelector("#profile-page-buttons").innerHTML = b;
        this.footer.querySelector(`#${this.id}-remove`).addEventListener("click", (e) => {
          this._removeItem(this._current.itemIdx, 0, true);
          e.stopPropagation();
          e.cancelBubble = true;
          e.preventDefault();
        });
        if (this._contentPage !== this._current.collection) {
          this._contentPage = this._current.collection;
          this._loadPage(this._current.collection).then((contents2) => {
            this._setContents(contents2);
            this._loadItem(true);
          }).catch(() => {
          });
        } else
          this._loadItem();
      } else if (pages.length === 5) {
        let b = `<button id="${this.id}-remove" type="button" class="btn-sm btn btn-danger" title="Remove ${this._getItemType()}"><i class="bi bi-trash"></i></button>`;
        this.footer.querySelector("#profile-page-buttons").innerHTML = b;
        this.footer.querySelector(`#${this.id}-remove`).addEventListener("click", (e) => {
          this._removeItem(this._current.itemIdx, 0, true);
          e.stopPropagation();
          e.cancelBubble = true;
          e.preventDefault();
        });
        if (this._contentPage !== this._current.collection) {
          this._contentPage = this._current.collection;
          this._loadPage(this._current.collection).then((contents2) => this._setContents(contents2)).catch(() => {
            this._loadItem(true);
          });
        } else
          this._loadItem();
      } else {
        let b = `<button id="btn-${this.id}-add-profile" type="button" class="btn-sm btn btn-outline-secondary" title="Add profile"><i class="bi bi-plus-lg"></i></button>`;
        this.footer.querySelector("#profile-page-buttons").innerHTML = b;
        this.footer.querySelector(`#btn-${this.id}-add-profile`).addEventListener("click", () => {
          this._createProfile(true);
        });
        this._contentPage = null;
        this._setContents("");
      }
    }
    _setCurrent(pages) {
      if (!pages)
        return false;
      this._current.itemIdx = this._current.itemSubIdx = -1;
      this._current.parent = null;
      if (pages.length > 1) {
        this._current.profileName = pages[1];
        if (!this.profiles.contains(this._current.profileName)) {
          this._setContents(`<h1 id="empty" style="width: 100%;text-align:center">Profile ${this._current.profileName} not found.</h1>`);
          this._contentPage = null;
          return false;
        }
        this._current.profile = this.profiles.items[this._current.profileName];
      }
      if (pages.length > 2) {
        this._current.collection = pages[2];
        if (!this._current.profile[this._current.collection]) {
          this._setContents(`<h1 id="empty" style="width: 100%;text-align:center">${capitalize(this._current.collection)} not found in ${this._current.profileName}.</h1>`);
          this._contentPage = null;
          return false;
        }
        this._current.item = this._current.profile[pages[2]];
      }
      if (pages.length > 3) {
        this._current.itemIdx = +pages[3];
        if (this._current.itemIdx < 0 || this._current.itemIdx >= this._current.item.length) {
          this._setContents(`<h1 id="empty" style="width: 100%;text-align:center">${capitalize(this._getItemType())} not found.</h1>`);
          this._contentPage = null;
          return;
        }
        this._current.item = this._current.profile[pages[2]][this._current.itemIdx];
      }
      if (pages.length > 4) {
        this._current.itemSubIdx = +pages[4];
        if (!this._current.item.triggers) {
          this._setContents(`<h1 id="empty" style="width: 100%;text-align:center">Invalid trigger.</h1>`);
          this._contentPage = null;
          return;
        }
        if (this._current.itemSubIdx < 0 || this._current.itemSubIdx >= this._current.item.triggers.length) {
          this._setContents(`<h1 id="empty" style="width: 100%;text-align:center">Trigger state not found.</h1>`);
          this._contentPage = null;
          return;
        }
        this._current.parent = this._current.item;
        this._current.item = this._current.item.triggers[this._current.itemSubIdx];
      }
      return true;
    }
    _loadPage(page) {
      return new Promise((resolve, reject) => {
        $.ajax({
          url: "dialogs/profiles-" + page + ".htm",
          cache: false,
          type: "GET"
        }).done((data) => {
          data = data.replace(/{profileURL}/g, encodeURIComponent(this._current.profileName)).replace(/{profile}/g, this._current.profileName);
          resolve(data);
        }).fail(function() {
          reject("");
        });
      });
    }
    _setContents(contents) {
      this._contents.innerHTML = contents;
      const scripts = this._contents.querySelectorAll("script");
      const args = {
        client,
        item: this._current.item,
        FilterArrayByKeyValue,
        keyCharToCode,
        keyCodeToChar,
        profile: this._current.profile,
        profileName: this._current.profileName,
        parent: this._current.parent,
        current: this._current,
        GetDisplay,
        Trigger,
        debounce,
        updateHash,
        DialogButtons
      };
      this.emit("content-changing");
      for (let s = 0, sl = scripts.length; s < sl; s++) {
        let script = new Function("body", "dialog", ...Object.keys(args), "try { " + scripts[s].textContent + "}catch(e){client.error(e)}");
        script.apply(client, [this._contents, this, ...Object.values(args), this]);
      }
      this.emit("content-changed");
    }
    _loadItem(events) {
      const forms = this._contents.querySelectorAll("input,select,textarea");
      for (let f = 0, fl = forms.length; f < fl; f++) {
        if (!(forms[f].id in this._current.item) && forms[f].dataset.enum !== "true")
          continue;
        if (forms[f].type === "checkbox") {
          if (forms[f].dataset.enum === "true") {
            const name2 = forms[f].name || forms[f].id.substring(0, forms[f].id.lastIndexOf("-"));
            const value = +forms[f].id.substring(forms[f].id.lastIndexOf("-") + 1);
            forms[f].checked = (this._current.item[name2] & value) === value;
          } else
            forms[f].checked = this._current.item[forms[f].id];
          if (events)
            forms[f].addEventListener("change", (e) => {
              const target = e.currentTarget || e.target;
              if (target.style.display === "none") return;
              if (target.dataset.enum === "true") {
                const name2 = target.name || target.id.substring(0, target.id.lastIndexOf("-"));
                const enums = this.body.querySelectorAll(`[name=${name2}]`);
                let value = 0;
                for (let e2 = 0, el = enums.length; e2 < el; e2++) {
                  if (enums[e2].checked)
                    value |= +enums[e2].value;
                }
                this._current.item[name2] = value;
              } else {
                this._current.item[target.id] = target.checked || false;
                if (target.id === "enabled")
                  this._menu.querySelector(`#enabled-${this._sanitizeID(this._current.profileName)}-${this._current.collection}-${this._current.itemIdx}`).checked = this._current.item[target.id];
              }
              this.changed = true;
              this._updateItemMenu();
            });
        } else {
          forms[f].value = this._current.item[forms[f].id];
          if (events) {
            forms[f].addEventListener("change", (e) => {
              const target = e.currentTarget || e.target;
              if (target.style.display === "none") return;
              this.setValue(this._current.item, target.id, target.value);
              this.changed = true;
              this._updateItemMenu();
            });
            forms[f].addEventListener("input", (e) => {
              const target = e.currentTarget || e.target;
              if (target.style.display === "none") return;
              this.setValue(this._current.item, target.id, target.value);
              this.changed = true;
              this._updateItemMenu();
            });
          }
          let c = this.changed;
          forms[f].dispatchEvent(new Event("change"));
          this.changed = c;
        }
      }
      this.emit("item-loaded", this._current);
    }
    _updateItemMenu(currentItem, profile, collection, index) {
      profile = profile || this._current.profileName;
      collection = collection || this._current.collection;
      if (typeof index !== "number")
        index = this._current.itemIdx;
      const currentParent = this._current.parent;
      currentItem = currentItem || this._current.item;
      debounce(() => {
        let item = this.body.querySelector(`#${this._sanitizeID(profile)}-${collection}-${index}`);
        if (!item) return;
        let display;
        display = GetDisplay(currentParent || currentItem);
        item.title = display;
        item.firstChild.childNodes[2].textContent = " " + display;
        let bc = this.header.querySelector("ol").children;
        if (bc.length > 4) {
          if (bc[4].children.length)
            bc[4].children[0].textContent = display;
          else
            bc[4].textContent = display;
        }
        if (bc.length > 5) {
          bc[5].textContent = GetDisplay(currentItem);
        }
      }, 200, "updateItemMenu");
    }
    _expandPath(pages, select) {
      if (!Array.isArray(pages))
        pages = pages.split("/");
      let id;
      let el;
      let expand;
      let po = 0;
      if (pages[0] === "profiles")
        po = 1;
      let last = pages.length - 1;
      for (let p = po, pl = pages.length; p < pl; p++) {
        id = this._sanitizeID(pages.slice(po, p + 1).join("-"));
        el = document.getElementById(id);
        if (!el) continue;
        if (p === last) {
          setTimeout(() => {
            const items = this._menu.querySelectorAll(".active");
            for (let i2 = 0, il = items.length; i2 < il; i2++)
              items[i2].classList.remove("active");
            scrollChildIntoView(this._menu, el);
            el.classList.add("active");
            if (select)
              el.firstChild.click();
          }, 100);
        } else {
          expand = el.querySelector(".dropdown-menu");
          if (!expand || expand.classList.contains("show")) continue;
          el = el.querySelector("i");
          if (el) {
            el.closest("li").querySelector(".dropdown-menu").classList.toggle("show");
            el.classList.toggle("bi-chevron-right");
            el.classList.toggle("bi-chevron-down");
          }
        }
      }
    }
    _goBack() {
      if (this._errorField) {
        this._errorField.focus();
        return;
      }
      const pages = this._page.split("/");
      if (pages.length === 5)
        updateHash(pages.slice(0, pages.length - 2).join("/"), this._page);
      else
        updateHash(pages.slice(0, pages.length - 1).join("/"), this._page);
    }
    _createProfile(defaults) {
      let i2 = this.profiles.length;
      let name2 = "NewProfile" + i2;
      while (this.profiles.contains(name2)) {
        i2++;
        name2 = "NewProfile" + i2;
      }
      const profile = new Profile(name2, defaults);
      name2 = name2.toLowerCase();
      this.profiles.add(profile);
      this.profiles.SortByPriority();
      let menuItem = this._profile(name2);
      i2 = this.profiles.keys.indexOf(name2);
      const menu = document.getElementById("profile-menu");
      if (i2 === -1 || i2 >= menu.children.length)
        i2 = menu.children.length - 1;
      if (i2 < 0) i2 = 0;
      menu.children[i2].insertAdjacentHTML("afterend", menuItem);
      this._profileEvents(menu.children[i2 + 1]);
      this.changed = true;
      updateHash("profiles/" + name2, this._page);
    }
    _deleteProfile(profile) {
      if (!profile) return false;
      confirm_box("Remove profile?", `Delete "${profile}"?`).then((e) => {
        if (e.button === 4 /* Yes */) {
          this.profiles.remove(profile);
          this._menu.querySelector("#" + profile).remove();
          if (this._page.startsWith("profiles/" + profile))
            updateHash("profiles", this._page);
          this.changed = true;
        }
      });
    }
    _renameProfile(name2, oldProfile) {
      if (!name2) return "Name can not be empty!";
      oldProfile = (oldProfile || this._current.profileName).toLowerCase();
      name2 = name2.toLowerCase();
      if (name2 === oldProfile) return true;
      if (this.profiles.contains(name2))
        return "A profile named " + name2 + " already exists!";
      this.profiles.remove(oldProfile);
      this._current.profile.name = name2;
      this._current.profileName = name2;
      this.profiles.add(this._current.profile);
      const oldID = this._sanitizeID(oldProfile);
      const newID = this._sanitizeID(name2);
      let items;
      items = this.body.querySelector(`#${oldID} a`);
      items.children[2].childNodes[1].textContent = " " + capitalize(name2);
      document.querySelector(`#${oldID} a`).children[3].childNodes[1].textContent = " " + capitalize(name2);
      items = this.body.querySelector(`#${oldID}`);
      items.id = newID;
      items.title = name2;
      this._replaceProfileName(this._menu.firstChild, oldProfile, name2);
      this._replaceProfileName(this._contents, oldProfile, name2);
      this.header.querySelector("ol").children[2].textContent = capitalize(name2);
      return true;
    }
    _replaceProfileName(container, oldName, newName) {
      let items;
      let i2, il;
      const oldID = this._sanitizeID(oldName);
      const newID = this._sanitizeID(newName);
      items = container.querySelectorAll(`[id*="-${oldID}-"]`);
      for (i2 = 0, il = items.length; i2 < il; i2++)
        items[i2].id = items[i2].id.replace(`-${oldID}-`, `-${newID}-`);
      items = container.querySelectorAll(`[id$="-${oldID}"]`);
      for (i2 = 0, il = items.length; i2 < il; i2++)
        items[i2].id = items[i2].id.replace(`-${oldID}`, `-${newID}`);
      items = container.querySelectorAll(`[id^="${oldID}-"]`);
      for (i2 = 0, il = items.length; i2 < il; i2++)
        items[i2].id = items[i2].id.replace(`${oldID}-`, `${newID}-`);
      items = container.querySelectorAll(`[data-profile="${oldID}"]`);
      for (i2 = 0, il = items.length; i2 < il; i2++)
        items[i2].dataset.profile = newID;
      const oldPath = encodeURIComponent(oldName);
      const newPath2 = encodeURIComponent(newName);
      items = container.querySelectorAll(`[href*="/${oldPath}/"]`);
      for (i2 = 0, il = items.length; i2 < il; i2++)
        items[i2].href = items[i2].getAttribute("href").replace(`/${oldPath}/`, `/${newPath2}/`);
      items = container.querySelectorAll(`[href$="/${oldPath}"]`);
      for (i2 = 0, il = items.length; i2 < il; i2++)
        items[i2].href = items[i2].getAttribute("href").replace(`/${oldPath}`, `/${newPath2}`);
      items = container.querySelectorAll(`[href^="${oldPath}/"]`);
      for (i2 = 0, il = items.length; i2 < il; i2++)
        items[i2].href = items[i2].getAttribute("href").replace(`${oldPath}/`, `${newPath2}/`);
      items = container.querySelectorAll(`[data-path*="/${oldPath}/"]`);
      for (i2 = 0, il = items.length; i2 < il; i2++)
        items[i2].dataset.path = items[i2].dataset.path.replace(`/${oldPath}`, `/${newPath2}`);
      items = container.querySelectorAll(`[data-page*="/${oldPath}/"]`);
      for (i2 = 0, il = items.length; i2 < il; i2++)
        items[i2].dataset.page = items[i2].dataset.page.replace(`/${oldPath}/`, `/${newPath2}/`);
      items = container.querySelectorAll(`[data-page$="/${oldPath}"]`);
      for (i2 = 0, il = items.length; i2 < il; i2++)
        items[i2].dataset.page = items[i2].dataset.page.replace(`/${oldPath}`, `/${newPath2}`);
    }
    _sortProfiles() {
      this.profiles.SortByPriority();
      const menu = this._menu.firstChild;
      const items = Array.from(menu.children);
      items.sort((a, b) => {
        let ap = this.profiles.items[a.dataset.profile].priority;
        let bp = this.profiles.items[b.dataset.profile].priority;
        if (ap > bp)
          return -1;
        if (ap < bp)
          return 1;
        if (a.dataset.profile === "default")
          return -1;
        if (b.dataset.profile === "default")
          return 1;
        ap = a.dataset.profile;
        bp = b.dataset.profile;
        if (ap > bp)
          return 1;
        if (ap < bp)
          return -1;
        return 0;
      });
      items.forEach((item) => menu.appendChild(item));
    }
    _save() {
      if (!this.changed) return true;
      if (this._errorField) {
        this._errorField.focus();
        return false;
      }
      this.profiles.save().then(() => {
        client.loadProfiles().then(() => {
        });
      });
      this.changed = false;
      return true;
    }
    close() {
      if (!this._canClose) {
        this._confirmSave().then((r) => {
          if (r) {
            if (!this._save()) return;
          }
          this._canClose = true;
          this.close();
        }).catch(() => {
          this._canClose = false;
        });
      } else
        super.close();
    }
    reload() {
      if (!this._setCurrent(this._page.split("/")))
        return;
      this._loadItem();
      this._updateItemMenu();
    }
    _confirmSave() {
      return new Promise((resolve, reject) => {
        if (this._profilesChanged) {
          confirm_box("Save changes?", `Save changes to profiles?`, null, 12 /* YesNo */ | 2 /* Cancel */).then((e) => {
            if (e.button === 4 /* Yes */)
              resolve(true);
            else if (e.button === 8 /* No */)
              resolve(false);
            else
              reject();
          }).catch((e) => {
            reject();
          });
        } else
          resolve(true);
      });
    }
    _sanitizeID(name2) {
      return name2.toLowerCase().replace(/[^a-z0-9:.-]+/gi, "_");
    }
    _getItemType(collection) {
      collection = collection || this._current.collection;
      if (!collection) return;
      if (collection === "aliases") return "alias";
      return collection.substring(0, collection.length - 1);
    }
    _addItem(collection, item) {
      if (!collection) collection = this._current.collection;
      if (!collection) return;
      var index = this._current.profile[collection].length;
      let menuItem;
      if (!item) {
        if (collection === "aliases")
          item = new Alias();
        else if (collection === "triggers")
          item = new Trigger();
        else if (collection === "buttons")
          item = new Button();
        else if (collection === "macros")
          item = new Macro();
        else if (collection === "context")
          item = new Context();
      }
      this._current.profile[collection].push(item);
      let m = this._menu.querySelector(`#${this._sanitizeID(this._current.profileName)}-${collection}`);
      if (index === 0) {
        menuItem = this._getItem([{
          name: capitalize(collection),
          items: this._current.profile[collection],
          useName: true,
          enabled: this._current.profile[collection]
        }], 0, this._sanitizeID(this._current.profileName), "profiles/" + encodeURIComponent(this._current.profileName), 1);
        var newNode = document.createElement("div");
        newNode.innerHTML = menuItem;
        if (m.replaceWith)
          m.replaceWith(newNode.firstChild);
        else if (m.replaceChild)
          m.parentNode.replaceChild(newNode.firstChild, m);
        else
          m.outerHTML = menuItem;
        m = this._menu.querySelector(`#${this._sanitizeID(this._current.profileName)}-${collection}`);
        this._profileEvents(m);
      } else {
        menuItem = this._getItem(this._current.profile[collection], index, `${this._sanitizeID(this._current.profileName)}-${collection}`, `profiles/${encodeURIComponent(this._current.profileName)}/${collection}`, 2);
        m = m.querySelector("ul");
        m.insertAdjacentHTML("beforeend", menuItem);
        m = this._menu.querySelector(`#${this._sanitizeID(this._current.profileName)}-${collection}`);
        this._profileEvents(m.lastChild);
      }
      updateHash(`profiles/${encodeURIComponent(this._current.profileName)}/${collection}/${index}`, this._page);
      this.changed = true;
    }
    _removeItem(index, collection, back) {
      if (!collection) collection = this._current.collection;
      if (!collection) return;
      confirm_box("Remove profile?", `Delete ${this._getItemType()}?`).then((e) => {
        if (e.button === 4 /* Yes */) {
          const id = `${this._sanitizeID(this._current.profileName)}-${collection}`;
          const items = this._current.profile[collection];
          items.splice(index, 1);
          this._menu.querySelector(`#${id}-${index}`).remove();
          if (this._current.itemIdx === -1)
            this.setBody(this._page);
          if (items.length === 0) {
            this._menu.querySelector(`#${id} i`).remove();
            this._menu.querySelector(`#${id} a`).insertAdjacentHTML("afterbegin", '<i class="align-middle float-start no-icon"></i>');
          } else {
            const menuItems = this._menu.querySelector(`#${id} ul`);
            let i2 = menuItems.children.length;
            const href = `#profiles/${encodeURIComponent(this._current.profileName)}/${collection}/`;
            for (; index < i2; index++) {
              const item = menuItems.children[index];
              item.id = `${id}-${index}`;
              item.firstChild.href = `${href}${index}`;
              item.firstChild.children[1].id = `enabled-${id}-${index}`;
            }
          }
          this.changed = true;
          if (back)
            this._goBack();
        }
      });
    }
    setValue(obj, prop, value) {
      if (value == "false") value = false;
      if (value == "true") value = true;
      if (value == "null") value = null;
      if (value == "undefined") value = void 0;
      if (typeof value == "string" && parseFloat(value).toString() == value)
        value = parseFloat(value);
      obj[prop] = this.convertType(value, typeof obj[prop]);
    }
    convertType(value, type) {
      if (typeof value === type)
        return value;
      switch (type) {
        case "number":
          if (typeof value == "string" && parseFloat(value).toString() == value)
            return parseFloat(value);
          return Number(value);
        case "boolean":
          return Boolean(value);
        case "string":
          return "" + value;
      }
      return value;
    }
  };
  function GetDisplay(arr) {
    if (arr.displaytype === 1) {
      const f = new Function("item", "keyCodeToChar", "MacroDisplay", arr.display);
      return f(arr, keyCodeToChar, MacroDisplay);
    }
    if ($.isFunction(arr.display))
      return arr.display(arr);
    if ($.isFunction(arr[arr.display]))
      return arr[arr.display](arr);
    if (!arr[arr.display])
      return arr["name"];
    return arr[arr.display];
  }

  // src/interface/contextmenu.ts
  var Contextmenu = class _Contextmenu extends EventEmitter {
    constructor(items, id) {
      super();
      this._cleanUp = () => {
        window.removeEventListener("click", this._cleanUp);
        window.removeEventListener("mousedown", this._mouseup);
        window.removeEventListener("keydown", this._cleanUp);
        if (this._menu)
          this._menu.remove();
      };
      this._mouseup = (e) => {
        if (this._menu.contains(e.srcElement)) return;
        this._cleanUp();
      };
      this._items = items || [];
      this._id = id || (/* @__PURE__ */ new Date()).getTime();
      this._createMenu();
    }
    _createMenu() {
      if (!this._menu) {
        let menu = `<ul id="${this._id}" class="dropdown-menu show">`;
        for (var i2 = 0, il = this._items.length; i2 < il; i2++) {
          menu += `<li><a class="dropdown-item" data-index="${i2}" href="#">${this._items[i2].name}</a></li>`;
        }
        menu += "</ul>";
        document.body.insertAdjacentHTML("afterend", menu);
        this._menu = document.getElementById(this._id);
      }
      let items = this._menu.querySelectorAll("li a");
      for (let i3 = 0, il2 = items.length; i3 < il2; i3++) {
        items[i3].addEventListener("click", (e) => {
          let index = +e.currentTarget.dataset.index;
          if (typeof this._items[index].action === "function")
            this._items[index].action(this._items[i3], e);
          this._cleanUp();
        });
      }
    }
    close() {
      this._cleanUp();
    }
    show(x2, y2) {
      this._menu.style.left = x2 + "px";
      this._menu.style.top = y2 + "px";
      this._menu.style.display = "block";
      this._menu.style.position = "absolute";
      setTimeout(() => {
        window.addEventListener("click", this._cleanUp);
        window.addEventListener("mousedown", this._mouseup);
        window.addEventListener("keydown", this._cleanUp);
      }, 100);
    }
    static popup(items, x2, y2) {
      new _Contextmenu(items).show(x2, y2);
    }
  };

  // src/interface/interface.ts
  var editor;
  var editorDialog;
  var _currentIcon = -1;
  var _selword = "";
  var _selurl = "";
  var _selline = "";
  var lastMouse;
  function doLink(url) {
    confirm_box("Open?", `Open '${url}'?`).then((e) => {
      if (e.button === 4 /* Yes */) {
        window.open(url);
        if (client.getOption("CommandonClick"))
          client.commandInput.focus();
      }
    });
  }
  function doMXPLink(el, url) {
    if (url.startsWith("OoMUD://") || url.startsWith("jiMUD://") || url.startsWith("client://"))
      doMXPSend(0, el, url.substring(8));
    else {
      confirm_box("Open?", `Open '${url}'?`).then((e) => {
        if (e.button === 4 /* Yes */) {
          window.open(url);
          if (client.getOption("CommandonClick"))
            client.commandInput.focus();
        }
      });
    }
  }
  function doMXPSend(e, el, url, pmt, tt) {
    var im = el.querySelector("img[ismap]");
    var extra = "";
    if (im) {
      var os = offset(im);
      var x2 = Math.floor(e.clientX - os.left);
      var y2 = Math.floor(e.clientY - os.top);
      extra = "?" + x2 + "," + y2;
    }
    if (url.constructor === Array || url.__proto__.constructor === Array || Object.prototype.toString.call(url) === "[object Array]") {
      let items = [];
      for (var i2 = 0, il = url.length; i2 < il; i2++) {
        url[i2] = url[i2].replace("&text;", el.textContent);
        if (i2 < tt.length)
          items.push({
            name: tt[i2],
            action: (item) => MXPMenuHandler(item.cmd, item.pmt),
            pmt,
            cmd: url[i2] + extra
          });
        else
          items.push({
            name: url[i2],
            action: (item) => MXPMenuHandler(item.cmd, item.pmt),
            pmt,
            cmd: url[i2] + extra
          });
      }
      Contextmenu.popup(items, e.clientX, e.clientY);
    } else if (pmt) {
      url = url.replace("&text;", el.textContent) + extra;
      client.commandInput.value = url;
      setSelectionRange(client.commandInput, url.length, url.length);
    } else
      client.send(url.replace("&text;", el.textContent) + extra + "\n", true);
    setTimeout(() => {
      if (client.getOption("CommandonClick"))
        client.commandInput.focus();
    }, 0);
  }
  function MXPMenuHandler(cmd, pmt) {
    if (pmt) {
      client.commandInput.value = cmd;
      setSelectionRange(client.commandInput, cmd.length, cmd.length);
    } else
      client.send(cmd, true);
    setTimeout(() => {
      if (client.getOption("CommandonClick"))
        client.commandInput.focus();
    }, 0);
  }
  function doMXPTooltip(el) {
    el.title = el.title.replace("&text;", el.textContent);
  }
  window.doLink = doLink;
  window.doMXPLink = doMXPLink;
  window.doMXPSend = doMXPSend;
  window.MXPMenuHandler = MXPMenuHandler;
  window.doMXPTooltip = doMXPTooltip;
  function initializeInterface() {
    let options;
    _setIcon(0);
    initMenu();
    window.readClipboard = () => pasteText();
    window.readClipboardHTML = () => pasteText();
    client.readClipboard = window.readClipboard;
    client.readClipboardHTML = window.readClipboardHTML;
    window.writeClipboard = (txt, html) => copyText(txt);
    client.writeClipboard = window.writeClipboard;
    client.closeWindow = (window2) => {
      switch (window2) {
        case "editor":
        case "help":
        case "about":
          closeDialog(window2);
          break;
        case "profiles":
        case "profiles-manager":
        case "profile-manager":
        case "manager":
          closeDialog("profiles");
          break;
        case "prefs":
        case "options":
        case "preferences":
          closeDialog("settings");
          break;
        case "history":
        case "command-history":
          closeDialog("history");
          break;
        default:
          client.emit("close-window", window2);
          break;
      }
    };
    ["repeatnum", "i"].forEach((a) => {
      Object.defineProperty(window, a, {
        get: function() {
          if (!client) return void 0;
          return client.repeatnum;
        },
        configurable: true
      });
    });
    Object.defineProperty(window, "$selected", {
      get: function() {
        if (!client) return "";
        return client.display.selection;
      },
      configurable: true
    });
    Object.defineProperty(window, "$copied", {
      get: function() {
        return "";
      },
      configurable: true
    });
    Object.defineProperty(window, "$selword", {
      get: function() {
        if (!client) return "";
        return client.input.vStack["$selword"] || _selword || (lastMouse ? client.display.getWordFromPosition(lastMouse.pageX, lastMouse.pageY) : "");
      },
      configurable: true
    });
    Object.defineProperty(window, "$selurl", {
      get: function() {
        if (!client) return "";
        let value = client.input.vStack["$selurl"] || _selurl || "";
        if (value) return value;
        if (!lastMouse) return "";
        var parent = lastMouse.srcElement.parentNode;
        if (parent && parent.classList && parent.classList.contains("URLLink"))
          return parent.title;
        else if (parent && parent.classList && parent.classList.contains("MXPLink") && parent.dataset && parent.dataset.href && parent.dataset.href.length > 0)
          return parent.dataset.href;
        return "";
      },
      configurable: true
    });
    Object.defineProperty(window, "$selline", {
      get: function() {
        if (!client) return "";
        let value = client.input.vStack["$selline"] || _selline || "";
        if (value) return value;
        if (!lastMouse) return "";
        var pos = client.display.getLineOffset(lastMouse.pageX, lastMouse.pageY);
        if (pos.y < 0 || pos.y >= client.display.lines.length)
          return "";
        return client.display.getLineText(pos.y, true);
      },
      configurable: true
    });
    Object.defineProperty(window, "$selectedword", {
      get: function() {
        if (!client) return "";
        return client.input.vStack["$selectedword"] || _selword || (lastMouse ? client.display.getWordFromPosition(lastMouse.pageX, lastMouse.pageY) : "");
      },
      configurable: true
    });
    Object.defineProperty(window, "$selectedurl", {
      get: function() {
        if (!client) return "";
        let value = client.input.vStack["$selectedurl"] || _selurl || "";
        if (value) return value;
        if (!lastMouse) return "";
        var parent = lastMouse.srcElement.parentNode;
        if (parent && parent.classList && parent.classList.contains("URLLink"))
          return parent.title;
        else if (parent && parent.classList && parent.classList.contains("MXPLink") && parent.dataset && parent.dataset.href && parent.dataset.href.length > 0)
          return parent.dataset.href;
        return "";
      },
      configurable: true
    });
    Object.defineProperty(window, "$selectedline", {
      get: function() {
        if (!client) return "";
        let value = client.input.vStack["$selectedline"] || _selline || "";
        if (value) return value;
        if (!lastMouse) return "";
        var pos = client.display.getLineOffset(lastMouse.pageX, lastMouse.pageY);
        if (pos.y < 0 || pos.y >= client.display.lines.length)
          return "";
        return client.display.getLineText(pos.y, true);
      },
      configurable: true
    });
    Object.defineProperty(window, "$action", {
      get: function() {
        if (!client) return "";
        return client.input.vStack["$action"] || (client.input.lastTriggerExecuted ? client.input.lastTriggerExecuted.value : "") || "";
      },
      configurable: true
    });
    Object.defineProperty(window, "$trigger", {
      get: function() {
        if (!client) return "";
        return client.input.vStack["$trigger"] || client.input.lastTriggered || "";
      },
      configurable: true
    });
    Object.defineProperty(window, "$caption", {
      get: function() {
        if (!client) return "";
        return client.input.vStack["$caption"] || "";
      },
      configurable: true
    });
    client.input.on("history-navigate", () => {
      if (client.getOption("commandAutoSize") || client.getOption("commandScrollbars"))
        resizeCommandInput();
    });
    client.on("options-loaded", () => {
      client.commandInput.removeEventListener("input", resizeCommandInput);
      client.commandInput.removeEventListener("change", resizeCommandInput);
      initCommandInput();
      updateCommandInput();
      if (client.getOption("commandAutoSize") || client.getOption("commandScrollbars"))
        resizeCommandInput();
      if (editorDialog) {
        editorDialog.resetState(client.getOption("windows.editor") || { center: true });
        if (editor.simple != client.getOption("simpleEditor")) {
          let value = "";
          if (!editor.isSimple)
            value = editor.getFormattedText().replace(/(?:\r)/g, "");
          editor.simple = client.getOption("simpleEditor");
          if (!editor.isSimple) {
            editorDialog.hideFooter();
            if (editorDialog.header.querySelector("#adv-editor-switch"))
              editorDialog.header.querySelector("#adv-editor-switch").title = "Switch to simple";
          } else {
            editor.value = value;
            editorDialog.showFooter();
            if (editorDialog.header.querySelector("#adv-editor-switch"))
              editorDialog.header.querySelector("#adv-editor-switch").title = "Switch to advanced";
            setTimeout(() => editor.focus(), 100);
          }
        }
      }
      if (_dialogs.history) _dialogs.history.resetState(client.getOption("windows.history") || { center: true, width: 400, height: 275 });
      if (_dialogs.profiles) _dialogs.profiles.resetState(client.getOption("windows.profiles") || { center: true, width: 400, height: 275 });
    });
    client.on("set-title", (title) => {
      if (!title || !title.length)
        title = client.defaultTitle;
      else if (title.indexOf(client.defaultTitle) === -1)
        title += " - " + client.defaultTitle;
      if (client.connecting)
        title = "Connecting - " + title;
      else if (client.connected)
        title = "Connected - " + title;
      else
        title = "Disconnected - " + title;
      window.document.title = title;
    });
    client.on("connected", () => _setIcon(1));
    client.on("closed", () => _setIcon(0));
    client.on("received-data", () => {
      if (!client.active && client.connected)
        _setIcon(2);
    });
    client.on("focus", () => {
      if (client.connected)
        _setIcon(1);
      else
        _setIcon(0);
    });
    client.on("print", () => {
      if (!client.active && client.connected)
        _setIcon(2);
    });
    client.display.on("selection-done", (e) => {
      if (client.getOption("AutoCopySelectedToClipboard") && client.display.hasSelection) {
        copyText(client.display.selection);
        client.display.clearSelection();
      }
    });
    client.on("profiles-loaded", () => {
      buildButtons();
    });
    client.on("notify", (title, message, options2) => {
      if (!client.getOption("enableNotifications") || !("Notification" in window)) return;
      options2 = options2 || { silent: true };
      if (!Object.prototype.hasOwnProperty.call(options2, "silent"))
        options2.silent = true;
      switch (_currentIcon) {
        case 1:
          options2.icon = options2.icon || "images/connected.png";
          break;
        case 2:
          options2.icon = options2.icon || "images/connectednonactive.png";
          break;
        default:
          options2.icon = options2.icon || "images/disconnected.png";
          break;
      }
      if (message) {
        options2.body = message;
        if (options2.body.length > 127)
          options2.body = options2.body.substr(0, 127) + "...";
      }
      if (Notification.permission === "granted") {
        var notify = new window.Notification(title, options2);
        notify.onclick = () => {
          client.emit("notify-clicked", title, message);
          client.raise("notify-clicked", [title, message]);
        };
        notify.onclose = () => {
          client.emit("notify-closed", title, message);
          client.raise("notify-closed", [title, message]);
        };
      } else if (Notification.permission !== "denied") {
        Notification.requestPermission().then((permission) => {
          if (permission === "granted") {
            var notify2 = new window.Notification(title, options2);
            notify2.onclick = () => {
              client.emit("notify-clicked", title, message);
              client.raise("notify-clicked", [title, message]);
            };
            notify2.onclose = () => {
              client.emit("notify-closed", title, message);
              client.raise("notify-closed", [title, message]);
            };
          } else
            client.echo("Notification permission denied.", -7, -8, true, true);
        });
      } else
        client.echo("Notification permission denied.", -7, -8, true, true);
    });
    client.on("window", (window2, args, name2) => {
      switch (window2) {
        case "editor":
        case "help":
        case "about":
          if (args === "close")
            closeDialog(window2);
          else
            showDialog(window2);
          break;
        case "profiles":
        case "profiles-manager":
        case "profile-manager":
        case "manager":
          if (args === "close")
            closeDialog("profiles");
          else
            showDialog("profiles");
          break;
        case "prefs":
        case "options":
        case "preferences":
          if (args === "close")
            closeDialog("settings");
          else
            showDialog("settings");
          break;
        case "history":
        case "command-history":
          if (args === "close")
            closeDialog("history");
          else
            showDialog("history");
          break;
      }
    });
    document.getElementById("btn-adv-editor").addEventListener("click", (e) => {
      showDialog("editor");
    });
    options = client.getOption("windows.editor");
    if (options && options.show)
      document.getElementById("btn-adv-editor").click();
    options = client.getOption("windows.history");
    if (options && options.show)
      showDialog("history");
    options = client.getOption("windows.profiles");
    if (options && options.show)
      showDialog("profiles");
    document.getElementById("btn-command-history").addEventListener("show.bs.dropdown", function() {
      document.body.appendChild(document.getElementById("command-history-menu"));
      let h = "";
      const menu = document.getElementById("command-history-menu");
      let history2 = client.commandHistory;
      for (let i2 = 0, il = history2.length; i2 < il; i2++)
        h += `<li id="command-history-item-${i2}"><a data-index="${i2}" class="dropdown-item" href="javascript:void(0)">${history2[i2]}</a></li>`;
      if (history2.length) {
        h += '<li><hr class="dropdown-divider"></li>';
        h += `<li><a id="history-clear" class="dropdown-item" href="javascript:void(0)">Clear history</a></li>`;
      }
      h += `<li><a id="history-show" class="dropdown-item" href="javascript:void(0)">Show history window...</a></li>`;
      menu.innerHTML = h;
      if (history2.length)
        menu.querySelector("#history-clear").addEventListener("click", () => {
          confirm_box("Clear history?", `Clear all history`).then((e) => {
            if (e.button === 4 /* Yes */) {
              client.clearCommandHistory();
            }
          });
        });
      menu.querySelector("#history-show").addEventListener("click", () => showDialog("history"));
      const items = document.querySelectorAll('[id^="command-history-item"] a');
      for (let i2 = 0, il = items.length; i2 < il; i2++) {
        items[i2].addEventListener("click", (e) => {
          var cmd = client.commandHistory[parseInt(e.currentTarget.dataset.index, 10)];
          client.AddCommandToHistory(cmd);
          client.sendCommand(cmd, null, client.getOption("allowCommentsFromCommand"));
        });
      }
    });
    document.getElementById("btn-command-history").addEventListener("hidden.bs.dropdown", function() {
      document.getElementById("btn-command-history").parentElement.appendChild(document.getElementById("command-history-menu"));
    });
    client.commandInput.removeEventListener("input", resizeCommandInput);
    client.commandInput.removeEventListener("change", resizeCommandInput);
    initCommandInput();
    updateCommandInput();
    if (client.getOption("commandAutoSize") || client.getOption("commandScrollbars"))
      resizeCommandInput();
    window.addEventListener("keydown", (event2) => {
      if (event2.which === 33)
        client.display.pageUp();
      else if (event2.which === 34)
        client.display.pageDown();
    });
    window.addEventListener("error", (e) => {
      const { message, filename, lineno, colno, error } = e;
      if (message.includes("ResizeObserver loop completed with undelivered notifications"))
        return;
      if (client) {
        if (error)
          client.error(error);
        else if (message.startsWith("Uncaught Error: "))
          client.error(`${message.substr(16)}`);
        else
          client.error(`${message}`);
        if (client.getOption("enableDebug")) {
          client.error("Url: " + filename);
          client.error("Line: " + lineno);
          client.error("Column: " + colno);
          client.error(error);
        }
      } else {
        console.error("Message: " + message);
        console.error("Url: " + filename);
        console.error("Line: " + lineno);
        console.error("Column: " + colno);
        console.error(error);
      }
      return true;
    });
    window.addEventListener("mousemove", (event2) => {
      lastMouse = event2;
    });
    window.addEventListener("hashchange", hashChange, false);
    window.addEventListener("load", hashChange);
    client.on("command-history-changed", (history2) => {
      _loadHistory();
    });
    showButtons();
  }
  function removeHash(string) {
    if (!string || string.length === 0) return;
    string = string.trim();
    if (string.startsWith("#"))
      string = string.substring(1);
    var hashes = decodeURI(window.location.hash.substring(1)).split(",").filter((s) => s.trim() !== string);
    window.location.hash = hashes.join(",");
  }
  function updateHash(add, remove) {
    if (!Array.isArray(add))
      add = [add];
    remove = remove || [];
    if (!Array.isArray(remove))
      remove = [remove];
    remove = remove.concat(...add);
    var hashes = decodeURI(window.location.hash.substring(1)).split(",").filter((s) => s.length && !remove.includes(s.trim()));
    hashes = hashes.concat(...add);
    window.location.hash = hashes.join(",");
  }
  function hashChange() {
    if (!window.location.hash || window.location.hash.length < 2) return;
    var dialogs = decodeURI(window.location.hash.substring(1)).split(",").map((s) => s.trim());
    for (let d2 = dialogs.length - 1; d2 >= 0; d2--)
      switch (dialogs[d2]) {
        case "about":
          showDialog("about");
          break;
        case "editor":
          document.getElementById("btn-adv-editor").click();
          break;
        default:
          if (dialogs[d2] === "history" || dialogs[d2].startsWith("settings") || dialogs[d2].startsWith("profiles"))
            showDialog(dialogs[d2]);
          else
            client.emit("window", dialogs[d2]);
          break;
      }
  }
  var _dialogs = {};
  function showDialog(name2) {
    switch (name2) {
      case "about":
        if (!_dialogs.about) {
          _dialogs.about = new Dialog({ title: '<i class="bi-info-circle"></i> About', noFooter: true, resizable: false, center: true, maximizable: false });
          _dialogs.about.on("closed", () => {
            delete _dialogs.about;
            removeHash(name2);
          });
          _dialogs.about.on("canceled", () => {
            delete _dialogs.about;
            removeHash(name2);
          });
        }
        loadDialog(_dialogs.about, name2, 1, true).catch((e) => {
          client.error(e);
        });
        return _dialogs.about;
      case "history":
        if (!_dialogs.history) {
          _dialogs.history = new Dialog(Object.assign({}, client.getOption("windows.history") || { center: true, width: 400, height: 275 }, { title: '<i class="bi bi-clock-history"></i> Command history', id: "command-history" }));
          _dialogs.history.on("closed", () => {
            client.setOption("windows.history", _dialogs.history.windowState);
            delete _dialogs.history;
            removeHash(name2);
          });
          _dialogs.history.on("canceled", () => {
            client.setOption("windows.history", _dialogs.history.windowState);
            removeHash("history");
            delete _dialogs.history;
            removeHash(name2);
          });
          _dialogs.history.on("resized", (e) => {
            client.setOption("windows.history", e);
          });
          _dialogs.history.on("moved", (e) => {
            client.setOption("windows.history", e);
          });
          _dialogs.history.on("maximized", () => {
            client.setOption("windows.history", _dialogs.history.windowState);
          });
          _dialogs.history.on("restored", () => {
            client.setOption("windows.history", _dialogs.history.windowState);
          });
          _dialogs.history.on("shown", () => {
            client.setOption("windows.history", _dialogs.history.windowState);
          });
          let footer = "";
          footer += `<button id="${_dialogs.history.id}-clear" type="button" class="btn-sm float-end btn btn-danger" title="Clear history"><i class="bi bi-trash"></i><span class="icon-only"> Clear</span></button>`;
          footer += `<button id="${_dialogs.history.id}-send" type="button" class="btn-sm float-end btn btn-primary" title="Send"><i class="bi bi-send-fill"></i><span class="icon-only"> Send</span></button>`;
          footer += `<button id="${_dialogs.history.id}-refresh" type="button" class="btn-sm float-start btn btn-light" title="Refresh"><i class="bi bi-arrow-repeat"></i><span class="icon-only"> Refresh</span></button>`;
          _dialogs.history.footer.innerHTML = footer;
          _dialogs.history.body.innerHTML = `<select id="history-list" multiple="multiple" class="form-select"></select>`;
          _dialogs.history.body.querySelector("#history-list").addEventListener("dblclick", (e) => {
            const cmd = e.currentTarget.value;
            client.AddCommandToHistory(cmd);
            client.sendCommand(cmd, false, client.getOption("allowCommentsFromCommand"));
            _dialogs.history.close();
          });
          _dialogs.history.body.querySelector("#history-list").addEventListener("change", (e) => {
            client.setHistoryIndex(e.currentTarget.selectedIndex);
            _dialogs.history.footer.querySelector(`#${_dialogs.history.id}-send`).style.display = history.length && _dialogs.history.body.querySelector("#history-list").selectedIndex !== -1 ? "" : "none";
          });
          _dialogs.history.footer.querySelector(`#${_dialogs.history.id}-refresh`).addEventListener("click", () => _loadHistory());
          _dialogs.history.footer.querySelector(`#${_dialogs.history.id}-send`).addEventListener("click", () => {
            const list = _dialogs.history.body.querySelector("#history-list");
            let cmds = [];
            for (let l2 = 0, ll = list.options.length; l2 < ll; l2++) {
              if (list.options[l2].selected) {
                cmds.push(list.options[l2].value);
              }
            }
            for (let c = 0, cl = cmds.length; c < cl; c++) {
              client.AddCommandToHistory(cmds[c]);
              client.sendCommand(cmds[c], false, client.getOption("allowCommentsFromCommand"));
            }
          });
          _dialogs.history.footer.querySelector(`#${_dialogs.history.id}-clear`).addEventListener("click", () => {
            confirm_box("Clear history?", `Clear all history`).then((e) => {
              if (e.button === 4 /* Yes */) {
                client.clearCommandHistory();
              }
            });
          });
        }
        _loadHistory();
        _dialogs.history.show();
        return _dialogs.history;
      case "editor":
        if (!editorDialog) {
          editorDialog = new Dialog(Object.assign({}, client.getOption("windows.editor") || { center: true }, { title: '<i class="fas fa-edit"></i> Advanced editor', id: "adv-editor" }));
          editorDialog.on("resized", (e) => {
            client.setOption("windows.editor", e);
          });
          editorDialog.on("moved", (e) => {
            client.setOption("windows.editor", e);
          });
          editorDialog.on("maximized", () => {
            client.setOption("windows.editor", editorDialog.windowState);
          });
          editorDialog.on("restored", () => {
            client.setOption("windows.editor", editorDialog.windowState);
          });
          editorDialog.on("shown", () => {
            client.setOption("windows.editor", editorDialog.windowState);
            editor.initialize();
          });
          editorDialog.on("closing", () => {
            editor.remove();
          });
          editorDialog.on("closed", () => {
            client.setOption("windows.editor", editorDialog.windowState);
            removeHash("editor");
          });
          editorDialog.on("canceling", () => {
            editor.remove();
          });
          editorDialog.on("canceled", () => {
            client.setOption("windows.editor", editorDialog.windowState);
            removeHash("editor");
          });
          editorDialog.on("focus", () => editor.focus());
          const textarea = document.createElement("textarea");
          textarea.classList.add("form-control", "form-control-sm");
          textarea.id = "adv-editor-txt";
          editorDialog.body.appendChild(textarea);
          editorDialog.body.style.overflow = "hidden";
          if (!editor) editor = new AdvEditor(textarea, !client.getOption("simpleEditor"));
          editor.on("close", () => {
            editorDialog.close();
          });
          editor.on("editor-init", () => editor.focus());
          editor.on("click", () => editorDialog.focus());
          editorDialog.dialog.editor = editor;
          if (tinymce)
            editorDialog.header.querySelector("#adv-editor-max").insertAdjacentHTML("afterend", '<button type="button" class="btn btn-light float-end" id="adv-editor-switch" title="Switch to advanced" style="padding: 0 4px;margin-top: -1px;"><i class="bi-shuffle"></i></button>');
          editorDialog.footer.innerHTML = `<button id="btn-adv-editor-clear" type="button" class="btn-sm float-start btn btn-light" title="Clear editor"><i class="bi bi-journal-x"></i><span class="icon-only"> Clear</span></button><button id="btn-adv-editor-append" type="button" class="btn-sm float-start btn btn-light" title="Append file..."><i class="bi bi-box-arrow-in-down"></i><span class="icon-only"> Append file...</span></button><button id="btn-adv-editor-send" type="button" class="btn-sm float-end btn btn-primary" title="Send"><i class="bi bi-send-fill"></i><span class="icon-only"> Send</span></button>`;
          if (editorDialog.header.querySelector("#adv-editor-switch")) {
            if (!editor.isSimple)
              editorDialog.header.querySelector("#adv-editor-switch").title = "Switch to simple";
            editorDialog.header.querySelector("#adv-editor-switch").addEventListener("click", () => {
              client.setOption("simpleEditor", !editor.simple);
              let value = "";
              if (!editor.isSimple)
                value = editor.getFormattedText().replace(/(?:\r)/g, "");
              editor.simple = !editor.simple;
              if (!editor.isSimple) {
                editorDialog.hideFooter();
                editorDialog.header.querySelector("#adv-editor-switch").title = "Switch to simple";
              } else {
                editor.value = value;
                editorDialog.showFooter();
                editorDialog.header.querySelector("#adv-editor-switch").title = "Switch to advanced";
                setTimeout(() => editor.focus(), 100);
              }
            });
          }
          document.getElementById("btn-adv-editor-append").addEventListener("click", () => {
            openFileDialog("Append file", false).then((files) => {
              readFile(files[0]).then((contents) => {
                editor.insert(contents);
              }).catch(client.error);
            }).catch(() => {
            });
          });
          document.getElementById("btn-adv-editor-send").addEventListener("click", () => {
            client.sendCommand(editor.value());
            if (client.getOption("editorClearOnSend"))
              editor.clear();
            if (client.getOption("editorCloseOnSend"))
              editorDialog.close();
          });
          document.getElementById("btn-adv-editor-clear").addEventListener("click", () => {
            editor.clear();
            editor.focus();
          });
          if (!editor.isSimple)
            editorDialog.hideFooter();
        }
        editorDialog.show();
        if (editor.isSimple)
          editor.focus();
        return editorDialog;
    }
    if (name2.startsWith("settings")) {
      if (!_dialogs.settings) {
        _dialogs.settings = new SettingsDialog();
        _dialogs.settings.on("closed", () => {
          delete _dialogs.settings;
        });
        _dialogs.settings.on("canceled", () => {
          delete _dialogs.settings;
        });
      }
      if (name2 === "settings") {
        _dialogs.settings.dialog.dataset.path = name2;
        _dialogs.settings.dialog.dataset.fullPath = name2;
        _dialogs.settings.dialog.dataset.hash = window.location.hash;
        _dialogs.settings.setBody("", { client });
        _dialogs.settings.showModal();
      } else
        loadDialog(_dialogs.settings, name2, 2, false).catch((e) => {
          client.error(e);
        });
      return _dialogs.settings;
    }
    if (name2.startsWith("profiles")) {
      if (!_dialogs.profiles) {
        _dialogs.profiles = new ProfilesDialog();
        _dialogs.profiles.on("closed", () => {
          delete _dialogs.profiles;
        });
        _dialogs.profiles.on("canceled", () => {
          delete _dialogs.profiles;
        });
      }
      _dialogs.profiles.dialog.dataset.path = name2;
      _dialogs.profiles.dialog.dataset.fullPath = name2;
      _dialogs.profiles.dialog.dataset.hash = window.location.hash;
      _dialogs.profiles.setBody("", { client });
      _dialogs.profiles.show();
      return _dialogs.profiles;
    }
  }
  function loadDialog(dialog, path, show, showError) {
    return new Promise((resolve, reject) => {
      var subpath = path.split("/");
      $.ajax({
        url: "dialogs/" + subpath[0] + ".htm",
        cache: false,
        type: "GET"
      }).done(function(data) {
        dialog.dialog.dataset.path = subpath[0];
        dialog.dialog.dataset.fullPath = path;
        dialog.dialog.dataset.hash = window.location.hash;
        dialog.setBody(data, { client });
        if (show == 1)
          dialog.show();
        else if (show === 2)
          dialog.showModal();
        resolve(data);
      }).fail(function(err) {
        if (showError && client.enableDebug)
          dialog.setBody(`<h1 style="width: 100%;text-align:center">Error loading ${path}</h1> ${err.statusText}`);
        else if (showError)
          dialog.setBody(`<h1 style="width: 100%;text-align:center">Error loading ${path}</h1>`);
        else
          dialog.setBody("");
        reject(path + ": " + subpath.statusText);
      });
    });
  }
  function closeDialog(dialog) {
    if (_dialogs[dialog])
      _dialogs[dialog].close();
    else if (dialog === "editor") {
      if (editorDialog)
        editorDialog.close();
    }
  }
  function _loadHistory() {
    if (!_dialogs.history) return;
    const list = document.getElementById("history-list");
    list.innerHTML = "";
    let history2 = client.commandHistory;
    var fragment = document.createDocumentFragment();
    for (var i2 = 0, l2 = history2.length; i2 < l2; i2++) {
      var opt = document.createElement("option");
      opt.appendChild(document.createTextNode(history2[i2]));
      opt.value = history2[i2];
      fragment.append(opt);
    }
    list.appendChild(fragment);
    _dialogs.history.footer.querySelector(`#${_dialogs.history.id}-clear`).style.display = history2.length ? "" : "none";
    _dialogs.history.footer.querySelector(`#${_dialogs.history.id}-send`).style.display = history2.length && list.selectedIndex !== -1 ? "" : "none";
  }
  function resizeCommandInput() {
    debounce(() => {
      _resizeCommandInput();
    }, 250, "resizeCommand");
  }
  async function initCommandInput() {
    if (client.getOption("commandAutoSize") || client.getOption("commandScrollbars")) {
      client.commandInput.addEventListener("input", resizeCommandInput);
      client.commandInput.addEventListener("change", resizeCommandInput);
    }
    if (client.getOption("commandWordWrap")) {
      document.getElementById("commandMeasure").style.whiteSpace = "pre-wrap";
      document.getElementById("commandMeasure").style.overflowWrap = "anywhere";
    } else {
      document.getElementById("commandMeasure").style.whiteSpace = "";
      document.getElementById("commandMeasure").style.overflowWrap = "";
    }
    if (client.getOption("commandScrollbars")) {
      document.getElementById("commandMeasure").style.overflow = "auto";
      client.commandInput.style.overflow = "auto";
    } else {
      document.getElementById("commandMeasure").style.overflow = "";
      client.commandInput.style.overflow = "";
    }
  }
  var commandInputResize = {};
  function updateCommandInput() {
    const measure = document.getElementById("commandMeasure");
    document.body.appendChild(measure);
    const cmd = client.commandInput.parentElement;
    const cmdSize = window.getComputedStyle(cmd);
    measure.style.fontSize = client.commandInput.style.fontSize;
    measure.style.fontFamily = client.commandInput.style.fontFamily;
    measure.style.width = client.commandInput.offsetWidth + "px";
    const oldMeasure = measure.innerHTML;
    measure.innerHTML = "W";
    let minHeight = client.getOption("commandMinLines");
    const height = measure.offsetHeight;
    minHeight = height * (minHeight < 1 ? 1 : minHeight);
    let padding = parseFloat(cmdSize.borderTopWidth) || 0;
    padding += parseFloat(cmdSize.borderBottomWidth) || 0;
    padding += parseFloat(cmdSize.paddingTop) || 0;
    padding += parseFloat(cmdSize.paddingBottom) || 0;
    let inset = cmdSize.inset.split(" ");
    padding += (parseFloat(inset[0]) || 0) * 2;
    measure.innerHTML = oldMeasure;
    cmd.style.height = height + padding + "px";
    client.commandInput.parentElement.style.height = height + "px";
    client.commandInput.closest("nav").style.height = height + "px";
    client.display.container.style.bottom = height + padding + "px";
    commandInputResize = {
      measure,
      cmd,
      cmdSize,
      height,
      padding,
      minHeight
    };
  }
  function _resizeCommandInput() {
    const measure = commandInputResize.measure;
    const cmd = commandInputResize.cmd;
    measure.innerHTML = client.commandInput.value + "\n";
    let height = measure.offsetHeight;
    if (height < commandInputResize.minHeight)
      height = commandInputResize.minHeight;
    const padding = commandInputResize.padding;
    cmd.style.height = height + padding + "px";
    client.commandInput.parentElement.style.height = height + "px";
    client.commandInput.closest("nav").style.height = height + "px";
    client.display.container.style.bottom = height + padding + "px";
  }
  function _setIcon(ico) {
    if (_currentIcon === ico)
      return;
    _currentIcon = ico;
    let icon = "disconnected";
    switch (ico) {
      case 1:
        icon = "connected";
        break;
      case 2:
        icon = "connectednonactive";
        break;
    }
    document.getElementById("icon1").remove();
    document.getElementById("icon2").remove();
    document.getElementById("icon3").remove();
    document.querySelector("head").insertAdjacentHTML("afterbegin", `<link id="icon1" rel="shortcut icon" href="images/${icon}.ico" /><link id="icon2" rel="icon" href="images/${icon}.ico" /><link id="icon3" rel="icon" type="image/x-icon" href="images/${icon}.png" />`);
  }
  function toggleButtons() {
    client.setOption("showButtons", !client.getOption("showButtons"));
    showButtons();
  }
  function createButton(button, index) {
    var c = "";
    var tt = "";
    var caption = button.caption;
    var bh = 0;
    if (caption.substring(0, 3) === "fa-") {
      caption = caption.split(",");
      if (caption.length > 1)
        caption = '<i class="fas ' + caption[0] + ' fa-fw" data-fa-transform="' + caption[1] + '"></i>';
      else
        caption = '<i class="fas ' + caption[0] + ' fa-fw"></i>';
      bh = 26;
    } else if (caption.substring(0, 4) === "fas-") {
      caption = caption.split(",");
      if (caption.length > 1)
        caption = '<i class="fas fa-' + caption[0].substring(4) + ' fa-fw" data-fa-transform="' + caption[1] + '"></i>';
      else
        caption = '<i class="fas fa-' + caption[0].substring(4) + ' fa-fw"></i>';
      bh = 26;
    } else if (caption.substring(0, 4) === "far-") {
      caption = caption.split(",");
      if (caption.length > 1)
        caption = '<i class="far fa-' + caption[0].substring(4) + ' fa-fw" data-fa-transform="' + caption[1] + '"></i>';
      else
        caption = '<i class="far fa-' + caption[0].substring(4) + ' fa-fw"></i>';
      bh = 26;
    } else if (caption.substring(0, 4) === "fab-") {
      caption = caption.split(",");
      if (caption.length > 1)
        caption = '<i class="fab fa-' + caption[0].substring(4) + ' fa-fw" data-fa-transform="' + caption[1] + '"></i>';
      else
        caption = '<i class="fab fa-' + caption[0].substring(4) + ' fa-fw"></i>';
      bh = 26;
    } else if (caption.substring(0, 7) === "http://" || caption.substring(0, 7) === "https://")
      caption = '<img src="' + caption + '" style="max-width: ' + button.width + "px;max-height:" + button.height + 'px"/>';
    else {
      if (!button.iconOnly)
        caption = button.caption;
      tt = button.caption;
    }
    if (button.icon && button.icon.length) {
      var icon = button.icon;
      if (icon.substring(0, 3) === "fa-") {
        icon = icon.split(",");
        if (icon.length > 1)
          icon = '<i class="fas ' + icon[0] + ' fa-fw" data-fa-transform="' + icon[1] + '"></i>';
        else
          icon = '<i class="fas ' + icon[0] + ' fa-fw"></i>';
        bh = 26;
      } else if (icon.substring(0, 4) === "fas-") {
        icon = icon.split(",");
        if (icon.length > 1)
          icon = '<i class="fas fa-' + icon[0].substring(4) + ' fa-fw" data-fa-transform="' + icon[1] + '"></i>';
        else
          icon = '<i class="fas fa-' + icon[0].substring(4) + ' fa-fw"></i>';
        bh = 26;
      } else if (icon.substring(0, 4) === "far-") {
        icon = icon.split(",");
        if (icon.length > 1)
          icon = '<i class="far fa-' + icon[0].substring(4) + ' fa-fw" data-fa-transform="' + icon[1] + '"></i>';
        else
          icon = '<i class="far fa-' + icon[0].substring(4) + ' fa-fw"></i>';
        bh = 26;
      } else if (icon.substring(0, 4) === "fab-") {
        icon = icon.split(",");
        if (icon.length > 1)
          icon = '<i class="fab fa-' + icon[0].substring(4) + ' fa-fw" data-fa-transform="' + icon[1] + '"></i>';
        else
          icon = '<i class="fab fa-' + icon[0].substring(4) + ' fa-fw"></i>';
        bh = 26;
      } else if (button.icon.length) {
        icon = '<img src="' + icon + '" style="max-width: ' + button.width + "px;max-height:" + button.height + 'px"/>';
      }
      if (button.iconOnly)
        caption = icon;
      else
        caption = icon + caption;
    }
    c += "<button";
    c += ' data-index="' + index + '"';
    if (button.name && button.name.length !== 0)
      c += ' id="button-' + button.name + '"';
    c += ' class="user-button" style="';
    if (button.left === -1 && button.right === -1 && button.top === -1 && button.bottom === -1) {
      c += "position: static;margin-right:2px;margin-top:2px;";
    } else {
      if (button.left >= 0)
        c += "left:" + (button.left || 0) + "px;";
      if (button.top >= 0)
        c += "top:" + (button.top || 0) + "px;";
      if (button.bottom >= 0)
        c += "bottom:" + (button.bottom || 0) + "px;";
      if (button.right >= 0)
        c += "right:" + (button.right || 0) + "px;";
      if (button.right === -1 && button.left === -1)
        c += "right:0px;";
      if (button.bottom === -1 && button.top === -1)
        c += "top:0px;";
    }
    if (button.width)
      c += "width: " + button.width + "px;";
    else if (bh === 26)
      c += "min-width: 26px;";
    if (button.height)
      c += "height: " + button.height + "px;";
    c += '" title="' + tt + '" draggable="true" data-index="' + index + '">' + caption + "</button>";
    return c;
  }
  function showButtons() {
    if (client.getOption("showButtons"))
      document.getElementById("buttons").style.visibility = "visible";
    else
      document.getElementById("buttons").style.visibility = "";
  }
  function buildButtons() {
    var c = "";
    var buttons = client.buttons;
    var b, bl;
    for (b = 0, bl = buttons.length; b < bl; b++) {
      if (!buttons[b].enabled) continue;
      c += createButton(buttons[b], b);
    }
    document.getElementById("buttons").innerHTML = c;
    const items = document.querySelectorAll("#buttons button");
    for (let i2 = 0, il = items.length; i2 < il; i2++) {
      items[i2].addEventListener("click", (e) => {
        ExecuteButton(e.currentTarget, +e.currentTarget.dataset.index);
      });
      dragButton(items[i2]);
    }
  }
  function ExecuteButton(el, idx) {
    if (idx < 0) return false;
    if (el.dataset.moving === "true") {
      delete el.dataset.moving;
      return;
    }
    var buttons = client.buttons;
    if (idx >= buttons.length) return false;
    var button = buttons[idx];
    if (!button.enabled) return false;
    var ret;
    switch (button.style) {
      case 1:
        ret = client.parseOutgoing(button.value);
        break;
      case 2:
        var f = new Function("try { " + button.value + "} catch (e) { if(this.options.showScriptErrors) this.error(e);}");
        ret = f.apply(client);
        break;
      default:
        ret = button.value;
        break;
    }
    if (ret === null || typeof ret == "undefined")
      return true;
    if (button.send) {
      if (!ret.endsWith("\n"))
        ret += "\n";
      if (button.chain) {
        if (client.commandInput.value.endsWith(" ")) {
          client.commandInput.value += ret;
          client.sendCommand();
          return true;
        }
      }
      if (client.connected)
        client.send(ret);
      if (client.telnet.echo && client.getOption("commandEcho"))
        client.echo(ret);
    } else if (button.append)
      client.commandInput.value += ret;
    return true;
  }
  function dragButton(elmnt) {
    var pos3 = 0, pos4 = 0;
    var delay;
    if (document.getElementById(elmnt.id + "header")) {
      document.getElementById(elmnt.id + "header").onmousedown = dragMouseDown;
    } else {
      elmnt.onmousedown = dragMouseDown;
      elmnt.ontouchstart = dragTouchStart;
      elmnt.onmouseleave = dragMouseleave;
    }
    function dragMouseDown(e) {
      e = e || window.event;
      if (e.buttons !== 1) return;
      e.preventDefault();
      var b = elmnt.getBoundingClientRect();
      pos3 = e.pageX - b.left;
      pos4 = e.pageY - b.top;
      document.onmouseup = closeDragButton;
      delay = setTimeout(function() {
        document.onmousemove = elementDrag;
        delay = null;
      }, 500);
    }
    function dragMouseleave() {
      if (delay)
        closeDragButton();
    }
    function elementDrag(e) {
      e = e || window.event;
      e.preventDefault();
      elmnt.style.position = "absolute";
      elmnt.style.top = e.pageY - pos4 + "px";
      elmnt.style.left = e.pageX - document.body.clientWidth - pos3 + "px";
      elmnt.dataset.moving = "true";
    }
    function dragTouchStart(e) {
      e = e || window.event;
      if (!e.touches.length) return;
      var b = elmnt.getBoundingClientRect();
      pos3 = e.touches[0].pageX - b.left;
      pos4 = e.touches[0].pageY - b.top;
      document.ontouchend = closeDragButton;
      delay = setTimeout(function() {
        document.ontouchmove = elementMove;
        delay = null;
      }, 500);
    }
    function elementMove(e) {
      e = e || window.event;
      e.preventDefault();
      elmnt.style.position = "absolute";
      if (!e.touches.length) return;
      elmnt.style.top = e.touches[0].pageY - pos4 + "px";
      elmnt.style.left = e.touches[0].pageX - document.body.clientWidth - pos3 + "px";
      elmnt.dataset.moving = "true";
    }
    function closeDragButton() {
      var b = elmnt.getBoundingClientRect();
      var idx = parseInt(elmnt.dataset.index, 10);
      if (idx < 0) return;
      var buttons = client.buttons;
      if (idx >= buttons.length) return;
      var button = buttons[idx];
      if (!button.enabled) return;
      if (button.left === -1 && button.right === -1 && button.top === -1 && button.bottom === -1) {
        button.top = b.top || -1;
        button.right = document.body.clientWidth - b.right || -1;
      } else {
        if (button.left >= 0)
          button.left = document.body.clientWidth - b.left || -1;
        if (button.top >= 0)
          button.top = b.top || -1;
        if (button.bottom >= 0)
          button.bottom = b.bottom || -1;
        if (button.right >= 0)
          button.right = document.body.clientWidth - b.right || -1;
        if (button.right === -1 && button.left === -1)
          button.right = document.body.clientWidth - b.right || -1;
        if (button.bottom === -1 && button.top === -1)
          button.top = b.top || -1;
      }
      document.onmouseup = null;
      document.onmousemove = null;
      document.ontouchend = null;
      document.ontouchmove = null;
      clearTimeout(delay);
      client.saveProfiles();
    }
  }
  window.initializeInterface = initializeInterface;

  // src/html/mapper.menu.htm
  var mapper_menu_default = '<div class="offcanvas offcanvas-start" data-bs-scroll="true" data-bs-backdrop="false" tabindex="-1" id="mapper-menu" aria-labelledby="mapper-menu-Label" style="position:absolute"><div class="offcanvas-body"><button type="button" class="btn btn-close text-reset btn-danger btn-close text-reset" data-bs-dismiss="offcanvas" aria-label="Close" style="position:absolute;right:5px;top:5px"></button><ul class="navbar-nav justify-content-end flex-grow-1"><li id="mapper-enable" class="nav-item" title="Enable"><a class="nav-link" href="javascript:void(0)"><i class="bi bi-map"></i>&nbsp;<span>Enabled</span></a></li><li id="mapper-legend" class="nav-item" title="Show legend"><a class="nav-link" href="javascript:void(0)"><i class="fa fa-map-marker"></i>&nbsp;<span>Show legend</span></a></li><li id="mapper-room" class="nav-item" title="Show room properties"><a class="nav-link" href="javascript:void(0)"><i class="fa fa-list-alt"></i>&nbsp;<span>Show room properties</span></a></li><li><hr class="dropdown-divider"></li><li id="mapper-refresh" class="nav-item" title="Refresh"><a class="nav-link" href="javascript:void(0)"><i class="fa fa-refresh"></i>&nbsp;<span>Refresh</span></a></li><li><hr class="dropdown-divider"></li><li id="mapper-split" class="nav-item" title="Split areas"><a class="nav-link" href="javascript:void(0)"><i class="fa fa-object-ungroup"></i>&nbsp;<span>Split areas</span></a></li><li id="mapper-fill" class="nav-item" title="Display walls"><a class="nav-link" href="javascript:void(0)"><i class="fa fa-building"></i>&nbsp;<span>Display walls</span></a></li><li><hr class="dropdown-divider"></li><li id="mapper-remove" class="nav-item"><a class="nav-link" href="javascript:void(0)" role="button" data-bs-target="#remove-submenu" data-bs-toggle="collapse" aria-expanded="false" aria-controls="remove-submenu"><i class="fa fa-eraser"></i>&nbsp;<span>Remove</span></a><ul class="navbar-nav justify-content-end flex-grow-1 collapse" id="remove-submenu"><li class="nav-item" id="mapper-remove-selected"><a class="nav-link disabled" href="javascript:void(0)" style="padding-left:40px">Remove selected room</a></li><li class="nav-item" id="mapper-remove-current"><a class="nav-link disabled" href="javascript:void(0)" style="padding-left:40px">Remove current room</a></li><li><hr class="dropdown-divider"></li><li id="mapper-remove-current-area" class="nav-item"><a class="nav-link" href="javascript:void(0)" style="padding-left:40px">Remove current area</a></li><li id="mapper-remove-all" class="nav-item"><a class="nav-link" href="javascript:void(0)" style="padding-left:40px">Remove all</a></li></ul></li><li id="mapper-export" class="nav-item"><a class="nav-link" href="javascript:void(0)" role="button" data-bs-target="#export-submenu" data-bs-toggle="collapse" aria-expanded="false" aria-controls="export-submenu"><i class="fa fa-exchange"></i>&nbsp;<span>Export/Import</span></a><ul class="navbar-nav justify-content-end flex-grow-1 collapse" id="export-submenu"><li id="mapper-export-image" class="nav-item"><a class="nav-link" href="javascript:void(0)" style="padding-left:40px">Export as image</a></li><li id="mapper-export-scaled-image" class="nav-item"><a class="nav-link" href="javascript:void(0)" style="padding-left:40px">Export as scaled image</a></li><li id="mapper-export-current-image" class="nav-item"><a class="nav-link" href="javascript:void(0)" style="padding-left:40px">Export current view as image</a></li><li><hr class="dropdown-divider"></li><li id="mapper-export-current-area" class="nav-item"><a class="nav-link" href="javascript:void(0)" style="padding-left:40px">Export current area</a></li><li id="mapper-export-all" class="nav-item"><a class="nav-link" href="javascript:void(0)" style="padding-left:40px">Export all</a></li><li><hr class="dropdown-divider"></li><li id="mapper-import-merge" class="nav-item"><a class="nav-link" href="javascript:void(0)" style="padding-left:40px">Import and merge</a></li><li id="mapper-import-replace" class="nav-item"><a class="nav-link" href="javascript:void(0)" style="padding-left:40px">Import and replace</a></li></ul></li><li><hr class="dropdown-divider"></li><li id="mapper-export" class="nav-item"><a class="nav-link" href="javascript:void(0)" role="button" data-bs-target="#actions-submenu" data-bs-toggle="collapse" aria-expanded="false" aria-controls="actions-submenu"><i class="fa-solid fa-shoe-prints"></i>&nbsp;<span>Actions</span></a><ul class="navbar-nav justify-content-end flex-grow-1 collapse" id="actions-submenu"><li id="mapper-follow" class="nav-item"><a class="nav-link" href="javascript:void(0)" style="padding-left:40px">Follow</a></li><li><hr class="dropdown-divider"></li><li id="mapper-focus" class="nav-item"><a class="nav-link" href="javascript:void(0)" style="padding-left:40px">Focus on current room</a></li><li id="mapper-set-current" class="nav-item"><a class="nav-link disabled" href="javascript:void(0)" style="padding-left:40px">Set selected as current</a></li><li><hr class="dropdown-divider"></li><li id="mapper-highlight-path" class="nav-item"><a class="nav-link disabled" href="javascript:void(0)" style="padding-left:40px">Highlight path</a></li><li id="mapper-clear-path" class="nav-item"><a class="nav-link disabled" href="javascript:void(0)" style="padding-left:40px">Clear path</a></li><li><hr class="dropdown-divider"></li><li id="mapper-walk-path" class="nav-item"><a class="nav-link disabled" href="javascript:void(0)" style="padding-left:40px">Walk path</a></li><li id="mapper-walk-highlighted-path" class="nav-item"><a class="nav-link disabled" href="javascript:void(0)" style="padding-left:40px">Walk highlighted path</a></li><li><hr class="dropdown-divider"></li><li id="mapper-copy-path" class="nav-item"><a class="nav-link disabled" href="javascript:void(0)" style="padding-left:40px">Copy path</a></li><li id="mapper-copy-stacked" class="nav-item"><a class="nav-link disabled" href="javascript:void(0)" style="padding-left:40px">Copy as stacked</a></li><li id="mapper-copy-speedpath" class="nav-item"><a class="nav-link disabled" href="javascript:void(0)" style="padding-left:40px">Copy as speedpath</a></li><li id="mapper-copy-highlighted-path" class="nav-item"><a class="nav-link disabled" href="javascript:void(0)" style="padding-left:40px">Copy highlighted path</a></li><li id="mapper-copy-highlighted-stacked" class="nav-item"><a class="nav-link disabled" href="javascript:void(0)" style="padding-left:40px">Copy highlighted as stacked</a></li><li id="mapper-copy-highlighted-speedpath" class="nav-item"><a class="nav-link disabled" href="javascript:void(0)" style="padding-left:40px">Copy highlighted as speedpath</a></li></ul></li><li><hr class="dropdown-divider"></li><li id="mapper-about" class="nav-item" title="About map"><a class="nav-link" href="javascript:void(0)"><i class="bi-info-circle"></i>&nbsp;<span>About</span></a></li></ul></div></div>';

  // src/html/mapper.room.htm
  var mapper_room_default = '<div class="dialog-header"><button id="mapper-room-close" style="padding:4px" type="button" class="btn btn-close float-end btn-danger" data-dismiss="modal" title="Hide properties"></button><div><i class="fa fa-list-alt"></i>&nbsp;Room properties</div></div><div class="accordion" id="mapper-room-accordion"><div class="accordion-item"><h2 class="accordion-header"><button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#mapper-room-general" aria-expanded="true" aria-controls="General">General</button></h2><div id="mapper-room-general" class="accordion-collapse collapse show" data-bs-parent="#mapper-room-accordion"><div class="accordion-body" style="padding:5px"><div class="mb-3"><label for="mapper-room-name">Name</label><input type="text" class="form-control" id="mapper-room-name" placeholder=""></div><div class="mb-3"><label for="mapper-room-background">Background</label><input type="text" class="form-control" id="mapper-room-background" placeholder=""></div></div></div></div><div class="accordion-item"><h2 class="accordion-header"><button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#mapper-room-location" aria-expanded="true" aria-controls="mapper-room-location">Location</button></h2><div id="mapper-room-location" class="accordion-collapse collapse" data-bs-parent="#mapper-room-accordion"><div class="accordion-body" style="padding:5px"><div class="mb-3"><label for="mapper-room-area" class="form-label">Area</label><select id="mapper-room-area" class="form-select"></select></div><div class="mb-3"><label for="mapper-room-x" class="form-label">X</label><input type="number" class="form-control" id="mapper-room-x"></div><div class="mb-3"><label for="mapper-room-y" class="form-label">Y</label><input type="number" class="form-control" id="mapper-room-y"></div><div class="mb-3"><label for="mapper-room-z" class="form-label">Z</label><input type="number" class="form-control" id="mapper-room-z"></div><div class="mb-3"><label for="mapper-room-zone" class="form-label">Zone</label><input type="number" class="form-control" id="mapper-room-zone"></div></div></div></div><div class="accordion-item"><h2 class="accordion-header"><button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#mapper-room-details" aria-expanded="true" aria-controls="mapper-room-details">Details</button></h2><div id="mapper-room-details" class="accordion-collapse collapse" data-bs-parent="#mapper-room-accordion"><div class="accordion-body" style="padding:5px"><div class="form-check form-switch"><input type="checkbox" class="form-check-input" id="mapper-room-indoors"><label class="form-check-label" for="mapper-room-indoors">Indoors</label></div><div class="mb-3"><label for="font" class="form-label">Terrain</label><div class="input-group"><input id="mapper-room-env" type="text" class="form-control" aria-label="Room terrain"><button type="button" class="btn btn-outline-secondary dropdown-toggle dropdown-toggle-split" style="border:var(--bs-border-width) solid var(--bs-border-color)" data-bs-toggle="dropdown" aria-expanded="false"><span class="visually-hidden">Toggle Dropdown</span></button><ul id="mapper-room-terrains" class="dropdown-menu dropdown-menu-end" style="height:200px;overflow:auto"><li><a class="dropdown-item" href="javascript:void(0)">beach</a></li><li><a class="dropdown-item" href="javascript:void(0)">bog</a></li><li><a class="dropdown-item" href="javascript:void(0)">city</a></li><li><a class="dropdown-item" href="javascript:void(0)">cliff</a></li><li><a class="dropdown-item" href="javascript:void(0)">cobble</a></li><li><a class="dropdown-item" href="javascript:void(0)">desert</a></li><li><a class="dropdown-item" href="javascript:void(0)">dirt</a></li><li><a class="dropdown-item" href="javascript:void(0)">dirtroad</a></li><li><a class="dropdown-item" href="javascript:void(0)">farmland</a></li><li><a class="dropdown-item" href="javascript:void(0)">forest</a></li><li><a class="dropdown-item" href="javascript:void(0)">grass</a></li><li><a class="dropdown-item" href="javascript:void(0)">grassland</a></li><li><a class="dropdown-item" href="javascript:void(0)">highmountain</a></li><li><a class="dropdown-item" href="javascript:void(0)">hills</a></li><li><a class="dropdown-item" href="javascript:void(0)">icesheet</a></li><li><a class="dropdown-item" href="javascript:void(0)">jungle</a></li><li><a class="dropdown-item" href="javascript:void(0)">lake</a></li><li><a class="dropdown-item" href="javascript:void(0)">mountain</a></li><li><a class="dropdown-item" href="javascript:void(0)">ocean</a></li><li><a class="dropdown-item" href="javascript:void(0)">pavedroad</a></li><li><a class="dropdown-item" href="javascript:void(0)">plains</a></li><li><a class="dropdown-item" href="javascript:void(0)">prairie</a></li><li><a class="dropdown-item" href="javascript:void(0)">river</a></li><li><a class="dropdown-item" href="javascript:void(0)">rockdesert</a></li><li><a class="dropdown-item" href="javascript:void(0)">rocky</a></li><li><a class="dropdown-item" href="javascript:void(0)">sand</a></li><li><a class="dropdown-item" href="javascript:void(0)">sanddesert</a></li><li><a class="dropdown-item" href="javascript:void(0)">savannah</a></li><li><a class="dropdown-item" href="javascript:void(0)">stone</a></li><li><a class="dropdown-item" href="javascript:void(0)">swamp</a></li><li><a class="dropdown-item" href="javascript:void(0)">tundra</a></li><li><a class="dropdown-item" href="javascript:void(0)">underwater</a></li><li><a class="dropdown-item" href="javascript:void(0)">water</a></li></ul></div></div><div><label for="font" class="form-label">Details</label></div><div class="form-check"><input class="form-check-input" type="checkbox" value="1" id="mapper-room-details-1" name="details" data-enum="true"><label class="form-check-label" for="mapper-room-details-1">Dock</label></div><div class="form-check"><input class="form-check-input" type="checkbox" value="2" id="mapper-room-details-2" name="details" data-enum="true"><label class="form-check-label" for="mapper-room-details-2">Pier</label></div><div class="form-check"><input class="form-check-input" type="checkbox" value="4" id="mapper-room-details-4" name="details" data-enum="true"><label class="form-check-label" for="mapper-room-details-4">Bank</label></div><div class="form-check"><input class="form-check-input" type="checkbox" value="8" id="mapper-room-details-8" name="details" data-enum="true"><label class="form-check-label" for="mapper-room-details-8">Shop</label></div><div class="form-check"><input class="form-check-input" type="checkbox" value="16" id="mapper-room-details-16" name="details" data-enum="true"><label class="form-check-label" for="mapper-room-details-16">Hospital</label></div><div class="form-check"><input class="form-check-input" type="checkbox" value="32" id="mapper-room-details-32" name="details" data-enum="true"><label class="form-check-label" for="mapper-room-details-32">Bar</label></div><div class="form-check"><input class="form-check-input" type="checkbox" value="64" id="mapper-room-details-64" name="details" data-enum="true"><label class="form-check-label" for="mapper-room-details-64">Restaurant</label></div><div class="form-check"><input class="form-check-input" type="checkbox" value="128" id="mapper-room-details-128" name="details" data-enum="true"><label class="form-check-label" for="mapper-room-details-128">WaterSource</label></div><div class="form-check"><input class="form-check-input" type="checkbox" value="256" id="mapper-room-details-256" name="details" data-enum="true"><label class="form-check-label" for="mapper-room-details-256">Trainer</label></div><div class="form-check"><input class="form-check-input" type="checkbox" value="512" id="mapper-room-details-512" name="details" data-enum="true"><label class="form-check-label" for="mapper-room-details-512">Stable</label></div></div></div></div><div class="accordion-item"><h2 class="accordion-header"><button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#mapper-room-notes" aria-expanded="true" aria-controls="mapper-room-notes">Notes</button></h2><div id="mapper-room-notes" class="accordion-collapse collapse" data-bs-parent="#mapper-room-accordion"><div class="accordion-body" style="padding:5px"><textarea class="form-control" rows="10" style="width:100%" id="mapper-room-notes"></textarea></div></div></div></div>';

  // src/plugins/mapper.ts
  var Mapper = class extends Plugin {
    constructor(options) {
      super(options instanceof Client ? options : options?.client);
      if (options && !(options instanceof Client)) {
      }
      this._clientContainer = document.getElementById("client-container");
      Map.load().then((map) => {
        this.map = map;
      }).catch((err) => this.client.error(err));
    }
    remove() {
      if (!this.client) return;
      this.client.removeListenersFromCaller(this);
      let idx = this.client.telnet.GMCPSupports.indexOf("Room 1");
      this.client.telnet.GMCPSupports.splice(idx, 1);
    }
    initialize() {
      if (!this.client) return;
      this.client.telnet.GMCPSupports.push("Room 1");
      this.client.on("received-GMCP", this.processGMCP, this);
      this.client.on("window", (window2) => {
        if (window2 === "mapper") this.show();
      });
      this.client.on("options-loaded", () => {
        if (this._dialogMap) {
          this._dialogMap.commandDelay = client.getOption("commandDelay");
          this._dialogMap.commandDelayCount = client.getOption("commandDelayCount");
          this._dialogMap.enabled = this.client.getOption("mapper.enabled");
          if (this._dialogMap.enabled)
            document.getElementById("mapper-enable").classList.add("active");
          else
            document.getElementById("mapper-enable").classList.remove("active");
          this._dialogMap.showLegend = this.client.getOption("mapper.legend");
          if (this._dialogMap.showLegend)
            document.getElementById("mapper-legend").classList.add("active");
          else
            document.getElementById("mapper-legend").classList.remove("active");
          this._dialogMap.follow = this.client.getOption("mapper.follow");
          if (this._dialogMap.follow)
            document.getElementById("mapper-follow").classList.add("active");
          else
            document.getElementById("mapper-follow").classList.remove("active");
          this._dialogMap.splitArea = this.client.getOption("mapper.split");
          if (this._dialogMap.splitArea)
            document.getElementById("mapper-split").classList.add("active");
          else
            document.getElementById("mapper-split").classList.remove("active");
          this._dialogMap.fillWalls = this.client.getOption("mapper.fill");
          if (this._dialogMap.fillWalls)
            document.getElementById("mapper-fill").classList.add("active");
          else
            document.getElementById("mapper-fill").classList.remove("active");
          if (this._dialogMap.follow)
            this._dialogMap.focusCurrentRoom();
        }
        if (this._dialog)
          this._dialog.resetState(Object.assign({}, client.getOption("windows.mapper") || { center: true }));
        let options2 = client.getOption("windows.mapper");
        if (options2 && options2.show || this.client.getOption("showMapper"))
          this.show();
      });
      this.on("debug", (e) => this.client.debug(e), this);
      this.on("error", (e) => this.client.error(e), this);
      let options = client.getOption("windows.mapper");
      if (options && options.show || this.client.getOption("showMapper"))
        this.show();
    }
    get menu() {
      return [
        {
          name: "-",
          position: 5,
          exists: "#menu-plugins",
          id: "plugins"
        },
        {
          name: " Show mapper",
          action: (e) => {
            this.show();
          },
          icon: '<i class="bi bi-map"></i>',
          position: 6
        }
      ];
    }
    get settings() {
      return [{
        name: " Mapper",
        action: "settings-mapper",
        icon: '<i class="bi bi-map"></i>',
        position: 7
      }];
    }
    get map() {
      return this._map;
    }
    set map(map) {
      this._map = map;
      if (this._dialogMap)
        this._dialogMap.map = map;
      this.emit("map-loaded");
    }
    /**
     * processGMCP - process incoming GMCP for Room events
     * @param {string} mod Client#received-GMCP module
     * @param {Object} data Client#received-GMCP data object
     */
    async processGMCP(mod, data) {
      if (!this.client.getOption("mapper.enabled")) return;
      switch (mod) {
        case "Room.Info":
          this.processData(data);
          break;
        case "Room.WrongDir":
          break;
      }
    }
    processData(data) {
      if (!this._map) {
        setTimeout(() => {
          this.processData(data);
        }, 10);
        return;
      }
      try {
        let room = this._map.getRoom({ num: "" + data.num });
        ;
        if (!room) {
          room = new Room();
          room.zone = this._map.current.zone;
          if (this._map.current.num !== null) {
            switch (data.prevroom.dir) {
              case "west":
                room.x--;
                break;
              case "east":
                room.x++;
                break;
              case "north":
                room.y--;
                break;
              case "south":
                room.y++;
                break;
              case "northeast":
                room.y--;
                room.x++;
                break;
              case "northwest":
                room.y--;
                room.x--;
                break;
              case "southeast":
                room.y++;
                room.x++;
                break;
              case "southwest":
                room.y++;
                room.x--;
                break;
              case "up":
                room.z++;
                break;
              case "down":
                room.z--;
                break;
              //out means you leave a zone
              case "out":
                room.zone = this._map.current.zone - 1;
                break;
              //enter or unknown exits new zone
              default:
                room.zone = this._map.current.zone + 1;
                break;
            }
            room.x += this._map.current.x;
            room.y += this._map.current.y;
            room.z += this._map.current.z;
          }
          if (data.area === this._map.current.area) {
            if (this._map.roomExists({ x: room.x, y: room.y, z: room.z, zone: this._map.current.zone, area: this._map.current.area }) || data.prevroom.zone) {
              room.zone = this._map.getFreeZone(this._map.current.zone);
              this._updateCurrent(room, data);
            } else {
              this._updateCurrent(room, data);
            }
          } else if (this._map.roomExists({ x: room.x, y: room.y, z: room.z, zone: this._map.current.zone }) || data.prevroom.zone) {
            room.zone = this._map.getFreeZone(this._map.current.zone);
            this._updateCurrent(room, data);
          } else {
            this._updateCurrent(room, data);
          }
        } else {
          this._updateCurrent(room, data);
        }
        this._map.save().catch((err) => this.client.error(err));
      } catch (e) {
        this.emit("error", e);
      }
    }
    _updateCurrent(room, data) {
      room.num = data.num;
      room.area = data.area;
      room.name = data.name;
      room.env = data.environment;
      room.indoors = data.indoors;
      let exit;
      for (exit in data.exits)
        room.exits[exit] = data.exits[exit];
      room.details = 0 /* None */;
      if (typeof data.details === "number")
        room.details = data.details;
      else
        for (let x2 = 0; x2 < data.details.length; x2++) {
          switch (data.details[x2]) {
            case "dock":
              room.details |= 1 /* Dock */;
              break;
            case "pier":
              room.details |= 2 /* Pier */;
              break;
            case "bank":
              room.details |= 4 /* Bank */;
              break;
            case "shop":
              room.details |= 8 /* Shop */;
              break;
            case "hospital":
              room.details |= 16 /* Hospital */;
              break;
            case "bar":
              room.details |= 32 /* Bar */;
              break;
            case "restaurant":
              room.details |= 64 /* Restaurant */;
              break;
            case "watersource":
              room.details |= 128 /* WaterSource */;
              break;
            case "trainer":
            case "training":
            case "advance":
              room.details |= 256 /* Trainer */;
              break;
            case "stable":
              room.details |= 512 /* Stable */;
              break;
          }
        }
      room = this._map.setRoom(room);
      this._map.current = room.clone();
      this.emit("current-changed", this._map.current);
    }
    /**
     * debug - emit debug event if enabledDebug on
     * @param {string | object} e The debug message or an object of data 
     */
    debug(e) {
      this.emit("debug", e);
    }
    refresh() {
    }
    createDialog() {
      if (this._dialog) return;
      this._dialog = new Dialog(Object.assign({}, client.getOption("windows.mapper") || { center: true }, { title: '<i class="bi bi-map"></i><select id="mapper-area" class="form-select form-select-sm me-2 mb-1" title="Select Area"></select>', id: "win-mapper", noFooter: true, minHeight: 350 }));
      this._dialog.on("resized", (e) => {
        this.client.setOption("windows.mapper", e);
        debounce(() => {
          this._dialogSplitter.panel1.parentElement.style.top = toolbar.offsetHeight + "px";
        }, 25, "mapper-resize");
      });
      this._dialog.on("moved", (e) => {
        this.client.setOption("windows.mapper", e);
      });
      this._dialog.on("maximized", () => {
        this.client.setOption("windows.mapper", this._dialog.windowState);
        debounce(() => {
          this._dialogSplitter.panel1.parentElement.style.top = toolbar.offsetHeight + "px";
        }, 25, "mapper-resize");
      });
      this._dialog.on("restored", () => {
        this.client.setOption("windows.mapper", this._dialog.windowState);
        debounce(() => {
          this._dialogSplitter.panel1.parentElement.style.top = toolbar.offsetHeight + "px";
        }, 25, "mapper-resize");
      });
      this._dialog.on("shown", () => {
        this.client.setOption("windows.mapper", this._dialog.windowState);
        this.client.setOption("showMapper", this._dialog.windowState.show !== 0);
        this._dialogSplitter.panel1.parentElement.style.top = toolbar.offsetHeight + "px";
      });
      this._dialog.on("closing", () => {
      });
      this._dialog.on("closed", () => {
        this.client.setOption("windows.mapper", this._dialog.windowState);
        this.client.setOption("showMapper", this._dialog.windowState.show !== 0);
        removeHash("mapper");
      });
      this._dialog.on("canceling", () => {
      });
      this._dialog.on("canceled", () => {
        this.client.setOption("windows.mapper", this._dialog.windowState);
        this.client.setOption("showMapper", this._dialog.windowState.show !== 0);
        removeHash("mapper");
      });
      this._dialog.on("resizing", () => {
        this._dialogSplitter.panel1.parentElement.style.top = toolbar.offsetHeight + "px";
      });
      const toolbar = document.createElement("nav");
      toolbar.id = "mapper-toolbar";
      toolbar.classList.add("navbar", "bg-light", "align-items-center");
      toolbar.innerHTML = `<form class="container-fluid justify-content-start"><button id="btn-mapper-menu" class="me-2 mb-1 btn-sm btn btn-outline-secondary" type="button" aria-controls="mapper-menu" title="Show menu" aria-expanded="false" data-bs-toggle="offcanvas" data-bs-target="#mapper-menu" aria-controls="mapper-menu"><i class="fa-solid fa-bars"></i></button><button id="btn-mapper-focus" type="button" class="btn btn-sm btn-outline-secondary me-2 mb-1" title="Focus on current room"><i class="fa fa-crosshairs"></i></button><div class="btn-group me-2 mb-1"><label for="mapper-level" class="mt-1 me-1">Level: </label><input id="mapper-level" class="form-control form-control-sm" type="number" title="Map Level"></div><div class="btn-group me-2 mb-1"><label for="mapper-zone" class="mt-1 me-1">Zone: </label><input id="mapper-zone" class="form-control form-control-sm" type="number" title="Map Zone"></div><div class="btn-group me-2 mb-1"><label for="mapper-zoom" class="me-1">Zoom: </label><input id="mapper-zoom" class="form-range" type="range" min="25" max="300" step="5""><label id="mapper-zoom-display">100%</label></div></form>`;
      this._dialog.body.appendChild(toolbar);
      this._dialog.body.insertAdjacentHTML("afterbegin", mapper_menu_default);
      this._dialog.body.querySelector("#mapper-enable a").addEventListener("click", () => {
        this._dialogMap.enabled = !this._dialogMap.enabled;
        if (this._dialogMap.enabled)
          this._dialog.body.querySelector("#mapper-enable").classList.add("active");
        else
          this._dialog.body.querySelector("#mapper-enable").classList.remove("active");
        closeMenu2();
      });
      this._dialog.body.querySelector("#mapper-legend a").addEventListener("click", () => {
        this._dialogMap.showLegend = !this._dialogMap.showLegend;
        if (this._dialogMap.showLegend)
          this._dialog.body.querySelector("#mapper-legend").classList.add("active");
        else
          this._dialog.body.querySelector("#mapper-legend").classList.remove("active");
        closeMenu2();
      });
      this._dialog.body.querySelector("#mapper-room a").addEventListener("click", () => {
        this._dialogSplitter.panel2Collapsed = !this._dialogSplitter.panel2Collapsed;
        if (this._dialogSplitter.panel2Collapsed) {
          this._dialog.dialog.dataset.panel = "left";
          this._dialog.body.querySelector("#mapper-room").classList.remove("active");
          this._dialog.body.querySelector("#mapper-room").title = "Show room properties";
          this._dialog.body.querySelector("#mapper-room a span").textContent = "Show room properties";
        } else {
          this._dialog.dialog.dataset.panel = "right";
          this._dialog.body.querySelector("#mapper-room").classList.add("active");
          this._dialog.body.querySelector("#mapper-room").title = "Hide room properties";
          this._dialog.body.querySelector("#mapper-room a span").textContent = "Hide room properties";
        }
        this._dialogSplitter.panel1.parentElement.style.top = toolbar.offsetHeight + "px";
        this.client.setOption("mapper.room", !this._dialogSplitter.panel2Collapsed);
        closeMenu2();
      });
      this._dialog.body.querySelector("#mapper-refresh a").addEventListener("click", () => {
        this._dialogMap.refresh();
        closeMenu2();
      });
      this._dialog.body.querySelector("#mapper-split a").addEventListener("click", () => {
        this._dialogMap.splitArea = !this._dialogMap.splitArea;
        if (this._dialogMap.splitArea)
          this._dialog.body.querySelector("#mapper-split").classList.add("active");
        else
          this._dialog.body.querySelector("#mapper-split").classList.remove("active");
        closeMenu2();
      });
      this._dialog.body.querySelector("#mapper-fill a").addEventListener("click", () => {
        this._dialogMap.fillWalls = !this._dialogMap.fillWalls;
        if (this._dialogMap.fillWalls)
          this._dialog.body.querySelector("#mapper-fill").classList.add("active");
        else
          this._dialog.body.querySelector("#mapper-fill").classList.remove("active");
        closeMenu2();
      });
      this._dialog.body.querySelector("#mapper-follow a").addEventListener("click", () => {
        this._dialogMap.follow = !this._dialogMap.follow;
        if (this._dialogMap.follow)
          document.getElementById("mapper-follow").classList.add("active");
        else
          document.getElementById("mapper-follow").classList.remove("active");
        closeMenu2();
      });
      this._dialog.body.querySelector("#mapper-focus a").addEventListener("click", () => {
        this._dialogMap.focusCurrentRoom();
        closeMenu2();
      });
      this._dialog.body.querySelector("#mapper-set-current a").addEventListener("click", () => {
        this._dialogMap.current = this._dialogMap.selected;
        closeMenu2();
      });
      this._dialog.body.querySelector("#btn-mapper-focus").addEventListener("click", () => {
        this._dialogMap.focusCurrentRoom();
        closeMenu2();
      });
      this._dialog.body.querySelector("#mapper-highlight-path a").addEventListener("click", () => {
        this._dialogMap.focusCurrentRoom();
        this._dialogMap.showPath();
        closeMenu2();
      });
      this._dialog.body.querySelector("#mapper-clear-path a").addEventListener("click", () => {
        this._dialogMap.clearPath();
        closeMenu2();
      });
      this._dialog.body.querySelector("#mapper-walk-path a").addEventListener("click", () => {
        this._dialogMap.walkPath();
        closeMenu2();
      });
      this._dialog.body.querySelector("#mapper-walk-highlighted-path a").addEventListener("click", () => {
        this._dialogMap.walkMarkedPath();
        closeMenu2();
      });
      this._dialog.body.querySelector("#mapper-copy-path a").addEventListener("click", () => {
        this._dialogMap.copyPath("\n");
        closeMenu2();
      });
      this._dialog.body.querySelector("#mapper-copy-stacked a").addEventListener("click", () => {
        this._dialogMap.copyPath(this.client.getOption("commandStackingChar"));
        closeMenu2();
      });
      this._dialog.body.querySelector("#mapper-copy-speedpath a").addEventListener("click", () => {
        this._dialogMap.copySpeedpath();
        closeMenu2();
      });
      this._dialog.body.querySelector("#mapper-copy-highlighted-path a").addEventListener("click", () => {
        this._dialogMap.copyMarkedPath("\n");
        closeMenu2();
      });
      this._dialog.body.querySelector("#mapper-copy-highlighted-stacked a").addEventListener("click", () => {
        this._dialogMap.copyMarkedPath(this.client.getOption("commandStackingChar"));
        closeMenu2();
      });
      this._dialog.body.querySelector("#mapper-remove-selected a").addEventListener("click", () => {
        confirm_box("Remove selected room?", `Are you sure you want to remove selected room?`).then((e) => {
          if (e.button === 4 /* Yes */)
            this._dialogMap.clearSelectedRoom();
        });
        closeMenu2();
      });
      this._dialog.body.querySelector("#mapper-remove-current a").addEventListener("click", () => {
        confirm_box("Remove current room?", `Are you sure you want to remove current room?`).then((e) => {
          if (e.button === 4 /* Yes */)
            this._dialogMap.clearCurrentRoom();
        });
        closeMenu2();
      });
      this._dialog.body.querySelector("#mapper-remove-current-area a").addEventListener("click", () => {
        confirm_box("Remove current area?", `Are you sure you want to remove all rooms from current area?`).then((e) => {
          if (e.button === 4 /* Yes */)
            this._dialogMap.clearArea();
        });
        closeMenu2();
      });
      this._dialog.body.querySelector("#mapper-remove-all a").addEventListener("click", () => {
        confirm_box("Remove all rooms and areas?", `Are you sure you want to remove all rooms?`).then((e) => {
          if (e.button === 4 /* Yes */)
            this._dialogMap.clearAll();
        });
        closeMenu2();
      });
      this._dialog.body.querySelector("#mapper-export-image a").addEventListener("click", () => {
        this._dialogMap.exportImage();
        closeMenu2();
      });
      this._dialog.body.querySelector("#mapper-export-scaled-image a").addEventListener("click", () => {
        this._dialogMap.exportImage(true);
        closeMenu2();
      });
      this._dialog.body.querySelector("#mapper-export-current-image a").addEventListener("click", () => {
        this._dialogMap.exportCurrentImage();
        closeMenu2();
      });
      this._dialog.body.querySelector("#mapper-export-current-area a").addEventListener("click", () => {
        this._dialogMap.exportArea();
        closeMenu2();
      });
      this._dialog.body.querySelector("#mapper-export-all a").addEventListener("click", () => {
        this._dialogMap.exportAll();
        closeMenu2();
      });
      this._dialog.body.querySelector("#mapper-import-merge a").addEventListener("click", () => {
        openFileDialog("Import map and merge", false).then((files) => {
          readFile(files[0]).then((data) => {
            this.import(data, 0 /* Merge */);
          }).catch(client.error);
        }).catch(() => {
        });
        closeMenu2();
      });
      this._dialog.body.querySelector("#mapper-import-replace a").addEventListener("click", () => {
        confirm_box("Import and Replace?", `Are you sure you want to remove all rooms and replace them?`).then((e) => {
          if (e.button === 4 /* Yes */)
            openFileDialog("Import map and replace", false).then((files) => {
              readFile(files[0]).then((data) => {
                this.import(data, 1 /* Replace */);
              }).catch(client.error);
            }).catch(() => {
            });
        });
        closeMenu2();
      });
      this._dialog.body.querySelector("#mapper-copy-highlighted-speedpath a").addEventListener("click", () => {
        this._dialogMap.copyMarkedSpeedpath();
        closeMenu2();
      });
      this._dialog.body.querySelector("#mapper-about a").addEventListener("click", () => {
        alert_box({ title: '<i class="fa-solid fa-circle-info"></i> Map information', width: 300, height: 200, keepCentered: true, center: true, resizable: false, moveable: false, maximizable: false, buttons: 1 /* Ok */ }, `Areas: ${this._map.Areas.length}<br>Rooms: ${this._map.count}<br>Highest zone: ${this._map.zone}`, 2);
        closeMenu2();
      });
      this._dialogMap = new MapDisplay(document.createElement("div"), { map: this._map });
      this._dialogMap.on("error", (e) => this.client.error(e), this);
      this._dialogMap.on("remove-selected", () => {
        confirm_box("Remove selected room?", `Are you sure you want to remove selected room?`).then((e) => {
          if (e.button === 4 /* Yes */)
            this._dialogMap.clearSelectedRoom();
        });
      });
      this._dialogMap.on("active-room-changed", (room) => {
        const area = document.getElementById("mapper-area");
        if (!room.area || room.area.length === 0) {
          if (area.options.length)
            area.value = area.options[0].value;
        } else {
          if (!area.querySelectorAll(`option[value="${room.area.replace(/"/g, "&quot;")}"]`).length) {
            area.insertAdjacentHTML("beforeend", `<option value="${room.area.replace(/"/g, "&quot;")}">${room.area}</option>`);
            document.getElementById("mapper-room-area").insertAdjacentHTML("beforeend", `<option value="${room.area.replace(/"/g, "&quot;")}">${room.area}</option>`);
          }
          area.value = room.area;
        }
        document.getElementById("mapper-level").value = room.z;
        document.getElementById("mapper-zone").value = room.zone;
        room = room.clone();
        room.ID = room.num;
        delete room.num;
        this.client.setOption("mapper.active", room);
      });
      this._dialogMap.on("setting-changed", (setting, value) => {
        if (setting === "active") {
          document.getElementById("mapper-area").value = value.area;
          document.getElementById("mapper-level").value = value.z;
          document.getElementById("mapper-zone").value = value.zone;
        } else if (setting === "scale") {
          document.getElementById("mapper-zoom").value = value;
          document.getElementById("mapper-zoom-display").textContent = value + "%";
        }
        this.client.setOption(`mapper.${setting}`, value);
      });
      document.getElementById("mapper-area").addEventListener("change", (e) => {
        this._dialogMap.setArea(e.currentTarget.value);
      });
      document.getElementById("mapper-level").addEventListener("change", (e) => {
        this._dialogMap.setLevel(parseInt(e.currentTarget.value, 10));
      });
      document.getElementById("mapper-zone").addEventListener("change", (e) => {
        this._dialogMap.setZone(parseInt(e.currentTarget.value, 10));
      });
      this._dialogSplitter = new Splitter({ id: "mapper", parent: this._dialog.body, orientation: 1 /* vertical */ });
      this._dialogSplitter.on("splitter-moved", (e) => {
        this.client.setOption("mapper.roomWidth", e);
      });
      this._dialogSplitter.panel2Collapsed = true;
      if (this.client.getOption("mapper.room"))
        this._dialog.body.querySelector("#mapper-room a").click();
      this._dialogSplitter.SplitterDistance = client.getOption("mapper.roomWidth");
      this._dialogSplitter.panel2.innerHTML = mapper_room_default;
      document.getElementById("mapper-room-close").addEventListener("click", () => {
        this._dialog.body.querySelector("#mapper-room a").click();
      });
      document.getElementById("mapper-room-accordion").querySelectorAll("input,textarea,select,.accordion-body button").forEach((f) => {
        f.disabled = true;
        if (f.tagName === "BUTTON") return;
        if (f.type === "checkbox") {
          f.addEventListener("change", (e) => {
            if (this._dialogMap.selected === null || this._dialogMap.selected.num === null) return;
            const target = e.currentTarget || e.target;
            const name2 = f.name || f.id.substring(12);
            if (target.dataset.enum === "true") {
              const name3 = target.name || target.id.substring(0, target.id.lastIndexOf("-"));
              const enums = document.getElementById("mapper-room-accordion").querySelectorAll(`[name=${name3}]`);
              let value = 0;
              for (let e2 = 0, el2 = enums.length; e2 < el2; e2++) {
                if (enums[e2].checked)
                  value |= +enums[e2].value;
              }
              this._dialogMap.selected[name3] = value;
            } else
              this._dialogMap.selected[name2] = target.checked;
            this._map.setRoom(this._dialogMap.selected);
            this._map.save().catch((err) => this.client.error(err));
          });
        } else {
          f.addEventListener("change", (e) => {
            if (this._dialogMap.selected === null || this._dialogMap.selected.num === null) return;
            const name2 = f.name || f.id.substring(12);
            debounce(() => {
              const target = e.currentTarget || e.target;
              this._dialogMap.selected[name2] = target.value;
              this._map.setRoom(this._dialogMap.selected);
              this._map.save().catch((err) => this.client.error(err));
            }, 100, name2);
          });
          f.addEventListener("input", (e) => {
            if (this._dialogMap.selected === null || this._dialogMap.selected.num === null) return;
            const name2 = f.name || f.id.substring(12);
            debounce(() => {
              const target = e.currentTarget || e.target;
              this._dialogMap.selected[name2] = target.value;
              this._map.setRoom(this._dialogMap.selected);
            }, 100, name2);
          });
        }
      });
      this._dialogMap.on("room-selected", (room) => {
        document.getElementById("mapper-room-accordion").querySelectorAll("input,textarea,select,.accordion-body button").forEach((f) => {
          if (room === null || room.num === null) {
            f.disabled = true;
            if (f.tagName === "BUTTON") return;
            if (f.type === "checkbox")
              f.checked = false;
            else
              f.value = "";
          } else {
            f.disabled = false;
            if (f.tagName === "BUTTON") return;
            const name2 = f.name || f.id.substring(12);
            if (f.type === "checkbox") {
              if (f.dataset.enum === "true") {
                const value = +f.value;
                f.checked = (room[name2] & value) === value;
              } else
                f.checked = room[name2];
            } else
              f.value = room[name2];
          }
        });
        const selected = room;
        const current = this._map.current;
        this._updateMenu("#mapper-remove-selected a", selected === null || selected.num === null);
        this._updateMenu("#mapper-set-current a", selected === null || selected.num === null);
        this._updateMenu("#mapper-highlight-path a", selected === null || selected.num === null || !current || current.num === null || selected.num === current.num);
        this._updateMenu("#mapper-walk-path a", selected === null || selected.num === null || !current || current.num === null || selected.num === current.num);
        this._updateMenu("#mapper-copy-path a", selected === null || selected.num === null || !current || current.num === null || selected.num === current.num);
        this._updateMenu("#mapper-copy-stacked a", selected === null || selected.num === null || !current || current.num === null || selected.num === current.num);
        this._updateMenu("#mapper-copy-speedpath a", selected === null || selected.num === null || !current || current.num === null || selected.num === current.num);
      });
      this._dialogMap.on("current-changed", (room) => {
        const selected = this._dialogMap.selected;
        const current = room;
        this._updateMenu("#mapper-remove-current a", current === null || current.num === null);
        this._updateMenu("#mapper-remove-selected a", selected === null || selected.num === null);
        this._updateMenu("#mapper-set-current a", selected === null || selected.num === null);
        this._updateMenu("#mapper-highlight-path a", selected === null || selected.num === null || !current || current.num === null || selected.num === current.num);
        this._updateMenu("#mapper-walk-path a", selected === null || selected.num === null || !current || current.num === null || selected.num === current.num);
        this._updateMenu("#mapper-copy-path a", selected === null || selected.num === null || !current || current.num === null || selected.num === current.num);
        this._updateMenu("#mapper-copy-stacked a", selected === null || selected.num === null || !current || current.num === null || selected.num === current.num);
        this._updateMenu("#mapper-copy-speedpath a", selected === null || selected.num === null || !current || current.num === null || selected.num === current.num);
      });
      this._dialogMap.on("path-shown", () => {
        this._updateMenu("#mapper-highlight-path a", false);
        this._updateMenu("#mapper-walk-path a", false);
        this._updateMenu("#mapper-walk-highlighted-path a", false);
        this._updateMenu("#mapper-clear-path a", false);
        this._updateMenu("#mapper-copy-highlighted-path a", false);
        this._updateMenu("#mapper-copy-highlighted-stacked a", false);
        this._updateMenu("#mapper-copy-highlighted-speedpath a", false);
      });
      this._dialogMap.on("path-cleared", () => {
        this._updateMenu("#mapper-clear-path a", true);
        this._updateMenu("#mapper-walk-highlighted-path a", true);
        this._updateMenu("#mapper-copy-highlighted-path a", true);
        this._updateMenu("#mapper-copy-highlighted-stacked a", true);
        this._updateMenu("#mapper-copy-highlighted-speedpath a", true);
      });
      const el = this._dialog.body.querySelector("#mapper-room-env");
      let items = this._dialog.body.querySelectorAll("#mapper-room-terrains .active");
      let i2, il;
      for (i2 = 0, il = items.length; i2 < il; i2++)
        items[i2].classList.remove("active");
      items = this._dialog.body.querySelectorAll("#mapper-room-terrains .dropdown-item");
      for (i2 = 0, il = items.length; i2 < il; i2++) {
        items[i2].addEventListener("click", function() {
          el.value = this.textContent;
          el.dispatchEvent(new Event("change"));
        });
      }
      el.nextElementSibling.addEventListener("show.bs.dropdown", (event2) => {
        let items2 = this._dialog.body.querySelectorAll("#mapper-room-terrains .dropdown-item");
        for (i2 = 0, il = items2.length; i2 < il; i2++) {
          items2[i2].classList.remove("active");
          if (el.value === items2[i2].textContent)
            items2[i2].classList.add("active");
        }
        ;
      });
      this._dialogSplitter.panel1.append(this._dialogMap.container);
      this._dialogMap.container.classList.add("map");
      this._dialogMap.active = new Room(client.getOption("mapper.active"));
      this._dialogMap.active.num = this._dialogMap.active.num || this._dialogMap.active.ID;
      this._dialogMap.commandDelay = client.getOption("commandDelay");
      this._dialogMap.commandDelayCount = client.getOption("commandDelayCount");
      this._dialogMap.on("debug", (msg) => {
        this.client.debug(msg);
      });
      document.getElementById("mapper-level").value = "" + this._dialogMap.active.z;
      document.getElementById("mapper-zone").value = "" + this._dialogMap.active.zone;
      document.getElementById("mapper-zoom").addEventListener("input", (e) => {
        this._dialogMap.scale = +e.currentTarget.value;
      });
      const initMapper = () => {
        const m = this._map.Areas.length;
        const area = document.getElementById("mapper-area");
        area.addEventListener("mouseup", (e) => {
          e.stopPropagation();
          e.cancelBubble = true;
        });
        area.addEventListener("touchstart", (e) => {
          e.stopPropagation();
          e.cancelBubble = true;
        }, { passive: true });
        area.addEventListener("mousedown", (e) => {
          e.stopPropagation();
          e.cancelBubble = true;
        });
        let h = "";
        for (var i3 = 0; i3 < m; i3++)
          h += `<option value="${this._map.Areas[i3].replace(/"/g, "&quot;")}">${this._map.Areas[i3]}</option>`;
        area.innerHTML = h;
        document.getElementById("mapper-room-area").innerHTML = h;
        if (this._dialogMap.active.area && this._map.Areas.indexOf(this._dialogMap.active.area) !== -1)
          area.value = this._dialogMap.active.area;
        else if (m > 0) {
          this._dialogMap.active.area = this.map.Areas[0];
          this._dialogMap.emit("setting-changed", "active", this._dialogMap.active.area);
          area.value = this._dialogMap.active.area;
        }
        this._dialogMap.refresh();
        this._dialogMap.enabled = this.client.getOption("mapper.enabled");
        if (this._dialogMap.enabled)
          document.getElementById("mapper-enable").classList.add("active");
        this._dialogMap.showLegend = this.client.getOption("mapper.legend");
        if (this._dialogMap.showLegend)
          document.getElementById("mapper-legend").classList.add("active");
        this._dialogMap.follow = this.client.getOption("mapper.follow");
        if (this._dialogMap.follow)
          document.getElementById("mapper-follow").classList.add("active");
        this._dialogMap.splitArea = this.client.getOption("mapper.split");
        if (this._dialogMap.splitArea)
          document.getElementById("mapper-split").classList.add("active");
        this._dialogMap.fillWalls = this.client.getOption("mapper.fill");
        if (this._dialogMap.fillWalls)
          document.getElementById("mapper-fill").classList.add("active");
        if (this._dialogMap.follow)
          this._dialogMap.focusCurrentRoom();
        this._dialogMap.scale = this.client.getOption("mapper.scale");
        this._map.on("rooms-removed", (rooms) => {
          this._map.save();
        });
        this._map.on("areas-removed", (areas) => {
          const area2 = document.getElementById("mapper-area");
          const roomArea = document.getElementById("mapper-room-area");
          if (this._map.Areas.length === 0) {
            area2.innerHTML = "";
            roomArea.innerHTML = "";
          } else {
            for (var i4 = area2.length - 1; i4 >= 0; i4--) {
              if (areas.indexOf(area2.options[i4].value) !== -1)
                area2.remove(i4);
            }
            for (var i4 = roomArea.length - 1; i4 >= 0; i4--) {
              if (areas.indexOf(roomArea.options[i4].value) !== -1)
                roomArea.remove(i4);
            }
          }
        });
        this._map.on("areas-added", (areas) => {
          let h2 = "";
          const m2 = this._map.Areas.length;
          for (let i4 = 0; i4 < m2; i4++)
            h2 += `<option value="${this._map.Areas[i4].replace(/"/g, "&quot;")}">${this._map.Areas[i4]}</option>`;
          document.getElementById("mapper-area").innerHTML = h2;
          document.getElementById("mapper-room-area").innerHTML = h2;
          if (this._dialogMap.active.area && this._map.Areas.indexOf(this._dialogMap.active.area) !== -1)
            document.getElementById("mapper-area").value = this._dialogMap.active.area;
          else if (m2 > 0) {
            this._dialogMap.active.area = this.map.Areas[0];
            this._dialogMap.emit("setting-changed", "active", this._dialogMap.active.area);
            document.getElementById("mapper-area").value = this._dialogMap.active.area;
          }
        });
        this._map.on("import-progress", (progress) => {
          if (this._dialogProgress)
            this._dialogProgress.progress = progress;
        });
        this._map.on("import-complete", () => {
          client.sendGMCP("Room.Info");
          if (this._dialogProgress)
            this._dialogProgress.close();
          this._dialogProgress = null;
          this._dialogMap.refresh();
          this._map.save();
        });
        this._map.on("import-canceled", () => {
          client.sendGMCP("Room.Info");
          if (this._dialogProgress)
            this._dialogProgress.close();
          this._dialogProgress = null;
          this._dialogMap.refresh();
          this._map.save();
        });
      };
      this.on("map-loaded", () => {
        initMapper();
      });
      if (this.map)
        initMapper();
    }
    show() {
      this.createDialog();
      this._dialog.show();
    }
    _updateMenu(selector, disabled) {
      if (disabled)
        this._dialog.body.querySelector(selector).classList.add("disabled");
      else
        this._dialog.body.querySelector(selector).classList.remove("disabled");
    }
    import(data, type) {
      if (this._dialogProgress)
        throw new Error("Import already in progress");
      if (typeof data === "string")
        data = JSON.parse(data);
      this._dialogProgress = progress_box("Importing map");
      this._dialogProgress.on("canceled", () => {
        this.map.cancelImport();
      });
      this._dialogProgress.on("closed", (reason) => {
        if (reason === "canceled")
          this.map.cancelImport();
      });
      this._dialogProgress.on("shown", () => {
        this.map.import(data, type);
      });
      this._dialogProgress.showModal();
    }
  };
  function closeMenu2() {
    const instance = bootstrap.Offcanvas.getInstance(document.getElementById("mapper-menu"));
    if (!instance) return;
    instance.hide();
  }

  // src/html/status.htm
  var status_default = '<div id="status-drag-bar"></div><div id="status" class="d-flex flex-column"><button id="status-close" style="padding:4px" type="button" class="btn btn-close btn-danger" title="Hide status"></button><div id="character-name" class="status-panel">&nbsp;</div><div id="environment" class="status-panel day"><div id="environmentleft"></div><div id="environmentcenter"></div><div id="environmentright"></div><div id="environmentweather"></div></div><div id="body" class="status-panel"><div id="limbs"><button id="health" class="button button-sm active" title="Show limb health"><i class="fa fa-heart"></i></button><button id="armor" class="button button-sm" title="Show limb armor protection"><svg width="11" height="17" viewBox="0 0 10 17" preserveAspectRatio="xMidYMid"><path fill="currentColor" d="M5 0c0 0 1 0 1 0 1 0 2 1 3 1 1 1 1 2 1 3 0 2 0 5 0 8 -1 1-2 3-3 3 0-2 0-4 0-6 1-1 2-1 2-1C9 7 9 6 9 6 8 6 7 7 6 7 6 7 5 8 5 8 5 8 4 7 4 7 3 7 2 6 1 6 1 6 1 7 1 8c1 0 2 1 2 1 0 2 0 4 0 6 -1-1-2-1-3-2 0 0-1-1-1-1 0-1 0-1 0-2 0-1 0-1 0-2 0-1 0-3 0-4 0-1 1-2 2-2C3 1 4 0 5 0z"/></svg></button><svg id="fullbody" class="health-full" xmlns="http://www.w3.org/2000/svg" width="128" height="200" viewBox="-0.9 -0.8 179 297"><path id="rightwing" d="M140.5 0.1c7-0.8 8 6.4 7.7 11.8 -0.4 9.2-0.3 18.2 1.1 25.8 0.6 3.1 2 6 2 8.3 0.1 7.6-6.1 11.4-10 14.6 1.9 0.5 4.5 0.3 6 1.1 0.6 1.8 0.3 4.7 0 6.6 1.9 0.5 4.7 0.1 6 1.1 0.4 2.2-0.7 2.4-0.6 4 0.3 3 4.2 4.2 4.3 6.6 0.1 1.8-1.1 2.3-2 4 0.6 1.1 2.2 1.2 2.3 2.9 -2.3 2.3-4.2 4.2-1.4 6.9 5.8 5.6 20.4 8.8 21.8 18.6 -3.5 3.1-7.3-0.6-10-2.6 -3-2.2-5.1-5.5-7.7-7.7 -3.3-2.8-9.4-7.3-12.3-2 -0.3 1.6 0.9 1.8 0.6 3.4 -6-0.7-7.7 3-9.7 6.3 -4.9-0.5-6.6-5.4-12.3-4 -1.1-1-1.8-0.7-3.4-0.3 -0.3-1.5-1.6-2-3.2-2.3 -1.5-7.4-6.6-11.2-11.5-15.2 -1.3 5.8-4.9 9.5-11.8 9.8 -5.8-7.5-8.3-23-5.4-35.6 2-1.4 4.5-2.4 8-2.3C103.8 35.9 114.5 3 140.5 0.1zM138.2 6.1c3.6 0.1 5.2 2.3 4.6 6.6C146.3 8.9 141.8 0.5 138.2 6.1zM129.9 7.2c-7 3.1-12.1 10.6-15.5 18.4 1.6 0.2 2.8-2.6 4.6-4 1.4-1.1 3.6-1.8 4.9-3.2C126.7 15.3 126.6 9.9 129.9 7.2zM139.1 9.8c-6.4 4-8.6 12.1-11.5 19.5C133.3 26 139.7 19.4 139.1 9.8zM140.5 20.4c3.4-0.7 4 4.1 2.3 6C146.7 26.3 144.7 15.9 140.5 20.4zM124.7 20.7c-2.7 4.4-7.3 6.9-10.9 10.6 -7.8 8.1-10.7 20.2-13.2 32.7 4.9-6.8 9.9-13.3 15.8-19.8 1.8-2 4.7-4 5.7-6C124.6 33.4 123.5 27.4 124.7 20.7zM140.5 24.1c-1.2 0-2.6-0.1-3.4 0.3 -2.1 4-5.7 6.6-10 8.3 -0.2 1.1-0.6 2.1-0.9 3.2C132.1 33.1 138.4 30.8 140.5 24.1zM145.9 32.7c-0.9 1.9-1.6 4-2.6 5.7C146.1 38.4 146.3 35.1 145.9 32.7zM119.8 44.2c5.5 0.4 9.9-2.7 15.5-3.2 1.5-3 5.2-3.8 6.3-7.2C131.7 33.5 125.4 39.2 119.8 44.2zM144.2 42.8c0.6 2.8-1.6 4.8-3.7 5.7C144.8 50.7 149.8 43.7 144.2 42.8zM111.5 53.7c5.5-2.1 11.4-3.7 18.1-4.6 1.4-2.5 4.9-2.9 6.9-4.9C125.6 43.5 116.3 48.3 111.5 53.7zM108.7 57.7c4.6 0.6 10.2 0.3 14.3 1.4 2.4-1.8 4.6-3.8 7.5-5.2C122.4 52.3 113.7 54.5 108.7 57.7zM138.2 54.8c-3.6 0.5-4.2 3.8-8 4C133.9 59.7 138 58.4 138.2 54.8zM103.8 63.7c2.7-1.8 11.9 1.9 12-3.2C110.9 60 105.3 60 103.8 63.7zM119 61.7c0.7 1.4-0.4 2.9 0 3.7 2.4 0 3.7-1.1 3.4-3.7C121.8 61.3 119.6 61.3 119 61.7zM126.4 65.1c4.1-0.3 11.1 1.8 14.6-0.6C138.9 59.6 128.5 62.6 126.4 65.1zM130.7 67.7c3.4 3.1 8 5 14.6 4.9C143.7 69 137.3 66.5 130.7 67.7zM110.1 71.7c4.6 4.2 17.8 5.3 23.2 1.1 -3.3-2.2-6.9-4-12-3.2C118.1 70.3 114.1 72.8 110.1 71.7zM108.4 74.3c-0.5 0.2 0 0.5 0 0.9 9.8 7 20.8 12.9 34.7 15.8 -3.7-4.5-6.7-9.5-11.5-12.9C122.6 78.9 114.6 77.2 108.4 74.3zM135.6 76c2.6 2.5 9 2.6 13.8 2C147.2 74.3 140.9 76.5 135.6 76zM109.8 78.3c-0.4 0.1 0 0.3 0 0.6 3.9 3.2 8.4 5.5 12 8.9 3.6 3.3 7.2 6.8 8.9 12 1.5 0.5 2.8 1.2 3.7 2.3 0-6.3-5.4-10.3-9.7-13.8C120 84.6 114.9 81.2 109.8 78.3zM136.2 79.2c1.7 2.9 7.1 4.5 12.3 4.9 0.1-1-0.1-1.6-0.3-2.3C144.9 80.2 139 81.2 136.2 79.2zM152.5 81.2c-0.6 0.2-0.9 0.6-1.4 0.9 -0.1 1.2 0.4 1.9 0.9 2.6C152.5 83.8 152.3 82.3 152.5 81.2zM110.1 81.5c-0.8 0.6 0.1 1.8 0 2.6 4.4 2.6 7.6 6.4 8.9 12 0.5 0 1 0 1.4 0 0.8 2 2.3 3.5 3.4 5.2 1.7-0.2 2-1.9 4.3-1.4C125.3 90.5 116.8 86.9 110.1 81.5zM141.9 85.2c0.5 2.1 3 4.6 6 5.2 0.1-1.3 0-2.5-0.6-3.2C144.9 87.2 143.2 86.4 141.9 85.2zM149.7 86.7c0.1 1.6 0.9 2.5 1.4 3.7 0.8-0.6 1-1.8 1.4-2.9C151.4 87.4 151.1 86.4 149.7 86.7zM127.6 88.1c2.8 2.9 5.3 6.2 10 7.2C135.1 92.1 132.6 88.8 127.6 88.1zM140.5 93.2c0.5 1 0 3 2 2.6 0.3-0.3 0.3-1 0.3-1.7C142 93.9 141.6 93.2 140.5 93.2zM144.2 98.7c1.1-1.2 3.1-3 3.4-4C146 94.4 144.1 96.2 144.2 98.7zM136.8 98.1c-0.7 0.6 0.1 1.1 0 2 0.8 0.2 0.7-0.4 1.4-0.3C138.2 98.8 137.6 98.3 136.8 98.1zM140.5 101.6c-0.9-0.5-2.3 0.9-2.3 2.3C139 103.2 139.3 101.9 140.5 101.6z"/><path id="leftwing" d="M78.9 60c3.6-0.1 6 0.9 8 2.3 2.9 12.6 0.4 28-5.4 35.6 -6.9-0.3-10.4-3.9-11.8-9.7 -4.9 4-10 7.8-11.5 15.2 -1.5 0.3-2.9 0.8-3.2 2.3 -1.6-0.4-2.3-0.7-3.4 0.3 -5.8-1.3-7.5 3.5-12.3 4 -2.1-3.3-3.7-7-9.7-6.3 -0.3-1.6 0.9-1.8 0.6-3.4 -3-5.3-9-0.8-12.3 2 -2.6 2.3-4.7 5.5-7.7 7.7 -2.7 2-6.5 5.7-10 2.6 1.4-9.8 16-13 21.8-18.6 2.8-2.7 0.9-4.6-1.4-6.9 0.1-1.6 1.7-1.7 2.3-2.9 -0.9-1.8-2.1-2.2-2-4 0.1-2.4 4-3.6 4.3-6.6 0.2-1.6-0.9-1.8-0.6-4 1.3-1.1 4.1-0.6 6-1.1 -0.3-1.9-0.6-4.8 0-6.6 1.5-0.9 4.1-0.6 6-1.1 -3.9-3.2-10.2-7.1-10-14.6 0-2.3 1.4-5.2 2-8.3 1.5-7.6 1.6-16.6 1.1-25.8C29.3 6.5 30.3-0.7 37.3 0.1 63.3 3 74 35.9 78.9 60zM35 12.7c-0.6-4.3 1-6.5 4.6-6.6C36 0.5 31.5 8.9 35 12.7zM53.9 18.4c1.3 1.4 3.5 2 4.9 3.2 1.8 1.5 3 4.2 4.6 4C60 17.9 54.9 10.3 47.9 7.2 51.2 9.9 51 15.3 53.9 18.4zM50.2 29.3c-2.9-7.4-5.1-15.5-11.5-19.5C38.1 19.4 44.5 26 50.2 29.3zM35 26.4c-1.7-1.9-1.2-6.7 2.3-6C33 15.9 31.1 26.3 35 26.4zM55.6 38.2c1 2 3.9 4 5.7 6 5.9 6.4 10.9 12.9 15.8 19.8 -2.5-12.5-5.4-24.6-13.2-32.7 -3.6-3.7-8.2-6.2-10.9-10.6C54.3 27.4 53.2 33.4 55.6 38.2zM51.6 35.9c-0.3-1.1-0.6-2-0.9-3.2 -4.4-1.7-8-4.3-10-8.3 -0.9-0.4-2.2-0.3-3.4-0.3C39.3 30.8 45.7 33.1 51.6 35.9zM34.4 38.5c-1-1.8-1.7-3.9-2.6-5.7C31.4 35.1 31.7 38.4 34.4 38.5zM36.1 33.9c1.1 3.4 4.8 4.2 6.3 7.2 5.6 0.4 10 3.6 15.5 3.2C52.4 39.2 46.1 33.5 36.1 33.9zM37.3 48.5c-2.1-1-4.3-2.9-3.7-5.7C27.9 43.7 33 50.7 37.3 48.5zM41.3 44.2c2 1.9 5.4 2.4 6.9 4.9 6.7 0.9 12.6 2.5 18.1 4.6C61.5 48.3 52.2 43.5 41.3 44.2zM47.3 54c2.9 1.3 5.1 3.3 7.5 5.2 4.1-1.1 9.7-0.8 14.3-1.4C64.1 54.5 55.3 52.3 47.3 54zM47.6 58.8c-3.8-0.2-4.5-3.6-8-4C39.8 58.4 43.9 59.7 47.6 58.8zM61.9 60.6c0.2 5.1 9.3 1.3 12 3.2C72.5 60 66.9 60 61.9 60.6zM55.3 61.7c-0.2 2.6 1 3.8 3.4 3.7 0.4-0.8-0.7-2.3 0-3.7C58.1 61.3 56 61.3 55.3 61.7zM36.7 64.6c3.5 2.4 10.5 0.3 14.6 0.6C49.3 62.6 38.9 59.6 36.7 64.6zM32.4 72.6c6.6 0.1 11.2-1.8 14.6-4.9C40.5 66.5 34 69 32.4 72.6zM56.5 69.7c-5.2-0.8-8.7 0.9-12 3.2 5.5 4.1 18.7 3 23.2-1.1C63.7 72.8 59.7 70.3 56.5 69.7zM46.2 78.1c-4.7 3.4-7.8 8.4-11.5 12.9 13.9-2.9 24.9-8.8 34.7-15.8 0-0.3 0.5-0.6 0-0.9C63.2 77.2 55.2 78.9 46.2 78.1zM28.4 78.1c4.8 0.6 11.2 0.5 13.8-2C36.9 76.5 30.5 74.3 28.4 78.1zM53 88.4c-4.3 3.4-9.8 7.4-9.7 13.8 0.9-1.1 2.2-1.8 3.7-2.3 1.7-5.2 5.3-8.7 8.9-12 3.7-3.4 8.1-5.7 12-8.9 0-0.3 0.4-0.4 0-0.6C62.9 81.2 57.8 84.6 53 88.4zM29.5 81.8c-0.2 0.7-0.4 1.3-0.3 2.3 5.2-0.3 10.6-2 12.3-4.9C38.7 81.2 32.8 80.2 29.5 81.8zM25.8 84.6c0.5-0.7 0.9-1.4 0.9-2.6 -0.5-0.3-0.8-0.7-1.4-0.9C25.5 82.3 25.3 83.8 25.8 84.6zM49.6 99.8c2.3-0.4 2.6 1.3 4.3 1.4 1.2-1.7 2.6-3.1 3.4-5.2 0.5 0 1 0 1.4 0 1.3-5.7 4.5-9.5 8.9-12 -0.1-0.8 0.8-2 0-2.6C60.9 86.9 52.4 90.5 49.6 99.8zM30.4 87.2c-0.6 0.7-0.7 1.8-0.6 3.2 3-0.5 5.6-3 6-5.2C34.5 86.4 32.8 87.2 30.4 87.2zM25.2 87.5c0.4 1 0.6 2.2 1.4 2.9 0.5-1.2 1.3-2.1 1.4-3.7C26.6 86.4 26.4 87.4 25.2 87.5zM40.1 95.3c4.7-1 7.2-4.2 10-7.2C45.1 88.8 42.7 92.1 40.1 95.3zM35 94.1c0 0.7 0 1.4 0.3 1.7 2 0.4 1.5-1.6 2-2.6C36.2 93.2 35.8 93.9 35 94.1zM30.1 94.7c0.3 1 2.3 2.9 3.4 4C33.7 96.2 31.8 94.4 30.1 94.7zM39.6 99.8c0.7-0.1 0.6 0.5 1.4 0.3 -0.1-0.9 0.7-1.4 0-2C40.1 98.3 39.5 98.8 39.6 99.8zM39.6 103.9c0.1-1.4-1.4-2.8-2.3-2.3C38.5 101.9 38.7 103.2 39.6 103.9z"/><path id="tail" d="M146 229.8c1.8-3.3 1.5-7.5 4.3-10.1 -2-5.3 0.6-12.5-1.2-17.8 -5.6-7.1-8.8-15.2-18.3-20.7 -6.5-1.7-14.5-9.2-22.2-9.3 -4.7-2.4-5.9-6.3-10.4-8.7 0.8-0.8 1-1.7 0.9-2.6l-13.4-3.7c-0.9 3.9 0.5 6.9-0.2 10.8 4.4 4.3 5.6 10.4 11.7 13.6 3.1 1.6 6.9-0.4 9 3.6 8.4 4.5 18.5 0.8 23.2 10 0 0 0 0 0-0.1 5.3 3.7 6.6 9 9.4 13.7 0.2 3 0.4 6.7 0.6 8.9 0.5 4.1 0 2.9-1.8 6.8 -1 2.2-0.4 2.5-1 5 -4.8 0.9-6.5 6-10.2 8.7 -3.1 2.3-7.5 2.5-9.9 5.6 6.5 0.9 11.8-1.1 17.8-1.2 1.6-4.2 4.7-3.2 6.4-4.9 1.1-1.1 1-3.4 1.9-4.6C143.8 231.2 145.4 231 146 229.8z"/><path id="head" d="M97.5 43.8c0.5-1.7 1.8-3 2.6-4.7 0.4-0.9-0.1-2.1 0.5-3.2 0.1-0.2 0.9 0.1 1.1 0 1.1-1.1-0.1-4.1 1.1-6.3 0.5-2-2.3-0.9-1.6-3.2 1.6-4.8-0.3-12.8-3.2-13.2 1.8-0.6-1.5-0.2-0.5-1.6 -2.5-0.6-5-1.3-7.4-2.1 -1.1 0-2.1 0-3.2 0 -0.2 1.7-3 0.8-4.7 1.1 0.4 1.4-0.9 0.7-1.6 1.1 -0.6 0.4-1.3 1.3-1.6 1.6 -0.1 0.1-1 0.4-1.1 0.5 -0.5 1.2-0.8 3.1-2.1 4.2 0.9 2.7-0.9 6.1 0.5 9 0.3 1.1-0.8 1.1-1.1 1.6 -0.9 1.5-0.4 7.5 2.1 7.9 0 3.3 1.7 5 2.6 7.4 -0.1 1.4 0 3 0 4.6 5.8 0 11.6 0 17.4 0C97.4 46.8 97.5 45.3 97.5 43.8z"/><path id="lefthand" d="M48.4 162.4c0 0.7 0 1.4 0 2.1 0.3 0 0.6 0.4 0 0.5 0 1.6 0 3.2 0 4.7 1.7-0.6 0.8 1.5 1.1 2.1 0.3 0.8 1.2 1.4 1.6 2.1 1.7 3 2.5 4 5.3 5.3 0.9 0.4 1.9 1.6 3.2 1.1 1.3-2.9-0.6-3.8-2.1-5.3 -0.2-1.3 2.4 0.3 1.6-1.6 -2.1-2.3-7.7-3.9-5.3-9 4.1-0.6 1.3 5.7 5.3 5.3 0.5-3 0-7 0.5-11.1 -0.6-1.6-2.4-3.4-2.6-5.3 0 0 0-0.1 0-0.1l-7.3 0C49.4 156.6 49 159.6 48.4 162.4z"/><path id="leftleg" d="M78 266.8c-0.7-4.4-0.5-11.2 0-16.9 0.4-4.1 1.8-7.8 2.1-11.6 0.2-3.3 0.3-6.9 0-10 -0.4-3.5-2.2-6.2-2.1-9 0.1-1.9 1.4-3.7 2.1-5.8 1.1-3.3 2.2-6.8 2.6-10 0.9-6.3 0.6-13.4 1.1-20 0.4-5 1.6-8.6 2.6-12.1 0.3-0.9 0.9-1.4 1.1-2.1 0.7-3.5-0.9-6.7 1.3-8.1 -8.6 0-17.2 0-25.9 0 -0.1 9.7 1.1 19.4 1.5 28.6 0.2 3.8-0.3 7.7 0 11.1 0.3 3.5 0.7 7.9 0 11.1 0 0.2-1 1.3-1.1 1.6 -0.2 1.6-0.3 3.2-0.5 4.7 -0.7 5.4-0.9 12.8-0.5 17.9 0.3 4.6 1.5 7.4 2.6 10.5 1.1 3.2 2 6.1 2.6 9.5 0.2 1 0.9 2 1.1 3.2 0.2 1.3-0.2 2.9 0 4.2 0.2 1.5 0.9 2.4 1.1 3.7 0 0 0 0 0 0h8.5C78 267.1 78 267 78 266.8z"/><path id="leftfoot" d="M78.1 267.3h-8.5c0.5 5.9-1.2 9.3-1.1 14.2 -1.7 3-3.8 7.9-3.2 11.6 2 2.4 9.1-0.4 11.1 2.1 0.7 0 1.4 0 2.1 0 3.9-5-0.7-15.5 2.1-21.1C80 271.9 78.6 269.8 78.1 267.3z"/><path id="leftarm" d="M63.2 59.1c-0.6 0.2-0.7 0.9-1.1 1.1 -0.4 0.2-1.2-0.2-1.6 0 -0.5 0.3-0.2 0.8-0.5 1.1 -0.4 0.2-1.2-0.2-1.6 0 -0.5 0.3-0.2 0.8-0.5 1.1 -0.2 0.2-0.8-0.2-1.1 0 -0.2 0.1-0.4 1-0.5 1.1 -1.2 0.6-0.6 0.5-1.6 1.6 -0.6 0.6-1.5 1.4-2.1 3.2 -0.3 0.8-0.3 1.2-0.5 1.6 -0.8 1.8-1 7-1.6 11.1 -0.5 2.9-1.3 6-1.6 9 -0.7 8 2.4 17.9 0 24.3 0 0.1-0.5 0-0.5 0 0 4.9 0 9.8 0 14.8 0.9 7.7 1.6 16.6 1.1 24.7l7.3 0c-0.1-1.1 0.6-3.1 1.1-5.2 0.7-2.9 1.7-6.3 2.1-7.9 0.8-3.1 1.4-6.1 1.6-9 0.5-6.1-1.2-12.9-0.5-17.9 0.3-1.8 1.2-3.6 1.6-5.3 0.5-2.1 0.8-4.2 1.1-6.3 0.5-4.2 0-8.9 2.5-11.9V59.1C65.2 59 64.1 58.8 63.2 59.1z"/><path id="rightfoot" d="M96.9 274c1.3 2.8 1.2 6.6 1.1 10.1 -0.2 4.2-0.9 8.1 1.1 11.2 0.5 0 1.1 0 1.6 0 0.5-1.3 2.2-0.9 3.7-1.1 3-0.3 6.7 0.3 8.4-1.1 0.3-4.1-2.2-7.7-3.2-11.7 -0.4-1.6-0.2-3-0.5-4.8 -0.3-1.5-1-3.2-1.1-4.8 -0.1-1.3 0-2.6 0.1-4h-9C98.6 270.2 97.9 272.3 96.9 274z"/><path id="torso" d="M89.5 161.7c8.4 0 16.9 0 25.5 0 0-1.2-0.1-2.4-0.1-3.5 -0.5-7.1-1.7-14.2-2.6-21.2 -0.5-3.6-0.9-7.1-1.6-10.6 -1.1-5.7-3-12.3-2.1-19.1 0.3-2.7 1.8-5 2.1-7.4 0.4-3.2-1-6.5 0.8-9.7v-31.1c-0.8 0-1.6 0.1-2.4 0 -1.3-1.7-3.9-1.3-5.8-2.1 -0.3-0.1-1.4-1.2-2.1-1.6 -0.9-0.4-1.9-0.4-2.6-1.1 -0.8-1.5-1-3.7-1.1-6 -5.8 0-11.6 0-17.4 0 0 2 0 4-0.6 5.5 -1 0.3-1.7 1-2.6 1.6 -0.4 0.3-1 0.2-1.6 0.5 -0.5 0.3-0.5 0.8-1.1 1.1 -0.6 0.3-1.5-0.2-2.1 0 -0.4 0.2-0.4 0.9-1.1 1.1 -0.6 0.2-1.5-0.2-2.1 0 -0.2 0.1-0.9 1-1.1 1.1 -0.6 0.1-1.2 0.1-1.8 0v30.9c0.1-0.1 0.1-0.1 0.2-0.2 0.7 2.8 0.1 5.9 0.5 9 0.4 2.8 1.8 5.2 2.1 7.9 0.3 2.8 0.2 6.4 0 9.5 -0.4 4.9-2 9.2-2.6 13.2 -0.2 1.2 0.1 2.5 0 3.7 -0.1 1.2-0.9 2.1-1.1 3.2 -0.2 1.4 0.2 2.8 0 4.2 -0.2 1.1-0.9 2.2-1.1 3.2 -0.2 1.8 0.2 3.5 0 5.3 -0.2 1.5-0.9 3.2-1.1 4.8 -0.3 2.6-0.4 5.2-0.4 7.8 8.7 0 17.3 0 25.9 0H89.5z"/><path id="rightleg" d="M114.9 217.2c-0.5-4.3-2-8.4-2.1-12.7 -0.1-4.3 0.9-9.1 1.1-13.7 0.1-2.8-0.1-5.2 0-7.9 0.3-7.2 1.3-14.5 1.2-21.8 -8.6 0-17 0-25.5 0 -0.4 6.7 3.5 13.3 4.2 20.2 0.3 3.5-0.2 6.7 0 10 0.3 4.6 0.8 9.1 1.6 13.2 0.4 2.1 1 3.9 1.6 5.8 0.2 0.5-0.1 1.1 0 1.6 0.1 0.2 0.9 0.8 1.1 1.1 0.2 0.6-0.3 1.5 0 2.1 0.1 0.1 0.9-0.1 1.1 0 0.1 0.1-0.1 0.8 0 1.1 1.2 4-0.5 6.8-1.1 10.5 -0.6 4.7-0.6 10.8 0 15.8 0.1 1.2 0.8 2.5 1.1 3.7 0.3 1.5 0.4 2.9 0.5 4.2 0.6 6.4 0.5 12.6-0.5 17.6h9c0.2-2.9 0.6-5.9 1-7.6 0.7-3.3 1.3-5.8 2.1-8.4 0.6-2.2 1.5-5 2.1-6.3 0.6-1.3 1.3-3.1 1.6-4.2C116.5 233.7 115.9 225 114.9 217.2z"/><path id="rightarm" d="M128 154c-0.5-11.9 1.1-24.4 1.6-33.7 0-1.4 0-2.8 0-4.2 -3.4-6.7 0.2-18.4-1.1-29 -0.2-2-1.2-3.8-1.6-5.8 -0.9-5.7-0.5-10-2.6-14.2 -0.2-0.3-0.3-1.2-0.5-1.6 -0.1-0.2-0.9 0.2-1.1 0 -0.2-0.2-0.6-1.6-1.1-2.1 -0.6-0.7-1-1.2-2.6-2.1 -0.7-0.4-0.6-0.1-1.1-0.5 -0.7-0.7-1.4 0-3.2-0.5 -0.7-0.2-0.5-0.9-1.6-1.1 -0.6-0.1-1.2-0.1-1.8 0v31c0.1-0.1 0.1-0.3 0.2-0.4 -0.6 0.9 1 0.9 1.1 1.1 0.3 0.6-0.2 1.5 0 2.1 1.5 4.5 1.1 11.6 2.1 15.8 0.4 1.8 1.4 3.5 1.6 5.3 0.8 6.9-1.3 15.2 0 20.6 1.7 6.9 3.4 13.1 4.2 20h7.4C128.1 154.3 128.1 154.1 128 154z"/><path id="righthand" d="M120.7 154.5c0 0 0 0 0 0 -0.9 1.5-1.9 3-2.6 4.7 -0.4 1.7 0.5 3.6 0.5 5.3 0.1 1.9-1.6 4.8 0.5 5.3 2.1 0.7 1.5-5.8 5.3-5.3 0.6 2.2-0.1 3.8-1.1 5.3 -1 1.4-3.4 2.9-4.7 3.2 -0.3 2.7 1.9 0 1.6 2.1 -0.8 0.8-1.8 1.4-2.1 2.6 -1 0.7 1.2 1.1 0 2.6 2.4 0.1 4.9-1.2 5.8-2.1 0.5-0.5 0.5-1.4 1.1-2.1 0.8-1 2-2 2.6-3.2 2.9-5.2 1-10.9 0.6-18.5H120.7z"/></svg><div id="lefthandweapon"></div><div id="righthandweapon"></div><div id="overall" class="health-full">Top Shape</div></div><div id="hp-status"><div><span>HP:</span><div class="progressbar" id="hp-bar"><div class="progressbar-text">0/0</div><div class="progressbar-value"></div></div></div><div><span>SP:</span><div class="progressbar" id="sp-bar"><div class="progressbar-text">0/0</div><div class="progressbar-value"></div></div></div><div><span>MP:</span><div class="progressbar" id="mp-bar"><div class="progressbar-text">0/0</div><div class="progressbar-value"></div></div></div></div></div><div id="experience" class="status-panel"><div><span>XP:</span><span id="xp-value">0</span></div><div><span>Needed:</span><span id="need-value">0</span><div class="progressbar" id="need-percent"><div class="progressbar-text" style="text-align:right;right:2px;color:#000">0</div><div class="progressbar-value"></div></div></div><div><span>Earned:</span><span id="earn-value">0</span></div><div><span>BankedXP:</span><span id="xp-banked">0</span></div></div><div id="bars" class="flex-grow-1"><div id="party"></div><div id="combat"></div></div><div class="progressbar" id="lagMeter"><div class="progressbar-text">0.000 s</div><div class="progressbar-value" style="width:100%"></div></div></div><div id="status-simple"><div id="status-simple-hp" data-var="hp" class="progress"><div class="progress-bar" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100"></div></div><div id="status-simple-sp" data-var="sp" class="progress"><div class="progress-bar" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100"></div></div><div id="status-simple-mp" data-var="mp" class="progress"><div class="progress-bar" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100"></div></div><div id="status-simple-xp" data-var="xp" class="progress"><div class="progress-bar" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100"></div></div></div><div id="status-simple-lagMeter" class="progress"><div class="progress-bar" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100"></div></div>';

  // src/plugins/status.ts
  var Status = class extends Plugin {
    constructor(client2) {
      super(client2);
      this._info = [];
      this._infoAC = [];
      this._infoLimb = [];
      this._ac = false;
      this._rTimeout = 0;
      this._dragging = false;
      this._clientContainer = document.getElementById("client-container");
    }
    get splitterDistance() {
      return this._splitterDistance;
    }
    set splitterDistance(value) {
      if (value === this._splitterDistance) return;
      this._splitterDistance = value;
      this._updateSplitter();
    }
    get maxWidth() {
      return Math.floor(document.body.clientWidth * 0.66);
    }
    get currentLag() {
      if (!this._lagMeter || !this._lagMeter.firstElementChild) return "";
      return this._lagMeter.firstElementChild.textContent || "";
    }
    _updateSplitter() {
      const p = parseInt(this._styles.right, 10) * 2;
      if (!this._splitterDistance || this._splitterDistance < 1) {
        const bounds = this._status.getBoundingClientRect();
        this._splitterDistance = bounds.width + document.body.clientWidth - bounds.right;
      }
      if (!this.client.getOption("showStatus"))
        this.updateInterface();
      else {
        if (!this.client.getOption("statusMode"))
          this._clientContainer.style.right = this._splitterDistance + "px";
        this._status.style.width = this._splitterDistance - p + "px";
        document.getElementById("status-drag-bar").style.right = this.splitterDistance + "px";
      }
      this.client.setOption("statusWidth", this._splitterDistance);
      this.emit("split-moved", this._splitterDistance);
    }
    remove() {
      let idx = this.client.telnet.GMCPSupports.indexOf("Char 1");
      this.client.telnet.GMCPSupports.splice(idx, 1);
      idx = this.client.telnet.GMCPSupports.indexOf("Char.Vitals 1");
      this.client.telnet.GMCPSupports.splice(idx, 1);
      idx = this.client.telnet.GMCPSupports.indexOf("Char.Experience 1");
      this.client.telnet.GMCPSupports.splice(idx, 1);
      idx = this.client.telnet.GMCPSupports.indexOf("oMUD 1");
      this.client.telnet.GMCPSupports.splice(idx, 1);
      idx = this.client.telnet.GMCPSupports.indexOf("Char.Skills 1");
      this.client.telnet.GMCPSupports.splice(idx, 1);
      this.client.removeListenersFromCaller(this);
      this.client.telnet.removeListenersFromCaller(this);
      delete window.$character;
      delete window.$characterid;
    }
    initialize() {
      document.body.insertAdjacentHTML("beforeend", status_default);
      this._status = document.getElementById("status");
      this._styles = getComputedStyle(this._status);
      this.client.telnet.GMCPSupports.push("oMUD 1", "Char 1", "Char.Vitals 1", "Char.Experience 1", "Char.Skills 1");
      this.client.on("received-GMCP", this.processGMCP, this);
      this.client.on("window", (window2) => {
      });
      this._lagMeter = document.getElementById("lagMeter");
      this.client.telnet.on("latency-changed", (lag, avg) => {
        this.updateLagMeter(lag);
      });
      this.client.on("closed", () => {
        this.updateLagMeter(0, true);
      });
      this.client.telnet.GMCPSupports.push("oMUD 1");
      this.client.telnet.GMCPSupports.push("Char.Skills 1");
      this.client.on("add-line", (data) => {
        if (data.line === "Connected...")
          this.init();
      });
      this.client.on("options-loaded", () => {
        this._info["EXPERIENCE_NEED"] = this._info["EXPERIENCE_NEED_RAW"] - this._info["EXPERIENCE"];
        if (this.client.getOption("showArmor")) {
          this.ac = true;
          this._status.querySelector("#health").classList.remove("active");
          this._status.querySelector("#armor").classList.add("active");
        }
        this.splitterDistance = client.getOption("statusWidth");
        this.updateInterface();
      });
      this.on("debug", (e) => this.client.debug(e), this);
      this.on("error", (e) => this.client.error(e), this);
      document.getElementById("status-drag-bar").addEventListener("mousedown", (e) => {
        if (e.button !== 0) return;
        e.preventDefault();
        this._dragging = true;
        const main = document.getElementById("status-drag-bar");
        const w = this._status.style.width;
        this._status.style.width = "";
        const bounds = this._status.getBoundingClientRect();
        this._status.style.width = w;
        const bounds2 = main.getBoundingClientRect();
        const ghostBar = document.createElement("div");
        ghostBar.id = "status-ghost-bar";
        ghostBar.style.top = "0";
        ghostBar.style.bottom = "0";
        ghostBar.style.left = bounds2.left + "px";
        ghostBar.style.cursor = "ew-resize";
        document.body.append(ghostBar);
        const maxWidth = this.maxWidth;
        this._move = (e2) => {
          if (e2.pageX < maxWidth)
            ghostBar.style.left = maxWidth - bounds2.width + "px";
          else if (e2.pageX > bounds.left - bounds2.width)
            ghostBar.style.left = bounds.left + parseInt(this._styles.right, 10) - bounds2.width + "px";
          else
            ghostBar.style.left = e2.pageX + "px";
        };
        document.addEventListener("mousemove", this._move);
      });
      window.addEventListener("resize", () => this.resize());
      document.addEventListener("mouseup", (e) => {
        if (!this._dragging) return;
        const w = this._status.style.width;
        this._status.style.width = "";
        const bounds = this._status.getBoundingClientRect();
        const minWidth = bounds.width + parseInt(this._styles.right, 10);
        const maxWidth = this.maxWidth;
        const l2 = document.getElementById("status-drag-bar").getBoundingClientRect().width;
        this._status.style.width = w;
        if (e.pageX < maxWidth)
          this.splitterDistance = document.body.clientWidth - maxWidth;
        else if (e.pageX > bounds.left - l2)
          this.splitterDistance = minWidth;
        else
          this.splitterDistance = document.body.clientWidth - e.pageX - l2;
        document.getElementById("status-ghost-bar").remove();
        document.removeEventListener("mousemove", this._move);
        this._dragging = false;
        this.updateInterface();
      });
      document.getElementById("status-close").addEventListener("click", () => {
        this.client.setOption("showStatus", false);
        this.updateInterface();
        let button = document.querySelector("#menu-status");
        if (client.getOption("showStatus")) {
          button.title = "Hide status";
          button.classList.add("active");
          document.querySelector("#menu-status a span").textContent = "Hide status";
        } else {
          button.title = "Show status";
          button.classList.remove("active");
          document.querySelector("#menu-status a span").textContent = "Show status";
        }
      });
      this._status.querySelector("#health").addEventListener("click", () => {
        if (!this.ac) return;
        this.ac = false;
        this._status.querySelector("#health").classList.add("active");
        this._status.querySelector("#armor").classList.remove("active");
        this.client.setOption("showArmor", this.ac);
      });
      this._status.querySelector("#armor").addEventListener("click", () => {
        if (this.ac) return;
        this.ac = true;
        this._status.querySelector("#health").classList.remove("active");
        this._status.querySelector("#armor").classList.add("active");
        this.client.setOption("showArmor", this.ac);
      });
      if (this.client.getOption("showArmor")) {
        this.ac = true;
        this._status.querySelector("#health").classList.remove("active");
        this._status.querySelector("#armor").classList.add("active");
      }
      this.splitterDistance = client.getOption("statusWidth");
      Object.defineProperty(window, "$character", {
        get: () => {
          if (!this._info) return "";
          return this._info["name"] || "";
        },
        configurable: true
      });
      Object.defineProperty(window, "$characterid", {
        get: function() {
          return -1;
        },
        configurable: true
      });
      this.client.display.container.append(document.getElementById("status-simple-lagMeter"));
      this._updateSplitter();
      this.updateInterface();
      this.init();
    }
    get menu() {
      return [
        {
          name: "-",
          position: 5,
          exists: "#menu-plugins",
          id: "plugins"
        },
        {
          id: "status",
          name: this.client.getOption("showStatus") ? "Hide status" : "Show status",
          active: this.client.getOption("showStatus"),
          action: (e) => {
            this.client.setOption("showStatus", !this.client.getOption("showStatus"));
            this.updateInterface();
            let button = document.querySelector("#menu-status");
            if (client.getOption("showStatus")) {
              button.title = "Hide status";
              button.classList.add("active");
              document.querySelector("#menu-status a span").textContent = "Hide status";
            } else {
              button.title = "Show status";
              button.classList.remove("active");
              document.querySelector("#menu-status a span").textContent = "Show status";
            }
          },
          icon: '<i class="fa-solid fa-heart"></i>',
          position: 6
        }
      ];
    }
    get settings() {
      return [{
        name: " Status",
        action: "settings-status",
        icon: '<i class="fa-solid fa-heart"></i>',
        position: 7
      }];
    }
    async processGMCP(mod, obj) {
      try {
        let limb;
        switch (mod.toLowerCase()) {
          case "char.name":
            this._info["name"] = obj.name;
            this.setTitle(obj.name);
            break;
          case "char.base":
            this.init();
            this._info["name"] = obj.name;
            this.setTitle(obj.name);
            break;
          case "char.vitals":
            this.updateBar("hp-bar", obj.hp, obj.hpmax);
            this.updateBar("sp-bar", obj.sp, obj.spmax);
            this.updateBar("mp-bar", obj.mp, obj.mpmax);
            this._info["hp"] = obj.hp;
            this._info["hpmax"] = obj.hpmax;
            this._info["sp"] = obj.sp;
            this._info["spmax"] = obj.spmax;
            this._info["mp"] = obj.mp;
            this._info["mpmax"] = obj.mpmax;
            this.updateSimpleBar("status-simple-hp");
            this.updateSimpleBar("status-simple-sp");
            this.updateSimpleBar("status-simple-mp");
            this._doUpdate(4 /* overall */);
            break;
          case "char.experience":
            this._info["EXPERIENCE"] = obj.current;
            this._info["EXPERIENCE_NEED_RAW"] = obj.need;
            this._info["EXPERIENCE_NEED"] = obj.need - obj.current;
            this._info["EXPERIENCE_NEED_P"] = obj.needPercent;
            this._info["EXPERIENCE_EARNED"] = obj.earned;
            this._info["EXPERIENCE_BANKED"] = obj.banked;
            this._doUpdate(8 /* xp */);
            break;
          case "omud.ac":
            for (limb in obj) {
              if (!obj.hasOwnProperty(limb)) continue;
              this.setLimbAC(limb, obj[limb]);
              this.updateLimb(limb);
            }
            break;
          case "omud.limb":
            for (limb in obj) {
              if (!obj.hasOwnProperty(limb)) continue;
              this.setLimbHealth(limb, obj[limb]);
              this.updateLimb(limb);
            }
            break;
          case "omud.weapons":
            for (limb in obj) {
              if (!obj.hasOwnProperty(limb)) continue;
              this.setWeapon(limb, obj[limb]);
            }
            break;
          case "omud.environment":
            if (obj.weather) {
              const env = document.getElementById("environment");
              env.classList.remove("weather-" + this._info["WEATHER"], "intensity-hard");
              this._info["WEATHER"] = obj.weather;
              this._info["WEATHER_INTENSITY"] = obj.weather_intensity;
              if (obj.weather !== "0" && obj.weather !== "none")
                env.classList.add("weather-" + obj.weather);
              if (obj.weather_intensity > 6)
                env.classList.add("intensity-hard");
            }
            if (obj.tod) {
              const env = document.getElementById("environment");
              env.classList.remove("day", "night", "twilight", "dawn");
              env.classList.add(obj.tod);
              $("#environment").removeClass((index, className) => {
                return (className.match(/(^|\s)moon\d-\S+/g) || []).join(" ");
              });
              if (obj.moons) {
                env.classList.add("moon1-" + obj.moons[0]);
                env.classList.add("moon2-" + obj.moons[1]);
                env.classList.add("moon3-" + obj.moons[2]);
              }
            }
            break;
          case "omud.combat":
            if (obj.action === "leave") {
              this._clear("combat");
              this.emit("leave combat");
            } else if (obj.action === "add")
              this.createIconBar("#combat", this._getID(obj, "combat_"), obj.name, obj.hp, 100, this._livingClass(obj, "monster-"), obj.order);
            else if (obj.action === "update") {
              if (obj.hp === 0)
                this.removeBar(this._getID(obj, "combat_"));
              else
                this.createIconBar("#combat", this._getID(obj, "combat_"), obj.name, obj.hp, 100, this._livingClass(obj, "monster-"), obj.order);
            } else if (obj.action === "remove")
              this.removeBar(this._getID(obj, "combat_"));
            break;
          case "omud.party":
            if (obj.action === "leave") {
              this._clear("party");
              this.emit("leave party");
            } else if (obj.action === "add") {
              this.createIconBar("#party", this._getID(obj, "party_"), obj.name, obj.hp, 100, this._livingClass(obj, "party-"), obj.name.replace('"', ""));
            } else if (obj.action === "update") {
              if (obj.hp === 0)
                this.removeBar(this._getID(obj, "party_"), true);
              else
                this.createIconBar("#party", this._getID(obj, "party_"), obj.name, obj.hp, 100, this._livingClass(obj, "party-"), obj.name.replace('"', ""));
            } else if (obj.action === "remove")
              this.removeBar(this._getID(obj, "party_"), true);
            if ((limb = document.getElementById("party")).children.length)
              limb.classList.add("hasmembers");
            else
              limb.classList.remove("hasmembers");
            break;
          case "omud.skill":
            if (obj.skill && obj.skill.length) {
              if (!this._info["skills"][obj.skill]) this._info["skills"][obj.skill] = { amount: 0, bonus: 0, percent: 0 };
              if (obj.hasOwnProperty("percent"))
                this._info["skills"][obj.skill].percent = obj.percent || 0;
              if (obj.hasOwnProperty("amount")) {
                this._info["skills"][obj.skill].amount = obj.amount;
                this._info["skills"][obj.skill].bonus = obj.bonus || 0;
                this._info["skills"][obj.skill].category = obj.category;
              }
              this.emit("skill updated", obj.skill, this._info["skills"][obj.skill]);
            }
            break;
        }
      } catch (e) {
        this.emit("error", e);
      }
    }
    updateInterface(noSplitter) {
      if (!this.client.getOption("showStatus")) {
        this._clientContainer.style.right = "";
        this._status.style.visibility = "hidden";
        this._status.style.display = "none";
        document.getElementById("status-drag-bar").style.display = "none";
        this.emit("updated-interface");
        document.getElementById("status-simple").style.display = "none";
        document.getElementById("status-simple-lagMeter").style.visibility = this.client.getOption("lagMeter") ? "visible" : "";
        return;
      }
      if (this.client.getOption("statusMode")) {
        this._clientContainer.style.right = "";
        this._status.style.visibility = "hidden";
        this._status.style.display = "none";
        document.getElementById("status-drag-bar").style.display = "none";
        document.getElementById("status-simple").style.display = "";
        document.getElementById("status-simple-lagMeter").style.visibility = this.client.getOption("lagMeter") ? "visible" : "";
        this.emit("updated-interface");
        return;
      }
      document.getElementById("status-simple").style.display = "none";
      document.getElementById("status-simple-lagMeter").style.visibility = "";
      const p = parseInt(this._styles.right, 10) * 2;
      this._clientContainer.style.right = this._splitterDistance + "px";
      this._status.style.width = this._splitterDistance - p + "px";
      this._status.style.visibility = "";
      this._status.style.display = "";
      document.getElementById("status-drag-bar").style.display = "";
      if (this.client.getOption("statusExperienceNeededProgressbar")) {
        $("#need-value").css("display", "none");
        $("#need-percent").css("display", "block");
      } else {
        $("#need-value").css("display", "");
        $("#need-percent").css("display", "none");
      }
      if (this.client.getOption("showStatusWeather"))
        $("#environment").css("display", "");
      else
        $("#environment").css("display", "none");
      if (!this.client.getOption("showStatusLimbs") && !this.client.getOption("showStatusHealth"))
        $("#body").css("display", "none");
      else
        $("#body").css("display", "");
      if (!this.client.getOption("showStatusLimbs"))
        $("#limbs").css("display", "none");
      else
        $("#limbs").css("display", "");
      if (!this.client.getOption("showStatusHealth"))
        $("#hp-status").css("display", "none");
      else
        $("#hp-status").css("display", "");
      if (this.client.getOption("showStatusExperience"))
        $("#experience").css("display", "");
      else
        $("#experience").css("display", "none");
      if (!this.client.getOption("showStatusPartyHealth") && !this.client.getOption("showStatusCombatHealth"))
        $("#bars").css("min-height", "");
      else
        $("#bars").css("min-height", "0");
      if (this.client.getOption("showStatusPartyHealth"))
        $("#party").css("display", "");
      else
        $("#party").css("display", "none");
      if (this.client.getOption("showStatusCombatHealth"))
        $("#combat").css("display", "");
      else
        $("#combat").css("display", "none");
      if (this._lagMeter) {
        if (this.client.getOption("lagMeter")) {
          this._lagMeter.style.visibility = "";
          this._lagMeter.style.display = "";
          this.updateLagMeter(0, true);
        } else {
          this._lagMeter.style.visibility = "hidden";
          this._lagMeter.style.display = "none";
        }
      }
      if (!noSplitter)
        this._updateSplitter();
      this.emit("updated-interface");
    }
    setTitle(title, lag) {
      if (!title || title.length === 0)
        this._status.querySelector("#character-name").innerHTML = "&nbsp;";
      else
        this._status.querySelector("#character-name").textContent = title;
      if (this.client.connected && lag && lag.length) {
        if (title && title.length)
          title = `${title} - ${lag}`;
        else
          title = `${lag}`;
      }
      client.emit("set-title", title || "");
    }
    init() {
      this.setTitle("");
      this._info = [];
      this._info["WEATHER"] = "none";
      this._info["WEATHER_INTENSITY"] = 0;
      this._info["EXPERIENCE"] = 0;
      this._info["EXPERIENCE_NEED"] = 0;
      this._info["EXPERIENCE_NEED_P"] = 0;
      this._info["EXPERIENCE_NEED_RAW"] = 0;
      this._info["EXPERIENCE_EARNED"] = 0;
      this._info["EXPERIENCE_BANKED"] = 0;
      this._info["skills"] = {};
      this._infoAC = [];
      this._infoAC["head"] = 0;
      this._infoAC["leftarm"] = 0;
      this._infoAC["leftfoot"] = 0;
      this._infoAC["lefthand"] = 0;
      this._infoAC["leftleg"] = 0;
      this._infoAC["rightarm"] = 0;
      this._infoAC["rightfoot"] = 0;
      this._infoAC["righthand"] = 0;
      this._infoAC["rightleg"] = 0;
      this._infoAC["torso"] = 0;
      this._infoAC["overall"] = 0;
      this._infoLimb = [];
      this._infoLimb["head"] = 0;
      this._infoLimb["leftarm"] = 0;
      this._infoLimb["leftfoot"] = 0;
      this._infoLimb["lefthand"] = 0;
      this._infoLimb["leftleg"] = 0;
      this._infoLimb["rightarm"] = 0;
      this._infoLimb["rightfoot"] = 0;
      this._infoLimb["righthand"] = 0;
      this._infoLimb["rightleg"] = 0;
      this._infoLimb["torso"] = 0;
      document.getElementById("leftwing").style.display = "none";
      document.getElementById("rightwing").style.display = "none";
      document.getElementById("tail").style.display = "none";
      this.updateBar("hp-bar", 0, 0);
      this.updateBar("sp-bar", 0, 0);
      this.updateBar("mp-bar", 0, 0);
      this.updateSimpleBar("status-simple-hp");
      this.updateSimpleBar("status-simple-sp");
      this.updateSimpleBar("status-simple-mp");
      document.getElementById("xp-value").textContent = "0";
      document.getElementById("xp-banked").textContent = "0";
      document.getElementById("need-value").textContent = "0";
      document.getElementById("earn-value").textContent = "0";
      this.updateBar("need-percent", 0, 0, "0");
      this.updateBar("status-simple-xp", 0, 0, "", true);
      this._clear("combat");
      this._clear("party");
      document.getElementById("party").classList.remove("hasmembers");
      this.updateOverall();
      this.updateStatus();
      this.emit("skill init");
    }
    _clear(id) {
      const el = document.getElementById(id);
      if (el) el.innerHTML = "";
    }
    updateStatus() {
      let limb;
      if (this._ac)
        for (limb in this._infoAC)
          this.updateLimb(limb);
      else
        for (limb in this._infoLimb)
          this.updateLimb(limb);
      this._doUpdate(4 /* overall */ | 8 /* xp */);
    }
    updateOverall() {
      const el = document.getElementById("overall");
      el.className = "";
      if (this._ac) {
        if (this._infoAC["overall"] === 6.5) {
          el.textContent = "Extensively";
          el.classList.add("armor-extensively");
        } else if (this._infoAC["overall"] === 6) {
          el.textContent = "Completely";
          el.classList.add("armor-completely");
        } else if (this._infoAC["overall"] === 5.5) {
          el.textContent = "Significantly";
          el.classList.add("armor-significantly");
        } else if (this._infoAC["overall"] === 5) {
          el.textContent = "Considerably";
          el.classList.add("armor-considerably");
        } else if (this._infoAC["overall"] === 4.5) {
          el.textContent = "Well";
          el.classList.add("armor-well");
        } else if (this._infoAC["overall"] === 4) {
          el.textContent = "Adequately";
          el.classList.add("armor-adequately");
        } else if (this._infoAC["overall"] === 3.5) {
          el.textContent = "Fairly";
          el.classList.add("armor-fairly");
        } else if (this._infoAC["overall"] === 3) {
          el.textContent = "Moderately";
          el.classList.add("armor-moderately");
        } else if (this._infoAC["overall"] === 2.5) {
          el.textContent = "Somewhat";
          el.classList.add("armor-somewhat");
        } else if (this._infoAC["overall"] === 2) {
          el.textContent = "Slightly";
          el.classList.add("armor-slightly");
        } else if (this._infoAC["overall"] === 1) {
          el.textContent = "Barely";
          el.classList.add("armor-barely");
        } else {
          el.textContent = "UNARMORED";
          el.classList.add("armor-unarmored");
        }
      } else {
        let v = 100;
        if (this._info["hpmax"] !== 0 && !isNaN(this._info["hpmax"]))
          v *= this._info["hp"] / this._info["hpmax"];
        if (v > 90) {
          el.textContent = "Top shape";
          el.classList.add("health-full");
        } else if (v > 75) {
          el.textContent = "Decent shape";
          el.classList.add("health-1-19");
        } else if (v > 60) {
          el.textContent = "Slightly injured";
          el.classList.add("health-20-39");
        } else if (v > 45) {
          el.textContent = "Hurting";
          el.classList.add("health-40-59");
        } else if (v > 30) {
          el.textContent = "Badly injured";
          el.classList.add("health-60-79");
        } else if (v > 15) {
          el.textContent = "Terribly injured";
          el.classList.add("health-80-99");
        } else {
          el.textContent = "Near death";
          el.classList.add("health-100");
        }
      }
    }
    updateLimb(limb) {
      limb = limb.replace(/\s/g, "");
      limb = limb.toLowerCase();
      if (limb === "overall") {
        this._doUpdate(4 /* overall */);
        return;
      }
      if (limb === "righthoof")
        limb = "rightfoot";
      else if (limb === "lefthoof")
        limb = "leftfoot";
      const eLimb = document.getElementById(limb);
      if (!eLimb)
        return;
      eLimb.setAttribute("class", "");
      eLimb.style.display = "block";
      if (this._ac) {
        if (this._infoAC[limb] === 6.5)
          eLimb.classList.add("armor-extensively");
        else if (this._infoAC[limb] === 6)
          eLimb.classList.add("armor-completely");
        else if (this._infoAC[limb] === 5.5)
          eLimb.classList.add("armor-significantly");
        else if (this._infoAC[limb] === 5)
          eLimb.classList.add("armor-considerably");
        else if (this._infoAC[limb] === 4.5)
          eLimb.classList.add("armor-well");
        else if (this._infoAC[limb] === 4)
          eLimb.classList.add("armor-adequately");
        else if (this._infoAC[limb] === 3.5)
          eLimb.classList.add("armor-fairly");
        else if (this._infoAC[limb] === 3)
          eLimb.classList.add("armor-moderately");
        else if (this._infoAC[limb] === 2.5)
          eLimb.classList.add("armor-somewhat");
        else if (this._infoAC[limb] === 2)
          eLimb.classList.add("armor-slightly");
        else if (this._infoAC[limb] === 1)
          eLimb.classList.add("armor-barely");
        else
          eLimb.classList.add("armor-unarmored");
      } else {
        if (this._infoLimb[limb] === 100)
          eLimb.classList.add("health-100");
        else if (this._infoLimb[limb] >= 80)
          eLimb.classList.add("health-80-99");
        else if (this._infoLimb[limb] >= 60)
          eLimb.classList.add("health-60-79");
        else if (this._infoLimb[limb] >= 40)
          eLimb.classList.add("health-40-59");
        else if (this._infoLimb[limb] >= 20)
          eLimb.classList.add("health-20-39");
        else if (this._infoLimb[limb] >= 1)
          eLimb.classList.add("health-1-19");
        else
          eLimb.classList.add("health-full");
      }
    }
    updateBar(id, value, max2, text, noText) {
      const bar = document.getElementById(id);
      if (!bar)
        return;
      else {
        let p = 100;
        if (max2 !== 0)
          p = value / max2 * 100;
        if (!noText)
          bar.firstElementChild.textContent = text || value + "/" + max2;
        bar.lastElementChild.style.width = 100 - p + "%";
        bar.lastElementChild.ariaValueNow = "" + p;
      }
    }
    updateSimpleBar(bar) {
      var p;
      const el = document.getElementById(bar);
      if (!el) return;
      const v = el.dataset.var.toLowerCase();
      if (!this._info || !this._info[v + "max"])
        p = 100;
      else
        p = this._info[v] / this._info[v + "max"] * 100;
      const progress = document.querySelector(`#${bar}  .progress-bar`);
      progress.style.width = 100 - p + "%";
      progress.ariaValueNow = "" + p;
    }
    createIconBar(parent, id, label, value, max2, icon, order) {
      let p = 100;
      if (max2 !== 0)
        p = value / max2 * 100;
      p = Math.floor(p);
      id = id.replace(" ", "");
      let bar = document.getElementById(id);
      if (!bar) {
        if (!icon)
          icon = label.replace(/\d+$/, "").trim().replace(" ", "-");
        bar = '<div title="' + label + '" class="combat-bar" id="' + id + '" data-value="' + (100 - p) / 20 * 20 + '" data-order="' + order + '">';
        bar += '<div class="combat-icon ' + icon + '"></div>';
        bar += '<div class="combat-name"> ' + label + "</div>";
        bar += '<div class="progressbar"><div class="progressbar-text">' + p + "%</div>";
        bar += '<div class="progressbar-value" style="width: ' + (100 - p) + '%"></div>';
        bar += "</div></div>";
        $(parent).append(bar);
        this._doUpdate(parent === "#party" ? 2 /* sortParty */ : 1 /* sortCombat */);
      } else {
        if (order !== +bar.getAttribute("data-order")) {
          bar.setAttribute("data-order", order);
          this._doUpdate(parent === "#party" ? 2 /* sortParty */ : 1 /* sortCombat */);
        }
        bar.setAttribute("data-value", (100 - p) / 20 * 20);
        bar.children[1].textContent = label;
        p = value / max2 * 100;
        bar.lastElementChild.firstElementChild.textContent = Math.ceil(p) + "%";
        bar.lastElementChild.lastElementChild.style.width = 100 - p + "%";
      }
    }
    removeBar(id, party) {
      const el = document.getElementById(id);
      if (!el) return;
      el.parentNode.removeChild(el);
      this._doUpdate(party ? 2 /* sortParty */ : 1 /* sortCombat */);
    }
    sortBars(p) {
      const listItems = p.children("div").get();
      listItems.sort((a, b) => {
        const compA = +a.getAttribute("data-order");
        const compB = +b.getAttribute("data-order");
        return compA < compB ? -1 : compA > compB ? 1 : 0;
      });
      $.each(listItems, (idx, itm) => {
        p.append(itm);
      });
    }
    updateLagMeter(lag, force) {
      if (!this._lagMeter) return;
      if (this.client.getOption("showLagInTitle"))
        this.setTitle(this._info["name"] || "", `${lag / 1e3}s`);
      if (!this.client.getOption("lagMeter") && !force) return;
      let p = 100;
      p = lag / 200 * 100;
      if (p > 100) p = 100;
      this._lagMeter.lastElementChild.style.width = 100 - p + "%";
      this._lagMeter.firstElementChild.textContent = lag / 1e3 + "s";
      const lm = document.querySelector("#status-simple-lagMeter .progress-bar");
      lm.style.width = 100 - p + "%";
      lm.ariaValueNow = "" + p;
    }
    _doUpdate(type) {
      if (!type) return;
      this._updating |= type;
      if (this._updating === 0 /* none */ || this._rTimeout)
        return;
      this._rTimeout = window.requestAnimationFrame(() => {
        if ((this._updating & 16 /* status */) === 16 /* status */) {
          this.updateStatus();
          this._updating &= ~16 /* status */;
        }
        if ((this._updating & 1 /* sortCombat */) === 1 /* sortCombat */) {
          this.sortBars($("#combat"));
          this._updating &= ~1 /* sortCombat */;
        }
        if ((this._updating & 2 /* sortParty */) === 2 /* sortParty */) {
          this.sortBars($("#party"));
          this._updating &= ~2 /* sortParty */;
        }
        if ((this._updating & 4 /* overall */) === 4 /* overall */) {
          this.updateOverall();
          this._updating &= ~4 /* overall */;
        }
        if ((this._updating & 8 /* xp */) === 8 /* xp */) {
          this.updateXP();
          this._updating &= ~8 /* xp */;
        }
        this._rTimeout = 0;
        this._doUpdate(this._updating);
      });
    }
    updateXP() {
      $("#xp-value").text(this._info["EXPERIENCE"]);
      $("#xp-banked").text(this._info["EXPERIENCE_BANKED"]);
      if (this._info["EXPERIENCE_NEED"] < 0) {
        $("#need-value").text(this.client.getOption("allowNegativeNumberNeeded") ? this._info["EXPERIENCE_NEED"] : 0);
        this.updateBar("need-percent", 100 - this._info["EXPERIENCE_NEED_P"], 100, this.client.getOption("allowNegativeNumberNeeded") ? this._info["EXPERIENCE_NEED"].toString() : "0");
        this.updateBar("status-simple-xp", 100 - this._info["EXPERIENCE_NEED_P"], 100, "", true);
      } else {
        $("#need-value").text(this._info["EXPERIENCE_NEED"]);
        this.updateBar("need-percent", 100 - this._info["EXPERIENCE_NEED_P"], 100, this._info["EXPERIENCE_NEED"].toString());
        this.updateBar("status-simple-xp", 100 - this._info["EXPERIENCE_NEED_P"], 100, "", true);
      }
      $("#earn-value").text(this._info["EXPERIENCE_EARNED"]);
    }
    resize() {
      if (!this.client.getOption("showStatus")) return;
      const w = this._status.style.width;
      this._status.style.width = "";
      const bounds = this._status.getBoundingClientRect();
      const minWidth = bounds.width + parseInt(this._styles.right, 10);
      const maxWidth = this.maxWidth;
      this._status.style.width = w;
      const bounds2 = this._status.getBoundingClientRect();
      if (bounds2.width < minWidth) {
        this.splitterDistance = minWidth;
      } else if (bounds2.width > maxWidth) {
        this.splitterDistance = maxWidth;
      }
    }
    get skills() {
      return this._info["skills"];
    }
    getSkill(skill) {
      if (!skill) return 0;
      return this._info["skills"][skill] || 0;
    }
    get name() {
      return this._info["name"];
    }
    get ac() {
      return this._ac;
    }
    set ac(enable) {
      if (this._ac !== enable) {
        this._ac = enable;
        this._doUpdate(16 /* status */);
        this.emit("display-changed");
      }
    }
    _sanitizeID(id) {
      id = id.replace(/\s/gi, "-");
      return id.replace(/[^a-zA-Z0-9_-]/gi, "");
    }
    _getID(obj, prefix) {
      if (!obj) return;
      if (!obj.id) return this._sanitizeID(obj.name || "");
      return (prefix || "obj_") + obj.id;
    }
    _livingClass(obj, prefix) {
      const cls = [];
      if (!prefix) prefix = "";
      if (obj.class && obj.class.length > 0)
        cls.push(prefix + this._sanitizeID(obj.class));
      if (obj.gender && obj.gender.length > 0)
        cls.push(prefix + this._sanitizeID(obj.gender));
      if (obj.race && obj.race.length > 0)
        cls.push(prefix + this._sanitizeID(obj.race));
      if (obj.guild && obj.guild.length > 0)
        cls.push(prefix + this._sanitizeID(obj.guild));
      if (obj.name && obj.name.length > 0)
        cls.push(prefix + this._sanitizeID(obj.name.replace(/\d+$/, "").trim()));
      return cls.join(" ").toLowerCase();
    }
    setWeapon(limb, weapon) {
      const l2 = limb;
      limb = limb.replace(/\s/g, "");
      limb = limb.toLowerCase();
      const eLimb = document.getElementById(limb + "weapon");
      if (!eLimb)
        return;
      eLimb.className = "";
      if (!weapon) return;
      if (weapon.quality && weapon.quality.length > 0)
        eLimb.classList.add("weapon-" + this._sanitizeID(weapon.quality));
      if (weapon.material && weapon.material.length > 0)
        eLimb.classList.add("weapon-" + this._sanitizeID(weapon.material));
      if (weapon.type && weapon.type.length > 0)
        eLimb.classList.add("weapon-" + this._sanitizeID(weapon.type));
      if (weapon.subtype && weapon.subtype.length > 0)
        eLimb.classList.add("weapon-" + this._sanitizeID(weapon.subtype));
      if (weapon.name && weapon.name.length > 0)
        eLimb.classList.add("weapon-" + this._sanitizeID(weapon.name));
      if (weapon.dominant)
        eLimb.classList.add("weapon-dominant");
      if (weapon.subtype && weapon.subtype.length > 0)
        eLimb.title = weapon.subtype + " in " + l2;
      else if (weapon.type && weapon.type.length > 0)
        eLimb.title = weapon.type + " in " + l2;
      else
        eLimb.title = "weapon in " + l2;
    }
    setLimbAC(limb, ac) {
      limb = limb.replace(/\s/g, "");
      limb = limb.toLowerCase();
      if (limb === "righthoof")
        limb = "rightfoot";
      else if (limb === "lefthoof")
        limb = "leftfoot";
      this._infoAC[limb] = ac;
    }
    setLimbHealth(limb, health) {
      limb = limb.replace(/\s/g, "");
      limb = limb.toLowerCase();
      if (limb === "righthoof")
        limb = "rightfoot";
      else if (limb === "lefthoof")
        limb = "leftfoot";
      this._infoLimb[limb] = health;
    }
  };

  // inline-worker:D:\Development\oiMUD\src\plugins\logger.worker.ts
  var logger_worker_default = "data:application/javascript;base64,KCgpID0+IHsKICAvLyBzcmMvbGliL3JnYmNvbG9yLmpzCiAgZnVuY3Rpb24gUkdCQ29sb3IoY29sb3Jfc3RyaW5nKSB7CiAgICB0aGlzLm9rID0gZmFsc2U7CiAgICBpZiAoY29sb3Jfc3RyaW5nLmNoYXJBdCgwKSA9PSAiIyIpIHsKICAgICAgY29sb3Jfc3RyaW5nID0gY29sb3Jfc3RyaW5nLnN1YnN0cigxLCA2KTsKICAgIH0KICAgIGNvbG9yX3N0cmluZyA9IGNvbG9yX3N0cmluZy5yZXBsYWNlKC8gL2csICIiKTsKICAgIGNvbG9yX3N0cmluZyA9IGNvbG9yX3N0cmluZy50b0xvd2VyQ2FzZSgpOwogICAgdmFyIHNpbXBsZV9jb2xvcnMgPSB7CiAgICAgIGFsaWNlYmx1ZTogImYwZjhmZiIsCiAgICAgIGFudGlxdWV3aGl0ZTogImZhZWJkNyIsCiAgICAgIGFxdWE6ICIwMGZmZmYiLAogICAgICBhcXVhbWFyaW5lOiAiN2ZmZmQ0IiwKICAgICAgYXp1cmU6ICJmMGZmZmYiLAogICAgICBiZWlnZTogImY1ZjVkYyIsCiAgICAgIGJpc3F1ZTogImZmZTRjNCIsCiAgICAgIGJsYWNrOiAiMDAwMDAwIiwKICAgICAgYmxhbmNoZWRhbG1vbmQ6ICJmZmViY2QiLAogICAgICBibHVlOiAiMDAwMGZmIiwKICAgICAgYmx1ZXZpb2xldDogIjhhMmJlMiIsCiAgICAgIGJyb3duOiAiYTUyYTJhIiwKICAgICAgYnVybHl3b29kOiAiZGViODg3IiwKICAgICAgY2FkZXRibHVlOiAiNWY5ZWEwIiwKICAgICAgY2hhcnRyZXVzZTogIjdmZmYwMCIsCiAgICAgIGNob2NvbGF0ZTogImQyNjkxZSIsCiAgICAgIGNvcmFsOiAiZmY3ZjUwIiwKICAgICAgY29ybmZsb3dlcmJsdWU6ICI2NDk1ZWQiLAogICAgICBjb3Juc2lsazogImZmZjhkYyIsCiAgICAgIGNyaW1zb246ICJkYzE0M2MiLAogICAgICBjeWFuOiAiMDBmZmZmIiwKICAgICAgZGFya2JsdWU6ICIwMDAwOGIiLAogICAgICBkYXJrY3lhbjogIjAwOGI4YiIsCiAgICAgIGRhcmtnb2xkZW5yb2Q6ICJiODg2MGIiLAogICAgICBkYXJrZ3JheTogImE5YTlhOSIsCiAgICAgIGRhcmtncmVlbjogIjAwNjQwMCIsCiAgICAgIGRhcmtraGFraTogImJkYjc2YiIsCiAgICAgIGRhcmttYWdlbnRhOiAiOGIwMDhiIiwKICAgICAgZGFya29saXZlZ3JlZW46ICI1NTZiMmYiLAogICAgICBkYXJrb3JhbmdlOiAiZmY4YzAwIiwKICAgICAgZGFya29yY2hpZDogIjk5MzJjYyIsCiAgICAgIGRhcmtyZWQ6ICI4YjAwMDAiLAogICAgICBkYXJrc2FsbW9uOiAiZTk5NjdhIiwKICAgICAgZGFya3NlYWdyZWVuOiAiOGZiYzhmIiwKICAgICAgZGFya3NsYXRlYmx1ZTogIjQ4M2Q4YiIsCiAgICAgIGRhcmtzbGF0ZWdyYXk6ICIyZjRmNGYiLAogICAgICBkYXJrdHVycXVvaXNlOiAiMDBjZWQxIiwKICAgICAgZGFya3Zpb2xldDogIjk0MDBkMyIsCiAgICAgIGRlZXBwaW5rOiAiZmYxNDkzIiwKICAgICAgZGVlcHNreWJsdWU6ICIwMGJmZmYiLAogICAgICBkaW1ncmF5OiAiNjk2OTY5IiwKICAgICAgZG9kZ2VyYmx1ZTogIjFlOTBmZiIsCiAgICAgIGZlbGRzcGFyOiAiZDE5Mjc1IiwKICAgICAgZmlyZWJyaWNrOiAiYjIyMjIyIiwKICAgICAgZmxvcmFsd2hpdGU6ICJmZmZhZjAiLAogICAgICBmb3Jlc3RncmVlbjogIjIyOGIyMiIsCiAgICAgIGZ1Y2hzaWE6ICJmZjAwZmYiLAogICAgICBnYWluc2Jvcm86ICJkY2RjZGMiLAogICAgICBnaG9zdHdoaXRlOiAiZjhmOGZmIiwKICAgICAgZ29sZDogImZmZDcwMCIsCiAgICAgIGdvbGRlbnJvZDogImRhYTUyMCIsCiAgICAgIGdyYXk6ICI4MDgwODAiLAogICAgICBncmVlbjogIjAwODAwMCIsCiAgICAgIGdyZWVueWVsbG93OiAiYWRmZjJmIiwKICAgICAgaG9uZXlkZXc6ICJmMGZmZjAiLAogICAgICBob3RwaW5rOiAiZmY2OWI0IiwKICAgICAgaW5kaWFucmVkOiAiY2Q1YzVjIiwKICAgICAgaW5kaWdvOiAiNGIwMDgyIiwKICAgICAgaXZvcnk6ICJmZmZmZjAiLAogICAgICBraGFraTogImYwZTY4YyIsCiAgICAgIGxhdmVuZGVyOiAiZTZlNmZhIiwKICAgICAgbGF2ZW5kZXJibHVzaDogImZmZjBmNSIsCiAgICAgIGxhd25ncmVlbjogIjdjZmMwMCIsCiAgICAgIGxlbW9uY2hpZmZvbjogImZmZmFjZCIsCiAgICAgIGxpZ2h0Ymx1ZTogImFkZDhlNiIsCiAgICAgIGxpZ2h0Y29yYWw6ICJmMDgwODAiLAogICAgICBsaWdodGN5YW46ICJlMGZmZmYiLAogICAgICBsaWdodGdvbGRlbnJvZHllbGxvdzogImZhZmFkMiIsCiAgICAgIGxpZ2h0Z3JleTogImQzZDNkMyIsCiAgICAgIGxpZ2h0Z3JlZW46ICI5MGVlOTAiLAogICAgICBsaWdodHBpbms6ICJmZmI2YzEiLAogICAgICBsaWdodHNhbG1vbjogImZmYTA3YSIsCiAgICAgIGxpZ2h0c2VhZ3JlZW46ICIyMGIyYWEiLAogICAgICBsaWdodHNreWJsdWU6ICI4N2NlZmEiLAogICAgICBsaWdodHNsYXRlYmx1ZTogIjg0NzBmZiIsCiAgICAgIGxpZ2h0c2xhdGVncmF5OiAiNzc4ODk5IiwKICAgICAgbGlnaHRzdGVlbGJsdWU6ICJiMGM0ZGUiLAogICAgICBsaWdodHllbGxvdzogImZmZmZlMCIsCiAgICAgIGxpbWU6ICIwMGZmMDAiLAogICAgICBsaW1lZ3JlZW46ICIzMmNkMzIiLAogICAgICBsaW5lbjogImZhZjBlNiIsCiAgICAgIG1hZ2VudGE6ICJmZjAwZmYiLAogICAgICBtYXJvb246ICI4MDAwMDAiLAogICAgICBtZWRpdW1hcXVhbWFyaW5lOiAiNjZjZGFhIiwKICAgICAgbWVkaXVtYmx1ZTogIjAwMDBjZCIsCiAgICAgIG1lZGl1bW9yY2hpZDogImJhNTVkMyIsCiAgICAgIG1lZGl1bXB1cnBsZTogIjkzNzBkOCIsCiAgICAgIG1lZGl1bXNlYWdyZWVuOiAiM2NiMzcxIiwKICAgICAgbWVkaXVtc2xhdGVibHVlOiAiN2I2OGVlIiwKICAgICAgbWVkaXVtc3ByaW5nZ3JlZW46ICIwMGZhOWEiLAogICAgICBtZWRpdW10dXJxdW9pc2U6ICI0OGQxY2MiLAogICAgICBtZWRpdW12aW9sZXRyZWQ6ICJjNzE1ODUiLAogICAgICBtaWRuaWdodGJsdWU6ICIxOTE5NzAiLAogICAgICBtaW50Y3JlYW06ICJmNWZmZmEiLAogICAgICBtaXN0eXJvc2U6ICJmZmU0ZTEiLAogICAgICBtb2NjYXNpbjogImZmZTRiNSIsCiAgICAgIG5hdmFqb3doaXRlOiAiZmZkZWFkIiwKICAgICAgbmF2eTogIjAwMDA4MCIsCiAgICAgIG9sZGxhY2U6ICJmZGY1ZTYiLAogICAgICBvbGl2ZTogIjgwODAwMCIsCiAgICAgIG9saXZlZHJhYjogIjZiOGUyMyIsCiAgICAgIG9yYW5nZTogImZmYTUwMCIsCiAgICAgIG9yYW5nZXJlZDogImZmNDUwMCIsCiAgICAgIG9yY2hpZDogImRhNzBkNiIsCiAgICAgIHBhbGVnb2xkZW5yb2Q6ICJlZWU4YWEiLAogICAgICBwYWxlZ3JlZW46ICI5OGZiOTgiLAogICAgICBwYWxldHVycXVvaXNlOiAiYWZlZWVlIiwKICAgICAgcGFsZXZpb2xldHJlZDogImQ4NzA5MyIsCiAgICAgIHBhcGF5YXdoaXA6ICJmZmVmZDUiLAogICAgICBwZWFjaHB1ZmY6ICJmZmRhYjkiLAogICAgICBwZXJ1OiAiY2Q4NTNmIiwKICAgICAgcGluazogImZmYzBjYiIsCiAgICAgIHBsdW06ICJkZGEwZGQiLAogICAgICBwb3dkZXJibHVlOiAiYjBlMGU2IiwKICAgICAgcHVycGxlOiAiODAwMDgwIiwKICAgICAgcmVkOiAiZmYwMDAwIiwKICAgICAgcm9zeWJyb3duOiAiYmM4ZjhmIiwKICAgICAgcm95YWxibHVlOiAiNDE2OWUxIiwKICAgICAgc2FkZGxlYnJvd246ICI4YjQ1MTMiLAogICAgICBzYWxtb246ICJmYTgwNzIiLAogICAgICBzYW5keWJyb3duOiAiZjRhNDYwIiwKICAgICAgc2VhZ3JlZW46ICIyZThiNTciLAogICAgICBzZWFzaGVsbDogImZmZjVlZSIsCiAgICAgIHNpZW5uYTogImEwNTIyZCIsCiAgICAgIHNpbHZlcjogImMwYzBjMCIsCiAgICAgIHNreWJsdWU6ICI4N2NlZWIiLAogICAgICBzbGF0ZWJsdWU6ICI2YTVhY2QiLAogICAgICBzbGF0ZWdyYXk6ICI3MDgwOTAiLAogICAgICBzbm93OiAiZmZmYWZhIiwKICAgICAgc3ByaW5nZ3JlZW46ICIwMGZmN2YiLAogICAgICBzdGVlbGJsdWU6ICI0NjgyYjQiLAogICAgICB0YW46ICJkMmI0OGMiLAogICAgICB0ZWFsOiAiMDA4MDgwIiwKICAgICAgdGhpc3RsZTogImQ4YmZkOCIsCiAgICAgIHRvbWF0bzogImZmNjM0NyIsCiAgICAgIHR1cnF1b2lzZTogIjQwZTBkMCIsCiAgICAgIHZpb2xldDogImVlODJlZSIsCiAgICAgIHZpb2xldHJlZDogImQwMjA5MCIsCiAgICAgIHdoZWF0OiAiZjVkZWIzIiwKICAgICAgd2hpdGU6ICJmZmZmZmYiLAogICAgICB3aGl0ZXNtb2tlOiAiZjVmNWY1IiwKICAgICAgeWVsbG93OiAiZmZmZjAwIiwKICAgICAgeWVsbG93Z3JlZW46ICI5YWNkMzIiCiAgICB9OwogICAgZm9yICh2YXIga2V5IGluIHNpbXBsZV9jb2xvcnMpIHsKICAgICAgaWYgKGNvbG9yX3N0cmluZyA9PSBrZXkpIHsKICAgICAgICBjb2xvcl9zdHJpbmcgPSBzaW1wbGVfY29sb3JzW2tleV07CiAgICAgIH0KICAgIH0KICAgIHZhciBjb2xvcl9kZWZzID0gWwogICAgICB7CiAgICAgICAgcmU6IC9ecmdiXCgoXGR7MSwzfSksXHMqKFxkezEsM30pLFxzKihcZHsxLDN9KVwpJC8sCiAgICAgICAgZXhhbXBsZTogWyJyZ2IoMTIzLCAyMzQsIDQ1KSIsICJyZ2IoMjU1LDIzNCwyNDUpIl0sCiAgICAgICAgcHJvY2VzczogZnVuY3Rpb24oYml0czIpIHsKICAgICAgICAgIHJldHVybiBbCiAgICAgICAgICAgIHBhcnNlSW50KGJpdHMyWzFdLCAxMCksCiAgICAgICAgICAgIHBhcnNlSW50KGJpdHMyWzJdLCAxMCksCiAgICAgICAgICAgIHBhcnNlSW50KGJpdHMyWzNdLCAxMCkKICAgICAgICAgIF07CiAgICAgICAgfQogICAgICB9LAogICAgICB7CiAgICAgICAgcmU6IC9eKFx3ezJ9KShcd3syfSkoXHd7Mn0pJC8sCiAgICAgICAgZXhhbXBsZTogWyIjMDBmZjAwIiwgIjMzNjY5OSJdLAogICAgICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGJpdHMyKSB7CiAgICAgICAgICByZXR1cm4gWwogICAgICAgICAgICBwYXJzZUludChiaXRzMlsxXSwgMTYpLAogICAgICAgICAgICBwYXJzZUludChiaXRzMlsyXSwgMTYpLAogICAgICAgICAgICBwYXJzZUludChiaXRzMlszXSwgMTYpCiAgICAgICAgICBdOwogICAgICAgIH0KICAgICAgfSwKICAgICAgewogICAgICAgIHJlOiAvXihcd3sxfSkoXHd7MX0pKFx3ezF9KSQvLAogICAgICAgIGV4YW1wbGU6IFsiI2ZiMCIsICJmMGYiXSwKICAgICAgICBwcm9jZXNzOiBmdW5jdGlvbihiaXRzMikgewogICAgICAgICAgcmV0dXJuIFsKICAgICAgICAgICAgcGFyc2VJbnQoYml0czJbMV0gKyBiaXRzMlsxXSwgMTYpLAogICAgICAgICAgICBwYXJzZUludChiaXRzMlsyXSArIGJpdHMyWzJdLCAxNiksCiAgICAgICAgICAgIHBhcnNlSW50KGJpdHMyWzNdICsgYml0czJbM10sIDE2KQogICAgICAgICAgXTsKICAgICAgICB9CiAgICAgIH0KICAgIF07CiAgICBmb3IgKHZhciBpID0gMCwgY2wgPSBjb2xvcl9kZWZzLmxlbmd0aDsgaSA8IGNsOyBpKyspIHsKICAgICAgdmFyIHJlID0gY29sb3JfZGVmc1tpXS5yZTsKICAgICAgdmFyIHByb2Nlc3NvciA9IGNvbG9yX2RlZnNbaV0ucHJvY2VzczsKICAgICAgdmFyIGJpdHMgPSByZS5leGVjKGNvbG9yX3N0cmluZyk7CiAgICAgIGlmIChiaXRzKSB7CiAgICAgICAgdmFyIGNoYW5uZWxzID0gcHJvY2Vzc29yKGJpdHMpOwogICAgICAgIHRoaXMuciA9IGNoYW5uZWxzWzBdOwogICAgICAgIHRoaXMuZyA9IGNoYW5uZWxzWzFdOwogICAgICAgIHRoaXMuYiA9IGNoYW5uZWxzWzJdOwogICAgICAgIHRoaXMub2sgPSB0cnVlOwogICAgICB9CiAgICB9CiAgICB0aGlzLnIgPSB0aGlzLnIgPCAwIHx8IGlzTmFOKHRoaXMucikgPyAwIDogdGhpcy5yID4gMjU1ID8gMjU1IDogdGhpcy5yOwogICAgdGhpcy5nID0gdGhpcy5nIDwgMCB8fCBpc05hTih0aGlzLmcpID8gMCA6IHRoaXMuZyA+IDI1NSA/IDI1NSA6IHRoaXMuZzsKICAgIHRoaXMuYiA9IHRoaXMuYiA8IDAgfHwgaXNOYU4odGhpcy5iKSA/IDAgOiB0aGlzLmIgPiAyNTUgPyAyNTUgOiB0aGlzLmI7CiAgICB0aGlzLnRvUkdCID0gZnVuY3Rpb24oKSB7CiAgICAgIHJldHVybiAicmdiKCIgKyB0aGlzLnIgKyAiLCAiICsgdGhpcy5nICsgIiwgIiArIHRoaXMuYiArICIpIjsKICAgIH07CiAgICB0aGlzLnRvSGV4ID0gZnVuY3Rpb24oKSB7CiAgICAgIHZhciByID0gdGhpcy5yLnRvU3RyaW5nKDE2KTsKICAgICAgdmFyIGcgPSB0aGlzLmcudG9TdHJpbmcoMTYpOwogICAgICB2YXIgYiA9IHRoaXMuYi50b1N0cmluZygxNik7CiAgICAgIGlmIChyLmxlbmd0aCA9PSAxKSByID0gIjAiICsgcjsKICAgICAgaWYgKGcubGVuZ3RoID09IDEpIGcgPSAiMCIgKyBnOwogICAgICBpZiAoYi5sZW5ndGggPT0gMSkgYiA9ICIwIiArIGI7CiAgICAgIHJldHVybiAiIyIgKyByICsgZyArIGI7CiAgICB9OwogIH0KCiAgLy8gc3JjL3BsdWdpbnMvbG9nZ2VyLndvcmtlci50cwogIGltcG9ydFNjcmlwdHMoImh0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vbW9tZW50QDIuMzAuMS9tb21lbnQubWluLmpzIik7CiAgdmFyIG9wdGlvbnMgPSB7CiAgICBwYXRoOiAiIiwKICAgIG9mZmxpbmU6IGZhbHNlLAogICAgZ2FnZ2VkOiBmYWxzZSwKICAgIGVuYWJsZWQ6IGZhbHNlLAogICAgdW5pcXVlOiB0cnVlLAogICAgcHJlcGVuZDogZmFsc2UsCiAgICBuYW1lOiAiIiwKICAgIHdoYXQ6IDEgLyogSHRtbCAqLywKICAgIGRlYnVnOiBmYWxzZSwKICAgIHRpbWVzdGFtcDogMCAvKiBOb25lICovLAogICAgdGltZXN0YW1wRm9ybWF0OiAiW1tdTU0tREQgSEg6bW06c3MuU1NTW11dICIKICB9OwogIHZhciBjb25uZWN0ZWQgPSBmYWxzZTsKICB2YXIgdGltZVN0YW1wOwogIHZhciBmVGltZVN0YW1wID0gIiI7CiAgdmFyIGxvZ2dpbmcgPSBmYWxzZTsKICB2YXIgY3VycmVudEZpbGUgPSAiIjsKICB2YXIgY29sb3JzID0ge307CiAgdmFyIGNvbG9yc0NudCA9IDA7CiAgdmFyIGJhY2tncm91bmRzID0ge307CiAgdmFyIGJhY2tncm91bmRzQ250ID0gMDsKICB2YXIgYnVmZmVyID0ge307CiAgdmFyIGZsdXNoQnVmZmVyOwogIHZhciBjb2xvclRhYmxlID0gbnVsbDsKICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoIm1lc3NhZ2UiLCAoZSkgPT4gewogICAgbGV0IGM7CiAgICBpZiAoIWUuZGF0YSkgcmV0dXJuOwogICAgc3dpdGNoIChlLmRhdGEuYWN0aW9uKSB7CiAgICAgIGNhc2UgIm9wdGlvbnMiOgogICAgICAgIGxldCBvcHRpb247CiAgICAgICAgbGV0IG9sZEVuYWJsZWQgPSBvcHRpb25zLmVuYWJsZWQ7CiAgICAgICAgZm9yIChvcHRpb24gaW4gZS5kYXRhLmFyZ3MpIHsKICAgICAgICAgIGlmICghZS5kYXRhLmFyZ3MuaGFzT3duUHJvcGVydHkob3B0aW9uKSkKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICBpZiAob3B0aW9uID09PSAiY29sb3JzIikgewogICAgICAgICAgICBjb25zdCBfY29sb3JzID0gZS5kYXRhLmFyZ3Nbb3B0aW9uXTsKICAgICAgICAgICAgaWYgKF9jb2xvcnMgJiYgX2NvbG9ycy5sZW5ndGggPiAwKSB7CiAgICAgICAgICAgICAgbGV0IGNscjsKICAgICAgICAgICAgICBjb25zdCBjbCA9IF9jb2xvcnMubGVuZ3RoOwogICAgICAgICAgICAgIGZvciAoY2xyID0gMDsgY2xyIDwgY2w7IGNscisrKSB7CiAgICAgICAgICAgICAgICBpZiAoIV9jb2xvcnNbY2xyXSB8fCBfY29sb3JzW2Nscl0ubGVuZ3RoID09PSAwKSBjb250aW51ZTsKICAgICAgICAgICAgICAgIFNldENvbG9yKGNsciwgX2NvbG9yc1tjbHJdKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9IGVsc2UgaWYgKGZsdXNoQnVmZmVyICYmIG9wdGlvbiA9PT0gIndoYXQiICYmIG9wdGlvbnNbb3B0aW9uXSAhPT0gZS5kYXRhLmFyZ3Nbb3B0aW9uXSkgewogICAgICAgICAgICBjID0gMCAvKiBOb25lICovOwogICAgICAgICAgICBpZiAoKG9wdGlvbnNbb3B0aW9uXSAmIDEgLyogSHRtbCAqLykgPT09IDEgLyogSHRtbCAqLyAmJiAoZS5kYXRhLmFyZ3Nbb3B0aW9uXSAmIDEgLyogSHRtbCAqLykgIT09IDEgLyogSHRtbCAqLykKICAgICAgICAgICAgICBjIHw9IDEgLyogSHRtbCAqLzsKICAgICAgICAgICAgaWYgKChvcHRpb25zW29wdGlvbl0gJiAyIC8qIFRleHQgKi8pID09PSAyIC8qIFRleHQgKi8gJiYgKGUuZGF0YS5hcmdzW29wdGlvbl0gJiAyIC8qIFRleHQgKi8pICE9PSAyIC8qIFRleHQgKi8pCiAgICAgICAgICAgICAgYyB8PSAyIC8qIFRleHQgKi87CiAgICAgICAgICAgIGlmICgob3B0aW9uc1tvcHRpb25dICYgNCAvKiBSYXcgKi8pID09PSA0IC8qIFJhdyAqLyAmJiAoZS5kYXRhLmFyZ3Nbb3B0aW9uXSAmIDQgLyogUmF3ICovKSAhPT0gNCAvKiBSYXcgKi8pCiAgICAgICAgICAgICAgYyB8PSA0IC8qIFJhdyAqLzsKICAgICAgICAgICAgaWYgKGMgIT09IDAgLyogTm9uZSAqLykgewogICAgICAgICAgICAgIGNvbnN0IGZPbGQgPSBmbHVzaEJ1ZmZlcjsKICAgICAgICAgICAgICBmbHVzaEJ1ZmZlci53aGF0ID0gYzsKICAgICAgICAgICAgICBmbHVzaCh0cnVlKTsKICAgICAgICAgICAgICBmT2xkLndoYXQgPSBvcHRpb25zW29wdGlvbl07CiAgICAgICAgICAgICAgZmx1c2hCdWZmZXIgPSBmT2xkOwogICAgICAgICAgICB9CiAgICAgICAgICAgIG9wdGlvbnNbb3B0aW9uXSA9IGUuZGF0YS5hcmdzW29wdGlvbl07CiAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgb3B0aW9uc1tvcHRpb25dID0gZS5kYXRhLmFyZ3Nbb3B0aW9uXTsKICAgICAgICB9CiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnRpbWVzdGFtcCA9PT0gImJvb2xlYW4iKQogICAgICAgICAgb3B0aW9ucy50aW1lc3RhbXAgPSBvcHRpb25zLnRpbWVzdGFtcCA/IDIgLyogRm9ybWF0ICovIDogMCAvKiBOb25lICovOwogICAgICAgIGlmICh0aW1lU3RhbXAgIT09IDApIHsKICAgICAgICAgIGZUaW1lU3RhbXAgPSBuZXcgbW9tZW50KHRpbWVTdGFtcCkuZm9ybWF0KG9wdGlvbnMuZm9ybWF0IHx8ICJZWVlZTU1ERC1ISG1tc3MiKTsKICAgICAgICAgIGJ1aWxkRmlsZW5hbWUoKTsKICAgICAgICAgIGZsdXNoKHRydWUpOwogICAgICAgIH0KICAgICAgICBpZiAob2xkRW5hYmxlZCAhPSBvcHRpb25zLmVuYWJsZWQpIHsKICAgICAgICAgIGlmICghb2xkRW5hYmxlZCAmJiAhbG9nZ2luZykKICAgICAgICAgICAgcG9zdE1lc3NhZ2UoeyBldmVudDogInN0YXJ0IiB9KTsKICAgICAgICAgIGVsc2UgaWYgKG9sZEVuYWJsZWQgJiYgbG9nZ2luZykKICAgICAgICAgICAgc3RvcCgpOwogICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5vZmZsaW5lKQogICAgICAgICAgICBwb3N0TWVzc2FnZSh7IGV2ZW50OiAic3RhcnQiIH0pOwogICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5vZmZsaW5lKQogICAgICAgICAgcG9zdE1lc3NhZ2UoeyBldmVudDogInN0YXJ0IiB9KTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAibmFtZSI6CiAgICAgICAgb3B0aW9ucy5uYW1lID0gZS5kYXRhLmFyZ3M7CiAgICAgICAgaWYgKGxvZ2dpbmcpCiAgICAgICAgICBmaWxlQ2hhbmdlZCgpOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlICJjb25uZWN0ZWQiOgogICAgICAgIGNvbm5lY3RlZCA9IGUuZGF0YS5hcmdzOwogICAgICAgIGJ1aWxkRmlsZW5hbWUoKTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAibG9nZ2luZyI6CiAgICAgICAgcG9zdE1lc3NhZ2UoeyBldmVudDogImxvZ2dpbmciLCBhcmdzOiBsb2dnaW5nIH0pOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlICJ0b2dnbGUiOgogICAgICAgIHRvZ2dsZSgpOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlICJzdG9wIjoKICAgICAgICBzdG9wKCk7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgInN0YXJ0SW50ZXJuYWwiOgogICAgICAgIGMgPSBvcHRpb25zLnVuaXF1ZTsKICAgICAgICBvcHRpb25zLnVuaXF1ZSA9IGZhbHNlOwogICAgICAgIGlmICghZS5kYXRhLmFyZ3MpCiAgICAgICAgICBzdGFydChbXSwgZmFsc2UpOwogICAgICAgIGVsc2UKICAgICAgICAgIHN0YXJ0KGUuZGF0YS5hcmdzLmxpbmVzLCBlLmRhdGEuYXJncy5mcmFnbWVudCk7CiAgICAgICAgb3B0aW9ucy51bmlxdWUgPSBjOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlICJzdGFydCI6CiAgICAgICAgaWYgKCFlLmRhdGEuYXJncykKICAgICAgICAgIHN0YXJ0KFtdLCBmYWxzZSk7CiAgICAgICAgZWxzZQogICAgICAgICAgc3RhcnQoZS5kYXRhLmFyZ3MubGluZXMsIGUuZGF0YS5hcmdzLmZyYWdtZW50KTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAiZmx1c2giOgogICAgICAgIGZsdXNoKGUuZGF0YS5hcmdzKTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAiYWRkLWxpbmUiOgogICAgICAgIGNvbnN0IGRhdGEgPSBlLmRhdGEuYXJnczsKICAgICAgICBpZiAoZGF0YS5mcmFnbWVudCkgewogICAgICAgICAgZmx1c2hCdWZmZXIgPSBkYXRhOwogICAgICAgICAgZmx1c2hCdWZmZXIubG9nZ2luZyA9IGxvZ2dpbmc7CiAgICAgICAgICBmbHVzaEJ1ZmZlci5maWxlID0gY3VycmVudEZpbGU7CiAgICAgICAgICBmbHVzaEJ1ZmZlci5jb25uZWN0ZWQgPSBjb25uZWN0ZWQ7CiAgICAgICAgICBmbHVzaEJ1ZmZlci5vZmZsaW5lID0gb3B0aW9ucy5vZmZsaW5lOwogICAgICAgICAgZmx1c2hCdWZmZXIud2hhdCA9IG9wdGlvbnMud2hhdDsKICAgICAgICAgIGZsdXNoQnVmZmVyLmdhZ2dlZCA9IGRhdGEuZ2FnZ2VkIHx8IG9wdGlvbnMuZ2FnZ2VkICYmIGRhdGEuZ2FnZ2VkOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmbHVzaEJ1ZmZlciA9IG51bGw7CiAgICAgICAgaWYgKCFsb2dnaW5nIHx8ICFvcHRpb25zLm9mZmxpbmUgJiYgIWNvbm5lY3RlZCkgcmV0dXJuOwogICAgICAgIGlmIChkYXRhLmdhZ2dlZCAmJiAhb3B0aW9ucy5nYWdnZWQpIHJldHVybjsKICAgICAgICBpZiAoKG9wdGlvbnMud2hhdCAmIDEgLyogSHRtbCAqLykgPT09IDEgLyogSHRtbCAqLykKICAgICAgICAgIHdyaXRlSHRtbChjcmVhdGVMaW5lKHsgdGV4dDogZGF0YS5saW5lLCBmb3JtYXRzOiBkYXRhLmZvcm1hdHMsIHRpbWVzdGFtcDogZGF0YS50aW1lc3RhbXAgfHwgRGF0ZS5ub3coKSB9KSk7CiAgICAgICAgaWYgKChvcHRpb25zLndoYXQgJiAyIC8qIFRleHQgKi8pID09PSAyIC8qIFRleHQgKi8gfHwgb3B0aW9ucy53aGF0ID09PSAwIC8qIE5vbmUgKi8pIHsKICAgICAgICAgIGlmIChvcHRpb25zLnRpbWVzdGFtcCA9PT0gMiAvKiBGb3JtYXQgKi8pCiAgICAgICAgICAgIHdyaXRlVGV4dChtb21lbnQoZGF0YS50aW1lc3RhbXApLmZvcm1hdChvcHRpb25zLnRpbWVzdGFtcEZvcm1hdCkpOwogICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy50aW1lc3RhbXAgIT09IDAgLyogTm9uZSAqLykKICAgICAgICAgICAgd3JpdGVUZXh0KG5ldyBEYXRlKGRhdGEudGltZXN0YW1wKS50b0lTT1N0cmluZygpKTsKICAgICAgICAgIHdyaXRlVGV4dChkYXRhLmxpbmUgKyAiXG4iKTsKICAgICAgICB9CiAgICAgICAgaWYgKChvcHRpb25zLndoYXQgJiA0IC8qIFJhdyAqLykgPT09IDQgLyogUmF3ICovKSB7CiAgICAgICAgICBpZiAob3B0aW9ucy50aW1lc3RhbXAgPT09IDIgLyogRm9ybWF0ICovKQogICAgICAgICAgICB3cml0ZVRleHQoIlx4MUJbLTc7LThtIiArIG1vbWVudChkYXRhLnRpbWVzdGFtcCkuZm9ybWF0KG9wdGlvbnMudGltZXN0YW1wRm9ybWF0KSArICJceDFCWzBtIik7CiAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLnRpbWVzdGFtcCAhPT0gMCAvKiBOb25lICovKQogICAgICAgICAgICB3cml0ZVRleHQoIlx4MUJbLTc7LThtIiArIG5ldyBEYXRlKGRhdGEudGltZXN0YW1wKS50b0lTT1N0cmluZygpICsgIlx4MUJbMG0iKTsKICAgICAgICAgIHdyaXRlUmF3KGRhdGEucmF3KTsKICAgICAgICB9CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgIndyaXRlLWRvbmUiOgogICAgICAgIGlmICghYnVmZmVyW2UuZGF0YS5maWxlXSkgcmV0dXJuOwogICAgICAgIGJ1ZmZlcltlLmRhdGEuZmlsZV0uc2hpZnQoKTsKICAgICAgICBpZiAoYnVmZmVyW2UuZGF0YS5maWxlXS5sZW5ndGgpIHsKICAgICAgICAgIGNvbnN0IHRtcCA9IGJ1ZmZlcltlLmRhdGEuZmlsZV0uc2hpZnQoKTsKICAgICAgICAgIGFwcGVuZEZpbGUodG1wLmZpbGUsIHRtcC5kYXRhLCB0cnVlKTsKICAgICAgICB9IGVsc2UKICAgICAgICAgIGRlbGV0ZSBidWZmZXJbZS5kYXRhLmZpbGVdOwogICAgICAgIGJyZWFrOwogICAgfQogIH0sIGZhbHNlKTsKICBmdW5jdGlvbiBmaWxlQ2hhbmdlZCgpIHsKICAgIGNvbnN0IHBGaWxlID0gY3VycmVudEZpbGU7CiAgICBidWlsZEZpbGVuYW1lKCk7CiAgICBpZiAocEZpbGUgPT09IGN1cnJlbnRGaWxlKSByZXR1cm47CiAgICBwb3N0TWVzc2FnZSh7IGV2ZW50OiAiZGVidWciLCBhcmdzOiAnRmlsZSBjaGFuZ2VkOiAiJyArIHBGaWxlICsgJyIgdG8gIicgKyBjdXJyZW50RmlsZSArICciJyB9KTsKICAgIGlmIChmbHVzaEJ1ZmZlciAmJiBmbHVzaEJ1ZmZlci5jdXJyZW50RmlsZSAhPT0gcEZpbGUpCiAgICAgIGZsdXNoKHRydWUpOwogICAgZWxzZSBpZiAoZmx1c2hCdWZmZXIpCiAgICAgIGZsdXNoQnVmZmVyLmN1cnJlbnRGaWxlID0gY3VycmVudEZpbGU7CiAgfQogIGZ1bmN0aW9uIGJ1aWxkRmlsZW5hbWUoKSB7CiAgICBjb25zdCBvID0gY3VycmVudEZpbGU7CiAgICBpZiAob3B0aW9ucy5wcmVmaXgpCiAgICAgIGN1cnJlbnRGaWxlID0gb3B0aW9ucy5wcmVmaXggKyBmVGltZVN0YW1wOwogICAgZWxzZQogICAgICBjdXJyZW50RmlsZSA9IGZUaW1lU3RhbXA7CiAgICBpZiAob3B0aW9ucy5uYW1lICYmIG9wdGlvbnMubmFtZS5sZW5ndGggPiAwKQogICAgICBjdXJyZW50RmlsZSArPSAiLiIgKyBvcHRpb25zLm5hbWU7CiAgICBpZiAob3B0aW9ucy5wb3N0Zml4KQogICAgICBjdXJyZW50RmlsZSArPSBvcHRpb25zLnBvc3RmaXg7CiAgICBpZiAob3B0aW9ucy5kZWJ1ZyAmJiBvICE9PSBjdXJyZW50RmlsZSkKICAgICAgcG9zdE1lc3NhZ2UoeyBldmVudDogImRlYnVnIiwgYXJnczogJ0xvZyBmaWxlOiAiJyArIGN1cnJlbnRGaWxlICsgJyInIH0pOwogIH0KICBmdW5jdGlvbiBhcHBlbmRGaWxlKGZpbGUsIGRhdGEsIGZvcmNlKSB7CiAgICB0cnkgewogICAgICBpZiAoIWJ1ZmZlcltmaWxlXSkgYnVmZmVyW2ZpbGVdID0gW107CiAgICAgIGlmIChidWZmZXJbZmlsZV0ubGVuZ3RoICYmICFmb3JjZSkgewogICAgICAgIGJ1ZmZlcltmaWxlXS5wdXNoKHsgZmlsZSwgZGF0YSB9KTsKICAgICAgICByZXR1cm47CiAgICAgIH0KICAgICAgYnVmZmVyW2ZpbGVdLnVuc2hpZnQoeyBmaWxlLCBkYXRhIH0pOwogICAgICBwb3N0TWVzc2FnZSh7IGV2ZW50OiAid3JpdGUiLCBmaWxlLCBkYXRhLCBjaGFyYWN0ZXI6IG9wdGlvbnMubmFtZSB8fCAiIiwgdGltZVN0YW1wLCBwb3N0Zml4OiBvcHRpb25zLnBvc3RmaXgsIHByZWZpeDogb3B0aW9ucy5wcmVmaXggfSk7CiAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgcG9zdE1lc3NhZ2UoeyBldmVudDogImVycm9yIiwgYXJnczogZXJyIH0pOwogICAgfQogIH0KICBmdW5jdGlvbiB3cml0ZVRleHQoZGF0YSkgewogICAgaWYgKCFsb2dnaW5nIHx8ICFvcHRpb25zLm9mZmxpbmUgJiYgIWNvbm5lY3RlZCkgcmV0dXJuOwogICAgaWYgKCFjdXJyZW50RmlsZSB8fCBjdXJyZW50RmlsZS5sZW5ndGggPT09IDApCiAgICAgIGJ1aWxkRmlsZW5hbWUoKTsKICAgIGFwcGVuZEZpbGUoY3VycmVudEZpbGUgKyAiLnR4dCIsIGRhdGEpOwogIH0KICBmdW5jdGlvbiB3cml0ZUh0bWwoZGF0YSkgewogICAgaWYgKCFsb2dnaW5nIHx8ICFvcHRpb25zLm9mZmxpbmUgJiYgIWNvbm5lY3RlZCkgcmV0dXJuOwogICAgaWYgKCFjdXJyZW50RmlsZSB8fCBjdXJyZW50RmlsZS5sZW5ndGggPT09IDApCiAgICAgIGJ1aWxkRmlsZW5hbWUoKTsKICAgIGFwcGVuZEZpbGUoY3VycmVudEZpbGUgKyAiLmh0bSIsIGRhdGEpOwogIH0KICBmdW5jdGlvbiB3cml0ZVJhdyhkYXRhKSB7CiAgICBpZiAoIWxvZ2dpbmcgfHwgIW9wdGlvbnMub2ZmbGluZSAmJiAhY29ubmVjdGVkKSByZXR1cm47CiAgICBpZiAoIWN1cnJlbnRGaWxlIHx8IGN1cnJlbnRGaWxlLmxlbmd0aCA9PT0gMCkKICAgICAgYnVpbGRGaWxlbmFtZSgpOwogICAgYXBwZW5kRmlsZShjdXJyZW50RmlsZSArICIucmF3IiwgZGF0YSk7CiAgfQogIGZ1bmN0aW9uIGZsdXNoKG5ld2xpbmUpIHsKICAgIGlmICghZmx1c2hCdWZmZXIgfHwgIWZsdXNoQnVmZmVyLmxvZ2dpbmcgfHwgIWZsdXNoQnVmZmVyLm9mZmxpbmUgJiYgIWZsdXNoQnVmZmVyLmNvbm5lY3RlZCkgcmV0dXJuOwogICAgY29uc3QgYyA9IGNvbm5lY3RlZDsKICAgIGNvbnN0IGYgPSBjdXJyZW50RmlsZTsKICAgIGNvbnN0IGwgPSBsb2dnaW5nOwogICAgbG9nZ2luZyA9IGZsdXNoQnVmZmVyLmxvZ2dpbmc7CiAgICBjb25uZWN0ZWQgPSBmbHVzaEJ1ZmZlci5jb25uZWN0ZWQ7CiAgICBjdXJyZW50RmlsZSA9IGZsdXNoQnVmZmVyLmN1cnJlbnRGaWxlOwogICAgaWYgKCFmbHVzaEJ1ZmZlci5nYWdnZWQpIHsKICAgICAgbGV0IG5sID0gIiI7CiAgICAgIGlmIChuZXdsaW5lKQogICAgICAgIG5sID0gIlxuIjsKICAgICAgaWYgKChmbHVzaEJ1ZmZlci53aGF0ICYgMSAvKiBIdG1sICovKSA9PT0gMSAvKiBIdG1sICovKQogICAgICAgIHdyaXRlSHRtbChjcmVhdGVMaW5lKHsgdGV4dDogZmx1c2hCdWZmZXIubGluZSwgZm9ybWF0czogZmx1c2hCdWZmZXIuZm9ybWF0cywgdGltZXN0YW1wOiBmbHVzaEJ1ZmZlci50aW1lc3RhbXAgfHwgRGF0ZS5ub3coKSB9KSk7CiAgICAgIGlmICgoZmx1c2hCdWZmZXIud2hhdCAmIDIgLyogVGV4dCAqLykgPT09IDIgLyogVGV4dCAqLyB8fCBmbHVzaEJ1ZmZlci53aGF0ID09PSAwIC8qIE5vbmUgKi8pIHsKICAgICAgICBpZiAob3B0aW9ucy50aW1lc3RhbXAgPT09IDIgLyogRm9ybWF0ICovKQogICAgICAgICAgd3JpdGVUZXh0KG1vbWVudChmbHVzaEJ1ZmZlci50aW1lc3RhbXApLmZvcm1hdChvcHRpb25zLnRpbWVzdGFtcEZvcm1hdCkpOwogICAgICAgIGVsc2UgaWYgKG9wdGlvbnMudGltZXN0YW1wICE9PSAwIC8qIE5vbmUgKi8pCiAgICAgICAgICB3cml0ZVRleHQobmV3IERhdGUoZmx1c2hCdWZmZXIudGltZXN0YW1wKS50b0lTT1N0cmluZygpKTsKICAgICAgICB3cml0ZVRleHQoZmx1c2hCdWZmZXIubGluZSArIG5sKTsKICAgICAgfQogICAgICBpZiAoKGZsdXNoQnVmZmVyLndoYXQgJiA0IC8qIFJhdyAqLykgPT09IDQgLyogUmF3ICovKSB7CiAgICAgICAgaWYgKG1vbWVudCAmJiBvcHRpb25zLnRpbWVzdGFtcCA9PT0gMiAvKiBGb3JtYXQgKi8pCiAgICAgICAgICB3cml0ZVRleHQoIlx4MUJbLTc7LThtIiArIG1vbWVudChmbHVzaEJ1ZmZlci50aW1lc3RhbXApLmZvcm1hdChvcHRpb25zLnRpbWVzdGFtcEZvcm1hdCkgKyAiXHgxQlswbSIpOwogICAgICAgIGVsc2UgaWYgKG9wdGlvbnMudGltZXN0YW1wICE9PSAwIC8qIE5vbmUgKi8pCiAgICAgICAgICB3cml0ZVRleHQoIlx4MUJbLTc7LThtIiArIG5ldyBEYXRlKGZsdXNoQnVmZmVyLnRpbWVzdGFtcCkudG9JU09TdHJpbmcoKSArICJceDFCWzBtIik7CiAgICAgICAgd3JpdGVSYXcoZmx1c2hCdWZmZXIucmF3ICsgbmwpOwogICAgICB9CiAgICB9CiAgICBsb2dnaW5nID0gbDsKICAgIGNvbm5lY3RlZCA9IGM7CiAgICBjdXJyZW50RmlsZSA9IGY7CiAgICBmbHVzaEJ1ZmZlciA9IG51bGw7CiAgfQogIGZ1bmN0aW9uIHN0YXJ0KGxpbmVzLCBmcmFnbWVudCkgewogICAgaWYgKCFvcHRpb25zLmVuYWJsZWQpIHsKICAgICAgaWYgKGxvZ2dpbmcpCiAgICAgICAgc3RvcCgpOwogICAgICByZXR1cm47CiAgICB9CiAgICBsb2dnaW5nID0gdHJ1ZTsKICAgIGlmIChvcHRpb25zLnVuaXF1ZSB8fCB0aW1lU3RhbXAgPT09IDApIHsKICAgICAgdGltZVN0YW1wID0gKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7CiAgICAgIGZUaW1lU3RhbXAgPSBuZXcgbW9tZW50KHRpbWVTdGFtcCkuZm9ybWF0KG9wdGlvbnMuZm9ybWF0IHx8ICJZWVlZTU1ERC1ISG1tc3MiKTsKICAgICAgZmx1c2godHJ1ZSk7CiAgICB9CiAgICBidWlsZEZpbGVuYW1lKCk7CiAgICBpZiAob3B0aW9ucy5wcmVwZW5kICYmIGxpbmVzICYmIGxpbmVzLmxlbmd0aCA+IDApIHsKICAgICAgaWYgKChvcHRpb25zLndoYXQgJiAxIC8qIEh0bWwgKi8pID09PSAxIC8qIEh0bWwgKi8pCiAgICAgICAgd3JpdGVIdG1sKGNyZWF0ZUxpbmVzKGxpbmVzIHx8IFtdKSk7CiAgICAgIGlmICgob3B0aW9ucy53aGF0ICYgMiAvKiBUZXh0ICovKSA9PT0gMiAvKiBUZXh0ICovIHx8IG9wdGlvbnMud2hhdCA9PT0gMCAvKiBOb25lICovKSB7CiAgICAgICAgaWYgKG9wdGlvbnMudGltZXN0YW1wID09PSAyIC8qIEZvcm1hdCAqLykKICAgICAgICAgIHdyaXRlVGV4dChsaW5lcy5tYXAoKGwpID0+IG1vbWVudChsLnRpbWVzdGFtcCkuZm9ybWF0KG9wdGlvbnMudGltZXN0YW1wRm9ybWF0KSArIGwudGV4dCkuam9pbigiXG4iKSArIChmcmFnbWVudCB8fCBsaW5lcy5sZW5ndGggPT09IDAgPyAiIiA6ICJcbiIpKTsKICAgICAgICBlbHNlIGlmIChvcHRpb25zLnRpbWVzdGFtcCAhPT0gMCAvKiBOb25lICovKQogICAgICAgICAgd3JpdGVUZXh0KGxpbmVzLm1hcCgobCkgPT4gbmV3IERhdGUobC50aW1lc3RhbXApLnRvSVNPU3RyaW5nKCkgKyBsLnRleHQpLmpvaW4oIlxuIikgKyAoZnJhZ21lbnQgfHwgbGluZXMubGVuZ3RoID09PSAwID8gIiIgOiAiXG4iKSk7CiAgICAgICAgZWxzZQogICAgICAgICAgd3JpdGVUZXh0KGxpbmVzLm1hcCgobCkgPT4gbC50ZXh0KS5qb2luKCJcbiIpICsgKGZyYWdtZW50IHx8IGxpbmVzLmxlbmd0aCA9PT0gMCA/ICIiIDogIlxuIikpOwogICAgICB9CiAgICAgIGlmICgob3B0aW9ucy53aGF0ICYgNCAvKiBSYXcgKi8pID09PSA0IC8qIFJhdyAqLykgewogICAgICAgIGlmIChvcHRpb25zLnRpbWVzdGFtcCA9PT0gMiAvKiBGb3JtYXQgKi8pCiAgICAgICAgICB3cml0ZVRleHQobGluZXMubWFwKChsKSA9PiAiXHgxQlstNzstOG0iICsgbW9tZW50KGwudGltZXN0YW1wKS5mb3JtYXQob3B0aW9ucy50aW1lc3RhbXBGb3JtYXQpICsgIlx4MUJbMG0iICsgbC5yYXcpLmpvaW4oIiIpKTsKICAgICAgICBlbHNlIGlmIChvcHRpb25zLnRpbWVzdGFtcCAhPT0gMCAvKiBOb25lICovKQogICAgICAgICAgd3JpdGVUZXh0KGxpbmVzLm1hcCgobCkgPT4gIlx4MUJbLTc7LThtIiArIG5ldyBEYXRlKGwudGltZXN0YW1wKS50b0lTT1N0cmluZygpICsgIlx4MUJbMG0iICsgbC5yYXcpLmpvaW4oIiIpKTsKICAgICAgICBlbHNlCiAgICAgICAgICB3cml0ZVJhdyhsaW5lcy5tYXAoKGwpID0+IGwucmF3KS5qb2luKCIiKSk7CiAgICAgIH0KICAgIH0KICAgIHBvc3RNZXNzYWdlKHsgZXZlbnQ6ICJzdGFydGVkIiwgYXJnczogbG9nZ2luZyB9KTsKICB9CiAgZnVuY3Rpb24gc3RvcCgpIHsKICAgIGxvZ2dpbmcgPSBmYWxzZTsKICAgIHBvc3RNZXNzYWdlKHsgZXZlbnQ6ICJzdG9wcGVkIiwgYXJnczogbG9nZ2luZyB9KTsKICB9CiAgZnVuY3Rpb24gdG9nZ2xlKCkgewogICAgb3B0aW9ucy5lbmFibGVkID0gIW9wdGlvbnMuZW5hYmxlZDsKICAgIHBvc3RNZXNzYWdlKHsgZXZlbnQ6ICJ0b2dnbGVkIiwgYXJnczogb3B0aW9ucy5lbmFibGVkIH0pOwogICAgY29uc3QgYyA9IG9wdGlvbnMudW5pcXVlOwogICAgb3B0aW9ucy51bmlxdWUgPSBmYWxzZTsKICAgIGlmIChvcHRpb25zLmVuYWJsZWQgJiYgIWxvZ2dpbmcpCiAgICAgIHBvc3RNZXNzYWdlKHsgZXZlbnQ6ICJzdGFydEludGVybmFsIiB9KTsKICAgIGVsc2UgaWYgKCFvcHRpb25zLmVuYWJsZWQgJiYgbG9nZ2luZykKICAgICAgc3RvcCgpOwogICAgb3B0aW9ucy51bmlxdWUgPSBjOwogIH0KICBmdW5jdGlvbiBjcmVhdGVMaW5lcyhsaW5lcykgewogICAgY29uc3QgdGV4dCA9IFtdOwogICAgY29uc3QgbGwgPSBsaW5lcy5sZW5ndGg7CiAgICBmb3IgKGxldCBsID0gMDsgbCA8IGxsOyBsKyspCiAgICAgIHRleHQucHVzaChjcmVhdGVMaW5lKGxpbmVzW2xdKSk7CiAgICByZXR1cm4gdGV4dC5qb2luKCIiKTsKICB9CiAgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHN0cikgewogICAgaWYgKCFzdHIgfHwgc3RyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7CiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1ssXS9nLCAiLSIpLnJlcGxhY2UoL1tcKFwpXHM7XS9nLCAiIik7CiAgfQogIGZ1bmN0aW9uIGNyZWF0ZUxpbmUobGluZSkgewogICAgY29uc3QgcGFydHMgPSBbXTsKICAgIGxldCBvZmZzZXQgPSAwOwogICAgbGV0IGZDbHM7CiAgICBjb25zdCB0ZXh0ID0gbGluZS50ZXh0OwogICAgY29uc3QgZm9ybWF0cyA9IGxpbmUuZm9ybWF0czsKICAgIGNvbnN0IGZMZW4gPSBmb3JtYXRzLmxlbmd0aDsKICAgIGxldCByaWdodCA9IGZhbHNlOwogICAgY29uc3Qgc3R5bGVzID0gW107CiAgICBpZiAob3B0aW9ucy50aW1lc3RhbXAgIT09IDAgLyogTm9uZSAqLykgewogICAgICBmQ2xzID0gW107CiAgICAgIGxldCBjb2xvciA9IEdldENvbG9yKC04KTsKICAgICAgaWYgKGJhY2tncm91bmRzW2dldENsYXNzTmFtZShjb2xvcildKQogICAgICAgIGZDbHMucHVzaCgiIGIiLCBiYWNrZ3JvdW5kc1tnZXRDbGFzc05hbWUoY29sb3IpXSk7CiAgICAgIGVsc2UgewogICAgICAgIGJhY2tncm91bmRzW2dldENsYXNzTmFtZShjb2xvcildID0gYmFja2dyb3VuZHNDbnQ7CiAgICAgICAgZkNscy5wdXNoKCIgYiIsIGJhY2tncm91bmRzQ250KTsKICAgICAgICBzdHlsZXMucHVzaChgLmIke2JhY2tncm91bmRzQ250fSB7IGJhY2tncm91bmQtY29sb3I6ICR7Y29sb3J9OyB9YCk7CiAgICAgICAgYmFja2dyb3VuZHNDbnQrKzsKICAgICAgfQogICAgICBjb2xvciA9IEdldENvbG9yKC03KTsKICAgICAgaWYgKGNvbG9yc1tnZXRDbGFzc05hbWUoY29sb3IpXSkKICAgICAgICBmQ2xzLnB1c2goIiBjIiwgY29sb3JzW2dldENsYXNzTmFtZShjb2xvcildKTsKICAgICAgZWxzZSB7CiAgICAgICAgY29sb3JzW2dldENsYXNzTmFtZShjb2xvcildID0gY29sb3JzQ250OwogICAgICAgIGZDbHMucHVzaCgiIGMiLCBjb2xvcnNDbnQpOwogICAgICAgIHN0eWxlcy5wdXNoKGAuYyR7Y29sb3JzQ250fSB7IGNvbG9yOiAke2NvbG9yfTsgfWApOwogICAgICAgIGNvbG9yc0NudCsrOwogICAgICB9CiAgICB9CiAgICBpZiAob3B0aW9ucy50aW1lc3RhbXAgPT09IDIgLyogRm9ybWF0ICovICYmIG1vbWVudCkKICAgICAgcGFydHMucHVzaCgnPHNwYW4gY2xhc3M9InRpbWVzdGFtcCcsIC4uLmZDbHMsICciJywgLi4uZkNscywgIj4iLCBtb21lbnQobGluZS50aW1lc3RhbXApLmZvcm1hdChvcHRpb25zLnRpbWVzdGFtcEZvcm1hdCksICI8L3NwYW4+Iik7CiAgICBlbHNlIGlmIChvcHRpb25zLnRpbWVzdGFtcCAhPT0gMCAvKiBOb25lICovKSB7CiAgICAgIHBhcnRzLnB1c2goJzxzcGFuIGNsYXNzPSJ0aW1lc3RhbXAnLCAuLi5mQ2xzLCAnIicsIC4uLmZDbHMsICI+IiwgbmV3IERhdGUobGluZS50aW1lc3RhbXApLnRvSVNPU3RyaW5nKCksICIgPC9zcGFuPiIpOwogICAgfQogICAgZkNscyA9IG51bGw7CiAgICBmb3IgKGxldCBmID0gMDsgZiA8IGZMZW47IGYrKykgewogICAgICBjb25zdCBmb3JtYXQgPSBmb3JtYXRzW2ZdOwogICAgICBsZXQgbkZvcm1hdDsKICAgICAgbGV0IGVuZDsKICAgICAgbGV0IGNvbG9yOwogICAgICBpZiAoZiA8IGZMZW4gLSAxKSB7CiAgICAgICAgbkZvcm1hdCA9IGZvcm1hdHNbZiArIDFdOwogICAgICAgIGlmIChmb3JtYXQub2Zmc2V0ID09PSBuRm9ybWF0Lm9mZnNldCAmJiBuRm9ybWF0LmZvcm1hdFR5cGUgPT09IGZvcm1hdC5mb3JtYXRUeXBlKQogICAgICAgICAgY29udGludWU7CiAgICAgICAgZW5kID0gbkZvcm1hdC5vZmZzZXQ7CiAgICAgIH0gZWxzZQogICAgICAgIGVuZCA9IHRleHQubGVuZ3RoOwogICAgICBvZmZzZXQgPSBmb3JtYXQub2Zmc2V0OwogICAgICBpZiAoZm9ybWF0LmZvcm1hdFR5cGUgPT09IDAgLyogTm9ybWFsICovKSB7CiAgICAgICAgZkNscyA9IFtdOwogICAgICAgIGNvbG9yID0gZm9ybWF0LmJhY2tncm91bmQ7CiAgICAgICAgaWYgKHR5cGVvZiBjb2xvciA9PT0gIm51bWJlciIpCiAgICAgICAgICBjb2xvciA9IEdldENvbG9yKGNvbG9yKTsKICAgICAgICBpZiAoYmFja2dyb3VuZHNbZ2V0Q2xhc3NOYW1lKGNvbG9yKV0pCiAgICAgICAgICBmQ2xzLnB1c2goIiBiIiwgYmFja2dyb3VuZHNbZ2V0Q2xhc3NOYW1lKGNvbG9yKV0pOwogICAgICAgIGVsc2UgaWYgKGNvbG9yKSB7CiAgICAgICAgICBiYWNrZ3JvdW5kc1tnZXRDbGFzc05hbWUoY29sb3IpXSA9IGJhY2tncm91bmRzQ250OwogICAgICAgICAgZkNscy5wdXNoKCIgYiIsIGJhY2tncm91bmRzQ250KTsKICAgICAgICAgIHN0eWxlcy5wdXNoKGAuYiR7YmFja2dyb3VuZHNDbnR9IHsgYmFja2dyb3VuZC1jb2xvcjogJHtjb2xvcn07IH1gKTsKICAgICAgICAgIGJhY2tncm91bmRzQ250Kys7CiAgICAgICAgfQogICAgICAgIGNvbG9yID0gZm9ybWF0LmNvbG9yOwogICAgICAgIGlmICh0eXBlb2YgY29sb3IgPT09ICJudW1iZXIiKQogICAgICAgICAgY29sb3IgPSBHZXRDb2xvcihjb2xvcik7CiAgICAgICAgaWYgKGNvbG9yc1tnZXRDbGFzc05hbWUoY29sb3IpXSkKICAgICAgICAgIGZDbHMucHVzaCgiIGMiLCBjb2xvcnNbZ2V0Q2xhc3NOYW1lKGNvbG9yKV0pOwogICAgICAgIGVsc2UgaWYgKGNvbG9yKSB7CiAgICAgICAgICBjb2xvcnNbZ2V0Q2xhc3NOYW1lKGNvbG9yKV0gPSBjb2xvcnNDbnQ7CiAgICAgICAgICBmQ2xzLnB1c2goIiBjIiwgY29sb3JzQ250KTsKICAgICAgICAgIHN0eWxlcy5wdXNoKGAuYyR7Y29sb3JzQ250fSB7IGNvbG9yOiAke2NvbG9yfTsgfWApOwogICAgICAgICAgY29sb3JzQ250Kys7CiAgICAgICAgfQogICAgICAgIGlmIChjb2xvcnNbZ2V0Q2xhc3NOYW1lKGZvcm1hdC5mb250KV0pCiAgICAgICAgICBmQ2xzLnB1c2goIiBmIiwgY29sb3JzW2dldENsYXNzTmFtZShmb3JtYXQuZm9udCldKTsKICAgICAgICBlbHNlIGlmIChmb3JtYXQuZm9udCkgewogICAgICAgICAgY29sb3JzW2dldENsYXNzTmFtZShmb3JtYXQuZm9udCldID0gY29sb3JzQ250OwogICAgICAgICAgZkNscy5wdXNoKCIgZiIsIGNvbG9yc0NudCk7CiAgICAgICAgICBzdHlsZXMucHVzaChgLmYke2NvbG9yc0NudH0geyBmb250LWZhbWlseTogJHtmb3JtYXQuZm9udH07IH1gKTsKICAgICAgICAgIGNvbG9yc0NudCsrOwogICAgICAgIH0KICAgICAgICBpZiAoY29sb3JzW2dldENsYXNzTmFtZShmb3JtYXQuc2l6ZSldKQogICAgICAgICAgZkNscy5wdXNoKCIgZiIsIGNvbG9yc1tnZXRDbGFzc05hbWUoZm9ybWF0LnNpemUpXSk7CiAgICAgICAgZWxzZSBpZiAoZm9ybWF0LnNpemUpIHsKICAgICAgICAgIGNvbG9yc1tnZXRDbGFzc05hbWUoZm9ybWF0LnNpemUpXSA9IGNvbG9yc0NudDsKICAgICAgICAgIGZDbHMucHVzaCgiIGYiLCBjb2xvcnNDbnQpOwogICAgICAgICAgc3R5bGVzLnB1c2goYC5mJHtjb2xvcnNDbnR9IHsgZm9udC1zaXplOiAke2Zvcm1hdC5zaXplfTsgfWApOwogICAgICAgICAgY29sb3JzQ250Kys7CiAgICAgICAgfQogICAgICAgIGlmIChmb3JtYXQuc3R5bGUgIT09IDAgLyogTm9uZSAqLykgewogICAgICAgICAgaWYgKChmb3JtYXQuc3R5bGUgJiAxIC8qIEJvbGQgKi8pID09PSAxIC8qIEJvbGQgKi8pCiAgICAgICAgICAgIGZDbHMucHVzaCgiIGIiKTsKICAgICAgICAgIGlmICgoZm9ybWF0LnN0eWxlICYgNCAvKiBJdGFsaWMgKi8pID09PSA0IC8qIEl0YWxpYyAqLykKICAgICAgICAgICAgZkNscy5wdXNoKCIgaSIpOwogICAgICAgICAgaWYgKChmb3JtYXQuc3R5bGUgJiAxMDI0IC8qIE92ZXJsaW5lICovKSA9PT0gMTAyNCAvKiBPdmVybGluZSAqLykKICAgICAgICAgICAgZkNscy5wdXNoKCIgbyIpOwogICAgICAgICAgaWYgKChmb3JtYXQuc3R5bGUgJiA1MTIgLyogRG91YmxlVW5kZXJsaW5lICovKSA9PT0gNTEyIC8qIERvdWJsZVVuZGVybGluZSAqLyB8fCAoZm9ybWF0LnN0eWxlICYgOCAvKiBVbmRlcmxpbmUgKi8pID09PSA4IC8qIFVuZGVybGluZSAqLykKICAgICAgICAgICAgZkNscy5wdXNoKCIgdSIpOwogICAgICAgICAgaWYgKChmb3JtYXQuc3R5bGUgJiA1MTIgLyogRG91YmxlVW5kZXJsaW5lICovKSA9PT0gNTEyIC8qIERvdWJsZVVuZGVybGluZSAqLykKICAgICAgICAgICAgY29sb3IgPSBmb3JtYXQuY29sb3I7CiAgICAgICAgICBlbHNlCiAgICAgICAgICAgIGNvbG9yID0gZm9ybWF0LmJhY2tncm91bmQ7CiAgICAgICAgICBpZiAodHlwZW9mIGNvbG9yID09PSAibnVtYmVyIikKICAgICAgICAgICAgY29sb3IgPSBHZXRDb2xvcihjb2xvcik7CiAgICAgICAgICBpZiAoY29sb3JzWyJiYiIgKyBnZXRDbGFzc05hbWUoY29sb3IpXSkKICAgICAgICAgICAgZkNscy5wdXNoKCIgYmIiLCBjb2xvcnNbImJiIiArIGdldENsYXNzTmFtZShjb2xvcildKTsKICAgICAgICAgIGVsc2UgaWYgKGNvbG9yKSB7CiAgICAgICAgICAgIGNvbG9yc1siYmIiICsgZ2V0Q2xhc3NOYW1lKGNvbG9yKV0gPSBjb2xvcnNDbnQ7CiAgICAgICAgICAgIGZDbHMucHVzaCgiIGJiIiwgY29sb3JzQ250KTsKICAgICAgICAgICAgc3R5bGVzLnB1c2goYC5iYiR7Y29sb3JzQ250fSB7IGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAke2NvbG9yfTsgfWApOwogICAgICAgICAgICBjb2xvcnNDbnQrKzsKICAgICAgICAgIH0KICAgICAgICAgIGlmICgoZm9ybWF0LnN0eWxlICYgMzIgLyogUmFwaWQgKi8pID09PSAzMiAvKiBSYXBpZCAqLyB8fCAoZm9ybWF0LnN0eWxlICYgMTYgLyogU2xvdyAqLykgPT09IDE2IC8qIFNsb3cgKi8pIHsKICAgICAgICAgICAgaWYgKHRoaXMuZW5hYmxlRmxhc2hpbmcpCiAgICAgICAgICAgICAgZkNscy5wdXNoKCIgYW5zaS1ibGluayIpOwogICAgICAgICAgICBlbHNlIGlmICgoZm9ybWF0LnN0eWxlICYgNTEyIC8qIERvdWJsZVVuZGVybGluZSAqLykgIT09IDUxMiAvKiBEb3VibGVVbmRlcmxpbmUgKi8gJiYgKGZvcm1hdC5zdHlsZSAmIDggLyogVW5kZXJsaW5lICovKSAhPT0gOCAvKiBVbmRlcmxpbmUgKi8pCiAgICAgICAgICAgICAgZkNscy5wdXNoKCIgdSIpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKChmb3JtYXQuc3R5bGUgJiAyNTYgLyogU3RyaWtlb3V0ICovKSA9PT0gMjU2IC8qIFN0cmlrZW91dCAqLykKICAgICAgICAgICAgZkNscy5wdXNoKCIgcyIpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBjb2xvciA9IGZvcm1hdC5iYWNrZ3JvdW5kOwogICAgICAgICAgaWYgKHR5cGVvZiBjb2xvciA9PT0gIm51bWJlciIpCiAgICAgICAgICAgIGNvbG9yID0gR2V0Q29sb3IoY29sb3IpOwogICAgICAgICAgaWYgKGNvbG9yc1siYmIiICsgZ2V0Q2xhc3NOYW1lKGNvbG9yKV0pCiAgICAgICAgICAgIGZDbHMucHVzaCgiIGJiIiwgY29sb3JzWyJiYiIgKyBnZXRDbGFzc05hbWUoY29sb3IpXSk7CiAgICAgICAgICBlbHNlIGlmIChjb2xvcikgewogICAgICAgICAgICBjb2xvcnNbImJiIiArIGdldENsYXNzTmFtZShjb2xvcildID0gY29sb3JzQ250OwogICAgICAgICAgICBmQ2xzLnB1c2goIiBiYiIsIGNvbG9yc0NudCk7CiAgICAgICAgICAgIHN0eWxlcy5wdXNoKGAuYmIke2NvbG9yc0NudH0geyBib3JkZXItYm90dG9tOiAxcHggc29saWQgJHtjb2xvcn07IH1gKTsKICAgICAgICAgICAgY29sb3JzQ250Kys7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChmQ2xzLmxlbmd0aCAhPT0gMCkKICAgICAgICAgIGZDbHMgPSAnIGNsYXNzPSInICsgZkNscy5qb2luKCIiKS50cmltKCkgKyAnIic7CiAgICAgICAgZWxzZQogICAgICAgICAgZkNscyA9ICIiOwogICAgICAgIGlmIChmb3JtYXQuaHIpCiAgICAgICAgICBwYXJ0cy5wdXNoKCc8c3BhbiBzdHlsZT0ibWluLXdpZHRoOjEwMCU7d2lkdGg6MTAwJTsiJywgZkNscywgJz48ZGl2IHN0eWxlPSJwb3NpdGlvbjpyZWxhdGl2ZTt0b3A6IDUwJTt0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTUwJSk7aGVpZ2h0OjRweDt3aWR0aDoxMDAlOyBiYWNrZ3JvdW5kLWNvbG9yOicsIHR5cGVvZiBmb3JtYXQuY29sb3IgPT09ICJudW1iZXIiID8gR2V0Q29sb3IoZm9ybWF0LmNvbG9yKSA6IGZvcm1hdC5jb2xvciwgJyI+PC9kaXY+PC9zcGFuPicpOwogICAgICAgIGVsc2UgaWYgKGVuZCAtIG9mZnNldCAhPT0gMCkKICAgICAgICAgIHBhcnRzLnB1c2goIjxzcGFuIiwgLi4uZkNscywgIj4iLCBodG1sRW5jb2RlKHRleHQuc3Vic3RyaW5nKG9mZnNldCwgZW5kKSksICI8L3NwYW4+Iik7CiAgICAgIH0gZWxzZSBpZiAoZm9ybWF0LmZvcm1hdFR5cGUgPT09IDEgLyogTGluayAqLykgewogICAgICAgIHBhcnRzLnB1c2goJzxhIGRyYWdnYWJsZT0iZmFsc2UiIGNsYXNzPSJVUkxMaW5rIiBocmVmPSJqYXZhc2NyaXB0OnZvaWQoMCk7IiB0aXRsZT0iJyk7CiAgICAgICAgcGFydHMucHVzaChmb3JtYXQuaHJlZi5yZXBsYWNlKC8iL2csICImcXVvdDsiKSk7CiAgICAgICAgcGFydHMucHVzaCgnIiBvbmNsaWNrPSInLCB0aGlzLmxpbmtGdW5jdGlvbiwgIignIiwgZm9ybWF0LmhyZWYucmVwbGFjZSgvXFwvZywgIlxcXFwiKS5yZXBsYWNlKC8iL2csICImcXVvdDsiKSwgYCcpO3JldHVybiBmYWxzZTsiPmApOwogICAgICAgIGlmIChlbmQgLSBvZmZzZXQgPT09IDApIGNvbnRpbnVlOwogICAgICAgIHBhcnRzLnB1c2goIjxzcGFuIiwgLi4uZkNscywgIj4iKTsKICAgICAgICBwYXJ0cy5wdXNoKGh0bWxFbmNvZGUodGV4dC5zdWJzdHJpbmcob2Zmc2V0LCBlbmQpKSk7CiAgICAgICAgcGFydHMucHVzaCgiPC9zcGFuPiIpOwogICAgICB9IGVsc2UgaWYgKGZvcm1hdC5mb3JtYXRUeXBlID09PSAyIC8qIExpbmtFbmQgKi8gfHwgZm9ybWF0LmZvcm1hdFR5cGUgPT09IDQgLyogTVhQTGlua0VuZCAqLyB8fCBmb3JtYXQuZm9ybWF0VHlwZSA9PT0gOCAvKiBNWFBTZW5kRW5kICovKSB7CiAgICAgICAgcGFydHMucHVzaCgiPC9hPiIpOwogICAgICB9IGVsc2UgaWYgKGZvcm1hdC5mb3JtYXRUeXBlID09PSAzIC8qIE1YUExpbmsgKi8pIHsKICAgICAgICBwYXJ0cy5wdXNoKCc8YSBkcmFnZ2FibGU9ImZhbHNlIiBjbGFzcz0iTVhQTGluayIgaHJlZj0iamF2YXNjcmlwdDp2b2lkKDApOyIgdGl0bGU9IicpOwogICAgICAgIHBhcnRzLnB1c2goZm9ybWF0LmhyZWYucmVwbGFjZSgvIi9nLCAiJnF1b3Q7IikpOwogICAgICAgIHBhcnRzLnB1c2goJyInKTsKICAgICAgICBpZiAoZm9ybWF0LmV4cGlyZSAmJiBmb3JtYXQuZXhwaXJlLmxlbmd0aCkKICAgICAgICAgIHBhcnRzLnB1c2goYCBkYXRhLWV4cGlyZT0iJHtmb3JtYXQuZXhwaXJlfSJgKTsKICAgICAgICBwYXJ0cy5wdXNoKCcgb25jbGljaz0iJywgdGhpcy5teHBMaW5rRnVuY3Rpb24sICIodGhpcywgJyIsIGZvcm1hdC5ocmVmLnJlcGxhY2UoL1xcL2csICJcXFxcIikucmVwbGFjZSgvIi9nLCAiJnF1b3Q7IiksIGAnKTtyZXR1cm4gZmFsc2U7Ij5gKTsKICAgICAgICBpZiAoZW5kIC0gb2Zmc2V0ID09PSAwKSBjb250aW51ZTsKICAgICAgICBwYXJ0cy5wdXNoKCI8c3BhbiIsIC4uLmZDbHMsICI+Iik7CiAgICAgICAgcGFydHMucHVzaChodG1sRW5jb2RlKHRleHQuc3Vic3RyaW5nKG9mZnNldCwgZW5kKSkpOwogICAgICAgIHBhcnRzLnB1c2goIjwvc3Bhbj4iKTsKICAgICAgfSBlbHNlIGlmIChmb3JtYXQuZm9ybWF0VHlwZSA9PT0gNyAvKiBNWFBTZW5kICovKSB7CiAgICAgICAgcGFydHMucHVzaCgnPGEgZHJhZ2dhYmxlPSJmYWxzZSIgY2xhc3M9Ik1YUExpbmsiIGhyZWY9ImphdmFzY3JpcHQ6dm9pZCgwKTsiIHRpdGxlPSInKTsKICAgICAgICBwYXJ0cy5wdXNoKGZvcm1hdC5oaW50LnJlcGxhY2UoLyIvZywgIiZxdW90OyIpKTsKICAgICAgICBwYXJ0cy5wdXNoKCciJyk7CiAgICAgICAgaWYgKGZvcm1hdC5leHBpcmUgJiYgZm9ybWF0LmV4cGlyZS5sZW5ndGgpCiAgICAgICAgICBwYXJ0cy5wdXNoKGAgZGF0YS1leHBpcmU9IiR7Zm9ybWF0LmV4cGlyZX0iYCk7CiAgICAgICAgcGFydHMucHVzaCgnIG9ubW91c2VvdmVyPSInLCB0aGlzLm14cFRvb2x0aXBGdW5jdGlvbiwgJyh0aGlzKTsiJyk7CiAgICAgICAgcGFydHMucHVzaCgnIG9uY2xpY2s9IicsIHRoaXMubXhwU2VuZEZ1bmN0aW9uLCAiKGV2ZW50fHx3aW5kb3cuZXZlbnQsIHRoaXMsICIsIGZvcm1hdC5ocmVmLnJlcGxhY2UoL1xcL2csICJcXFxcIikucmVwbGFjZSgvIi9nLCAiJnF1b3Q7IiksICIsICIsIGZvcm1hdC5wcm9tcHQgPyAiMSIgOiAiMCIsICIsICIsIGZvcm1hdC50dC5yZXBsYWNlKC9cXC9nLCAiXFxcXCIpLnJlcGxhY2UoLyIvZywgIiZxdW90OyIpLCAnKTtyZXR1cm4gZmFsc2U7Ij4nKTsKICAgICAgICBpZiAoZW5kIC0gb2Zmc2V0ID09PSAwKSBjb250aW51ZTsKICAgICAgICBwYXJ0cy5wdXNoKCI8c3BhbiIsIC4uLmZDbHMsICI+Iik7CiAgICAgICAgcGFydHMucHVzaChodG1sRW5jb2RlKHRleHQuc3Vic3RyaW5nKG9mZnNldCwgZW5kKSkpOwogICAgICAgIHBhcnRzLnB1c2goIjwvc3Bhbj4iKTsKICAgICAgfSBlbHNlIGlmIChmb3JtYXQuZm9ybWF0VHlwZSA9PT0gOSAvKiBNWFBFeHBpcmVkICovICYmIGVuZCAtIG9mZnNldCAhPT0gMCkgewogICAgICAgIHBhcnRzLnB1c2goIjxzcGFuIiwgLi4uZkNscywgIj4iKTsKICAgICAgICBwYXJ0cy5wdXNoKGh0bWxFbmNvZGUodGV4dC5zdWJzdHJpbmcob2Zmc2V0LCBlbmQpKSk7CiAgICAgICAgcGFydHMucHVzaCgiPC9zcGFuPiIpOwogICAgICB9IGVsc2UgaWYgKGZvcm1hdC5mb3JtYXRUeXBlID09PSA1IC8qIEltYWdlICovKSB7CiAgICAgICAgbGV0IHRtcCA9ICIiOwogICAgICAgIHBhcnRzLnB1c2goJzxpbWcgc3JjPSInKTsKICAgICAgICBpZiAoZm9ybWF0LnVybC5sZW5ndGggPiAwKSB7CiAgICAgICAgICBwYXJ0cy5wdXNoKGZvcm1hdC51cmwpOwogICAgICAgICAgdG1wICs9IGZvcm1hdC51cmw7CiAgICAgICAgICBpZiAoIWZvcm1hdC51cmwuZW5kc1dpdGgoIi8iKSkgewogICAgICAgICAgICBwYXJ0cy5wdXNoKCIvIik7CiAgICAgICAgICAgIHRtcCArPSAiLyI7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChmb3JtYXQudC5sZW5ndGggPiAwKSB7CiAgICAgICAgICBwYXJ0cy5wdXNoKGZvcm1hdC50KTsKICAgICAgICAgIHRtcCArPSBmb3JtYXQudDsKICAgICAgICAgIGlmICghZm9ybWF0LnQuZW5kc1dpdGgoIi8iKSkgewogICAgICAgICAgICBwYXJ0cy5wdXNoKCIvIik7CiAgICAgICAgICAgIHRtcCArPSAiLyI7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHRtcCArPSBmb3JtYXQubmFtZTsKICAgICAgICBwYXJ0cy5wdXNoKGZvcm1hdC5uYW1lLCAnIiAgc3R5bGU9IicpOwogICAgICAgIGlmIChmb3JtYXQudy5sZW5ndGggPiAwKQogICAgICAgICAgcGFydHMucHVzaCgid2lkdGg6IiwgZm9ybWF0VW5pdChmb3JtYXQudyksICI7Iik7CiAgICAgICAgaWYgKGZvcm1hdC5oLmxlbmd0aCA+IDApCiAgICAgICAgICBwYXJ0cy5wdXNoKCJoZWlnaHQ6IiwgZm9ybWF0VW5pdChmb3JtYXQuaCksICI7Iik7CiAgICAgICAgc3dpdGNoIChmb3JtYXQuYWxpZ24udG9Mb3dlckNhc2UoKSkgewogICAgICAgICAgY2FzZSAibGVmdCI6CiAgICAgICAgICAgIHBhcnRzLnB1c2goImZsb2F0OmxlZnQ7Iik7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgY2FzZSAicmlnaHQiOgogICAgICAgICAgICBwYXJ0cy5wdXNoKCJmbG9hdDpyaWdodDsiKTsKICAgICAgICAgICAgcmlnaHQgPSB0cnVlOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIGNhc2UgInRvcCI6CiAgICAgICAgICBjYXNlICJtaWRkbGUiOgogICAgICAgICAgY2FzZSAiYm90dG9tIjoKICAgICAgICAgICAgcGFydHMucHVzaCgidmVydGljYWwtYWxpZ246IiwgZm9ybWF0LmFsaWduLCAiOyIpOwogICAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgICAgaWYgKGZvcm1hdC5oc3BhY2UubGVuZ3RoID4gMCAmJiBmb3JtYXQudnNwYWNlLmxlbmd0aCA+IDApIHsKICAgICAgICAgIHBhcnRzLnB1c2goIm1hcmdpbjoiKTsKICAgICAgICAgIHBhcnRzLnB1c2goZm9ybWF0VW5pdChmb3JtYXQudnNwYWNlKSwgIiAiKTsKICAgICAgICAgIHBhcnRzLnB1c2goZm9ybWF0VW5pdChmb3JtYXQuaHNwYWNlKSwgIjsiKTsKICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdC5oc3BhY2UubGVuZ3RoID4gMCkgewogICAgICAgICAgcGFydHMucHVzaCgibWFyZ2luOiIpOwogICAgICAgICAgcGFydHMucHVzaCgiMHB4ICIsIGZvcm1hdFVuaXQoZm9ybWF0LmhzcGFjZSksICI7Iik7CiAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQudnNwYWNlLmxlbmd0aCA+IDApIHsKICAgICAgICAgIHBhcnRzLnB1c2goIm1hcmdpbjoiKTsKICAgICAgICAgIHBhcnRzLnB1c2goZm9ybWF0VW5pdChmb3JtYXQudnNwYWNlKSwgIiAwcHg7Iik7CiAgICAgICAgfQogICAgICAgIHBhcnRzLnB1c2goJyInKTsKICAgICAgICBpZiAoZm9ybWF0LmlzbWFwKSBwYXJ0cy5wdXNoKCcgaXNtYXAgb25jbGljaz0icmV0dXJuIGZhbHNlOyInKTsKICAgICAgICBwYXJ0cy5wdXNoKGBzcmM9IiR7dG1wfSIvPmApOwogICAgICB9CiAgICB9CiAgICBpZiAoc3R5bGVzLmxlbmd0aCkKICAgICAgcGFydHMucHVzaCgiPHN0eWxlPiIsIC4uLnN0eWxlcywgIjwvc3R5bGU+Iik7CiAgICBpZiAocmlnaHQpCiAgICAgIHJldHVybiBgPHNwYW4gY2xhc3M9ImxpbmUiIHN0eWxlPSJtaW4td2lkdGg6MTAwJSI+JHtwYXJ0cy5qb2luKCIiKX08YnI+PC9zcGFuPmA7CiAgICByZXR1cm4gYDxzcGFuIGNsYXNzPSJsaW5lIj4ke3BhcnRzLmpvaW4oIiIpfTxicj48L3NwYW4+YDsKICB9CiAgZnVuY3Rpb24gaHRtbEVuY29kZSh0ZXh0KSB7CiAgICBpZiAoIXRleHQgfHwgdGV4dC5sZW5ndGggPT09IDApCiAgICAgIHJldHVybjsKICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoLyYvZywgIiZhbXA7IikucmVwbGFjZSgvIi9nLCAiJnF1b3Q7IikucmVwbGFjZSgvJy9nLCAiJiMzOTsiKS5yZXBsYWNlKC88L2csICImbHQ7IikucmVwbGFjZSgvPi9nLCAiJmd0OyIpOwogIH0KICBmdW5jdGlvbiBmb3JtYXRVbml0KHN0cikgewogICAgaWYgKCFzdHIpIHJldHVybiBzdHI7CiAgICBpZiAoL15cZCtjJC8udGVzdChzdHIpKQogICAgICByZXR1cm4gc3RyICsgImgiOwogICAgaWYgKC9eXGQrJC8udGVzdChzdHIpKQogICAgICByZXR1cm4gcGFyc2VJbnQoc3RyLCAxMCkgKyAicHgiOwogICAgcmV0dXJuIHN0cjsKICB9CiAgZnVuY3Rpb24gYnVpbGRDb2xvclRhYmxlKCkgewogICAgY29uc3QgX0NvbG9yVGFibGUgPSBbXTsKICAgIGxldCByOwogICAgbGV0IGc7CiAgICBsZXQgYjsKICAgIGxldCBpZHg7CiAgICBmb3IgKHIgPSAwOyByIDwgNjsgcisrKSB7CiAgICAgIGZvciAoZyA9IDA7IGcgPCA2OyBnKyspIHsKICAgICAgICBmb3IgKGIgPSAwOyBiIDwgNjsgYisrKSB7CiAgICAgICAgICBpZHggPSAxNiArIHIgKiAzNiArIGcgKiA2ICsgYjsKICAgICAgICAgIF9Db2xvclRhYmxlW2lkeF0gPSAicmdiKCI7CiAgICAgICAgICBpZiAociA+IDApCiAgICAgICAgICAgIF9Db2xvclRhYmxlW2lkeF0gKz0gciAqIDQwICsgNTU7CiAgICAgICAgICBlbHNlCiAgICAgICAgICAgIF9Db2xvclRhYmxlW2lkeF0gKz0gIjAiOwogICAgICAgICAgX0NvbG9yVGFibGVbaWR4XSArPSAiLCI7CiAgICAgICAgICBpZiAoZyA+IDApCiAgICAgICAgICAgIF9Db2xvclRhYmxlW2lkeF0gKz0gZyAqIDQwICsgNTU7CiAgICAgICAgICBlbHNlCiAgICAgICAgICAgIF9Db2xvclRhYmxlW2lkeF0gKz0gIjAiOwogICAgICAgICAgX0NvbG9yVGFibGVbaWR4XSArPSAiLCI7CiAgICAgICAgICBpZiAoYiA+IDApCiAgICAgICAgICAgIF9Db2xvclRhYmxlW2lkeF0gKz0gYiAqIDQwICsgNTU7CiAgICAgICAgICBlbHNlCiAgICAgICAgICAgIF9Db2xvclRhYmxlW2lkeF0gKz0gIjAiOwogICAgICAgICAgX0NvbG9yVGFibGVbaWR4XSArPSAiKSI7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICBmb3IgKHIgPSAyMzI7IHIgPD0gMjU1OyByKyspIHsKICAgICAgZyA9IChyIC0gMjMyKSAqIDEwICsgODsKICAgICAgX0NvbG9yVGFibGVbcl0gPSBbInJnYigiLCBnLCAiLCIsIGcsICIsIiwgZywgIikiXS5qb2luKCIiKTsKICAgIH0KICAgIF9Db2xvclRhYmxlWzBdID0gInJnYigwLDAsMCkiOwogICAgX0NvbG9yVGFibGVbMV0gPSAicmdiKDEyOCwgMCwgMCkiOwogICAgX0NvbG9yVGFibGVbMl0gPSAicmdiKDAsIDEyOCwgMCkiOwogICAgX0NvbG9yVGFibGVbM10gPSAicmdiKDEyOCwgMTI4LCAwKSI7CiAgICBfQ29sb3JUYWJsZVs0XSA9ICJyZ2IoMCwgMCwgMjM4KSI7CiAgICBfQ29sb3JUYWJsZVs1XSA9ICJyZ2IoMTI4LCAwLCAxMjgpIjsKICAgIF9Db2xvclRhYmxlWzZdID0gInJnYigwLCAxMjgsIDEyOCkiOwogICAgX0NvbG9yVGFibGVbN10gPSAicmdiKDE4NywgMTg3LCAxODcpIjsKICAgIF9Db2xvclRhYmxlWzhdID0gInJnYigxMjgsIDEyOCwgMTI4KSI7CiAgICBfQ29sb3JUYWJsZVs5XSA9ICJyZ2IoMjU1LCAwLCAwKSI7CiAgICBfQ29sb3JUYWJsZVsxMF0gPSAicmdiKDAsIDI1NSwgMCkiOwogICAgX0NvbG9yVGFibGVbMTFdID0gInJnYigyNTUsIDI1NSwgMCkiOwogICAgX0NvbG9yVGFibGVbMTJdID0gInJnYig5MiwgOTIsIDI1NSkiOwogICAgX0NvbG9yVGFibGVbMTNdID0gInJnYigyNTUsIDAsIDI1NSkiOwogICAgX0NvbG9yVGFibGVbMTRdID0gInJnYigwLCAyNTUsIDI1NSkiOwogICAgX0NvbG9yVGFibGVbMTVdID0gInJnYigyNTUsIDI1NSwgMjU1KSI7CiAgICBfQ29sb3JUYWJsZVsyNTZdID0gInJnYigwLCAwLCAwKSI7CiAgICBfQ29sb3JUYWJsZVsyNTddID0gInJnYigxMTgsIDAsIDApIjsKICAgIF9Db2xvclRhYmxlWzI1OF0gPSAicmdiKDAsIDEwOCwgMCkiOwogICAgX0NvbG9yVGFibGVbMjU5XSA9ICJyZ2IoMTQ1LCAxMzYsIDApIjsKICAgIF9Db2xvclRhYmxlWzI2MF0gPSAicmdiKDAsIDAsIDE2NykiOwogICAgX0NvbG9yVGFibGVbMjYxXSA9ICJyZ2IoMTA4LCAwLCAxMDgpIjsKICAgIF9Db2xvclRhYmxlWzI2Ml0gPSAicmdiKDAsIDEwOCwgMTA4KSI7CiAgICBfQ29sb3JUYWJsZVsyNjNdID0gInJnYigxNjEsIDE2MSwgMTYxKSI7CiAgICBfQ29sb3JUYWJsZVsyNjRdID0gInJnYigwLCAwLCAwKSI7CiAgICBfQ29sb3JUYWJsZVsyNjVdID0gInJnYigxMjgsIDAsIDApIjsKICAgIF9Db2xvclRhYmxlWzI2Nl0gPSAicmdiKDAsIDEyOCwgMCkiOwogICAgX0NvbG9yVGFibGVbMjY3XSA9ICJyZ2IoMTI4LCAxMjgsIDApIjsKICAgIF9Db2xvclRhYmxlWzI2OF0gPSAicmdiKDAsIDAsIDIzOCkiOwogICAgX0NvbG9yVGFibGVbMjY5XSA9ICJyZ2IoMTI4LCAwLCAxMjgpIjsKICAgIF9Db2xvclRhYmxlWzI3MF0gPSAicmdiKDAsIDEyOCwgMTI4KSI7CiAgICBfQ29sb3JUYWJsZVsyNzFdID0gInJnYigxODcsIDE4NywgMTg3KSI7CiAgICBfQ29sb3JUYWJsZVsyNzJdID0gInJnYigwLDAsMCkiOwogICAgX0NvbG9yVGFibGVbMjczXSA9ICJyZ2IoMCwgMjU1LCAyNTUpIjsKICAgIF9Db2xvclRhYmxlWzI3NF0gPSAicmdiKDAsMCwwKSI7CiAgICBfQ29sb3JUYWJsZVsyNzVdID0gInJnYigyNTUsIDI1NSwgMCkiOwogICAgX0NvbG9yVGFibGVbMjc2XSA9ICJyZ2IoMCwgMCwgMCkiOwogICAgX0NvbG9yVGFibGVbMjc3XSA9ICJyZ2IoMjI5LCAyMjksIDIyOSkiOwogICAgX0NvbG9yVGFibGVbMjc4XSA9ICJyZ2IoMjA1LCAwLCAwKSI7CiAgICBfQ29sb3JUYWJsZVsyNzldID0gInJnYigyMjksIDIyOSwgMjI5KSI7CiAgICBfQ29sb3JUYWJsZVsyODBdID0gInJnYigyNTUsMjU1LDI1NSkiOwogICAgY29sb3JUYWJsZSA9IF9Db2xvclRhYmxlOwogIH0KICBmdW5jdGlvbiBHZXRDb2xvcihjb2RlKSB7CiAgICBpZiAoY29sb3JUYWJsZSA9PSBudWxsKQogICAgICBidWlsZENvbG9yVGFibGUoKTsKICAgIHN3aXRjaCAoY29kZSkgewogICAgICBjYXNlIC0xMjoKICAgICAgICByZXR1cm4gY29sb3JUYWJsZVsyNzldOwogICAgICAvL0Vycm9yQmFjawogICAgICBjYXNlIC0xMToKICAgICAgICByZXR1cm4gY29sb3JUYWJsZVsyNzhdOwogICAgICAvL0Vycm9yRm9yZQogICAgICBjYXNlIC0xMDoKICAgICAgICByZXR1cm4gY29sb3JUYWJsZVsyODBdOwogICAgICAvL0RlZmF1bHRCcmlnaHRGb3JlCiAgICAgIGNhc2UgLTg6CiAgICAgICAgcmV0dXJuIGNvbG9yVGFibGVbMjcyXTsKICAgICAgLy9JbmZvQmFja2dyb3VuZAogICAgICBjYXNlIC03OgogICAgICAgIHJldHVybiBjb2xvclRhYmxlWzI3M107CiAgICAgIC8vSW5mb1RleHQKICAgICAgY2FzZSAtNDoKICAgICAgICByZXR1cm4gY29sb3JUYWJsZVsyNzRdOwogICAgICAvL0xvY2FsRWNob0JhY2tncm91bmQKICAgICAgY2FzZSAtMzoKICAgICAgICByZXR1cm4gY29sb3JUYWJsZVsyNzVdOwogICAgICAvL0xvY2FsRWNob1RleHQKICAgICAgY2FzZSA0OToKICAgICAgY2FzZSAtMjoKICAgICAgICByZXR1cm4gY29sb3JUYWJsZVsyNzZdOwogICAgICAvL0RlZmF1bHRCYWNrCiAgICAgIGNhc2UgMzk6CiAgICAgIGNhc2UgLTE6CiAgICAgICAgcmV0dXJuIGNvbG9yVGFibGVbMjc3XTsKICAgICAgLy9EZWZhdWx0QmFjawogICAgICBjYXNlIDA6CiAgICAgIGNhc2UgMzA6CiAgICAgICAgcmV0dXJuIGNvbG9yVGFibGVbMF07CiAgICAgIGNhc2UgMToKICAgICAgY2FzZSAzMToKICAgICAgICByZXR1cm4gY29sb3JUYWJsZVsxXTsKICAgICAgY2FzZSAyOgogICAgICBjYXNlIDMyOgogICAgICAgIHJldHVybiBjb2xvclRhYmxlWzJdOwogICAgICBjYXNlIDM6CiAgICAgIGNhc2UgMzM6CiAgICAgICAgcmV0dXJuIGNvbG9yVGFibGVbM107CiAgICAgIGNhc2UgNDoKICAgICAgY2FzZSAzNDoKICAgICAgICByZXR1cm4gY29sb3JUYWJsZVs0XTsKICAgICAgY2FzZSA1OgogICAgICBjYXNlIDM1OgogICAgICAgIHJldHVybiBjb2xvclRhYmxlWzVdOwogICAgICBjYXNlIDY6CiAgICAgIGNhc2UgMzY6CiAgICAgICAgcmV0dXJuIGNvbG9yVGFibGVbNl07CiAgICAgIGNhc2UgNzoKICAgICAgY2FzZSAzNzoKICAgICAgICByZXR1cm4gY29sb3JUYWJsZVs3XTsKICAgICAgY2FzZSA0MDoKICAgICAgICByZXR1cm4gY29sb3JUYWJsZVsyNjRdOwogICAgICBjYXNlIDQxOgogICAgICAgIHJldHVybiBjb2xvclRhYmxlWzI2NV07CiAgICAgIGNhc2UgNDI6CiAgICAgICAgcmV0dXJuIGNvbG9yVGFibGVbMjY2XTsKICAgICAgY2FzZSA0MzoKICAgICAgICByZXR1cm4gY29sb3JUYWJsZVsyNjddOwogICAgICBjYXNlIDQ0OgogICAgICAgIHJldHVybiBjb2xvclRhYmxlWzI2OF07CiAgICAgIGNhc2UgNDU6CiAgICAgICAgcmV0dXJuIGNvbG9yVGFibGVbMjY5XTsKICAgICAgY2FzZSA0NjoKICAgICAgICByZXR1cm4gY29sb3JUYWJsZVsyNzBdOwogICAgICBjYXNlIDQ3OgogICAgICAgIHJldHVybiBjb2xvclRhYmxlWzI3MV07CiAgICAgIGNhc2UgODoKICAgICAgY2FzZSA5MDoKICAgICAgY2FzZSAxMDA6CiAgICAgIGNhc2UgMzAwOgogICAgICAvL3NldCBmb3JlZ3JvdW5kIGNvbG9yIHRvIGJsYWNrCiAgICAgIGNhc2UgNDAwOgogICAgICAgIHJldHVybiBjb2xvclRhYmxlWzhdOwogICAgICBjYXNlIDk6CiAgICAgIGNhc2UgOTE6CiAgICAgIGNhc2UgMTAxOgogICAgICBjYXNlIDMxMDoKICAgICAgLy9zZXQgZm9yZWdyb3VuZCBjb2xvciB0byByZWQKICAgICAgY2FzZSA0MTA6CiAgICAgICAgcmV0dXJuIGNvbG9yVGFibGVbOV07CiAgICAgIGNhc2UgMTA6CiAgICAgIGNhc2UgOTI6CiAgICAgIGNhc2UgMTAyOgogICAgICBjYXNlIDMyMDoKICAgICAgLy9zZXQgZm9yZWdyb3VuZCBjb2xvciB0byBncmVlbgogICAgICBjYXNlIDQyMDoKICAgICAgICByZXR1cm4gY29sb3JUYWJsZVsxMF07CiAgICAgIGNhc2UgMTE6CiAgICAgIGNhc2UgOTM6CiAgICAgIGNhc2UgMTAzOgogICAgICBjYXNlIDMzMDoKICAgICAgLy9zZXQgZm9yZWdyb3VuZCBjb2xvciB0byB5ZWxsb3cKICAgICAgY2FzZSA0MzA6CiAgICAgICAgcmV0dXJuIGNvbG9yVGFibGVbMTFdOwogICAgICBjYXNlIDEyOgogICAgICBjYXNlIDk0OgogICAgICBjYXNlIDEwNDoKICAgICAgY2FzZSAzNDA6CiAgICAgIC8vc2V0IGZvcmVncm91bmQgY29sb3IgdG8gYmx1ZQogICAgICBjYXNlIDQ0MDoKICAgICAgICByZXR1cm4gY29sb3JUYWJsZVsxMl07CiAgICAgIGNhc2UgMTM6CiAgICAgIGNhc2UgOTU6CiAgICAgIGNhc2UgMTA1OgogICAgICBjYXNlIDM1MDoKICAgICAgLy9zZXQgZm9yZWdyb3VuZCBjb2xvciB0byBtYWdlbnRhIChwdXJwbGUpCiAgICAgIGNhc2UgNDUwOgogICAgICAgIHJldHVybiBjb2xvclRhYmxlWzEzXTsKICAgICAgY2FzZSAxNDoKICAgICAgY2FzZSA5NjoKICAgICAgY2FzZSAxMDY6CiAgICAgIGNhc2UgMzYwOgogICAgICAvL3NldCBmb3JlZ3JvdW5kIGNvbG9yIHRvIGN5YW4KICAgICAgY2FzZSA0NjA6CiAgICAgICAgcmV0dXJuIGNvbG9yVGFibGVbMTRdOwogICAgICBjYXNlIDE1OgogICAgICBjYXNlIDk3OgogICAgICBjYXNlIDEwNzoKICAgICAgY2FzZSAzNzA6CiAgICAgIC8vc2V0IGZvcmVncm91bmQgY29sb3IgdG8gd2hpdGUKICAgICAgY2FzZSA0NzA6CiAgICAgICAgcmV0dXJuIGNvbG9yVGFibGVbMTVdOwogICAgICBjYXNlIDRlMzoKICAgICAgY2FzZSAzZTM6CiAgICAgICAgcmV0dXJuIGNvbG9yVGFibGVbMjU2XTsKICAgICAgY2FzZSA0MTAwOgogICAgICBjYXNlIDMxMDA6CiAgICAgICAgcmV0dXJuIGNvbG9yVGFibGVbMjU3XTsKICAgICAgY2FzZSA0MjAwOgogICAgICBjYXNlIDMyMDA6CiAgICAgICAgcmV0dXJuIGNvbG9yVGFibGVbMjU4XTsKICAgICAgY2FzZSA0MzAwOgogICAgICBjYXNlIDMzMDA6CiAgICAgICAgcmV0dXJuIGNvbG9yVGFibGVbMjU5XTsKICAgICAgY2FzZSA0NDAwOgogICAgICBjYXNlIDM0MDA6CiAgICAgICAgcmV0dXJuIGNvbG9yVGFibGVbMjYwXTsKICAgICAgY2FzZSA0NTAwOgogICAgICBjYXNlIDM1MDA6CiAgICAgICAgcmV0dXJuIGNvbG9yVGFibGVbMjYxXTsKICAgICAgY2FzZSA0NjAwOgogICAgICBjYXNlIDM2MDA6CiAgICAgICAgcmV0dXJuIGNvbG9yVGFibGVbMjYyXTsKICAgICAgY2FzZSA0NzAwOgogICAgICBjYXNlIDM3MDA6CiAgICAgICAgcmV0dXJuIGNvbG9yVGFibGVbMjYzXTsKICAgICAgZGVmYXVsdDoKICAgICAgICBpZiAoY29kZSA8PSAtMTYpIHsKICAgICAgICAgIGNvZGUgKz0gMTY7CiAgICAgICAgICBjb2RlICo9IC0xOwogICAgICAgIH0KICAgICAgICBpZiAoY29kZSA+PSAwICYmIGNvZGUgPCAyODEpCiAgICAgICAgICByZXR1cm4gY29sb3JUYWJsZVtjb2RlXTsKICAgICAgICByZXR1cm4gY29sb3JUYWJsZVsyNzddOwogICAgfQogIH0KICBmdW5jdGlvbiBTZXRDb2xvcihjb2RlLCBjb2xvcikgewogICAgaWYgKGNvbG9yVGFibGUgPT0gbnVsbCkKICAgICAgYnVpbGRDb2xvclRhYmxlKCk7CiAgICBpZiAoY29kZSA8IDAgfHwgY29kZSA+PSBjb2xvclRhYmxlLmxlbmd0aCkKICAgICAgcmV0dXJuOwogICAgY29sb3IgPSBuZXcgUkdCQ29sb3IoY29sb3IpOwogICAgaWYgKCFjb2xvci5vaykgcmV0dXJuOwogICAgY29sb3JUYWJsZVtjb2RlXSA9IGNvbG9yLnRvUkdCKCk7CiAgfQp9KSgpOwovKioKICogQSBjbGFzcyB0byBwYXJzZSBjb2xvciB2YWx1ZXMKICogQGF1dGhvciBTdG95YW4gU3RlZmFub3YgPHNzdG9vQGdtYWlsLmNvbT4KICogQGxpbmsgICBodHRwOi8vd3d3LnBocGllZC5jb20vcmdiLWNvbG9yLXBhcnNlci1pbi1qYXZhc2NyaXB0LwogKiBAbGljZW5zZSBVc2UgaXQgaWYgeW91IGxpa2UgaXQKICovCg==";

  // src/html/log.header.html
  var log_header_default = `<style>body{font-family:'Courier New',Courier,monospace;text-align:left;font-size:1em;white-space:pre;background-color:#000}@-webkit-keyframes blinker{0%{opacity:1}50%{opacity:0}100%{opacity:1}}@keyframes blinker{0%{opacity:1}50%{opacity:0}100%{opacity:1}}.animate .ansi-blink{text-decoration:blink;animation-name:blinker;animation-iteration-count:infinite;animation-timing-function:cubic-bezier(1,0,0,1);animation-duration:1s;-webkit-animation-name:blinker;-webkit-animation-iteration-count:infinite;-webkit-animation-timing-function:cubic-bezier(1,0,0,1);-webkit-animation-duration:1s}.line>span{padding:0;margin:0;display:inline-block;cursor:text;padding-bottom:1px}.ansi{padding:0;margin:0;display:inline-block;padding-bottom:1px;cursor:text;line-height:normal}.line{word-wrap:break-word;word-break:break-all;min-width:100%;display:block;clear:both;line-height:normal}.line hr{border:0}.line a,.line a:link,.line a:link span{color:inherit;font-weight:inherit;text-decoration:underline}.URLLink,.URLLink:link,.URLLink:link span{text-decoration:underline;cursor:pointer}a.MXPLink:link,a.MXPLink:link span{font-weight:400;color:inherit;text-decoration:underline}a.MXPLink:visited,a.MXPLink:visited span{text-decoration:underline}a.MXPLink:active,a.MXPLink:active span{text-decoration:underline}a.MXPLink:hover,a.MXPLink:hover span{text-decoration:underline}.line .b{font-weight:700}.line .i{font-style:italic}.line .o{text-decoration:overline}.line .u{text-decoration:underline}.line .du{text-decoration:underline;border-bottom:1px solid currentColor;padding-bottom:1px}.line .s{text-decoration:line-through}.line .o.du{text-decoration:underline overline}.line .u.o{text-decoration:underline overline}.line .o.s{text-decoration:overline line-through}.line .du.s{text-decoration:underline line-through}.line .s.u{text-decoration:underline line-through}.line .du.u.o{text-decoration:underline overline}.line .du.s.u{text-decoration:underline line-through}.line .du.o.s{text-decoration:underline overline line-through}.line .u.s.o{text-decoration:underline overline line-through}.line .du.o.s.u{text-decoration:underline overline line-through}</style><script type="text/javascript">function doLink(url) {
        if (confirm('Open \\'' + url + '\\'?') === true)
            window.open(encodeURI(url), '_blank');
    }

    // eslint-disable-next-line no-unused-vars
    function doMXPLink(el, url) {
        if (url.startsWith('OoMUD://') || url.startsWith('jiMUD://') || url.startsWith('client://'))
            doMXPSend(0, el, url.substring(8));
        else if (confirm('Open \\'' + url + '\\'?') === true)
            window.open(encodeURI(url.replace('&text;', el.textContent || '')), '_blank');
    }

    function doMXPSend(e, el, url, pmt, tt) {
        var im = el.querySelector('img[ismap]');
        var extra = '';
        if (im && im.length > 0) {
            var offset = im.offset();
            var x = Math.floor(e.clientX - offset.left);
            var y = Math.floor(e.clientY - offset.top);
            extra = '?' + x + ',' + y;
        }

        if (url.constructor === Array || url.__proto__.constructor === Array || Object.prototype.toString.call(url) === '[object Array]') {
            alert('MXP Menu not supported');
        }
        else {
            url = url.replace('&text;', el.textContent || '') + extra;
            if (!pmt)
                url += '\\n';
            alert(url);
            console.log(url);
        }
    }

    // eslint-disable-next-line no-unused-vars
    function doMXPTooltip(el) {
        el.title = el.title.replace('&test;', el.textContent || '');
    }<\/script>`;

  // src/plugins/logger.ts
  var Logger = class extends Plugin {
    constructor() {
      super(...arguments);
      this._keyQueue = [];
    }
    get manager() {
      return this._manager;
    }
    remove() {
      this.client.removeListenersFromCaller(this);
    }
    initialize() {
      if (this.client.getOption("logEnabled"))
        this._initializeLogger();
      this.client.on("cleared", () => {
        this._post({ action: "flush", args: true });
      }, this);
      this.client.on("connecting", () => {
        this._post({ action: "connected", args: this.client.connected });
        this._post({
          action: "start",
          args: {
            lines: this.client.display.lines,
            fragment: this.client.display.EndOfLine || this.client.telnet.prompt
          }
        });
      }, this);
      this.client.on("add-line-done", async (data) => {
        if (this.client.getOption("logEnabled"))
          this._post({ action: "add-line", args: data });
      }, this);
      this.client.on("set-title", (title, lag) => {
        this._post({ action: "name", args: $character });
      }, this);
      this.client.on("options-loaded", () => {
        this._updateMenuItem(this.client.getOption("logEnabled"));
        if (this.client.getOption("logEnabled"))
          this._initializeLogger();
        else
          this._loadLoggerOptions();
        if (this._manager)
          this._manager.resetState(client.getOption("windows.log-viewer") || { center: true });
      }, this);
      this.client.on("closed", () => {
        this._post({ action: "connected", args: client.connected });
        this._post({ action: "stop" });
      }, this);
      this.client.on("reconnect", () => {
        if (this.client.connected) return;
        this._post({ action: "connected", args: client.connected });
        this._post({ action: "stop" });
      }, this);
      this.client.on("window", (window2, args, name2) => {
        let pages = window2.split("/");
        if (!pages.length) return;
        switch (pages[0]) {
          case "log-viewer":
          case "logs":
          case "log.viewer":
            if (args === "close") {
              if (this._manager)
                this._manager.close();
              removeHash("logs");
            } else {
              if (!this._manager)
                this._manager = new LogManager();
              this._manager.dialog.dataset.path = window2;
              this._manager.show();
              this._manager.setBody(window2);
            }
            break;
        }
      });
      this._post({ action: "name", args: $character || "" });
      window.addEventListener("beforeunload", () => {
        this._post({ action: "flush" });
      });
    }
    get menu() {
      return [
        {
          name: " Enable logging",
          icon: '<i class="bi bi-file-text"></i>',
          position: "#menu-connect",
          active: this.client.getOption("logEnabled"),
          action: () => {
            if (!client.getOption("logEnabled"))
              this._initializeLogger();
            this._post({ action: "toggle" });
          }
        },
        {
          name: "Manage logs",
          icon: '<i class="fas fa-list"></i>',
          position: "#menu-profiles",
          action: () => {
            if (!this._manager)
              this._manager = new LogManager();
            updateHash("logs");
          }
        }
      ];
    }
    get settings() {
      return [{
        name: " Logging",
        action: "settings-logging",
        icon: '<i class="far fa-file-alt"></i>',
        position: 2
      }];
    }
    _post(data) {
      if (!this._logger) return;
      this._logger.postMessage(data);
    }
    createLogger() {
      return new Worker(logger_worker_default);
    }
    _initializeLogger() {
      if (this._logger) return;
      this._logger = this.createLogger();
      this._logger.addEventListener("message", (e) => {
        switch (e.data.event) {
          case "started":
            this._updateMenuItem(true);
            break;
          case "stopped":
            this._updateMenuItem(false);
            this._post({ action: "flush" });
            this._logger.terminate();
            this._logger = null;
            break;
          case "logging":
            break;
          case "error":
            this.client.error(e.data.args);
            break;
          case "debug":
            if (!this.client)
              console.log(e.data.args);
            else if (this.client.getOption("enableDebug"))
              this.client.debug(e.data.args);
            break;
          case "toggled":
            if (this.client)
              this.client.setOption("logEnabled", e.data.args);
            this._updateMenuItem(e.data.args);
            if (!e.data.args) {
              this._post({ action: "flush" });
              this._logger.terminate();
              this._logger = null;
            }
            break;
          case "startInternal":
          case "start":
            this._post({ action: e.data.event, args: { lines: this.client.display.lines || [], fragment: this.client.display.EndOfLine || this.client.telnet.prompt } });
            break;
          case "write":
            this.updateKey(e.data);
            localforage.getItem("OoMUDLog" + e.data.file).then((value) => {
              if (!value) value = "";
              value += e.data.data;
              localforage.setItem("OoMUDLog" + e.data.file, value).then(() => {
                if (this._manager) this._manager.logChanged(e.data.file, e.data.data);
                this._post({ action: "write-done", file: e.data.file });
              });
            });
            break;
        }
      });
      this._logger.addEventListener("error", (e) => {
        if (!this.client)
          console.error(e);
        else
          this.client.error(e);
      });
      this._loadLoggerOptions();
    }
    updateKey(data) {
      this._keyQueue.push(data);
      if (this._keyPromise) return;
      this._keyPromise = localforage.getItem("OoMUDLogKeys").then((value) => {
        if (!this._keyQueue.length) return;
        var _keys;
        if (!value)
          _keys = {};
        else
          _keys = value;
        this._keyQueue.forEach((key) => {
          _keys[key.file] = { character: key.character, timeStamp: key.timeStamp, postfix: data.postfix, prefix: data.prefix };
        });
        this._keyQueue = [];
        this._keyPromise = null;
        localforage.setItem("OoMUDLogKeys", _keys);
      });
    }
    _loadLoggerOptions() {
      this._post({
        action: "options",
        args: {
          offline: this.client.getOption("logOffline"),
          gagged: this.client.getOption("logGagged"),
          enabled: this.client.getOption("logEnabled"),
          unique: this.client.getOption("logUniqueOnConnect"),
          prepend: this.client.getOption("logPrepend"),
          what: this.client.getOption("logWhat"),
          debug: this.client.getOption("enableDebug"),
          format: this.client.getOption("logTimeFormat"),
          colors: this.client.getOption("colors"),
          timestamp: this.client.getOption("logTimestamp"),
          timestampFormat: this.client.getOption("logTimestampFormat")
        }
      });
    }
    _updateMenuItem(state) {
      const button = document.querySelector("#menu-enable-logging");
      if (state) {
        button.title = "Disable logging";
        button.classList.add("active");
        document.querySelector("#menu-enable-logging a span").textContent = "Disable logging";
      } else {
        button.title = "Enable logging";
        button.classList.remove("active");
        document.querySelector("#menu-enable-logging a span").textContent = "Enable logging";
      }
    }
  };
  var LogManager = class extends Dialog {
    constructor() {
      super(Object.assign({}, client.getOption("windows.log-viewer") || { center: true }, { title: '<i class="fas fa-list"></i> Log viewer', minWidth: 410 }));
      this._page = "logs";
      this.on("resized", (e) => {
        client.setOption("windows.log-viewer", e);
      });
      this.on("closed", () => {
        client.setOption("windows.log-viewer", this.windowState);
        removeHash(this._page);
      });
      this.on("canceled", () => {
        client.setOption("windows.log-viewer", this.windowState);
        removeHash(this._page);
      });
      this.on("moved", (e) => {
        client.setOption("windows.log-viewer", e);
      });
      this.on("maximized", () => {
        client.setOption("windows.log-viewer", this.windowState);
      });
      this.on("restored", () => {
        client.setOption("windows.log-viewer", this.windowState);
      });
      this.on("shown", () => {
        client.setOption("windows.log-viewer", this.windowState);
      });
      this.body.style.padding = "10px";
      this._splitter = new Splitter({ id: "log-viewer", parent: this.body, orientation: 1 /* vertical */, anchor: 1 /* panel1 */ });
      if (client.getOption("logger.split") >= 200)
        this._splitter.SplitterDistance = client.getOption("logger.split");
      this._splitter.on("splitter-moved", (distance) => {
        client.setOption("logger.split", distance);
      });
      this._menu = this._splitter.panel1;
      this._menu.style.overflow = "hidden";
      this._menu.style.overflowY = "auto";
      this._contents = document.createElement("iframe");
      this._contents.classList.add("viewer");
      this._splitter.panel2.append(this._contents);
      this._splitter.panel2.style.overflow = "auto";
      this._splitter.panel2.style.padding = "0";
      this._splitter.panel2.style.paddingLeft = "4px";
      this._buildMenu();
      let footer = "";
      footer += `<button id="${this.id}-back" type="button" class="btn-sm float-start btn btn-light" title="Go back"><i class="bi bi-arrow-left"></i><span class="icon-only"> Back</span></button>`;
      footer += `<button id="${this.id}-refresh" type="button" class="btn-sm float-start btn btn-light" title="Go back"><i class="bi bi-arrow-repeat"></i></i><span class="icon-only"> Refresh</span></button>`;
      footer += '<div class="vr float-start" style="margin-right: 4px;height: 29px;"></div>';
      footer += '<span id="logs-page-buttons"></span>';
      footer += `<button id="${this.id}-cancel" type="button" class="btn-sm float-end btn btn-light" title="Close dialog"><i class="bi bi-x-lg"></i><span class="icon-only"> Close</span></button>`;
      this.footer.innerHTML = footer;
      this.footer.classList.add("dropup");
      this.footer.querySelector(`#${this.id}-cancel`).addEventListener("click", () => {
        removeHash(this._page);
        this.close();
      });
      this.footer.querySelector(`#${this.id}-refresh`).addEventListener("click", () => {
        this._buildMenu(true).then(() => {
          const item = this._menu.querySelector(`a[href="#logs/${this._current}"]`);
          if (item) {
            item.classList.add("active");
            scrollChildIntoView(this._menu, item);
          }
        });
        this.setBody("");
      });
      this.footer.querySelector(`#${this.id}-back`).addEventListener("click", () => {
        this._goBack();
      });
      this.dialog.dataset.path = "logs";
      this.setBody("");
    }
    setBody(contents, args) {
      if (!this._logs) {
        setTimeout(() => {
          this.setBody(contents, args);
        });
        return;
      }
      this._page = this.dialog.dataset.path;
      if (this._page === "logs")
        this.dialog.dataset.panel = "left";
      else
        this.dialog.dataset.panel = "right";
      const pages = this._page.split("/");
      this._current = pages[pages.length - 1];
      this.title = buildBreadcrumb(pages, false, "/", (item, index, last) => {
        if (index === last) {
          if (this._logs[item] && !item.endsWith(".txt") && !item.endsWith(".raw") && !item.endsWith(".htm"))
            return `${formatDate(item)}${this._logs[item].character ? ", " + this._logs[item].character : ""}>`;
          else if (this._logs[item] && this._logs[item].timeStamp)
            return `${formatDate(this._logs[item].timeStamp)}${this._logs[item].character ? ", " + this._logs[item].character : ""}, ${item.substring(item.length - 3, item.length)}${this._logs[item].prefix ? ", " + this._logs[item].prefix : ""}${this._logs[item].postfix ? ", " + this._logs[item].postfix : ""}`;
        }
        return capitalize(item);
      });
      let items = this._menu.querySelectorAll("a.active");
      items.forEach((item) => item.classList.remove("active"));
      items = this._menu.querySelector(`a[href="#logs/${this._current}"]`);
      if (items)
        items.classList.add("active");
      if (pages.length < 2) {
        this._setContents("");
        this._splitter.panel2Collapsed = true;
        this.footer.querySelector(`#${this.id}-back`).style.display = "none";
        this.footer.querySelector("#logs-page-buttons").innerHTML = `<button id="${this.id}-clear" type="button" class="btn-sm btn btn-danger" title="Clear logs"><i class="bi bi-trash"></i><span class="icon-only"> Clear</span></button>`;
        this.footer.querySelector(`#${this.id}-clear`).addEventListener("click", () => {
          confirm_box("Clear logs?", "Remove all logs?").then((e) => {
            if (e.button === 4 /* Yes */) {
              var logs = Object.keys(this._logs);
              for (var r = 0, rl = logs.length; r < rl; r++) {
                localforage.removeItem("OoMUDLog" + logs[r]);
              }
              localforage.removeItem("OoMUDLogKeys").then(() => {
                this._buildMenu();
                this.setBody("");
              });
            }
          });
        });
        let clear = this.footer.querySelector(`#${this.id}-clear`);
        if (clear) clear.style.display = Object.keys(this._logs).length ? "" : "none";
        document.getElementById("logs-page-buttons").previousSibling.style.display = Object.keys(this._logs).length ? "" : "none";
      } else {
        localforage.getItem("OoMUDLog" + pages[1]).then((value) => {
          if (!pages[1].endsWith(".txt") && !pages[1].endsWith(".raw"))
            this._setContents(log_header_default + (value || "").replace(/\n/g, ""));
          else
            this._setContents("<style>body {font-family: 'Courier New', Courier, monospace;text-align: left;font-size: 1em;white-space: pre;background-color: white;}</style>" + (value || ""));
        });
        this.footer.querySelector(`#${this.id}-back`).style.display = "";
        this._splitter.panel2Collapsed = false;
        let b = `<button id="${this.id}-export" type="button" class="btn-sm float-start btn btn-light" title="Export log"><i class="bi bi-box-arrow-up"></i><span class="icon-only"> Export</span></button>`;
        b += `<button id="${this.id}-remove" type="button" class="btn-sm btn btn-danger" title="Remove log"><i class="bi bi-trash"></i><span class="icon-only"> Remove</span></button>`;
        this.footer.querySelector("#logs-page-buttons").innerHTML = b;
        this.footer.querySelector(`#${this.id}-remove`).addEventListener("click", (e) => {
          this._removeLog(this._current);
        });
        this.footer.querySelector(`#${this.id}-export`).addEventListener("click", (e) => {
          this._exportLog(this._current);
        });
      }
    }
    _setContents(contents) {
      this._contents.contentWindow.document.open();
      this._contents.contentWindow.document.write(contents);
      this._contents.contentWindow.document.close();
      this._contents.contentWindow.document.body.scrollTop = 0;
      this._contents.contentWindow.document.body.scrollLeft = 0;
      this.emit("content-changed");
    }
    _appendContents(contents, html) {
      if (html)
        this._contents.contentWindow.document.body.insertAdjacentHTML("beforeend", contents);
      else
        this._contents.contentWindow.document.body.insertAdjacentText("beforeend", contents);
    }
    _goBack() {
      const pages = this._page.split("/");
      if (pages.length === 5)
        updateHash(pages.slice(0, pages.length - 2).join("/"), this._page);
      else
        updateHash(pages.slice(0, pages.length - 1).join("/"), this._page);
    }
    _buildMenu(noLoader) {
      return new Promise((resolve, reject) => {
        if (!noLoader)
          this._menu.innerHTML = '<div class="loader"><div class="text">Loading... <div class="indicator"></div></div></div>';
        localforage.getItem("OoMUDLogKeys").then((logs) => {
          this._logs = logs || {};
          const keys = Object.keys(this._logs);
          keys.sort();
          if (keys.length === 0)
            this._menu.innerHTML = '<h1 id="empty" style="width: 100%;text-align:center">No logs.</h1>';
          else {
            let p = "";
            for (let k = 0, kl = keys.length; k < kl; k++) {
              let icon = "code";
              if (keys[k].endsWith(".txt"))
                icon = "text";
              else if (keys[k].endsWith(".raw"))
                icon = "binary";
              let title = keys[k];
              if (!keys[k].endsWith(".txt") && !keys[k].endsWith(".raw") && !keys[k].endsWith(".htm"))
                title = `${formatDate(keys[k])}${this._logs[keys[k]].character ? ", " + this._logs[keys[k]].character : ""}`;
              else if (this._logs[keys[k]].timeStamp)
                title = `${formatDate(this._logs[keys[k]].timeStamp)}${this._logs[keys[k]].character ? ", " + this._logs[keys[k]].character : ""}, ${keys[k].substring(keys[k].length - 3, keys[k].length)}${this._logs[keys[k]].prefix ? ", " + this._logs[keys[k]].prefix : ""}${this._logs[keys[k]].postfix ? ", " + this._logs[keys[k]].postfix : ""}`;
              p += `<a id="${keys[k]}" href="#logs/${encodeURIComponent(keys[k])}" class="list-group-item list-group-item-action" title="${title}"><span class="list-badge-button badge text-bg-danger" data-key="${keys[k]}" data-type="delete" title="Remove log"><i class="bi bi-trash"></i></span><span class="me-1 list-badge-button badge text-bg-secondary" data-key="${keys[k]}" data-type="export" title="Export log"><i class="bi bi-box-arrow-up"></i></span><i class="bi bi-file-${icon}"></i>${title}</a>`;
            }
            this._menu.innerHTML = '<div class="list-group" id="logs-menu">' + p + "</div>";
            this._menu.querySelectorAll('[data-type="delete"').forEach((item) => {
              item.addEventListener("click", (e) => {
                this._removeLog(e.currentTarget.dataset.key);
                e.stopPropagation();
                e.cancelBubble = true;
                e.preventDefault();
              });
            });
            this._menu.querySelectorAll('[data-type="export"').forEach((item) => {
              item.addEventListener("click", (e) => {
                this._exportLog(e.currentTarget.dataset.key);
                e.stopPropagation();
                e.cancelBubble = true;
                e.preventDefault();
              });
            });
          }
          resolve("");
        });
      });
    }
    async logChanged(log, value) {
      if (!this._logs || !this._logs[log]) {
        await this._buildMenu();
        const item = this._menu.querySelector(`a[href="#logs/${this._current}"]`);
        if (item) {
          item.classList.add("active");
          scrollChildIntoView(this._menu, item);
        }
        let clear = this.footer.querySelector(`#${this.id}-clear`);
        if (clear) clear.style.display = "";
        document.getElementById("logs-page-buttons").previousSibling.style.display = "";
      }
      if (this._current === log) {
        if (!log.endsWith(".txt") && !log.endsWith(".raw"))
          this._appendContents((value || "").replace(/\n/g, ""), true);
        else
          this._appendContents(value || "");
      }
    }
    _removeLog(log) {
      confirm_box("Remove log", "Remove log?").then((e) => {
        if (e.button === 4 /* Yes */) {
          localforage.removeItem("OoMUDLog" + log);
          delete this._logs[log];
          localforage.setItem("OoMUDLogKeys", this._logs);
          document.getElementById(log).remove();
          if (this._page !== "logs")
            this._goBack();
        }
      });
    }
    _exportLog(log) {
      localforage.getItem("OoMUDLog" + log).then((value) => {
        if (log.endsWith(".htm"))
          fileSaveAs.show(log_header_default + (value || ""), `oiMUD.${log}l`, "text/html");
        else if (log.endsWith(".raw"))
          fileSaveAs.show(value || "", `oiMUD.${log}.txt`, "text/plain");
        else if (log.endsWith(".txt"))
          fileSaveAs.show(value || "", `oiMUD.${log}`, "text/plain");
        else
          fileSaveAs.show(value || "", `oiMUD.${log}.html`, "text/plain");
      });
    }
  };
  function formatDate(date) {
    if (typeof date === "string")
      date = parseInt(date, 10);
    date = new Date(date);
    var hours = date.getHours();
    var minutes = date.getMinutes();
    var ampm = hours >= 12 ? "pm" : "am";
    hours = hours % 12;
    hours = hours ? hours : 12;
    minutes = minutes < 10 ? "0" + minutes : minutes;
    var strTime = hours + ":" + minutes + " " + ampm;
    return date.getMonth() + 1 + "/" + date.getDate() + "/" + date.getFullYear() + "  " + strTime;
  }

  // src/plugins/chat.ts
  var Chat = class extends Plugin {
    constructor() {
      super(...arguments);
      this._capture = 0;
      this._captureReview = 0;
      this._captures = [];
      this._captureReviews = [];
      this._noCapture = false;
      this._noCaptureStore = 0;
      this._unload = () => {
        let state = this._getWindowState();
        if (this._window && !this._window.closed) {
          this._window.close();
          state.show = true;
        } else
          state.show = false;
        this.client.setOption("windows.chatWindow", state);
      };
    }
    remove() {
      this.client.removeListenersFromCaller(this);
      delete this.client.sendChat;
      window.removeEventListener("beforeunload", this._unload);
    }
    initialize() {
      this.client.sendChat = (data) => {
        this.updateChat(this.client.parseInline(data));
      };
      this.client.sendChatRaw = (data) => {
        this.updateChat(data);
      };
      window.addEventListener("beforeunload", this._unload);
      this.client.on("function", (data) => {
        if (!data) return;
        let args = data.args;
        switch (data.name.toLowerCase()) {
          //spell-checker:ignore chatprompt chatp
          case "chatprompt":
          case "chatp":
            if ((this.client.getOption("echo") & 4) === 4)
              this.client.echo(data.raw, -3, -4, true, true);
            args = this.client.parseInline(args.join(" "));
            this.updateChat(args);
            data.handled = true;
            break;
          case "chat":
          case "ch":
            if ((this.client.getOption("echo") & 4) === 4)
              this.client.echo(data.raw, -3, -4, true, true);
            args = this.client.parseInline(args.join(" ") + "\n");
            this.updateChat(args);
            data.handled = true;
            break;
        }
      }, this);
      this.client.on("add-line", (data) => {
        var res, c, cl;
        if (!data || typeof data.raw == "undefined" || data.raw === null)
          return;
        if (data.fragment || this._captures.length === 0) return;
        res = /^(-*)\s*\[ (.*) matching (users|user) \]\s*(-*)$/.exec(data.raw);
        if (res && res.length > 0) {
          this._capture = 0;
          this._noCapture = true;
          return;
        }
        res = /^(-*)\s*\[ .* \]\s*(-*)$/.exec(data.raw);
        if (this._noCapture && res && res.length > 0) {
          this._capture = 0;
          this._noCapture = false;
          return;
        }
        if (data.raw === "Describers:" || data.raw === "You supply a list of nouns so when your object is complete it can correctly build an id list to allow you to properly interact with it." || data.raw === "You supply a list of adjectives so when your object is complete it can correctly build an id list to allow you to properly interact with it." || data.raw === "Available sizes:" || data.raw === "Available locations:" || data.raw === "Available tattoos:" || data.raw === "Available colors:") {
          this._capture = 0;
          this._noCapture = true;
          return;
        }
        if (this._noCapture && (data.raw.indexOf("Current name: ") === 0 || data.raw.indexOf("Enter up to 2 nouns, [#] to remove, 'f' to finish, 'q' to quit:") === 0 || data.raw.indexOf("Enter up to 3 adjectives, 'f' to finish, 'q' to quit:") === 0 || data.raw.indexOf("Enter selection ") === 0)) {
          this._capture = 0;
          this._noCapture = false;
          return;
        }
        res = /^ {2}# {2}Item.*$/.exec(data.raw);
        if (this._noCaptureStore === 0 && res && res.length > 0) {
          this._capture = 0;
          this._noCaptureStore = 1;
          return;
        }
        res = /^(-*)$/.exec(data.raw);
        if (this._noCaptureStore > 0 && res && res.length > 0) {
          this._capture = 0;
          this._noCaptureStore++;
        }
        if (this._noCaptureStore > 2) {
          this._capture = 0;
          this._noCaptureStore = 0;
        }
        if (this._noCapture || this._noCaptureStore > 0) return;
        if (this.client.getOption("chat.CaptureOnlyOpen")) {
          if (!(this._window && !this._window.closed || this._dialog && !this._dialog.opened)) {
            return;
          }
        }
        if (this._capture > 0 && data.raw.startsWith("    ")) {
          data.gagged |= this.client.getOption("chat.gag");
          this.updateChat(data);
          return;
        }
        for (c = 0, cl = this._captureReviews.length; c < cl; c++) {
          res = this._captureReviews[c].exec(data.raw);
          if (!res || res.length === 0)
            continue;
          this._captureReview = 1;
          data.gagged |= this.client.getOption("chat.gag");
          this.updateChat(data);
          return;
        }
        if (this._captureReview > 0) {
          data.gagged |= this.client.getOption("chat.gag");
          this.updateChat(data);
          if (data.raw == "-=-=- End Review -=-=-")
            this._captureReview = -1;
          return;
        }
        if (this._captureReview === -1) {
          data.gagged |= this.client.getOption("chat.gag");
          this.updateChat(data);
          this._captureReview = 0;
          return;
        }
        for (c = 0, cl = this._captures.length; c < cl; c++) {
          res = this._captures[c].exec(data.raw);
          if (!res || res.length === 0)
            continue;
          if (this._capture > 0)
            this._capture--;
          this._capture++;
          data.gagged |= this.client.getOption("chat.gag");
          this.updateChat(data);
          return;
        }
        if (this._capture > 0)
          this._capture--;
      }, this);
      this.client.on("window", (window2, args, name2) => {
        switch (window2) {
          case "chat-dialog":
          case "chatdialog":
          case "chat":
            if (args === "close") {
              if (this._dialog)
                this._dialog.close();
              removeHash("chat");
            } else
              this.showDialog();
            break;
          case "chatwin":
          case "chatwindow":
          case "chat-win":
          case "chat-window":
            if (args === "close") {
              if (this._window)
                this._window.close();
            } else
              this.showWindow();
            break;
        }
      });
      this.client.on("options-loaded", () => {
        this._loadOptions();
      });
      this.client.on("set-title", (title, lag) => {
        this._post({ action: "name", args: $character });
      }, this);
      this.client.on("connecting", () => {
        this._post({ action: "connected", args: this.client.connected });
      }, this);
      this._buildCaptures();
      this._loadOptions();
      if (this.client.getOption("showChat") || this.client.getOption("chat.persistent") || this.client.getOption("chat.captureTells") || this.client.getOption("chat.captureTalk") || this.client.getOption("chat.captureLines"))
        this.show();
      let options = this.client.getOption("windows.chat");
      if (options && options.show)
        this.showDialog();
      options = this.client.getOption("windows.chatWindow");
      if (options && options.show)
        this.showWindow();
    }
    get menu() {
      return [
        {
          name: "-",
          position: 5,
          exists: "#menu-plugins",
          id: "plugins"
        },
        {
          name: " Show chat",
          action: (e) => {
            this.client.getOption("showChatWindow") ? this.show() : this.showDialog();
          },
          icon: '<i class="bi bi-chat"></i>',
          position: "#menu-plugins"
        }
      ];
    }
    get settings() {
      return [{
        name: " Chat",
        action: "settings-chat",
        icon: '<i class="bi bi-chat"></i>',
        position: 'a[href="#settings-specialCharacters"]'
      }, {
        name: " Chat display",
        action: "settings-chatDisplay",
        icon: '<i class="bi bi-chat"></i>',
        position: 'a[href="#settings-chat"]'
      }];
    }
    _buildCaptures() {
      this._captures = [];
      this._captureReviews = [];
      if (this.client.getOption("chat.captureTells")) {
        this._captures.push(
          new RegExp("^([a-zA-Z'\\s_-]*) tells you:(.*)$"),
          new RegExp("^(\\([a-zA-Z'\\s_-]*\\)) tells you:(.*)$"),
          new RegExp("^You tell ([a-zA-Z'\\s_-]*):(.*)$"),
          new RegExp("^\\*([a-zA-Z'\\s_-]*)(\\s?)(.*?)$"),
          new RegExp("^([a-zA-Z'\\s_-]*) is idle, and may not have been paying attention.$"),
          new RegExp("^([a-zA-Z'\\s_-]*) is in combat and may not have heard you.$"),
          new RegExp("^([a-zA-Z'\\s_-]*) is in edit and may not be in a position to respond.$"),
          new RegExp("^([a-zA-Z'\\s_-]*) is arrested and can not respond.$"),
          new RegExp("^\\*You emote to ([a-zA-Z'\\s_-]*):(.*)$"),
          new RegExp("^([a-zA-Z'\\s_-]*) shouts in ([a-zA-Z'\\s_-]*):(.*)$"),
          new RegExp("^You shout in ([a-zA-Z'\\s_-]*):(.*)$")
        );
        if (this.client.getOption("chat.captureReviews"))
          this._captureReviews.push(new RegExp("^-=-=- Tell Review -=-=-$"));
      }
      if (this.client.getOption("chat.captureTalk")) {
        this._captures.push(
          new RegExp("^([a-zA-Z'\\s_-]*) says:(.*)$"),
          new RegExp("^You say:(.*)$"),
          new RegExp("^([a-zA-Z'\\s_-]*) whispers to you:(.*)$"),
          new RegExp("You whisper to ([a-zA-Z'\\s_-]*):(.*)"),
          new RegExp("^([a-zA-Z'\\s_-]*) yells:(.*)$"),
          new RegExp("^You yell:(.*)$"),
          new RegExp("You say in (.*):(.*)"),
          new RegExp("([a-zA-Z'\\s_-]*) says something in (.*)."),
          new RegExp("([a-zA-Z'\\s_-]*) says in (.*):(.*)")
        );
        if (this.client.getOption("chat.captureReviews"))
          this._captureReviews.push(new RegExp("^-=-=- Say Review -=-=-$"));
      }
      if (this.client.getOption("chat.captureLines")) {
        if (this.client.getOption("chat.captureAllLines")) {
          this._captures.push(new RegExp("^\\[(.*)\\](.*)$"));
          if (this.client.getOption("chat.captureReviews"))
            this._captureReviews.push(new RegExp("^-=-=- ((?:(?!\\b(Say|Tell|End)\\b).)+) Review -=-=-$"));
        } else {
          const lines = this.client.getOption("chat.lines");
          for (var l2 = 0, ll = lines.length; l2 < ll; l2++) {
            if (lines[l2].trim().length === 0) continue;
            this._captures.push(new RegExp("\\[" + lines[l2].trim() + "\\](.*)", "i"));
            if (this.client.getOption("chat.captureReviews"))
              this._captureReviews.push(new RegExp("^-=-=- " + lines[l2].trim() + " Review -=-=-$", "i"));
          }
        }
      }
    }
    updateChat(data) {
      if (typeof data === "string") {
        let display;
        let line2 = -1;
        if (this._dialog && this._dialog.opened) {
          line2 = this._dialog.display.lines.length - 1;
          this._dialog.display.append(data);
          display = this._dialog.display;
        }
        if (this._window && !this._window.closed) {
          if (!display) line2 = this._dialog.display.lines.length - 1;
          this._window.display.append(data);
          display = display || this._window.display;
        }
        if (display) {
          if (line2 < 0) line2 = 0;
          data = Object.assign({ fragment: display.EndOfLine, line: display.lines[line2].text }, display.lines[line2]);
        } else
          data = {
            line: data,
            formats: [{
              formatType: 0,
              offset: 0,
              color: 37,
              background: 40,
              size: 0,
              font: 0,
              style: 0,
              unicode: false
            }],
            raw: data,
            timestamp: Date.now()
          };
      } else {
        if (this._dialog && this._dialog.opened)
          this._dialog.display.model.addParserLine(data);
        if (this._window && !this._window.closed)
          this._window.display.model.addParserLine(data);
      }
      if (this.client.getOption("chat.log"))
        this._post({ action: "add-line", args: data });
    }
    _getWindowState() {
      let state = Object.assign({}, { show: false, width: 640, height: 480, x: window.screenLeft + 200, y: window.screenTop + 200 }, this.client.getOption("windows.chatWindow"));
      if (this._window && !this._window.closed) {
        state.width = this._window.document.body.clientWidth;
        state.height = this._window.document.body.clientHeight;
        state.x = this._window.screenLeft || this._window.screenX;
        state.y = this._window.screenTop || this._window.screenY;
      }
      return state;
    }
    _buildToolbar(doc, display) {
      const toolbar = doc.createElement("nav");
      toolbar.id = "chat-toolbar";
      toolbar.classList.add("navbar", "bg-light", "align-items-center");
      toolbar.innerHTML = `<form class="container-fluid justify-content-start"><button id="btn-chat-clear" type="button" class="btn btn-sm btn-outline-secondary me-2 mb-1" title="Clear display"><i class="bi bi-trash"></i></button><button id="btn-chat-lock" type="button" class="btn btn-sm btn-outline-secondary me-2 mb-1" title="Lock display"><i class="bi bi-lock-fill"></i></button><div class="vr me-2" style="height: 29px;"></div><button id="btn-chat-log" type="button" class="btn btn-sm btn-outline-secondary me-2 mb-1" title="Log chat"><i class="bi bi-file-text"></i></button><div class="vr me-2" style="height: 29px;"></div><button id="btn-chat-wrap" type="button" class="btn btn-sm btn-outline-secondary me-2 mb-1" title="Toggle word wrap"><i class="bi bi-text-wrap"></i></button></form>`;
      toolbar.querySelector("#btn-chat-clear").addEventListener("click", () => {
        display.clear();
      });
      toolbar.querySelector("#btn-chat-lock").addEventListener("click", () => {
        this.client.setOption("chat.scrollLocked", !this.client.getOption("chat.scrollLocked"));
        if (this._window) {
          this._window.display.scrollLock = this.client.getOption("chat.scrollLocked");
          this._updateScrollLockButton(this._window.document.querySelector("#btn-chat-lock"), this.client.getOption("chat.scrollLocked"));
        }
        if (this._dialog) {
          this._dialog.display.scrollLock = this.client.getOption("chat.scrollLocked");
          this._updateScrollLockButton(this._dialog.body.querySelector("#btn-chat-lock"), this.client.getOption("chat.scrollLocked"));
        }
      });
      toolbar.querySelector("#btn-chat-log").addEventListener("click", () => {
        this.client.setOption("chat.log", !this.client.getOption("chat.log"));
        if (this.client.getOption("chat.log"))
          this._createLogger();
        if (this._window)
          this._updateButtonState(this._window.document.querySelector("#btn-chat-log"), this.client.getOption("chat.log"));
        if (this._dialog)
          this._updateButtonState(this._dialog.body.querySelector("#btn-chat-log"), this.client.getOption("chat.log"));
        if (this._logger)
          this._post({ action: "toggle" });
      });
      toolbar.querySelector("#btn-chat-wrap").addEventListener("click", () => {
        this.client.setOption("chat.wrap", !this.client.getOption("chat.wrap"));
        if (this._window) {
          this._updateButtonState(this._window.document.querySelector("#btn-chat-wrap"), this.client.getOption("chat.wrap"));
          this._window.display.wordWrap = this.client.getOption("chat.wrap");
        }
        if (this._dialog) {
          this._updateButtonState(this._dialog.body.querySelector("#btn-chat-wrap"), this.client.getOption("chat.wrap"));
          this._dialog.display.wordWrap = this.client.getOption("chat.wrap");
        }
      });
      this._updateScrollLockButton(toolbar.querySelector("#btn-chat-lock"), this.client.getOption("chat.scrollLocked"));
      this._updateButtonState(toolbar.querySelector("#btn-chat-wrap"), this.client.getOption("chat.wrap"));
      this._updateButtonState(toolbar.querySelector("#btn-chat-log"), this.client.getOption("chat.log"));
      return toolbar;
    }
    _updateScrollLockButton(button, state) {
      if (!button) return;
      let icon = button.firstElementChild;
      if (state) {
        button.title = "Unlock display";
        button.classList.add("active");
        icon.classList.add("bi-unlock-fill");
        icon.classList.remove("bi-lock-fill");
      } else {
        button.title = "Lock display";
        button.classList.remove("active");
        icon.classList.remove("bi-unlock-fill");
        icon.classList.add("bi-lock-fill");
      }
    }
    _updateButtonState(button, state) {
      if (!button) return;
      if (state)
        button.classList.add("active");
      else
        button.classList.remove("active");
    }
    showWindow() {
      if (!this._window || this._window.closed) {
        let state = this._getWindowState();
        this._window = window.open("window.htm", "chat-window", "toolbar=no,location=no,directories=no,status=no,menubar=no,scrollbars=yes,resizable=yes,width=" + state.width + ",height=" + state.height + ",top=" + state.y + ",left=" + state.x);
        state.show = true;
        this._window.addEventListener("resize", () => {
          this.client.setOption("windows.chatWindow", this._getWindowState());
          debounce(() => {
            this._window.display.container.style.top = this._window.document.getElementById("chat-toolbar").offsetHeight + "px";
          }, 25, "chat-resize");
        });
        this._window.addEventListener("focus", () => {
          this.client.setOption("windows.chatWindow", this._getWindowState());
        });
        this._window.addEventListener("blur", () => {
          this.client.setOption("windows.chatWindow", this._getWindowState());
        });
        this._window.addEventListener("load", () => {
          this._window.document.querySelector("head").insertAdjacentHTML("afterbegin", `<<link id="icon1" rel="shortcut icon" href="images/chat.png" /><link id="icon2" rel="icon" href="images/chat.png" /><link id="icon3" rel="icon" type="image/x-icon" href="images/chat.png" /><link href="oiMUD.min.css" rel="stylesheet" type="text/css">>`);
          this._window.document.title = "Chat";
          let el = this._window.document.createElement("div");
          el.id = "chat-display";
          this._window.document.body.append(el);
          this._window.display = new Display(el);
          this._loadDisplayOptions(this._window.display);
          this._loadWindowOptions(this._window.document);
          const toolbar = this._buildToolbar(this._window.document, this._window.display);
          this._window.document.body.appendChild(toolbar);
          this._window.focus();
        });
      }
    }
    showDialog() {
      if (!this._dialog) {
        this._dialog = new Dialog(Object.assign({}, this.client.getOption("windows.chat") || { center: true }, { title: '<i class="bi bi-chat"></i> Chat', minWidth: 410, noFooter: true, id: "chat-dialog" }));
        this._dialog.header.querySelector("#chat-dialog-max").insertAdjacentHTML("afterend", '<button type="button" class="btn btn-light float-end" id="chat-dialog-window" title="Open chat window" style="padding: 0 4px;margin-top: -1px;"><i class="bi bi-window"></i></button>');
        this._dialog.header.querySelector("#chat-dialog-window").addEventListener("click", () => {
          this.showWindow();
        });
        let el = document.createElement("div");
        el.id = "chat-display";
        this._dialog.body.append(el);
        this._dialog.display = new Display(el);
        this._loadDisplayOptions(this._dialog.display);
        this._loadWindowOptions(this._dialog.body);
        const toolbar = this._buildToolbar(document, this._dialog.display);
        this._dialog.body.appendChild(toolbar);
        this._dialog.on("resized", (e) => {
          this.client.setOption("windows.chat", e);
          debounce(() => {
            el.style.top = toolbar.offsetHeight + "px";
          }, 25, "chat-resize");
        });
        this._dialog.on("closed", () => {
          this.client.setOption("windows.chat", this._dialog.windowState);
          removeHash("chat");
          this.client.setOption("showChat", false);
        });
        this._dialog.on("canceled", () => {
          this.client.setOption("windows.chat", this._dialog.windowState);
          removeHash("chat");
          this.client.setOption("showChat", false);
        });
        this._dialog.on("moved", (e) => {
          this.client.setOption("windows.chat", e);
        });
        this._dialog.on("maximized", () => {
          this.client.setOption("windows.chat", this._dialog.windowState);
        });
        this._dialog.on("restored", () => {
          this.client.setOption("windows.chat", this._dialog.windowState);
        });
        this._dialog.on("shown", () => {
          this.client.setOption("windows.chat", this._dialog.windowState);
          this.client.setOption("showChat", true);
        });
      }
      this._dialog.show();
    }
    show() {
      if ((this.client.getOption("showChatWindow") & 1 /* window */) == 1 /* window */)
        this.showWindow();
      if (this.client.getOption("showChat") || (this.client.getOption("showChatWindow") & 2 /* dialog */) == 2 /* dialog */)
        this.showDialog();
    }
    toggleDialog() {
      if (this._dialog && this._dialog.opened)
        this._dialog.close();
      else
        this.showDialog();
    }
    _getLogger() {
      if (this._loggerPlugin) return;
      for (let p = 0, pl = this.client.plugins.length; p < pl; p++) {
        if (this.client.plugins[p] instanceof Logger) {
          this._loggerPlugin = this.client.plugins[p];
          return;
        }
      }
    }
    _createLogger() {
      if (this._logger || !client.getOption("chat.log")) return;
      this._getLogger();
      if (!this._loggerPlugin) return;
      this._logger = this._loggerPlugin.createLogger();
      this._logger.addEventListener("message", (e) => {
        switch (e.data.event) {
          case "started":
            this.client.setOption("chat.log", true);
            if (this._window)
              this._updateButtonState(this._window.document.querySelector("#btn-chat-log"), true);
            if (this._dialog)
              this._updateButtonState(this._dialog.body.querySelector("#btn-chat-log"), true);
            break;
          case "stopped":
            this.client.setOption("chat.log", false);
            if (this._window)
              this._updateButtonState(this._window.document.querySelector("#btn-chat-log"), false);
            if (this._dialog)
              this._updateButtonState(this._dialog.body.querySelector("#btn-chat-log"), false);
            this._post({ action: "flush" });
            this._logger.terminate();
            this._logger = null;
            break;
          case "logging":
            break;
          case "error":
            this.client.error(e.data.args);
            break;
          case "debug":
            if (!this.client)
              console.log(e.data.args);
            else if (this.client.getOption("enableDebug"))
              this.client.debug(e.data.args);
            break;
          case "toggled":
            if (this.client)
              this.client.setOption("chat.log", e.data.args);
            if (this._window)
              this._updateButtonState(this._window.document.querySelector("#btn-chat-log"), e.data.args);
            if (this._dialog)
              this._updateButtonState(this._dialog.body.querySelector("#btn-chat-log"), e.data.args);
            if (!e.data.args) {
              this._post({ action: "flush" });
              this._logger.terminate();
              this._logger = null;
            }
            break;
          case "startInternal":
          case "start":
            if (this._dialog && this._dialog.opened)
              this._post({ action: e.data.event, args: { lines: this._dialog.display.lines, fragment: this._dialog.display.EndOfLine } });
            else if (this._window && !this._window.closed)
              this._post({ action: e.data.event, args: { lines: this._window.display.lines, fragment: this._window.display.EndOfLine } });
            else
              this._post({ action: e.data.event });
            break;
          case "write":
            this._getLogger();
            if (!this._loggerPlugin) return;
            this._loggerPlugin.updateKey(e.data);
            localforage.getItem("OoMUDLog" + e.data.file).then((value) => {
              if (!value) value = "";
              value += e.data.data;
              localforage.setItem("OoMUDLog" + e.data.file, value).then(() => {
                if (this._loggerPlugin.manager) this._loggerPlugin.manager.logChanged(e.data.file, e.data.data);
                this._post({ action: "write-done", file: e.data.file });
              });
            });
            break;
        }
      });
      this._logger.addEventListener("error", (e) => {
        if (!this.client)
          console.error(e);
        else
          this.client.error(e);
      });
      this._post({
        action: "options",
        args: {
          offline: client.getOption("logOffline"),
          gagged: client.getOption("logGagged"),
          enabled: client.getOption("chat.log"),
          unique: client.getOption("logUniqueOnConnect"),
          prepend: client.getOption("logPrepend"),
          what: client.getOption("logWhat"),
          debug: client.getOption("enableDebug"),
          postfix: ".chat",
          format: client.getOption("logTimeFormat"),
          timestamp: client.getOption("logTimestamp"),
          timestampFormat: client.getOption("logTimestampFormat")
        }
      });
    }
    _post(data) {
      if (!this._logger) return;
      this._logger.postMessage(data);
    }
    _loadDisplayOptions(display) {
      display.updateFont(client.getOption("chat.font"), client.getOption("chat.fontSize"));
      display.maxLines = client.getOption("chat.bufferSize");
      display.enableFlashing = client.getOption("chat.flashing");
      display.showTimestamp = client.getOption("chat.showTimestamp");
      display.timestampFormat = client.getOption("chat.timestampFormat");
      display.enableMXP = client.getOption("enableMXP");
      display.enableURLDetection = client.getOption("enableURLDetection");
      display.showInvalidMXPTags = client.getOption("display.showInvalidMXPTags");
      display.hideTrailingEmptyLine = client.getOption("display.hideTrailingEmptyLine");
      display.enableColors = client.getOption("chat.enableColors");
      display.enableBackgroundColors = client.getOption("chat.enableBackgroundColors");
      display.tabWidth = client.getOption("chat.tabWidth");
      display.displayControlCodes = client.getOption("chat.displayControlCodes");
      display.emulateTerminal = client.getOption("chat.emulateTerminal");
      display.emulateControlCodes = client.getOption("chat.emulateControlCodes");
      display.wordWrap = client.getOption("chat.wordWrap");
      display.wrapAt = client.getOption("chat.wrapAt");
      display.indent = client.getOption("chat.indent");
      display.scrollLock = client.getOption("chat.scrollLocked");
      display.scrollDisplay();
    }
    _loadWindowOptions(target) {
      this._updateScrollLockButton(target.querySelector("#btn-chat-lock"), this.client.getOption("chat.scrollLocked"));
      this._updateButtonState(target.querySelector("#btn-chat-wrap"), this.client.getOption("chat.wrap"));
      this._updateButtonState(target.querySelector("#btn-chat-log"), this.client.getOption("chat.log"));
    }
    _loadOptions() {
      if (this._dialog) {
        this._dialog.resetState(client.getOption("windows.chat") || { center: true });
        this._loadDisplayOptions(this._dialog.display);
        this._loadWindowOptions(this._dialog.body);
      }
      if (this._window) {
        this._loadDisplayOptions(this._window.display);
        this._loadWindowOptions(this._window.document);
      }
      if (this._logger)
        this._post({
          action: "options",
          args: {
            offline: client.getOption("logOffline"),
            gagged: client.getOption("logGagged"),
            enabled: client.getOption("chat.log"),
            unique: client.getOption("logUniqueOnConnect"),
            prepend: client.getOption("logPrepend"),
            what: client.getOption("logWhat"),
            debug: client.getOption("enableDebug"),
            prefix: "chat.",
            format: client.getOption("logTimeFormat"),
            timestamp: client.getOption("logTimestamp"),
            timestampFormat: client.getOption("logTimestampFormat")
          }
        });
      else
        this._createLogger();
      if (this._dialog && this._dialog.opened)
        this._post({ action: "start", args: { lines: this._dialog.display.lines, fragment: this._dialog.display.EndOfLine } });
      else if (this._window && !this._window.closed)
        this._post({ action: "start", args: { lines: this._window.display.lines, fragment: this._window.display.EndOfLine } });
      else
        this._post({ action: "start" });
    }
  };

  // src/plugins/ShadowMUD/backup.ts
  var Backup = class extends EventEmitter {
    constructor(client2) {
      super();
      this._port = 1034;
      this._abort = false;
      this.client = client2;
      this.initialize();
    }
    remove() {
      this.client.removeListenersFromCaller(this);
    }
    initialize() {
      this.client.telnet.GMCPSupports.push("Client 1");
      this.client.on("connected", () => {
        this._port = this.client.port;
        this._closeDialog();
        this._save = 0;
        this._abort = false;
      }, this);
      this.client.on("closed", () => {
        this._port = this.client.port;
        this._closeDialog();
        this._save = 0;
        this._abort = false;
      }, this);
      this.client.on("received-GMCP", async (mod, obj) => {
        if (mod.toLowerCase() !== "client" || !obj) return;
        this._getMapper();
        switch (obj.action) {
          case "save":
            if (this._abort) return;
            this._user = obj.user;
            this._showDialog("Saving data");
            this._abort = false;
            if (this._mapper && this._mapper.map.changed) {
              this._mapper.map.save().then(() => {
                this.save(2);
              });
            } else
              this.save(2);
            break;
          case "load":
            this.client.debug(`Starting load
    Chunks: ${obj.chunks}
    Start chunk: ${obj.chunk}
    Size: ${obj.size}
`);
            this._abort = false;
            this._user = obj.user;
            this._save = [obj.chunks || 1, obj.chunk || 0, obj.size, ""];
            this._showDialog("Loading data");
            if (this._mapper && this._mapper.map.changed) {
              this._mapper.map.save().then(() => {
                this.getChunk();
              });
            } else
              this.getChunk();
            break;
          case "error":
            this.abort(obj.error);
            break;
        }
      });
      this._port = this.client.port;
    }
    get URL() {
      if (this._port === 1039)
        return "http://shadowmud.com:1132/client";
      return "http://shadowmud.com:1130/client";
    }
    save(version2) {
      Map.load().then((map) => {
        const data = {
          version: 2,
          profiles: this.client.profiles.clone(2),
          settings: new Settings(),
          map: map ? map.Rooms : {}
        };
        let keys, k;
        const saveSelection = this.client.getOption("backupSave");
        if ((saveSelection & 2 /* Map */) !== 2 /* Map */) {
          delete data.map;
          this.client.debug("Backup save: setting for no mapper data enabled.");
        }
        if ((saveSelection & 4 /* Profiles */) !== 4 /* Profiles */) {
          delete data.profiles;
          this.client.debug("Backup save: setting for no profiles enabled.");
        }
        if ((saveSelection & 16 /* Windows */) !== 16 /* Windows */) {
          keys = Object.keys(data.settings);
          for (k = keys.length - 1; k >= 0; k--) {
            if (keys[k].startsWith("windows."))
              delete data.settings[keys[k]];
          }
          this.client.debug("Backup save: setting for no window data enabled.");
        }
        if ((saveSelection & 8 /* Settings */) !== 8 /* Settings */) {
          let windows;
          if ((saveSelection & 16 /* Windows */) === 16 /* Windows */) {
            windows = {};
            keys = Object.keys(data.settings);
            for (k = keys.length - 1; k >= 0; k--) {
              if (keys[k].startsWith("windows."))
                windows[keys[k]] = data.settings[keys[k]];
            }
          }
          delete data.settings;
          if ((saveSelection & 16 /* Windows */) === 16 /* Windows */)
            data.settings = windows;
          this.client.debug("Backup save: setting for no settings data enabled.");
        } else {
          let props = ["chat", "mapper", "profiles", "codeEditor", "buttons", "find", "display", "extensions"];
          for (let p = 0, pl = props.length; p < pl; p++) {
            let prop = {};
            if (data.settings[props[p]])
              prop = data.settings[props[p]];
            let sProp = props[p] + ".";
            keys = Object.keys(data.settings);
            for (k = keys.length - 1; k >= 0; k--) {
              if (keys[k].startsWith(sProp))
                prop[keys[k].substring(sProp.length)] = data.settings[keys[k]];
            }
            data.settings[props[p]] = prop;
          }
        }
        let jData = JSON.stringify(data);
        jData = LZString.compressToEncodedURIComponent(jData);
        this._save = [jData.match(/((\S|\s|.){1,20000})/g), 0, 0];
        this._save[3] = this._save[0].length;
        this.saveChunk();
      }).catch((err) => this.client.error(err));
    }
    abort(err) {
      if (err)
        this.client.debug("client load/save aborted for" + err);
      else
        this.client.debug("client load/save aborted");
      this._closeDialog();
      alert_box("Aborted", err || "Aborted importing or exporting data.", 4 /* exclamation */);
      this._save = 0;
      this._abort = true;
      $.ajax({
        type: "POST",
        url: this.URL,
        data: {
          user: this._user,
          a: "abort"
        }
      });
    }
    close() {
      this._closeDialog();
      this._save = 0;
      this._abort = false;
      $.ajax({
        type: "POST",
        url: this.URL,
        data: {
          user: this._user,
          a: "done"
        }
      });
    }
    getChunk() {
      this.client.debug("Requesting client chunk " + this._save[1]);
      $.ajax(
        {
          type: "POST",
          url: this.URL,
          data: {
            user: this._user,
            a: "get",
            c: ++this._save[1]
          },
          dataType: "json",
          success: (data) => {
            if (this._abort) return;
            if (!data)
              this.abort("No data returned");
            else if (data.msg)
              this.abort(data.msg || "Error");
            else if (data.error)
              this.abort(data.error);
            else {
              this._save[1] = data.chunk || 0;
              this._save[3] += data.data || "";
              this.client.debug("Got client chunk " + this._save[1]);
              this._updateProgress((this._save[1] + 1) / this._save[0] * 100);
              if (this._save[1] >= this._save[0] - 1)
                this.finishLoad();
              else
                this.getChunk();
            }
          },
          error: (data, error, errorThrown) => {
            this.abort(error);
          }
        }
      );
    }
    saveChunk() {
      $.ajax(
        {
          type: "POST",
          url: this.URL,
          data: {
            user: this._user,
            a: "save",
            data: this._save[0].shift(),
            append: this._save[1] > 0 ? 1 : 0
          },
          dataType: "json",
          success: (data) => {
            if (!data)
              this.abort("No data returned");
            else if (data.msg !== "Successfully saved")
              this.abort(data.msg || "Error");
            else if (data.error)
              this.abort(data.error);
            else if (this._save[0].length > 0) {
              this._updateProgress(this._save[1] / this._save[3] * 100);
              this._save[1]++;
              this.saveChunk();
            } else {
              if (typeof this._save[2] === "function") this._save[2]();
              client.raise("backup-saved");
              this.close();
            }
          },
          error: (data, error, errorThrown) => {
            this.abort(error);
          }
        }
      );
    }
    finishLoad() {
      this.client.debug("Got last chunk, processing data");
      let data = LZString.decompressFromEncodedURIComponent(this._save[3]);
      data = JSON.parse(data);
      if (data.version === 2) {
        const loadSelection = this.client.getOption("backupLoad");
        if (data.map && (loadSelection & 2 /* Map */) === 2 /* Map */)
          this._mapper.import(data.map, client.getOption("mapper.importType"));
        if (data.profiles && (loadSelection & 4 /* Profiles */) === 4 /* Profiles */) {
          const profiles = new ProfileCollection();
          const keys2 = Object.keys(data.profiles);
          const kl = keys2.length;
          let n;
          let k2 = 0;
          for (; k2 < kl; k2++) {
            n = keys2[k2];
            const p = new Profile(n);
            p.priority = data.profiles[keys2[k2]].priority;
            p.enabled = data.profiles[keys2[k2]].enabled ? true : false;
            p.enableMacros = data.profiles[keys2[k2]].enableMacros ? true : false;
            p.enableTriggers = data.profiles[keys2[k2]].enableTriggers ? true : false;
            p.enableAliases = data.profiles[keys2[k2]].enableAliases ? true : false;
            p.enableDefaultContext = data.profiles[keys2[k2]].enableDefaultContext ? true : false;
            p.macros = [];
            let l2 = data.profiles[keys2[k2]].macros.length;
            let item;
            if (l2 > 0) {
              for (let m = 0; m < l2; m++) {
                item = new Macro();
                item.key = data.profiles[keys2[k2]].macros[m].key;
                item.value = data.profiles[keys2[k2]].macros[m].value;
                item.style = data.profiles[keys2[k2]].macros[m].style;
                item.append = data.profiles[keys2[k2]].macros[m].append ? true : false;
                item.send = data.profiles[keys2[k2]].macros[m].send ? true : false;
                item.name = data.profiles[keys2[k2]].macros[m].name;
                item.group = data.profiles[keys2[k2]].macros[m].group;
                item.enabled = data.profiles[keys2[k2]].macros[m].enabled ? true : false;
                item.modifiers = data.profiles[keys2[k2]].macros[m].modifiers;
                item.chain = data.profiles[keys2[k2]].macros[m].chain ? true : false;
                item.notes = data.profiles[keys2[k2]].macros[m].notes || "";
                p.macros.push(item);
              }
            }
            l2 = data.profiles[keys2[k2]].aliases.length;
            if (l2 > 0) {
              for (let m = 0; m < l2; m++) {
                item = new Alias();
                item.pattern = data.profiles[keys2[k2]].aliases[m].pattern;
                item.value = data.profiles[keys2[k2]].aliases[m].value;
                item.style = data.profiles[keys2[k2]].aliases[m].style;
                item.multi = data.profiles[keys2[k2]].aliases[m].multi ? true : false;
                item.append = data.profiles[keys2[k2]].aliases[m].append ? true : false;
                item.name = data.profiles[keys2[k2]].aliases[m].name;
                item.group = data.profiles[keys2[k2]].aliases[m].group;
                item.enabled = data.profiles[keys2[k2]].aliases[m].enabled ? true : false;
                item.params = data.profiles[keys2[k2]].aliases[m].params;
                item.priority = data.profiles[keys2[k2]].aliases[m].priority;
                item.notes = data.profiles[keys2[k2]].aliases[m].notes || "";
                p.aliases.push(item);
              }
            }
            l2 = data.profiles[keys2[k2]].triggers.length;
            if (l2 > 0) {
              for (let m = 0; m < l2; m++) {
                item = new Trigger();
                item.pattern = data.profiles[keys2[k2]].triggers[m].pattern;
                item.value = data.profiles[keys2[k2]].triggers[m].value;
                item.style = data.profiles[keys2[k2]].triggers[m].style;
                item.verbatim = data.profiles[keys2[k2]].triggers[m].verbatim ? true : false;
                item.name = data.profiles[keys2[k2]].triggers[m].name;
                item.group = data.profiles[keys2[k2]].triggers[m].group;
                item.enabled = data.profiles[keys2[k2]].triggers[m].enabled ? true : false;
                item.priority = data.profiles[keys2[k2]].triggers[m].priority;
                item.triggerNewline = data.profiles[keys2[k2]].triggers[m].triggernewline ? true : false;
                item.caseSensitive = data.profiles[keys2[k2]].triggers[m].caseSensitive ? true : false;
                item.triggerPrompt = data.profiles[keys2[k2]].triggers[m].triggerprompt ? true : false;
                item.raw = data.profiles[keys2[k2]].triggers[m].raw ? true : false;
                item.temp = data.profiles[keys2[k2]].triggers[m].temp ? true : false;
                item.type = data.profiles[keys2[k2]].triggers[m].type;
                item.notes = data.profiles[keys2[k2]].triggers[m].notes || "";
                item.state = data.profiles[keys2[k2]].triggers[m].state || 0;
                item.params = data.profiles[keys2[k2]].triggers[m].params || "";
                item.fired = data.profiles[keys2[k2]].triggers[m].fired ? true : false;
                if (data.profiles[keys2[k2]].triggers[m].triggers && data.profiles[keys2[k2]].triggers[m].triggers.length) {
                  const il = data.profiles[keys2[k2]].triggers[m].triggers.length;
                  for (let i2 = 0; i2 < il; i2++) {
                    item.triggers.push(new Trigger(data.profiles[keys2[k2]].triggers[m].triggers[i2]));
                  }
                }
                p.triggers.push(item);
              }
            }
            if (data.profiles[keys2[k2]].buttons) {
              l2 = data.profiles[keys2[k2]].buttons.length;
              if (l2 > 0) {
                for (let m = 0; m < l2; m++) {
                  item = new Button(data.profiles[keys2[k2]].buttons[m]);
                  p.buttons.push(item);
                }
              }
            }
            if (data.profiles[keys2[k2]].contexts) {
              l2 = data.profiles[keys2[k2]].contexts.length;
              if (l2 > 0) {
                for (let m = 0; m < l2; m++) {
                  item = new Context(data.profiles[keys2[k2]].contexts[m]);
                  p.contexts.push(item);
                }
              }
            }
            profiles.add(p, true);
          }
          profiles.update();
          profiles.save().then(() => {
            this.client.loadProfiles();
          });
        }
        let keys, k;
        if ((loadSelection & 8 /* Settings */) === 8 /* Settings */) {
          this.client.setOption("mapper.enabled", data.settings.mapEnabled ? true : false);
          this.client.setOption("mapper.follow", data.settings.mapFollow ? true : false);
          this.client.setOption("mapper.legend", data.settings.legend ? true : false);
          this.client.setOption("mapper.split", data.settings.MapperSplitArea ? true : false);
          this.client.setOption("mapper.fill", data.settings.MapperFillWalls ? true : false);
          this.client.setOption("mapper.vscroll", data.settings.vscroll);
          this.client.setOption("mapper.hscroll", data.settings.hscroll);
          this.client.setOption("mapper.memory", data.settings.mapperMemory ? true : false);
          this.client.setOption("showScriptErrors", data.settings.showScriptErrors ? true : false);
          this.client.setOption("logWhat", data.settings ? 1 /* Html */ : 0 /* None */);
          this.client.setOption("showMapper", data.settings.MapperOpen ? true : false);
          let p, pl;
          for (p = 0, pl = SettingProperties.length; p < pl; p++) {
            let prop = SettingProperties[p];
            if (!data.settings.hasOwnProperty(prop)) {
              continue;
            }
            if (prop.startsWith("profiles.") || prop.startsWith("codeEditor.") || prop.startsWith("buttons.") || prop.startsWith("find.") || prop.startsWith("extensions.") || prop.startsWith("windows."))
              continue;
            this.client.setOption(prop, data.settings[prop]);
          }
          if (data.settings.windows && (loadSelection & 16 /* Windows */) === 16 /* Windows */) {
            if (data.settings["windows"]) {
              keys = Object.keys(data.settings["windows"]);
              for (k = keys.length - 1; k >= 0; k--) {
                this.client.setOption(`windows.${keys[k]}`, data.settings["windows"][keys[k]]);
              }
            }
            keys = Object.keys(data.settings);
            for (k = keys.length - 1; k >= 0; k--) {
              if (keys[k].startsWith("windows."))
                this.client.setOption(keys[k], data.settings[keys[k]]);
            }
          }
          let props = ["chat", "mapper", "profiles", "codeEditor", "buttons", "find", "display", "extensions"];
          for (p = 0, pl = props.length; p < pl; p++) {
            if (!data.settings[props[p]] || !data.settings.hasOwnProperty(props[p]))
              continue;
            keys = Object.keys(data.settings[props[p]]);
            for (k = keys.length - 1; k >= 0; k--) {
              this.client.setOption(`${props[p]}.${keys[k]}`, data.settings[props[p]][keys[k]]);
            }
          }
          this.client.clearCache();
          this.client.loadOptions();
        } else if (data.settings && (loadSelection & 16 /* Windows */) === 16 /* Windows */) {
          if (data.settings["windows"]) {
            keys = Object.keys(data.settings["windows"]);
            for (k = keys.length - 1; k >= 0; k--) {
              this.client.setOption(`windows.${keys[k]}`, data.settings["windows"][keys[k]]);
            }
          }
          keys = Object.keys(data.settings);
          for (k = keys.length - 1; k >= 0; k--) {
            if (keys[k].startsWith("windows."))
              this.client.setOption(keys[k], data.settings[keys[k]]);
          }
        }
      }
      client.raise("backup-loaded");
      this.close();
    }
    _showDialog(title) {
      if (this._dialogProgress)
        throw new Error("Client save/load is already in progress");
      this._dialogProgress = progress_box(title || "Saving data");
      this._dialogProgress.on("canceled", () => {
        this.abort();
      });
      this._dialogProgress.on("closed", (reason) => {
        if (reason === "canceled")
          this.abort();
      });
      this._dialogProgress.on("shown", () => {
      });
      this._dialogProgress.showModal();
    }
    _closeDialog() {
      if (this._dialogProgress)
        this._dialogProgress.close();
      this._dialogProgress = null;
    }
    _updateProgress(progress) {
      if (this._dialogProgress)
        this._dialogProgress.progress = progress;
    }
    _getMapper() {
      if (this._mapper) return;
      for (let p = 0, pl = this.client.plugins.length; p < pl; p++) {
        if (this.client.plugins[p] instanceof Mapper) {
          this._mapper = this.client.plugins[p];
          break;
        }
      }
    }
  };

  // src/plugins/ShadowMUD/shadowmud.ts
  var ShadowMUD = class extends Plugin {
    constructor(client2) {
      super(client2);
      this.backup = new Backup(client2);
    }
    remove() {
      this.backup.remove();
      this.client.removeListenersFromCaller(this);
    }
    initialize() {
      this.client.on("add-line", (data) => {
        if (!this._skipMoreTimeout && data.fragment && data.line.startsWith("--More--") && this.client.getOption("skipMore")) {
          this._skipMoreEvent = (data2) => {
            clearTimeout(this._skipMoreTimeout || 0);
            this._skipMoreTimeout = 0;
            this._skipMoreEvent = 0;
          };
          this.client.once("parse-command", this._skipMoreEvent, this);
          this._skipMoreTimeout = setTimeout(() => {
            this.client.removeListener("parse-command", this._skipMoreEvent);
            this._skipMoreTimeout = 0;
            this._skipMoreEvent = 0;
            this.client.sendCommand("\n");
          }, this.client.getOption("skipMoreDelay") >= 0 ? this.client.getOption("skipMoreDelay") : 0);
        }
      }, this);
    }
    get menu() {
      return [];
    }
    get settings() {
      return [{
        name: " ShadowMUD",
        action: "settings-shadowmud",
        icon: '<i class="shadowmud-icon"></i>'
      }];
    }
  };
  window.ShadowMUD = ShadowMUD;

  // src/client.ts
  var Client = class extends EventEmitter {
    constructor(options) {
      super();
      //#region Private properties
      this._enableDebug = false;
      this._itemCache = {
        triggers: null,
        aliases: null,
        macros: null,
        buttons: null,
        contexts: null,
        defaultContext: null,
        alarms: null,
        alarmPatterns: []
      };
      this._variables = {};
      this._options = {};
      //#endregion
      //#region Public properties
      this.active = true;
      this.connecting = false;
      this.version = version;
      this.connectTime = 0;
      this.disconnectTime = 0;
      this.lastSendTime = 0;
      this.defaultTitle = "oiMUD";
      this.errored = false;
      window.client = this;
      window.oiMUD = this;
      this._plugins = [];
      options = Object.assign({ display: "#display", commandInput: "#commandInput" }, options || {});
      if (!("display" in options) || typeof options.display === void 0)
        options.display = "#display";
      if (!("commandInput" in options) || typeof options.commandInput === void 0)
        options.commandInput = "#commandInput";
      this._display = new Display(options.display);
      this.display.on("click", (e) => {
        if (this.getOption("CommandonClick"))
          this._commandInput.focus();
      });
      this.display.on("scroll-lock", (lock) => {
        this.scrollLock = lock;
      });
      this.display.on("update-window", (width, height) => {
        this.telnet.updateWindow(width, height);
      });
      this.display.on("update-window", (width, height) => {
        this.telnet.updateWindow(width, height);
      });
      this.display.on("debug", (msg) => {
        this.debug(msg);
      });
      this.display.on("add-line", (data) => {
        this.emit("add-line", data);
      });
      this.display.on("add-line-done", (data) => {
        this.emit("add-line-done", data);
      });
      this.display.on("MXP-tag-reply", (tag, args) => {
        const e = { tag, args, preventDefault: false };
        this.emit("MXP-tag-reply", e);
        if (e.preventDefault)
          return;
        switch (tag) {
          case "VERSION":
            if (this.display.MXPStyleVersion && this.display.MXPStyleVersion.length) {
              this.debug(`MXP Tag REPLY: <VERSION MXP=1.0 STYLE=${this.display.MXPStyleVersion} CLIENT=jiMUD VERSION=${this.version} REGISTERED=no>`);
              this.send(`\x1B[1z<VERSION MXP=1.0 STYLE=${this.display.MXPStyleVersion} CLIENT=jiMUD VERSION=${this.version} REGISTERED=no>\r
`);
            } else {
              this.debug(`MXP Tag REPLY: <VERSION MXP=1.0 CLIENT=jiMUD VERSION=${this.version} REGISTERED=no>`);
              this.send(`\x1B[1z<VERSION MXP=1.0 CLIENT=jiMUD VERSION=${this.version} REGISTERED=no>\r
`);
            }
            break;
          case "SUPPORT":
            this.debug(`MXP Tag REPLY: <SUPPORTS ${args.join(" ")}>`);
            this.send(`\x1B[1z<SUPPORTS ${args.join(" ")}>\r
`);
            break;
          case "USER":
            this.emit("sendUsername", e);
            break;
          case "PASSWORD":
            this.emit("sendPassword", e);
            break;
        }
      });
      this.display.on("expire-links", (args) => {
        this.emit("expire-links", args);
      });
      this.display.on("parse-done", () => {
        this.emit("parse-done");
      });
      this.display.on("set-title", (title, type) => {
        if (typeof title === "undefined" || title == null || title.length === 0)
          this.emit("set-title", this.getOption("title").replace("$t", this.defaultTitle) || this.defaultTitle);
        else if (type !== 1)
          this.emit("set-title", this.getOption("title").replace("$t", title) || "");
      });
      this.display.on("music", (data) => {
        this.emit("music", data);
      });
      this.display.on("sound", (data) => {
        this.emit("sound", data);
      });
      this.display.on("bell", () => {
        this.emit("bell");
      });
      if (typeof options.commandInput === "string") {
        this._commandInput = document.querySelector(options.commandInput);
        if (!this._commandInput)
          throw new Error("Invalid selector for command input.");
      } else if (options.commandInput instanceof $)
        this._commandInput = options.commandInput[0];
      else if (options.commandInput instanceof HTMLElement)
        this._commandInput = options.commandInput;
      else
        throw new Error("Command input must be a selector, element or jquery object");
      this._telnet = new Telnet({ protocol: options.protocol, scheme: options.scheme });
      this._telnet.terminal = "oiMUD";
      this._telnet.version = this.version;
      this._telnet.GMCPSupports.push("oMUD 1");
      this._telnet.on("error", (err) => {
        if (this.enableDebug) this.debug(err);
        if (err) {
          if (err.type === "close" && err.code === 1006)
            return;
          const msg = [];
          if (err.type)
            msg.push(err.type);
          if (err.text)
            msg.push(err.text);
          if (err.message)
            msg.push(err.message);
          if (err.reason)
            msg.push(err.reason);
          if (err.code)
            this.error(err.code + " : " + msg.join(", "));
          else
            this.error(msg.join(", "));
        } else
          this.error("Unknown telnet error.");
        if (this.getOption("autoConnect") && !this._telnet.connected)
          setTimeout(() => {
            this.connect();
          }, client.getOption("autoConnectDelay"));
        this.emit("reconnect");
      });
      this.telnet.on("connecting", () => {
        this.connecting = true;
        this.echo("Trying to connect to " + this.host + ":" + this.port, -7 /* InfoText */, -8 /* InfoBackground */, true, true);
      });
      this.telnet.on("connect", () => {
        this.connecting = false;
        this.echo("Connected...", -7 /* InfoText */, -8 /* InfoBackground */, true, true);
        this.connectTime = Date.now();
        this.disconnectTime = 0;
        this.lastSendTime = Date.now();
        this.emit("connected");
        this.raise("connected");
      });
      this.telnet.on("debug", (msg) => {
        this.debug(msg);
      });
      this.telnet.on("receive-option", (data) => {
        this.emit("received-option", data);
      });
      this.telnet.on("close", () => {
        this.connecting = false;
        this.echo("Connection closed to " + this.host + ":" + this.port, -7 /* InfoText */, -8 /* InfoBackground */, true, true);
        this.disconnectTime = Date.now();
        this.emit("closed");
        this.raise("disconnected");
        this.connectTime = 0;
        this.lastSendTime = 0;
      });
      this.telnet.on("received-data", (data) => {
        data = { value: data };
        this.emit("received-data", data);
        if (data == null || typeof data === "undefined" || data.value == null || typeof data.value === "undefined")
          return;
        this._printInternal(data.value, false, true);
        this.debug("Latency: " + this.telnet.latency + "ms");
        this.debug("Latency: " + this.telnet.latency / 1e3 + "s");
      });
      this.telnet.on("received-MSDP", (data) => {
        this.emit("received-MSDP", data);
      });
      this.telnet.on("received-GMCP", (data) => {
        let val = data.value;
        let mod;
        let idx = 0;
        const dl = val.length;
        let c;
        if (dl === 0) return;
        for (idx = 0; idx < dl; idx++) {
          c = val.charAt(idx);
          if (c === " " || c === "{" || c === "[")
            break;
        }
        mod = val.substr(0, idx).trim();
        val = val.substr(idx).trim();
        this.debug("GMCP Module: " + mod);
        this.debug("GMCP Data: " + val);
        let obj;
        if (mod.toLowerCase() === "client.gui") {
          obj = val.split("/n");
          if (val.length >= 2) {
            obj = {
              version: parseInt(obj[0], 10),
              url: obj[1]
            };
          } else if (val.length > 0) {
            obj = {
              version: parseInt(obj[0], 10),
              url: obj[1]
            };
          } else
            obj = { version: obj, url: "" };
          this.emit("received-GMCP", mod, obj);
          return;
        }
        try {
          if (val.length > 0)
            obj = JSON.parse(val);
        } catch (e) {
          this.error("Invalid GMCP");
          return;
        }
        this.emit("received-GMCP", mod, obj);
      });
      this.telnet.on("windowSize", () => {
        this.UpdateWindow();
      });
      let tmp = getParameterByName("host");
      if (tmp !== null && tmp.length)
        this.host = tmp;
      else if (options && "host" in options)
        this.host = options.host;
      else
        this.host = "127.0.0.1";
      tmp = +getParameterByName("port");
      if (!isNaN(tmp) && tmp > 0)
        this.port = tmp;
      else if (options && "port" in options)
        this.port = options.port;
      else
        this.port = 23;
      this._input = new Input(this);
      this._input.on("scroll-lock", (lock) => {
        this.display.scrollLock = lock;
        this.emit("scroll-lock", lock);
      });
      this._input.on("command-history-changed", (history2) => this.emit("command-history-changed", history2));
      this._input.on("item-added", (type, profile, item) => {
        this.emit("item-added", type, profile, item);
      });
      this._input.on("item-updated", (type, profile, idx, item) => {
        this.emit("item-updated", type, profile, idx, item);
      });
      this._input.on("item-removed", (type, profile, idx) => {
        this.emit("item-removed", type, profile, idx);
      });
      this.loadOptions();
      this._commandInput.value = "";
      this._commandInput.focus();
      window.addEventListener("blur", () => {
        this.active = false;
        this.emit("blur");
        this.raise("blur");
      });
      window.addEventListener("focus", () => {
        this.active = true;
        this.emit("focus");
        this.raise("focus");
      });
      window.addEventListener("beforeunload", (e) => {
        if (this.connected) {
          if (e)
            e.returnValue = "Closing or reloading will disconnect you from the mud.";
          return "Closing or reloading will disconnect you from the mud.";
        }
        this.raise("closed");
      });
      window.addEventListener("unload", () => {
        if (this.connected)
          this.close();
      });
      this.addPlugin(new MSP(this));
      this.addPlugin(new Mapper(this));
      this.addPlugin(new Status(this));
      this.addPlugin(new Logger(this));
      this.addPlugin(new Chat(this));
      if (true)
        this.addPlugin(new Test(this));
      if (this.getOption("autoConnect"))
        setTimeout(() => {
          this.connect();
        }, client.getOption("autoConnectDelay"));
      this.emit("initialized");
    }
    //#endregion
    //#region Public setter/getters
    get telnet() {
      return this._telnet;
    }
    get variables() {
      return this._variables;
    }
    get commandInput() {
      return this._commandInput;
    }
    get display() {
      return this._display;
    }
    get profiles() {
      return this._profiles;
    }
    get plugins() {
      return this._plugins;
    }
    get options() {
      return this._options;
    }
    get input() {
      return this._input;
    }
    set simpleAlarms(value) {
      this.setOption("simpleAlarms", value);
    }
    get simpleAlarms() {
      return this.getOption("simpleAlarms");
    }
    set enableParsing(value) {
      this.setOption("enableParsing", value);
      this._input.enableParsing = value;
    }
    get enableParsing() {
      return this.getOption("enableParsing");
    }
    set enableTriggers(value) {
      this.setOption("enableTriggers", value);
      this._input.enableTriggers = value;
      this.startAlarms();
    }
    get enableTriggers() {
      return this.getOption("enableTriggers");
    }
    get enableDebug() {
      return this._enableDebug;
    }
    set enableDebug(enable) {
      this._enableDebug = enable;
      this._telnet.enableDebug = enable;
      this._display.enableDebug = enable;
    }
    get host() {
      return this._telnet.host;
    }
    set host(host) {
      this._telnet.host = host;
    }
    get port() {
      return this._telnet.port;
    }
    set port(port) {
      this._telnet.port = port;
    }
    get connected() {
      return this._telnet.connected;
    }
    get activeProfile() {
      return this._profiles.active;
    }
    get commandHistory() {
      return this._input.commandHistory;
    }
    get indices() {
      return this._input.indices;
    }
    get repeatnum() {
      return this._input.repeatnum;
    }
    get aliases() {
      if (this._itemCache.aliases)
        return this._itemCache.aliases;
      const keys = this.profiles.keys;
      const tmp = [];
      let k = 0;
      const kl = keys.length;
      if (kl === 0) return [];
      if (kl === 1) {
        if (!this.profiles.items[keys[0]].enabled || !this.profiles.items[keys[0]].enableAliases)
          this._itemCache.aliases = [];
        else
          this._itemCache.aliases = SortItemArrayByPriority(this.profiles.items[keys[k]].aliases);
        return this._itemCache.aliases;
      }
      for (; k < kl; k++) {
        if (!this.profiles.items[keys[k]].enabled || !this.profiles.items[keys[k]].enableAliases || this.profiles.items[keys[k]].aliases.length === 0)
          continue;
        tmp.push.apply(tmp, SortItemArrayByPriority(this.profiles.items[keys[k]].aliases));
      }
      this._itemCache.aliases = tmp;
      return this._itemCache.aliases;
    }
    get macros() {
      if (this._itemCache.macros)
        return this._itemCache.macros;
      const keys = this.profiles.keys;
      const tmp = [];
      let k = 0;
      const kl = keys.length;
      if (kl === 0) return [];
      if (kl === 1) {
        if (!this.profiles.items[keys[0]].enabled || !this.profiles.items[keys[0]].enableMacros)
          this._itemCache.macros = [];
        else
          this._itemCache.macros = SortItemArrayByPriority(this.profiles.items[keys[k]].macros);
        return this._itemCache.macros;
      }
      for (; k < kl; k++) {
        if (!this.profiles.items[keys[k]].enabled || !this.profiles.items[keys[k]].enableMacros || this.profiles.items[keys[k]].macros.length === 0)
          continue;
        tmp.push.apply(tmp, SortItemArrayByPriority(this.profiles.items[keys[k]].macros));
      }
      this._itemCache.macros = tmp;
      return this._itemCache.macros;
    }
    get triggers() {
      if (this._itemCache.triggers)
        return this._itemCache.triggers;
      const keys = this.profiles.keys;
      const tmp = [];
      let k = 0;
      const kl = keys.length;
      if (kl === 0) return [];
      if (kl === 1) {
        if (!this.profiles.items[keys[0]].enabled || !this.profiles.items[keys[0]].enableTriggers)
          this._itemCache.triggers = [];
        else
          this._itemCache.triggers = SortItemArrayByPriority(this.profiles.items[keys[0]].triggers);
        return this._itemCache.triggers;
      }
      for (; k < kl; k++) {
        if (!this.profiles.items[keys[k]].enabled || !this.profiles.items[keys[k]].enableTriggers || this.profiles.items[keys[k]].triggers.length === 0)
          continue;
        tmp.push.apply(tmp, SortItemArrayByPriority(this.profiles.items[keys[k]].triggers));
      }
      this._itemCache.triggers = tmp;
      return this._itemCache.triggers;
    }
    removeTrigger(trigger) {
      const keys = this.profiles.keys;
      let k = 0;
      const kl = keys.length;
      let idx = -1;
      if (kl === 0)
        return;
      if (kl === 1) {
        if (!this.profiles.items[keys[0]].enabled || !this.profiles.items[keys[0]].enableTriggers)
          return;
        idx = this.profiles.items[keys[k]].triggers.indexOf(trigger);
      } else
        for (; k < kl && idx !== -1; k++) {
          if (!this.profiles.items[keys[k]].enabled || !this.profiles.items[keys[k]].enableTriggers || this.profiles.items[keys[k]].triggers.length === 0)
            continue;
          idx = this.profiles.items[keys[k]].triggers.indexOf(trigger);
          if (idx !== -1)
            break;
        }
      if (idx === -1)
        return;
      this.profiles.items[keys[k]].triggers.splice(idx, 1);
      this._itemCache.triggers = null;
      if ((trigger.triggers.length || trigger.type === 3 /* Alarm */) && this._itemCache.alarms) {
        idx = this._itemCache.alarms.indexOf(trigger);
        if (idx !== -1) {
          this._itemCache.alarms.splice(idx, 1);
          this._itemCache.alarmPatterns.splice(idx, 1);
        }
      }
      this.saveProfiles();
      this.emit("item-removed", "trigger", keys[k], idx);
    }
    get alarms() {
      if (this._itemCache.alarms)
        return this._itemCache.alarms;
      const keys = this.profiles.keys;
      const tmp = [];
      let k = 0;
      const kl = keys.length;
      if (kl === 0) return [];
      if (kl === 1) {
        if (!this.profiles.items[keys[0]].enabled || !this.profiles.items[keys[0]].enableTriggers)
          this._itemCache.alarms = [];
        else
          this._itemCache.alarms = SortItemArrayByPriority(this.profiles.items[keys[k]].triggers).filter((a) => {
            if (a && a.enabled && a.triggers.length) {
              if (a.type === 3 /* Alarm */) return true;
              for (let s = 0, sl = a.triggers.length; s < sl; s++)
                if (a.triggers[s].enabled && a.triggers[s].type === 3 /* Alarm */)
                  return true;
              return false;
            }
            return a && a.enabled && a.type === 3 /* Alarm */;
          });
        this._itemCache.alarms.reverse();
        return this._itemCache.alarms;
      }
      for (; k < kl; k++) {
        if (!this.profiles.items[keys[k]].enabled || !this.profiles.items[keys[k]].enableTriggers || this.profiles.items[keys[k]].triggers.length === 0)
          continue;
        tmp.push.apply(tmp, SortItemArrayByPriority(this.profiles.items[keys[k]].triggers));
      }
      this._itemCache.alarms = tmp.filter((a) => {
        if (a && a.enabled && a.triggers.length) {
          if (a.type === 3 /* Alarm */) return true;
          for (let s = 0, sl = a.triggers.length; s < sl; s++)
            if (a.triggers[s].enabled && a.triggers[s].type === 3 /* Alarm */)
              return true;
          return false;
        }
        return a && a.enabled && a.type === 3 /* Alarm */;
      });
      this._itemCache.alarms.reverse();
      return this._itemCache.alarms;
    }
    get buttons() {
      if (this._itemCache.buttons)
        return this._itemCache.buttons;
      const keys = this.profiles.keys;
      const tmp = [];
      let k = 0;
      const kl = keys.length;
      if (kl === 0) return [];
      if (kl === 1) {
        if (!this.profiles.items[keys[0]].enabled || !this.profiles.items[keys[0]].enableButtons)
          this._itemCache.buttons = [];
        else
          this._itemCache.buttons = SortItemArrayByPriority(this.profiles.items[keys[k]].buttons);
        return this._itemCache.buttons;
      }
      for (; k < kl; k++) {
        if (!this.profiles.items[keys[k]].enabled || !this.profiles.items[keys[k]].enableButtons || this.profiles.items[keys[k]].buttons.length === 0)
          continue;
        tmp.push.apply(tmp, SortItemArrayByPriority(this.profiles.items[keys[k]].buttons));
      }
      this._itemCache.buttons = tmp;
      return this._itemCache.buttons;
    }
    get contexts() {
      if (this._itemCache.contexts)
        return this._itemCache.contexts;
      const keys = this.profiles.keys;
      const tmp = [];
      let k = 0;
      const kl = keys.length;
      if (kl === 0) return [];
      if (kl === 1) {
        if (!this.profiles.items[keys[0]].enabled || !this.profiles.items[keys[0]].enableContexts)
          this._itemCache.contexts = [];
        else
          this._itemCache.contexts = SortItemArrayByPriority(this.profiles.items[keys[k]].contexts);
        return this._itemCache.contexts;
      }
      for (; k < kl; k++) {
        if (!this.profiles.items[keys[k]].enabled || !this.profiles.items[keys[k]].enableContexts || this.profiles.items[keys[k]].contexts.length === 0)
          continue;
        tmp.push.apply(tmp, SortItemArrayByPriority(this.profiles.items[keys[k]].contexts));
      }
      this._itemCache.contexts = tmp;
      return this._itemCache["contexts"];
    }
    get defaultContext() {
      if (this._itemCache.defaultContext !== null)
        return this._itemCache.defaultContext;
      this._itemCache.defaultContext = this.profiles.defaultContext;
      return this._itemCache.defaultContext;
    }
    //#endregion    
    addPlugin(plugin) {
      if (!plugin) return;
      this.plugins.push(plugin);
      plugin.initialize();
    }
    removePlugin(plugin) {
      if (!this.plugins.length) return;
      const idx = this.plugins.indexOf(plugin);
      if (idx !== -1) {
        plugin.remove();
        this.plugins.splice(idx, 1);
      }
    }
    getVariable(name2) {
      return this.variables[name2];
    }
    setVariable(name2, value) {
      this.variables[name2] = value;
    }
    setVariables(variables) {
      const names = Object.keys(variables);
      if (names.length === 0) return;
      const nl = names.length;
      let name2;
      for (let n = 0; n < nl; n++) {
        name2 = names[n];
        this.variables[name2] = variables[name2];
      }
    }
    hasVariable(name2) {
      return this.variables.hasOwnProperty(name2);
    }
    removeVariable(name2) {
      if (!this.variables.hasOwnProperty(name2))
        return;
      delete this.variables[name2];
    }
    setHistoryIndex(index) {
      this._input.setHistoryIndex(index);
    }
    clearCommandHistory() {
      this._input.clearCommandHistory();
    }
    AddCommandToHistory(txt) {
      this._input.AddCommandToHistory(txt);
    }
    loadProfiles() {
      return new Promise((resolve) => {
        ProfileCollection.load().then((profiles) => {
          this._profiles = profiles;
          if (!this.profiles.contains("default")) {
            this.profiles.add(Profile.Default);
            this.saveProfiles();
          }
          this.clearCache();
          this.startAlarms();
          this.emit("profiles-loaded");
          resolve(this._profiles);
        });
      });
    }
    removeProfile(profile) {
      if (!profile) return;
      this.profiles.remove(profile);
      this.clearCache();
      this.startAlarms();
      this.emit("profile-removed", profile);
    }
    saveProfiles() {
      this._profiles.save();
      this.clearCache();
      this.emit("profiles-updated");
    }
    toggleProfile(profile) {
      this.profiles.toggle(profile);
      this.saveProfiles();
      this.clearCache();
      this.startAlarms();
      this.emit("profile-toggled", profile, this.profiles[profile].enabled);
    }
    startAlarms() {
      const al = this.alarms.length;
      if ((al === 0 || !this.getOption("enableTriggers")) && this._alarm) {
        clearInterval(this._alarm);
        this._alarm = null;
      } else if (al && !this._alarm)
        this._alarm = setInterval((client2) => {
          client2.process_alarms();
        }, 1e3, this);
    }
    setAlarmState(idx, state) {
      if (typeof idx === "object")
        idx = this.alarms.indexOf(idx);
      if (idx === -1 || idx >= this.alarms.length)
        return;
      let pattern = this._itemCache.alarmPatterns[idx];
      if (!pattern) {
        pattern = {};
        if (this.alarms[idx].type === 3 /* Alarm */)
          pattern[0] = Alarm.parse(this.alarms[idx]);
        for (let s = 0, sl = this.alarms[idx].triggers.length; s < sl; s++) {
          if (this.alarms[idx].triggers[s].enabled && this.alarms[idx].triggers[s].type === 3 /* Alarm */)
            pattern[s] = Alarm.parse(this.alarms[idx].triggers[s]);
        }
        this._itemCache.alarmPatterns[idx] = pattern;
      }
      for (const p in pattern) {
        if (!pattern.hasOwnProperty(p)) continue;
        if (state) {
          pattern[p].startTime += Date.now() - pattern[p].suspended;
          pattern[p].prevTime += Date.now() - pattern[p].suspended;
          if (pattern[p].tempTime)
            pattern[p].tempTime += Date.now() - pattern[p].suspended;
          pattern[p].suspended = 0;
        } else
          pattern[p].suspended = Date.now();
      }
    }
    setAlarmTempTime(idx, temp) {
      if (typeof idx === "object")
        idx = this.alarms.indexOf(idx);
      if (idx === -1 || idx >= this.alarms.length)
        return;
      let pattern = this._itemCache.alarmPatterns[idx];
      if (!pattern) {
        pattern = {};
        if (this.alarms[idx].type === 3 /* Alarm */)
          pattern[0] = Alarm.parse(this.alarms[idx]);
        for (let s = 0, sl = this.alarms[idx].triggers.length; s < sl; s++) {
          if (this.alarms[idx].triggers[s].enabled && this.alarms[idx].triggers[s].type === 3 /* Alarm */)
            pattern[s] = Alarm.parse(this.alarms[idx].triggers[s]);
        }
        this._itemCache.alarmPatterns[idx] = pattern;
      }
      if (pattern[0])
        pattern[0].setTempTime(temp);
    }
    restartAlarmState(idx, oldState, newState) {
      if (oldState === newState)
        return;
      if (typeof idx === "object")
        idx = this.alarms.indexOf(idx);
      if (idx === -1 || idx >= this.alarms.length)
        return;
      let pattern = this._itemCache.alarmPatterns[idx];
      if (!pattern) {
        pattern = {};
        if (this.alarms[idx].type === 3 /* Alarm */)
          pattern[0] = Alarm.parse(this.alarms[idx]);
        for (let s = 0, sl = this.alarms[idx].triggers.length; s < sl; s++) {
          if (this.alarms[idx].triggers[s].enabled && this.alarms[idx].triggers[s].type === 3 /* Alarm */)
            pattern[s] = Alarm.parse(this.alarms[idx].triggers[s]);
        }
        this._itemCache.alarmPatterns[idx] = pattern;
      }
      if (pattern[oldState])
        pattern[oldState].restart = Date.now();
      if (pattern[newState])
        pattern[newState].restart = Date.now();
    }
    getRemainingAlarmTime(idx) {
      if (typeof idx === "object")
        idx = this.alarms.indexOf(idx);
      if (idx === -1 || idx >= this.alarms.length)
        return 0;
      if (!this.alarms[idx].enabled)
        return 0;
      let pattern = this._itemCache.alarmPatterns[idx];
      if (!pattern) {
        pattern = {};
        if (this.alarms[idx].type === 3 /* Alarm */)
          pattern[0] = Alarm.parse(this.alarms[idx]);
        for (let s = 0, sl = this.alarms[idx].triggers.length; s < sl; s++) {
          if (this.alarms[idx].triggers[s].enabled && this.alarms[idx].triggers[s].type === 3 /* Alarm */)
            pattern[s] = Alarm.parse(this.alarms[idx].triggers[s]);
        }
        this._itemCache.alarmPatterns[idx] = pattern;
      }
      if (pattern[0]) {
        const alarm = pattern[0];
        const now = Date.now();
        const dNow = /* @__PURE__ */ new Date();
        let future = now;
        let fend = future + 9e7;
        let mod = 1e3;
        if (alarm.seconds !== -1)
          mod = 1e3;
        else if (alarm.minutes !== -1)
          mod = 6e4;
        else if (alarm.hours !== -1)
          mod = 36e5;
        if (alarm.tempTime) {
          if (alarm.tempTime - now > 0)
            return alarm.tempTime - now;
          return 0;
        } else {
          while (future < fend) {
            if (this._alarm_match(alarm, future, dNow))
              return future - now;
            future += mod;
            dNow.setTime(dNow.getTime() + mod);
          }
          return -1;
        }
      }
      return 0;
    }
    updateAlarms() {
      if (this._itemCache.alarmPatterns) {
        const old = this._itemCache.alarmPatterns;
        const oAlarms = this.alarms;
        this._itemCache.alarmPatterns = [];
        this._itemCache.alarms = null;
        const al = this.alarms.length;
        let idx = -1;
        for (let a = 0; a < al; a++) {
          idx = oAlarms.indexOf(this.alarms[a]);
          if (idx !== -1)
            this._itemCache.alarmPatterns[a] = old[idx];
        }
      }
      this.startAlarms();
    }
    process_alarms() {
      if (!this.getOption("enableTriggers"))
        return;
      let a = 0;
      let changed = false;
      const al = this.alarms.length;
      if (al === 0 && this._alarm) {
        clearInterval(this._alarm);
        this._alarm = null;
        return;
      }
      const patterns = this._itemCache.alarmPatterns;
      const now = Date.now();
      const alarms = this.alarms;
      const dNow = /* @__PURE__ */ new Date();
      for (a = al - 1; a >= 0; a--) {
        let trigger = alarms[a];
        const parent = trigger;
        if (!trigger.enabled) continue;
        if (trigger.state > trigger.triggers.length)
          trigger.state = 0;
        if (trigger.state !== 0 && trigger.triggers && trigger.triggers.length) {
          trigger = trigger.triggers[trigger.state - 1];
          while (!trigger.enabled && parent.state !== 0) {
            parent.state++;
            if (parent.state > parent.triggers.length) {
              parent.state = 0;
              trigger = trigger.triggers[parent.state - 1];
              break;
            }
            if (parent.state)
              trigger = trigger.triggers[parent.state - 1];
            else
              trigger = parent;
            changed = true;
          }
          if (changed) {
            if (this.getOption("saveTriggerStateChanges"))
              this.saveProfiles();
            this.emit("item-updated", "trigger", parent.profile.name, parent.profile.triggers.indexOf(parent));
          }
          if (!trigger.enabled) continue;
        }
        if (trigger.type === 131072 /* ReParse */ || trigger.type === 262144 /* ReParsePattern */) {
          const val = this._input.adjustLastLine(this.display.lines.length, true);
          const line2 = this.display.lines[val];
          a = this._input.TestTrigger(trigger, parent, a, line2, this.display.lines[val].raw || line2, val === this.display.lines.length - 1);
          continue;
        }
        if (trigger.type !== 3 /* Alarm */) continue;
        let alarm = patterns[a];
        if (!alarm) {
          try {
            patterns[a] = {};
            if (trigger.type === 3 /* Alarm */)
              patterns[a][0] = Alarm.parse(trigger);
            for (let s = 0, sl = trigger.triggers.length; s < sl; s++) {
              if (trigger.triggers[s].type === 3 /* Alarm */)
                patterns[a][s] = Alarm.parse(trigger.triggers[s]);
            }
          } catch (e) {
            patterns[a] = null;
            if (this.getOption("disableTriggerOnError")) {
              trigger.enabled = false;
              setTimeout(() => {
                this.saveProfiles();
                this.emit("item-updated", "trigger", parent.profile, parent.profile.triggers.indexOf(parent), parent);
              });
            }
            throw e;
          }
          alarm = patterns[a];
          if (!alarm) continue;
        }
        alarm = alarm[trigger.state];
        if (alarm.restart) {
          alarm.startTime = Date.now();
          alarm.prevTime = alarm.startTime;
          if (alarm.tempTime)
            alarm.tempTime += Date.now() - alarm.restart;
          alarm.restart = 0;
        }
        let match = true;
        if (alarm.tempTime) {
          match = now >= alarm.tempTime;
          if (match)
            alarm.tempTime = 0;
        } else
          match = this._alarm_match(alarm, now, dNow);
        if (match && !alarm.suspended) {
          alarm.prevTime = now;
          const state = parent.state;
          this._input.lastTriggered = alarm.pattern;
          this._input.ExecuteTrigger(trigger, [alarm.pattern], false, -a, null, null, parent);
          if (state !== parent.state)
            alarm.restart = Date.now();
          if (alarm.temp) {
            if (parent.triggers.length) {
              if (state === 0) {
                const item = parent.triggers.shift();
                item.state = state;
                item.priority = parent.priority;
                item.name = parent.name;
                item.profile = parent.profile;
                if (item.state > item.triggers.length)
                  item.state = 0;
                item.triggers = parent.triggers;
                alarms[a] = item;
                patterns[a] = null;
                this.saveProfiles();
                const idx = parent.profile.triggers.indexOf(parent);
                parent.profile.triggers[idx] = item;
                this.emit("item-updated", "trigger", parent.profile.name, idx, item);
              } else {
                parent.triggers.splice(state - 1, 1);
                patterns[a].splice(state - 1, 1);
                parent.state = state;
                if (parent.state > parent.triggers.length)
                  parent.state = 0;
                this.saveProfiles();
                const idx = parent.profile.triggers.indexOf(parent);
                this.emit("item-updated", "trigger", parent.profile.name, idx, parent);
              }
            } else {
              this._input.clearTriggerState(a);
              this.removeTrigger(parent);
            }
          }
          a = -this._input.cleanUpTriggerState(-a);
        }
      }
    }
    _alarm_match(alarm, now, dNow) {
      if (!alarm || alarm.suspended) return false;
      let match = true;
      let ts;
      let sec;
      let min;
      let hr;
      let hours;
      let minutes;
      let seconds;
      if (!moment || this.simpleAlarms) {
        ts = now - this.connectTime;
        if (ts < 1e3)
          return false;
        sec = Math.round(ts / 1e3);
        min = Math.floor(sec / 60);
        hr = Math.floor(min / 60);
        hours = hr;
        minutes = Math.floor(min % 60);
        seconds = Math.floor(sec % 60);
      } else {
        if (alarm.start)
          ts = moment.duration(now - this.connectTime);
        else
          ts = moment.duration(now - alarm.startTime);
        if (ts.asMilliseconds() < 1e3)
          return false;
        sec = Math.round(ts.asMilliseconds() / 1e3);
        min = Math.floor(sec / 60);
        hr = Math.floor(min / 60);
        hours = ts.hours();
        minutes = ts.minutes();
        seconds = ts.seconds();
      }
      if (alarm.hoursWildCard) {
        if (alarm.hours === 0)
          match = match && hours === 0;
        else if (alarm.hours !== -1)
          match = match && hr !== 0 && hr % alarm.hours === 0;
      } else if (alarm.hours !== -1)
        match = match && alarm.hours === (alarm.start ? hours : dNow.getHours());
      if (alarm.minutesWildcard) {
        if (alarm.minutes === 0)
          match = match && minutes === 0;
        else if (alarm.minutes !== -1)
          match = match && min !== 0 && min % alarm.minutes === 0;
      } else if (alarm.minutes !== -1)
        match = match && alarm.minutes === (alarm.start ? minutes : dNow.getMinutes());
      if (alarm.secondsWildcard) {
        if (alarm.seconds === 0)
          match = match && seconds === 0;
        else if (alarm.seconds !== -1)
          match = match && sec % alarm.seconds === 0;
      } else if (alarm.seconds !== -1)
        match = match && alarm.seconds === (alarm.start ? seconds : dNow.getSeconds());
      return match;
    }
    loadOptions() {
      this._options = new Settings();
      this.enableDebug = this._options.enableDebug;
      this.display.maxLines = this._options.bufferSize;
      this.display.enableFlashing = this._options.flashing;
      this.display.enableMXP = this._options.enableMXP;
      this.display.showInvalidMXPTags = this._options["display.showInvalidMXPTags"];
      this.display.enableURLDetection = this._options.enableURLDetection;
      this.display.enableMSP = this._options.enableMSP;
      this.display.enableColors = this._options["display.enableColors"];
      this.display.enableBackgroundColors = this._options["display.enableBackgroundColors"];
      this.display.wordWrap = this._options["display.wordWrap"];
      this.display.wrapAt = this._options["display.wrapAt"];
      this.display.indent = this._options["display.indent"];
      this.display.showTimestamp = this._options["display.showTimestamp"];
      this.display.tabWidth = this._options["display.tabWidth"];
      this.display.timestampFormat = this._options["display.timestampFormat"];
      const colors = this.getOption("colors");
      if (colors && colors.length > 0) {
        let c;
        const cl = colors.length;
        for (c = 0; c < cl; c++) {
          if (!colors[c] || colors[c].length === 0) continue;
          this.display.SetColor(c, colors[c]);
        }
      }
      if (this._telnet) {
        this._telnet.options.MCCP = this._options.enableMCCP;
        this._telnet.options.MXP = this._options.enableMXP;
        this._telnet.UTF8 = this._options.enableUTF8;
        this._telnet.options.ECHO = this._options.enableEcho;
        this._telnet.enableLatency = this._options.lagMeter;
        this._telnet.enablePing = this._options.enablePing;
      }
      this._input.scrollLock = this._options.scrollLocked;
      this._input.enableParsing = this._options.enableParsing;
      this._input.enableTriggers = this._options.enableTriggers;
      this.display.scrollLock = this._options.scrollLocked;
      this.display.hideTrailingEmptyLine = this._options["display.hideTrailingEmptyLine"];
      this.display.displayControlCodes = this.getOption("display.displayControlCodes");
      this.display.emulateTerminal = this.getOption("display.emulateTerminal");
      this.display.emulateControlCodes = this.getOption("display.emulateControlCodes");
      this._commandInput.wrap = this.getOption("commandWordWrap") ? "on" : "off";
      if (this.UpdateFonts) this.UpdateFonts();
      this.display.scrollDisplay();
      this.loadProfiles();
      this.emit("options-loaded");
    }
    setOption(name2, value) {
      if (name2 === -1 || name2 === "-1")
        return;
      this._options[name2] = value;
      Settings.setValue(name2, value);
      this.emit("option=changed", name2, value);
    }
    getOption(name2) {
      if (this._options && name2 in this._options)
        return this._options[name2];
      return this._options[name2] = Settings.getValue(name2);
    }
    UpdateFonts() {
      if (!this.display) return;
      this.display.updateFont(this._options.font + ", monospace", this._options.fontSize);
      this._commandInput.style.fontSize = this._options.cmdfontSize;
      this._commandInput.style.fontFamily = this._options.cmdfont + ", monospace";
    }
    parse(txt) {
      this._parseInternal(txt, false, false, true);
    }
    _parseInternal(txt, remote, force, prependSplit) {
      this.display.append(txt, remote, force, prependSplit);
    }
    error(err) {
      if (this.enableDebug) this.debug(err);
      let msg = "";
      if (err == null || typeof err === "undefined")
        err = new Error("Unknown");
      else if (typeof err === "string" && err.length === 0)
        err = new Error("Unknown");
      if (err.stack && this.getOption("showErrorsExtended"))
        msg = err.stack;
      else if (err instanceof Error || err instanceof TypeError)
        msg = err.name + ": " + err.message;
      else if (err.message)
        msg = err.message;
      else
        msg = "" + err;
      if (msg.match(/^.*Error: /g) || msg.match(/^.*Error - /g))
        this.echo(msg, -11 /* ErrorText */, -12 /* ErrorBackground */, true, true);
      else
        this.echo("Error: " + msg, -11 /* ErrorText */, -12 /* ErrorBackground */, true, true);
      if (this.getOption("logErrors")) {
        if (!this.getOption("showErrorsExtended")) {
          if (err.stack)
            msg = err.stack;
          else {
            err = new Error(err || msg);
            msg = err.stack;
          }
        } else if (!err.stack) {
          err = new Error(err || msg);
          msg = err.stack;
        }
        window.console.log((/* @__PURE__ */ new Date()).toLocaleString());
        window.console.log(msg);
        localforage.getItem("oiMUDErrorLog").then((value) => {
          localforage.setItem("oiMUDErrorLog", value = (value || "") + (/* @__PURE__ */ new Date()).toLocaleString() + "\n" + msg + "\n");
        }).catch((err2) => this.error(err2));
      }
      if (err === "Error: ECONNRESET - read ECONNRESET." && this.telnet.connected)
        this.close();
      this.raise("error", msg);
    }
    echo(str, fore, back, newline, forceLine) {
      if (str == null) str = "";
      if (newline == null) newline = false;
      if (forceLine == null) forceLine = false;
      if (fore == null) fore = -3 /* LocalEcho */;
      if (back == null) back = -4 /* LocalEchoBack */;
      const codes = "\x1B[0m" + this.display.CurrentAnsiCode() + "\n";
      str = "" + str;
      if (str.endsWith("\n"))
        str = str.substr(0, str.length - 1);
      if (this.telnet.prompt && forceLine) {
        this.print("\n\x1B[" + fore + ";" + back + "m" + str + codes, newline);
        this.telnet.prompt = false;
      } else
        this.print("\x1B[" + fore + ";" + back + "m" + str + codes, newline);
    }
    print(txt, newline) {
      this._printInternal(txt, newline, false, true);
    }
    _printInternal(txt, newline, remote, prependSplit) {
      if (txt == null || typeof txt === "undefined") return;
      if (newline == null) newline = false;
      if (remote == null) remote = false;
      if (newline && this.display.textLength > 0 && !this.display.EndOfLine && this.display.EndOfLineLength !== 0 && !this.telnet.prompt && !this.display.parseQueueEndOfLine)
        txt = "\n" + txt;
      this.emit("print");
      this._parseInternal(txt, remote, false, prependSplit);
    }
    send(data, echo) {
      this.telnet.sendData(data);
      this.lastSendTime = Date.now();
      if (echo && this.telnet.echo && this.getOption("commandEcho"))
        this.echo(data);
      else if (echo)
        this.echo("\n");
    }
    sendRaw(data) {
      this.telnet.sendData(data, true);
      this.lastSendTime = Date.now();
    }
    sendGMCP(data) {
      this.telnet.sendGMCP(data);
      this.lastSendTime = Date.now();
    }
    debug(str, style) {
      const data = { value: str };
      this.emit("debug", data);
      if (!this._enableDebug || data == null || typeof data === "undefined" || data.value == null || typeof data.value === "undefined" || data.value.length === 0)
        return;
      if (window.console) {
        if (style)
          window.console.log("%c" + str, style);
        else
          window.console.log(data.value);
      }
    }
    sendCommand(txt, noEcho, comments) {
      if (txt == null) {
        txt = this._commandInput.value;
        if (!this.telnet.echo)
          this._commandInput.value = "";
        else
          this._input.AddCommandToHistory(txt);
      }
      txt = "" + txt;
      if (!txt.endsWith("\n"))
        txt = txt + "\n";
      const data = { value: txt, handled: false, comments };
      this.emit("parse-command", data);
      if (data == null || typeof data === "undefined") return;
      if (data.handled || data.value == null || typeof data.value === "undefined") return;
      if (data.value.length > 0)
        this.send(data.value, !noEcho);
      if (!this.getOption("keepLastCommand"))
        this._commandInput.value = "";
      else if (this.getOption("selectLastCommand"))
        selectAll(this._commandInput);
    }
    sendBackground(txt, noEcho, comments) {
      if (txt == null) {
        txt = this._commandInput.value;
        if (!this.telnet.echo)
          this._commandInput.value = "";
        else
          this._input.AddCommandToHistory(txt);
      }
      txt = "" + txt;
      if (!txt.endsWith("\n"))
        txt = txt + "\n";
      const data = { value: txt, handled: false, comments };
      this.emit("parse-command", data);
      if (data == null || typeof data === "undefined") return;
      if (data.value == null || typeof data.value === "undefined") return;
      if (!data.handled && data.value.length > 0)
        this.send(data.value, !noEcho);
    }
    get scrollLock() {
      return this._input.scrollLock;
    }
    set scrollLock(enabled) {
      this._input.scrollLock = enabled;
    }
    toggleScrollLock() {
      this._input.toggleScrollLock();
    }
    UpdateWindow() {
      this.display.updateWindow();
    }
    close() {
      this.telnet.close();
    }
    connect() {
      this.errored = false;
      this.emit("connecting");
      this.display.ClearMXP();
      this.display.ResetMXPLine();
      this.telnet.connect();
      this.emit("connect");
      this._commandInput.focus();
    }
    receivedData(data) {
      this.telnet.receivedData(data);
    }
    notify(title, message, options) {
      if (this.enableDebug) {
        this.emit("debug", "notify title: " + title);
        this.emit("debug", "notify msg: " + message);
      }
      this.emit("notify", title, message, options);
    }
    clear() {
      this.display.clear();
      this.emit("cleared");
    }
    parseInline(text) {
      return this._input.parseInline(text);
    }
    parseOutgoing(text, eAlias, stacking, noFunction) {
      return this._input.parseOutgoing(text, eAlias, stacking, noFunction);
    }
    clearCache() {
      this._input.clearCaches();
      this._itemCache = {
        triggers: null,
        aliases: null,
        macros: null,
        buttons: null,
        contexts: null,
        defaultContext: null,
        alarms: null,
        alarmPatterns: []
      };
    }
    beep() {
      this.emit("bell");
    }
    raise(event2, args, delay) {
      if (!this.profiles) {
        setTimeout(() => {
          this.raise(event2, args, delay);
        }, 100);
        return;
      }
      if (!delay || delay < 1)
        this._input.triggerEvent(event2, args);
      else
        setTimeout(() => {
          this._input.triggerEvent(event2, args);
        }, delay);
    }
    show() {
      this.emit("show");
    }
    hide() {
      this.emit("hide");
    }
    toggle() {
      this.emit("toggle");
    }
  };
  window.Client = Client;
  window.Display = Display;
})();
/** @license zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */
/**
 * A class to parse color values
 * @author Stoyan Stefanov <sstoo@gmail.com>
 * @link   http://www.phpied.com/rgb-color-parser-in-javascript/
 * @license Use it if you like it
 */
